<html><head>
<style>
.menu {
       height: 100%;
       width: 130px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 10px;
           margin-left: 135px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Systemd</title>
<div class="menu">
<a href="index.html">Содержание</a>
<a href="#top">TOP</a>
<a href="#make">Создание модуля</a>
<a href="#auto">Включение и отключение автозагрузки</a>
<a href="#status">Проверка статуса</a>
</div>

<div class="content">
<a name="top"><h2 align=center>Systemd</h2>
Ссылки:<br>
<a href="https://timeweb.cloud/tutorials/linux/kak-ispolzovat-systemctl-dlya-upravleniya-sluzhbami-systemd">Как использовать Systemctl для управления службами Systemd</a><br>
<a href="https://linux-notes.org/pishem-systemd-unit-fajl/">Пишем systemd Unit файл</a>
<p>
<b>systemd</b> — набор базовых компонентов Linux-системы. Представляет собой менеджер системы и служб, который выполняется как процесс с PID 1 и запускает остальную часть системы.<br>
Она вытеснила в 2010-е годы традиционную подсистему init. Основная особенность — интенсивное распараллеливание запуска служб в процессе загрузки системы, что позволяет существенно ускорить запуск операционной системы.
<p>
Кроме быстродействия и возможности взаимодействовать с процессами напрямую, systemd также предоставляет информацию о сервисах, которую собирает из разных источников. Это достигается благодаря встроенной системе журналирования <b>journald</b>. Всю диагностическую информацию о работе сервиса вы можете увидеть благодаря journald — сообщения ядра, системные сообщения syslog, STDOUT и STDERR агрегируются в одном месте для того, чтобы пользователь мог быстро просмотреть информацию.
<p>
При управлении процессами менеджер systemd оперирует так называемыми модулями или юнитами. По сути, юнит — текстовое описание сервиса, в котором перечислены операции для выполнения до и после запуска службы.
<p>
Все модули можно найти в трёх каталогах:
<ul>
<li> /usr/lib/systemd/system — юниты сервисов, установленных с помощью менеджера пакетов. Самый простой пример — веб-серверы: Apache или Nginx.
<li> /run/systemd/system — юниты, которые создаются в процессе работы системы.
<li> /etc/systemd/system — юниты, которые создаёт администратор системы.
</ul>
Список всех запущенных модулей можно посмотреть, использовуя команду systemctl. В терминале вы увидите таблицу со статусом каждой службы. Разберём, что означает каждый из столбцов:
<ol>
<li> UNIT. Название модуля<br>
Модули делятся на категории по типу. Тип каждого модуля можно узнать из названия файла — он указан через точку. Все типы модулей:
<ul>
<li> .service — описывает, как управлять службой и приложением
<li> .socket — описывает сетевой буфер, который используется для активации сокета
<li> .device — описывает устройство как необходимое для управления systemd
<li> .mount — определяет точку монтирования в системе
<li> .automount — настраивает автоматическую установку точки монтирования
<li> .swap — описывает пространство подкачки в системе
<li> .target — обеспечивает синхронизацию устройств при загрузке системы
<li> .path — определяет путь, который используется для активации
<li> .timer — определяет задержку или активацию по плану
<li> .snapshot — делает снимок системы для последующего восстановления
<li> .slice — ограничивает узлы группы управления
<li> .scope — systemd создаёт эти модули автоматически, пользуясь информацией из интерфейса шины
</ul>
<br>При работе с systemctl обычно необходимо указывать полное имя юнита с суффиксом, например, sshd.socket. Существует несколько возможных сокращений:
<ul>
<li> Если суффикс не указан, systemctl предполагает, что это .service. Например, netctl равнозначно netctl.service.
<li> Точки монтирования автоматически преобразуются в юнит .mount. Например, /home равнозначно home.mount.
<li> Аналогично точкам монтрования, имена устройств автоматически преобразуются в юнит .device. Например, /dev/sda2 равнозначно dev-sda2.device.
</ul>
<li> LOAD. Статус загрузки конфигурации, если успешно — loaded.
<li> ACTIVE. Статус службы. Один из следующих: active, inactive, running, exited, dead, loaded, not-found, plugged, mounted, waiting, listening.
<li> SUB. Детальная информация о юните.
<li> DESCRIPTION. Краткое описание модуля — за что он отвечает.
</ol>
<p>
Чтобы увидеть все модули, независимо от того, запущены они или нет, воспользуйтесь командой:
<pre>
systemctl list-units --all
</pre>
Вы увидите все модули, которые когда-либо загружал или пытался загрузить диспетчер systemd. Для отображения конкретных записей используйте флаг --state. Так, например, для того, чтобы увидеть все неактивные юниты, нужно использовать:
<pre>
sudo systemctl list-units --all --state=inactive

systemctl list-unit-files - список всех файлов-юнитов

systemctl list-units --type=service  - список всех файлов.service
</pre>

<h3 align=center>Структура юнита</h3>
Каждый модуль представляет собой текстовый файл, который разделён на обязательные секции и переменные. Разберём на примере модуля sshd:
<pre> 
[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.target
Wants=sshd-keygen.target

[Service]
Type=notify
EnvironmentFile=-/etc/crypto-policies/back-ends/opensshserver.config
EnvironmentFile=-/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS $CRYPTO_POLICY
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target
</pre>
<b>Unit</b><br>
Это первая обязательная секция. В ней описаны правила взаимодействия с другими службами и указаны метаданные — описание и документация. Подробнее:
<ul>
<li> Description — описание модуля.
<li> Documentation — страница руководства man.
<li> After — после каких демонов и событий нужно запускать модуль. Например, модули веб-серверов запускаются только после сетевых интерфейсов.
<li> Requires — сервисы, необходимые для работы юнита
<li> Wants — сервисы, которые желательно запустить перед стартом модуля
</ul>
<p>
<b>Service</b><br>
В этой секции необходимо указать, какими командами запускать службу:
<ul>
<li> Type — как запускается демон? По умолчанию — simple, то есть служба просто запускается. Notify это примерно то же самое, но в таком случае процесс сообщит диспетчеру, что он готов к работе. Есть также типы forking (после запуска демона родительский процесс завершается) и one-shot (выполняется один раз).
<li> PIDFile — ссылка на основной процесс
<li> WorkingDirectory — текущая рабочая директория для запуска команд
<li> User — пользователь для запуска сервиса
<li> Group — группа для запуска сервиса
<li> ExecStart — команда для запуска сервиса
<li> ExecStop — команда для остановки сервиса
<li> TimeoutSec — время, которое служба ожидает остановки или старта
<li> Restart — настройки перезапуска
</ul>
<p>
<b>Install</b><br>
В этой секции нужно указать, на каком уровне загрузки системы нужно запускать сервис. Переменная WantedBy сообщает, как включится устройство, в качестве параметра указываются специальные файлы целей. Они служат для того, чтобы привести систему в разные состояния.<br>
Список доступных целей вы можете получить, выполнив команду:
<pre>  
sudo systemctl list-unit-files --type=target
</pre>
<h4>Редактирование модулей</h4>
Модули нельзя править напрямую. Для этого нужно использовать команду systemctl edit. Откроется файл, который можно использовать для переопределения директив службы или добавления новых. При этом настройки из файла переопределения приоритетнее, чем настройки по умолчанию. 
<p>
Если нужно отредактировать файл модуля целиком, а не добавлять новые директивы, нужно использовать флаг --full:
<pre>
sudo systemctl edit --full apache2.service
</pre>
Перед вами откроется редактор, в котором вы можете править настройки юнита. 
<p>
По умолчанию файлы переопределения хранятся в /etc/systemd/system/, в каталоге который называется так же, как модуль, но с суффиксом .d. Например, в случае apache2 это будет директория /etc/systemd/system/apache2.service.d/. 
<p>
Если вы редактируете конфигурацию напрямую с использованием флага --full, нужный файл находится в каталоге /etc/systemd/system/ и называется так же, как модуль.
<p>
Для того, чтобы удалить переопределения, которые вы добавили, просто удалите каталог с суффиксом .d. Если нужно восстановить настройки по умолчанию, удалите весь файл модуля. В случае с apache2 это:
<pre>  
sudo rm -r /etc/systemd/system/apache2.service.d
</pre>
или 
<pre>  
sudo rm /etc/systemd/system/apache2.service
</pre>
После этого нужно перезагрузить процесс systemd:
<pre>  
sudo systemctl daemon-reload
</pre>
<a name="make"><h4 align=center>Создание модуля</h4>
Сначала создадим юнит:
<pre>  
sudo nano /etc/systemd/system/tmwb.service
</pre>
В описании укажем следующие строки:
<pre>  
[Unit] 
Description=Timeweb uptime checker
[Service] 
Type=simple
ExecStart=/bin/bash /var/sc/check-uptime.sh 
RemainAfterExit=yes 
[Install] 
WantedBy=multi-user.target
</pre>
Теперь нужно применить изменения и запустить службу:
<pre>  
sudo systemctl daemon-reload
sudo systemctl start tmwb.service
</pre>
Проверим статус и убедимся, что всё работает корректно:
<pre>  
sudo systemctl status tmwb.service
</pre>
<a name="auto"><h4 align=center>Включение и отключение автозагрузки</h4>
Основное предназначение диспетчера systemd — запускать службы при загрузке системы. Но все команды, перечисленные выше, относились к работе только во время текущего сеанса. 
<p>
<b>Чтобы включить автозагрузку приложения, воспользуйтесь командой enable.</b> После этого systemd создаст символическую ссылку из служебного файла — /etc/systemd/system — в место, где диспетчер ищет приложения для автозапуска.
<pre>  
<b>sudo systemctl enable apache2.service</b>
</pre>
Чтобы отключить автозапуск, используйте disable. При этом символическая ссылка будет удалена.
<a name="status"><h4 align=center>Проверка статуса</h4>
Чтобы проверить статус службы в системе, нужно использовать команду <b>status</b>. 
<p>
Например, команда sudo systemctl status apache2.service отобразит статус, процессы в иерархии контрольных групп и фрагмент журнала.
<p>
Помимо развёрнутого отчёта о статусе службы диспетчер systemd также предоставляет методы для проверки конкретных статусов. Это позволяет обернуть множество проверок в скрипты и проще работать с результатом.
<ul>
<li> is-active. Проверяет, активен ли модуль. Возвращает active или inactive.
<li> <b>is-enabled. Проверяет, включена ли автозагрузка службы. Возвращает enabled или disabled.</b>
<li> is-failed. Проверяет, находится ли юнит в работе. Возвращает active, если всё работает корректно, failed — если ошибка. При этом вы можете получить также unknown или inactive, если служба была остановлена вручную.
</ul>













</div>
<br><br><br><br></body></html>
