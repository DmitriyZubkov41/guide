<html><head>
<style>
.menu {
       height: 100%;
       width: 120px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 10px;
           margin-left: 125px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Функции</title>
<div class="menu">
<a href="#top">Функции</a>
<a href="#prototip">Прототип функции</a>
<a href="#pointer">Указатели на функцию</a>
<a href="#typedef_ptr">&nbsp;&nbsp; typedef для указателей на функцию</a>
<a href="#stek">Стековый фрейм. Автоматические переменные</a>
<a href="#rekurs">Рекурсивные функции</a>
<a href="#variad">Вариадические функции</a>
<a href="#variables">Локальные и глобальные переменные</a>
<a href="#static">Ключевые слова static и extern</a>
<a href="#malloc">Функции malloc(), free()</a>
<a href="#calloc">Функции calloc(), realloc(), memcpy() и memmove()</a>
<a href="#enum">Перечисления enum</a>
<a href="#typedef">Директива typedef</a>

</div>

<div class="content">
<a name="top"><h3 align=center>Функции</h3>
Функции нужны, чтобы не дублировать одинаковые фрагменты программы, а просто заменять их вызовом функции.
<p>
Общий синтаксис объявления функции имеет следующий вид:
<pre>
&lt;тип данных&gt; &lt;имя функции&gt;([набор параметров])
{
        оператор_1;
        ...
        оператор_N;
}
</pre>
Здесь первая строчка соответствует заголовку функции, а операторные фигурные скобки – телу функции. <b>Тип данных перед именем функции определяет возвращаемый функцией тип значений</b>. В самом простом случае это могут быть базовые типы: int, char, double, short, ...<br>
Если же функция ничего не возвращает, то перед ней прописывается тип: <b>void</b> и return писать не обязательно.
<p>
<b>Имя функции</b> <br>
Если переменные, как правило, определяются существительными, то имена функций рекомендуется задавать глаголами, так как они связаны с определенными действиями. Например: 
get_coord, show_x, is_digit, и т.п.
<p>
После имени функции обязательно должны идти круглые скобки, в которых могут быть указаны <b>параметры функции.</b><br>
<b>Если функция не принимает никаких параметров</b>, то принято при ее объявлении в круглых скобках прописывать ключевое слово <b>void</b>. Тем самым мы подчеркиваем факт отсутствия параметров.
<p>
Параметры функции записываются как переменные через запятую. Собственно, это и есть обычные переменные. Причем, перед каждым параметром обязательно нужно указывать тип данных, даже при одинаковых типах. Объявление вида:<br>
int get_per(int width, height)       // ошибка<br>
будет неверным.
<p>
После определения заголовка функции, с новой строки записывается открывающаяся фигурная скобка. Обратите внимание, с новой строки, а не на текущей! Это общепринятая запись оформления функций на языке Си. Фигурные скобки тела функции пишутся в отдельных строчках. Почему так? Потому что заголовок функции – это отдельная синтаксическая конструкция, которая может быть определена без тела функции. 
<p>
Все обычные параметры и переменные, объявленные внутри функции, создаются в момент вызова этой функции и исчезают при ее завершении. То есть, параметры width, height и переменная p доступны только внутри функции get_per() и не существуют за ее пределами.
<p>
При каждом вызове функции в круглых скобках указываются значения, которые ей передаются. Эти значения называются 
<b>аргументами</b> и их должно быть ровно столько, сколько прописано параметров при объявлении функции.<br>
Параметры и аргументы функции - это не одно и тоже. Когда объявляем функцию, то в скобках называются параметры, а когда вызываем функцию, то аргументы.
<p>
Количество передаваемых аргументов должно равняться количеству параметров иначе будет ошибка. 
<p>
<b>nan</b> - значение  переменной (сокращение от Not a Number – не число)
<p>
<b>return</b><br>
ключевое слово внутри функции. return выполняет две задачи:<br>
1.  Возвращать какое-то значение. <b>Если функция что-то возвращает, то слово return в функции обязательно</b>. Если же не возвращает (тип функции void), то return писать не обязательно.
<p>
2. Завершать выполнение функции. Если внутри функции после return запишем еще какие-нибудь команды, то они будут игнорироваться.
<p>
Функции можно вызывать в качестве аргумента другой функции.<br>
Возникает вопрос, в каком порядке будут вызваны функции, записанные в аргументах? Например, при нахождении минимального среди пяти чисел, что будет вызвано вначале min_2() или min_3()? В действительности, стандартом языка Си этот момент не определен. Поэтому разные компиляторы могут транслировать программу так, что сначала min_3() вызовется, а затем, min_2(), или наоборот. Гарантии никакой нет. Однако точно можно сказать, что <b>вначале отрабатывают функции, стоящие в аргументах, и только после этого основная функция</b>. В этом мы можем быть уверены.
<p>
На первый взгляд может показаться, что нет особой разницы, в каком порядке срабатывают функции в аргументах. Но это не всегда так. Пусть, например, мы задумали использовать операцию инкремента при вызове функции min_2():
<pre>
int x = 1, y = -2, z = 10;
double res_1 = min_2(++x, x);
printf("res_1 = %.2f\n", res_1);
</pre>
И думаем, ага, вначале отработает первый аргумент и переменная x увеличится на 1, а затем, второй. В результате, минимальное будет равно 2. Но после запуска программы видим другое значение 1. А вот если в моем случае записать инкремент у второго аргумента:<br>
double res_1 = min_2(x, ++x);<br>
то получаем значение 2. То есть, порядок иногда имеет значение, но, так как мы его не знаем, то полагаться на подобные конструкции не стоит. Можно использовать инкремент или декремент, только если такая же переменная не стоит в других аргументах, например, так:<br>
double res_1 = min_2(y, ++x);<br>
В этом случае порядок для нас не важен. И, обратите внимание, операция инкремента у переменной x записана в префиксной форме. Почему именно так? Очевидно, в этом случае значение второго параметра b функции min_2() будет принимать значение:<br>
b = ++x;<br>
То есть, значение x будет увеличено на 1 и только после этого присвоено переменной b. Если же при вызове функции min_2() использовать постфиксную форму записи:<br>
double res_1 = min_2(y, x++);<br>
то это будет эквивалентно присваиванию: b = x++;


<a name="prototip"><h3 align=center>Прототипы функций</h3>
Обычная функция, объявленная в текущем модуле, может быть использована только в этом модуле и недоступна в других модулях.
<p>
Обычная функция, объявленная в текущем модуле, может быть использована и в любом другом, если указать ее прототип.
<p>
Часто бывают ситуации, когда нужно лишь объявить заголовок функции, а ее реализацию определить позже или даже прописать в другом модуле программы. Например:
<pre>
#include <stdio.h>
 
<b>double per_sq(double w, double h); //прототип функции</b>
 
int main(void) 
{
         printf("per = %.2f\n", per_sq(2.5, 3.5));
         return 0;
}
 
double per_sq(double w, double h)
{
         if(w < 0 || h < 0)
                   return 0;
 
         return 2 * (w + h);
}    
</pre>
Такой заголовок называют <b>прототипом функции</b>.
<p>
Конкретную реализацию функции можно прописывать в любом другом модуле проекта, или даже выносить ее в заранее скомпилированные объектные файлы, которые, затем, следует указывать при линковке (сборке) проекта.
<p>
В прототипе имена переменных можно опускать, компилятор их все равно не учитывает:<br>
double per_sq(double, double);<br>
Для компилятора главная информация – это возвращаемый тип, имя функции и количество параметров с их типами. Больше ничего ему не нужно для формирования вызова функции на уровне машинных кодов.
<h4 align=center>Прототипы функций в заголовочном файле</h4>
Текст программы, описанный в двух модулях, имеет один существенный недостаток. Если модулей станет больше и определение функции в файле func.c изменится, то его придется менять во всех прототипах других модулей. Поэтому поступают следующим образом. Все общие прототипы выносятся в заголовочные файлы, например, в файл func.h:
<pre>
#ifndef __FUNC_H__
#define __FUNC_H__
 
double per_sq(double, double);
 
#endif

А в модулях, где используется функция per_sq() подключается этот файл с помощью директивы #include:

#include &lt;stdio.h&gt;
<b>#include "func.h"</b>

int main(void) 
{
         printf("per = %.2f\n", per_sq(2.5, 3.5));
         return 0;
}
</pre>
<i>Все заголовочные пользовательские файлы при подключении берутся в двойные кавычки в отличии от стандартных заголововков, которые берутся в &lt;name.h&gt;</i>
<p>
Теперь, при изменении сигнатуры функции ее достаточно будет изменить в заголовочном файле func.h и изменение автоматически коснется всех модулей, где этот файл подключается.
<p>
Тело функции описывается в <b>другом третьем файле</b>: funk.c
<h3 align=center>Указатели как параметры. Передача массивов в функции</h3>
<a href="https://proproprogs.ru/c_base/c_ukazateli-kak-parametry-peredacha-massivov-v-funkcii">Указатели как параметры. Передача массивов в функции</a>
<p>
Польза от указателя, как параметр функции:<br>
1. переменные x и y доступны только в пределах функции main() и недоступны (по их именам) за пределами этой функции. Поэтому напрямую получить к ним доступ в другой функции не получится. Но через указатели это вполне можно сделать.<br>
2. Во-вторых, использование указателей позволяет нам определять функции, которые могут менять и возвращать более одного значения. Как вы помните, после оператора return можно указывать только одно значение (выражение), которое будет возвращено функцией. Прописывать несколько нельзя. Однако через указатели решить задачу с возвратом множества значений все же куда проще.
<h4 align=center>Передача массивов через параметры функции</h4>
<pre>



</pre>
<a name="pointer"><h3 align=center>Указатели на функцию. Функция как параметр (callback)</h3>
Синтаксис:
<p>
<b>&lt;тип&gt; (*&lt;имя указателя&gt;) (&lt;типы параметров&gt;);</b>
<p>
<b>Имя функции является указателем на эту функцию</b>, то есть под функцию положены ячейки памяти и с помощью команды printf("%p\n", name_funk); можно узнать адресс первой ячейки памяти под эту функцию.
<p>
Раз name_funk (имя функции) – это указатель, значит, можно объявить еще один указатель на эту функцию и присвоить ему адрес name_funk. Согласно приведенному синтаксису, такой указатель можно объявить следующим образом:
<pre>
int (*ptr_func) (int, int);
</pre>
Здесь первый int – это возвращаемый тип функции name_funk, далее в круглых скобках прописываем имя указателя (придумываем сами) и, затем, в круглых скобках через запятую типы параметров функции. Получаем указатель с именем ptr_func на любую функцию, которая возвращает целое значение и принимает два целочисленных параметра.
<p>
<b>Пример:</b><br>
Пусть существует функция int sq_rect(int, int). Создадим указатель:
<p>
int (*ptr_func) (int, int);
<p>
Этот указатель совпадает по сигнатуре с функцией  sq_rect, поэтому можем этому указателю присвоить адрес функции sq_rect:
<p>
ptr_func = sq_rect;
<p>
Вызовем функцию через ptr_func, передав два аргумента:
<pre>
int res = ptr_func(2, 3); //функцию можно вызывать через указатель на эту функцию<br>
printf("ptr_func(2, 3) = %d\n", res);
</pre>
Увидим результат ее работы такой же как и при обычном способе вызова функции sq_rect.
<p>
Указатель ptr_func может ссылаться на любую функцию с описанной сигнатурой (типы возвращаемого значения, параметров, количество параметров).
<pre>

</pre>
<h4 align=center>Указатель на функцию, как параметр функции</h4>
<b>Пример:</b><br>
Предположим, нам необходимо определить функцию, которая бы отбирала из одного массива в другой только те элементы, которые удовлетворяют некоторому критерию. Причем, критерий определяется другой независимой функцией. Реализовать эту задачу можно, например, следующим образом:
<pre>
#include &lt;stdio.h&gt;
 
#define SIZE        10
 
void filter(int dst[], size_t size_dst, 
                            const int src[], size_t size_src, 
                            <b>int (*is_correct)(int)</b>)
{
         for(int i = 0; i < size_dst; ++i)
                   dst[i] = 0; //обнуление, зачем?
 
         for(int i = 0, j = 0; i < size_src; ++i)
                   if(is_correct(src[i]))
                            dst[j++] = src[i];
}
 
int is_even(int x)
{
         return x % 2 == 0;
}
 
int main(void) 
{
         int digits[] = {-3, 4, 10, 11, -5, 3};
         int result[SIZE];
 
         filter(result, SIZE, digits, sizeof(digits) / sizeof(*digits), <b>is_even</b>);
         
         for(int i = 0; i < SIZE; ++i)
                   printf("%d ", result[i]);
 
         return 0;
}
</pre>
Вначале объявлена функция filter(), которая принимает два массива с их размерами и ссылку на функцию. Затем, массив dst, в который заносится результат, обнуляется и в следующем цикле выполняется копирование только тех значений из второго массива src, для которых функция is_correct() возвращает не нулевое значение. То есть, указатель is_correct определяет критерий отбора значений.
<p>
После функции filter() объявлена еще одна функция is_even(), которая будет использоваться в качестве критерия отбора: для четных значений она возвращает единицу, а для нечетных – ноль.
<p>
В функции main() объявляются два массива и, затем, вызывается функция filter(), в которую передаются <b>указатели</b> на эти массивы, их длины и <b>указатель на функцию is_even()</b>. То есть, параметр is_correct будет ссылаться на функцию is_even().
<p>
Уникальность функции filter() в том, что мы легко можем изменить критерий отбора, не меняя саму функцию filter(). Например, нам ставится задача выбрать все положительные числа. Нет ничего проще. Объявляем еще одну функцию для нового критерия отбора:
<pre>
int is_positive(int x)
{
         return x > 0;
}
</pre>
И указываем ее при вызове функции filter():
<p>
filter(result, SIZE, digits, sizeof(digits) / sizeof(*digits), <b>is_positive</b>);
Запускаем программу, получаем результат. <b>При этом в самой функции filter() ничего менять не надо</b>.

<h4 align=center>Массивы из указателей на функции</h4>
Общий синтаксис здесь следующий:
<pre>
<b>&lt;тип> (*&lt;имя массива&gt;[&lt;размер&gt;]) (&lt;параметры&gt;)</b>
</pre>
Давайте объявим в программе еще одну функцию для выделения нечетных значений:
<pre>
int is_odd(int x)
{
         return x % 2 != 0;
}
</pre>
И сформируем массив из указателей на эти критерильные функции:
<pre>
int (*criterials[]) (int) = {is_even, is_odd, is_positive};
</pre>
Теперь в filter() можно передавать одну из этих функций, просто указывая нужный индекс массива criterials:
<pre>
filter(result, SIZE, digits, sizeof(digits) / sizeof(*digits), criterials[1]);
</pre>
Это может быть полезно, когда у пользователя запрашивается критерий отбора, например, в виде меню:<br>
1. Четные значения.<br>
2. Нечетные значения.<br>
3. Положительные значения.
<p>
И выбранный номер select_id просто преобразуется в индекс indx = select_id - 1 массива criterials.
<pre>

==============================================================================================================================

</pre>
<a name="stek"><h3 align=center>Стековый фрейм. Автоматические переменные</h3>
Ссылки:<br>
<a href="https://proproprogs.ru/c_base/c_stekovyy-freym-avtomaticheskie-peremennye">Стековый фрейм. Автоматические переменные</a>
<p>
Когда запускается какая-либо программа, то происходит загрузка данных и программного кода в память устройства и, кроме того, автоматически выделяется область памяти под <b>стек вызова функций</b>. Его еще называют <b>стековым фреймом</b>. Я напомню, что стек – это такая структура, когда новые данные помещаются наверх и извлекаются тоже сверху. 
<p>
Зачем в программе понадобился такой стек? Давайте предположим, что объявлены две функции: max2() – для поиска максимального из двух значений; main() – основная функция, точка входа в программу:
<pre>
int max2(int a, int b)
{
         return (a > b) ? a : b;
}
 
int main(void) 
{
         int x = 1, y = 2;
         int res = max2(x, y);
         
         return 0;
}
</pre>
Каждая функция имеет свои собственные переменные, необходимые для ее работы. Например, в функции main() – это переменные x, y, res, а в функции max2() – это параметры a и b. Так вот, переменные, связанные с той или иной функцией автоматически создаются в момент вызова этой функции и становятся недоступными после ее завершения. А размещаются переменные, как раз в стековом фрейме. В нашем примере сначала будет вызвана функция main(). В стеке появится блок данных для этой функции. Затем, функция main() вызывает функцию max2() и в стеке появляется еще один блок данных для работы этой второй функции. После завершения функции max2() блок с данными для нее в стековом фрейме перестает быть актуальным и более не учитывается. Соответственно, параметры a и b становятся недоступными после завершения этой функции. То же самое происходит при завершении функции main(). Все ее данные в стековом фрейме как бы перестают существовать, в том числе и локальные переменные x, y, res.
<p>
Получается, что обычные переменные, объявленные внутри функции, автоматически создаются в момент ее вызова и пропадают после ее завершения. Именно поэтому такие переменные получили название <b>автоматические</b>. А область их видимости (то есть, существования) ограничивается телом функции.
<p>
Все обычные локальные переменные и параметры размещаются в стековом фрейме при очередном вызове функции. При этом память под переменные просто резервируется и не более того. Это значит, что локальные переменные могут принимать произвольные начальные значения, так как в ячейках памяти, которые они занимают, могут находиться любые величины, так называемый шум. Давайте в этом убедимся. Создадим в функции main() целочисленную переменную с именем var и выведем ее на экран:
<pre>
int var;
printf("var = %d\n", var);
В моем случае получилось значение:

var = 4199120
</pre>
У вас будет какое-то другое. То есть, начальные значения в локальных автоматических переменных непредсказуемы. Это нужно учитывать при составлении программы.
<p>
Другой важный вывод связан с тем, что стековый фрейм, как правило, имеет весьма ограниченный размер (несколько мегабайт). Это, во-первых, означает, что мы не можем вызывать бесконечно длинную цепочку функций (одну из другой), так как стек просто заполнится, и при очередном вызове получим ошибку:<br>
Stack Overflow (переполнение стека)
<p>
И, во-вторых, не следует внутри функций определять автоматические локальные переменные, которые занимают большой объем памяти. Например, массивы из большого числа элементов.
<pre>

=============================================================================================================================

</pre>
<a name="rekurs"><h3 align=center>Рекурсивные функции</h3>
Функции могут вызывать сами себя. Это называется <b>рекурсией</b>. А функции, которые это выполняют, <b>рекурсивными</b>.
<p>
Когда движение идет вглубь, то имеем <b>прямой ход рекурсии</b>, а при возврате – <b>обратный ход</b>. Максимальное число вызовов рекурсивной функции называют <b>глубиной рекурсии</b>.
<p>
<b>Пример использования рекурсивной функции:</b>
<pre>
#include &lt;stdio.h&gt;
 
#define N    5
 
void show_pole(const char (*p)[N])
{
         for(int i = 0; i < N; ++i) {
                   for(int j = 0; j < N; ++j)
                            printf("%c ", (p[i][j] == 0) ? '#' : '0'); // заполняем p решеткой или нулем
                   putchar('\n');
         }
}
 
void open_zeros(<b>const char (*p)[N]</b>, <b>char (*pp)[N]</b>, int i, int j) // примеры параметров типа двухмерных массивов
{
         if(p[i][j] != 0 || pp[i][j] == 1)
                   return;
 
         pp[i][j] = 1; // открываем клетку
 
         if(i-1 >= 0 && p[i-1][j] == 0) <b>open_zeros(p, pp, i-1, j)</b>; //клетка выше, вызываем снова функцию, <font color=red>почему i >=1?</font>
         if(i+1 < N && p[i+1][j] == 0) open_zeros(p, pp, i+1, j); // клетка ниже
         if(j-1 >= 0 && p[i][j-1] == 0) open_zeros(p, pp, i, j-1); //клетка левее
         if(j+1 < N && p[i][j+1] == 0) open_zeros(p, pp, i, j+1); // клетка правее
}
 
int main(void) 
{
         char pole[N][N] = {
                            {1, 1, 1, 1, 1},
                            {1, 1, 0, 1, 1},
                            {0, 0, 0, 0, 1},
                            {1, 1, 0, 0, 0},
                            {1, 1, 0, 1, 1},
         };
 
         char ppole[N][N] = {0};
 
         show_pole(ppole);
         open_zeros(pole, ppole, 2, 2);
         
         puts("--------------------");
         show_pole(ppole);
 
         return 0;
}
</pre>
Здесь функция show_pole() отображает клетки игрового поля. А рекурсивная функция open_zeros() открывает все соседние клетки с нулевыми значениями. Работает она очень просто. Вначале мы передаем ей оба массива и индексы начальной открываемой клетки. Если текущая клетка игрового поля содержит 0, то она открывается и запускается рекурсия во все соседние клетки.
<p>
Если в соседних клетках также будет число 0, то она откроется, и рекурсия от нее продолжится дальше. И так, пока вся группа связанных нулевых клеток не будет открыта.
<p>
<b>Где применяются?</b><br>
Рекурсивные функции очень удобны, когда нам нужно перебрать некие иерархические данные, которые имеют сложную структуру, и обычными циклами их проходить было бы затруднительно. В частности, рекурсия используется для переборов вершин бинарных деревьев или для перебора каталогов и файлов.<br>
Везде, где присутствует иерархичность можно подумать об использовании рекурсивных функций. Но нужно всегда помнить и об их недостатках. Они следующие:
<ol>
<li> рекурсивные вызовы работаю медленнее, чем итерации операторов циклов, поэтому, если задачу относительно просто можно реализовать через циклы, то именно их и следует применять;
<li> рекурсия не может идти до бесконечности; программа аварийно завершится, когда фреймовый стек будет полностью заполнен, поэтому если в задаче сложно оценить максимальную глубину рекурсии, то от использования рекурсивных функций лучше отказаться.
</ol>
<pre>

=============================================================================================================================

</pre>
<a name="variad"><h3 align=center>Функции с произвольным числом параметров</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/c_funkcii-s-proizvolnym-chislom-parametrov">Функции с произвольным числом параметров</a>
<p>
Функции с произвольным числом аргументов называют <b>вариадическими</b>.
Пример функции:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
 
int sum(int count, ...)
{
            int s = 0;
            va_list arg;            // указатель на параметр
            va_start(arg, count);   // получение адреса первого вариадического параметра 
 
            for(int i=0; i < count; ++i) {
                        s += va_arg(arg, int);  // получение значение вариадического параметра
                                                // и переход к следующему параметру
            }
 
            va_end(arg);               // завершение процедуры перебора вариадических параметров
 
            return s;
}
 
 
int main(void) 
{
            int res = sum(5, 1, 2, 3, 4, 5);
            printf("res = %d\n", res);
 
            return 0;
}
</pre>
Необходимо подключить <b>заголовочный файл stdarg.h</b>, в котором определен тип va_list для указателя по вариадическим параметрам функции (то есть, переменным параметрам, которые формируются при ее вызове). Кроме того, в файле stdarg.h определены следующие функции:
<ul>
<li> va_start() – для получения указателя на первый вариадический параметр функции (тот, что идет после параметра count в нашем примере);
<li> va_arg() – для получения значения текущего параметра и переход к следующему вариадическому параметру;
<li> va_end() – для завершения процедуры перебора (это необходимо, если потребуется новый обход параметров, тогда нужно будет снова вызвать va_start() и va_arg() для извлечения значений).
</ul>
После подключения всех необходимых файлов идет объявление вариадической функции с именем sum(). У таких функций вначале должен быть прописан хотя бы один обычный параметр. В нашем примере – это count. А уже в конце можно поставить многоточие, означающее, что функция может принимать произвольное число аргументов. В теле функции объявляется вспомогательная переменная s с начальным значением 0, в которой будет храниться сумма значений, а далее идет объявление указателя arg для перебора вариадических параметров. С помощью функции va_start() выполняется инициализация этого указателя на первый вариадический параметр. При этом вторым аргументом мы должны указать обычный параметр, стоящий непосредственно перед многоточием при объявлении функции sum(). После этого в цикле происходит перебор count значений (мы полагаем, что число вариадических параметров не менее count, а в идеале равно ему) с помощью функции va_arg(). Этой функции передается указатель arg и тип текущего вариадического параметра. Мы полагаем, что все значения имеют тип int. В конце после цикла вызывается завершающая функция va_end().
<p>
первый параметр у нас хранит число вариадических параметров и это значение мы прописываем сами. Например, если при вызове функции sum() первым аргументом указать меньшее число:
<pre>
int res = sum(3, 1, 2, 3, 4, 5);
</pre>
то будут просуммированы только первые три числа (из вариадических аргументов) и получим значение: 1+2+3 = 6
<p>
То есть, внутри функции sum() мы не знаем сколько аргументов в реальности было передано и просто доверяем значению в переменной count. Это один из недостатков вариадических функций. Нам как то нужно дополнительно передавать информацию о числе вариадических параметров. 
<p>
Вариадические функции очень редко используются на практике, так как они не так удобны, как обычные функции и к тому же не дают полного понимания о наборе этих вариадических параметров. Сторонний программист, глядя на объявление с многоточием не сразу поймет, что подается на вход такой функции и какую роль играют эти аргументы. Поэтому к ним лучше прибегать только в исключительных случаях, когда очевиден плюс от их использования.

<h4>Дополнение для языка С++</h4>
Если вы в будущем планируете программировать на языке С++, то важно знать еще две ключевые его возможности:
<ol>
<li> перегрузка функций;
<li> функции с параметрами по умолчанию.
</ol>
<b>Перегрузка функций</b> позволяет создавать несколько функций с одинаковыми именами, но разным набором параметров. Перегрузка здесь позволяет несколько ускорить работу программы и, при этом, от программиста не требуется никаких дополнительных действий (кроме объявления нужного набора функций).
<p>
<b>Параметры со значениями по умолчанию</b><br>
Следующий момент работы с функциями связан с параметрами со значениями по умолчанию. То есть, им сразу присваивается некоторое начальное значение, и если при вызове функции аргументы в них не будут подставлены, то эти параметры останутся с заранее прописанным значением. Например:
<pre>
void show_args(<b>short a=10, double b=20.0, int c=30</b>)
...
int main() {
         show_args();
         show_args(1);
         show_args(1, 2);
         show_args(1, 2, 3);
}
</pre>
Параметры со значениями по умолчанию <b>должны быть записаны в конце списка параметров функции</b>. Вот примеры правильных и неправильных объявлений:
<pre>
void my_func(int a, int b = 1, int c = 1);    //правильное объявление
void my_func(int a, int b, int c = 1);        //правильное объявление
void my_func(int a=1, int b, int c = 1);      //неправильное объявление
void my_func(int a, int b = 1, int c);        //неправильное объявление
</pre>
<pre>

===========================================================================================================================


</pre>
<a name="variables"><h3 align=center>Локальные и глобальные переменные</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/c_lokalnye-i-globalnye-peremennye">Локальные и глобальные переменные</a>
<p>
Переменные в программе можно объявлять, по сути, в двух разных местах: внутри функций (включая их параметры) и вне каких-либо функций – во внешнем блоке кода:
<pre>
#include &lt;stdio.h&gt;
/* Внешний блок кода */
<b>char name[] = "Variables"; // переменная вне функции</b>
 
int main(void) 
{
    <b>int var_main;  /* внутренняя переменная */</b>
    return 0;
}
</pre>
Так вот, переменные внутри функций и вне их ведут себя по-разному. 
<h4>Локальные переменные</h4>
Параметры и переменные, объявленные непосредственно внутри тела функции создаются в стековом фрейме в момент ее вызова. А при завершении функции память с блоком ее данных как бы исчезает, а значит, пропадают и все значения переменных, связанных с работой этой функции. То есть, получается, что параметры функции и переменные, объявленные внутри тела функции, автоматически формируются в момент ее вызова и перестают существовать после ее завершения. Про такие переменные говорят, что они имеют <b>область видимости в пределах функции</b> и являются <b>автоматическими</b> (автоматически создаются и уничтожаются). Кроме того, все переменные с ограниченной областью видимости называются <b>локальными</b>.
<p>
Нужно помнить, что стековый фрейм создается в момент запуска программы и, как правило, имеет фиксированный, ограниченный размер в памяти устройства. Это накладывает определенные ограничения на нас, как программистов: локальные переменные не должны занимать слишком много памяти. В частности, объявлять внутри функций массивы больших размеров далеко не лучшая практика. Поэтому логику программы следует продумывать так, чтобы все локальные переменные играли служебную, вспомогательную роль, а не содержали большие объемы данных, подменяя собой базы данных.

<h4>Глобальные переменные</h4>
Все переменные из внешнего блока размещаются либо в <b>секции .bss</b>, если <b>не инициализированы начальными значениями</b>, либо в <b>секции .data</b>, если <b>начальная инициализация присутствует</b>. Эти секции формируются в момент загрузки программы и размещаются в оперативной памяти устройства. То есть, их размер ограничивается только доступной памятью компьютера и при этом они никак не связаны со стековым фреймом и потому не имеют ограничений по памяти.
<p>
Переменные в секциях .bss и .data формируются в момент загрузки программы и существуют на всем протяжении ее работы. В частности, это означает, что область видимости этих переменных не ограничена и их можно совершенно спокойно использовать в любом месте программы, как минимум, в пределах текущего файла. Про такие переменные говорят, что они имеют <b>глобальную область видимости</b> или просто <b>глобальные</b>.
<p>
<b>Секция .bss после размещения в оперативной памяти автоматически заполняется нулями</b>. В результате, все глобальные переменные, которые в нее попадают, имеют нулевые начальные значения. И в этом мы можем быть уверены. А значения переменных секции .data формируются в результате загрузки в нее данных из исполняемого файла. С одной стороны это очень удобно, так как начальные значения инициализируются очень быстро, но с другой такие переменные можно инициализировать только константными величинами и соответствующими выражениями. Например, так:
<pre>
/* Внешний блок кода */
char name[] = "Variables";
int global_var_1 = 5;
int global_var_2 = 5 * 7;
int global_var_3 = sizeof(name) + 1;
</pre>
А вот, например, использовать переменные недопустимо:
<pre>
int global_var_4 = global_var_1;    // ошибка, нельзя использовать переменные
</pre>
Хотя, если переменная будет объявлена с ключевым словом const, тогда компилятор поймет, что она неизменяема и подставит вместо нее соответствующее значение (ошибки не будет):
<pre>
const int global_var_1 = 5;
...
int global_var_4 = global_var_1;   // ok
</pre>
<h4>Инициализация локальных переменных</h4>
Иначе обстоит дело с инициализацией локальных переменных. Так как они формируются в процессе работы программы, а не при ее загрузке, то их начальные значения можно определять любыми допустимыми выражениями языка Си. Например:
<pre>
int main(void) 
{
    int a = 1;
    int b = a * 2 + global_var_2;
    int size = global_var_3 * 10;
</pre>
Можно использовать обычные переменные, в том числе, и глобальные. Сразу отмечу, что использование глобальных переменных при реализации логики работы программы – это очень плохая практика. Связано это с тем, что значения таких переменных можно менять в любом месте программы, в любой функции текущего файла. Из-за этого поведение функций, использующие глобальные переменные, становится непредсказуемым. А ошибки, к которым они могут приводить, – трудно отслеживаемые. Поэтому в практике программирования на языке Си (и то же касается языка С++) глобальные переменные используются, как правило, для определения набора констант (числовых или строковых) и не более того. Очень редко имеет смысл объявлять переменную как глобальную.
<p>
Возможно, здесь у вас возникает вопрос: а как тогда нам в программе хранить данные большого размера, если для этого не стоит использовать стековый фрейм (то есть, локальные переменные) и глобальные переменные? На самом деле для таких целей, когда данные занимают от нескольких сот килобайт и более, лучше самостоятельно выделять нужный объем памяти и, затем, освобождать ее. Это можно сделать с помощью функций malloc() и free(), о которых мы еще будем говорить. А пока главное запомнить, что обычные переменные для представления больших данных, лучше не использовать.
<h4>Фигурные скобки для переменных</h4>
В языке Си операторные фигурные скобки образуют свой собственный независимый блок данных со своим набором локальных переменных. Например, в функции main() можно прописать в теле функции еще одни фигурные скобки и в них объявить внутреннюю переменную b:
<pre>
int main(void) 
{
    int a = 1;
 
    {
        int b = 2;
        printf("a = %d, b = %d\n", a, b);
    }
 
    printf("a = %d\n", a);
    return 0;
}
</pre>
В теле функции определена локальная переменная с именем a и начальным значением 1. При этом, в стековом фрейме только эта переменная и появляется. Затем, когда выполнение доходит до внутреннего блока фигурных скобок, в стековом фрейме появляется еще одна переменная b. Соответственно, обе переменных существуют и могут быть выведены на экран с помощью функции printf(). После завершения внутреннего блока, все данные связанные с ним в стековом фрейме пропадают и, следовательно, перестает существовать и переменная b. Поэтому вторая функция printf() может вывести только одну переменную a.
<p>
Если же попытаться вывести значение переменной b за пределами вложенного блока, то получим ошибку на этапе компиляции программы, говорящей, что переменная b не существует.
<p>
Такая логика работы довольно полезна, когда во внутренних блоках нужно объявить временные переменные, которые не нужны за его пределами.
<p>
<b>Собственные блоки операторов if, while, for, do-while</b><br>
Пример:
<pre>
int main(void) 
{
    int t = 33; //1 локальная t
 
    for(int t = 0; t < 3; ++t) { //2 локальная t
        printf("t = %d\n", t);
    }
    printf("main: t = %d\n", t);
    return 0;
}
</pre>
Здесь оператор for образует свой вложенный блок с переменной t, которая, затем, используется в его теле цикла. После завершения цикла на экран выводится значение прежней переменной t функции main:
<pre>
t = 0
t = 1
t = 2
main: t = 33
</pre>
Как видим, локальная переменная t не была изменена в операторе цикла for. Конечно, если бы мы не делали ее объявление в for:
<pre>
for(t = 0; t < 3; ++t) ...
</pre>
то использовалась бы внешняя переменная t из функции main(). Увидели бы результат:
<pre>
t = 0
t = 1
t = 2
main: t = 3
</pre>
Другой пример, на котором я первоначально дал неправильный ответ:
<pre>
int main(void)
{
    int n = 7;
    while(printf("before n=%d\n", n), n-- > 0) {
        printf("start n=%d\n", n);
        int n = 5;
        printf("%d\n", n);
        n++;
    }
    
    printf("%d\n", n);

    return 0;
}

Ответ:

before n=7
start n=6
5
before n=6
start n=5
5
before n=5
start n=4
5
before n=4
start n=3
5
before n=3
start n=2
5
before n=2
start n=1
5
before n=1
start n=0
5
before n=0
-1
</pre>
В строке: while(n-- > 0) n - это всегда 1 локальная n, а не 2 n, как я вначале думал.
<h4 align=center>Регистровые переменные</h4>
Центральный процессор компьютера сохраняет промежуточные данные в своих регистрах. Эти регистры физически находятся внутри процессора, а потому с ними очень быстро происходит обмен данными. Быстрее, чем с ячейками памяти, а значит, быстрее, чем с переменными.
<p>
Так вот, составляя программу, мы можем попросить компилятор разместить ту или иную переменную непосредственно в одном из регистров процессора. Разумеется, размер этой переменной (по числу бит) не должен превышать размер регистров ЦП. Делается это с помощью ключевого слова register, следующим образом:
<pre>
int main(void) 
{
    int p = 1;
    int n = 7;
 
    for(<b>register</b> int i = 2; i <= n; ++i)
        p *= i;
    return 0;
}
</pre>
Конечно, гарантии того, что переменная i будет соответствовать некоторому регистру ЦП, нет. Мы лишь выражаем свое желание, чтобы эта переменная стала регистровой. А поместит ли ее компилятор в регистр или нет зависит от множества факторов: от наличия свободного регистра; от типа и использования самой переменной i в программе. Например, если мы попытаемся получить адрес регистровой переменной, то она точно не будет в регистре, т.к. у регистров нет адреса и компилятор решит, что программист что-то напутал и сделает переменную самой обычной. Во всем остальном регистровые переменные ведут себя, как обычные локальные автоматические, то есть, они автоматически создаются внутри блока и исчезают за пределами блока.
<pre>


==========================================================================================================================

</pre>
<a name="static"><h3 align=center>Ключевые слова static и extern</h3>
Неинициализированные переменные располагаются либо в секции .bss, а инициализированные – в секции .data:
<pre>
char name[] = "Variables";  /* в секции .data */
double big_ar[1000000];     /* в секции .bss */
 
int main(void) 
{
    int var_main; /* автоматическая локальная переменная */
    return 0;
}
</pre>
Причем, расположение таких переменных в памяти устройства не меняется на всем протяжении работы программы. О таких переменных говорят, что они <b>статические</b>, то есть, не меняют свой адрес от запуска программы и до ее завершения. В отличие от автоматических переменных, адрес которых может меняться, и точно известен только после их появления в стековом фрейме. То есть, обычные локальные переменные не статические. Однако, при необходимости, можно объявить локальную переменную статической. Для этого нужно прописать ключевое слово <b>static</b> перед типом переменной, например, следующим образом:
<pre>
int main(void) 
{
    int var_main;           /* автоматическая локальная переменная */
    static short var_st;    /* локальная статическая переменная */
 
    return 0;
}
</pre>
Локальные статические переменные располагаются или в секции .bss (если не инициализированы) или в секции .data (если инициализированы), не в стэковом фрэйме для обычных локальных переменных. То есть там же, где и глобальные переменные. Соответственно, на них распространяются те же правила инициализации, что и на глобальные переменные: только константами и соответствующими выражениями. Если же статическая переменная не имеет начального значения, то она равна нулю, так как секция .bss при запуске программы заполняется нулями. 
<p>
Локальные статические переменные инициализируются и формируются в памяти устройства только один раз – в момент запуска программы. А строчка:
<pre>
static short var_st;
</pre>
лишь связывает имя var_st с соответствующей областью памяти либо из секции .bss либо из секции .data. Это, своего рода, указатель на заранее выделенную статическую область памяти. В действительности, все имена переменных на уровне машинных кодов заменяются соответствующими адресами памяти. Поэтому имена переменных – это всего лишь некоторая абстракция на уровне языка Си. В машинных кодах они не существуют.
<p>
Спрашивается, зачем нужна такая локальная статическая переменная?<br>
Первая ее особенность нам уже известна – возможность не занимать память в стековом фрейме, а располагаться в основной памяти устройства. Следовательно, статические переменные могут занимать большие объемы памяти без каких-либо последствий в работоспособности программы. 
<p>
Вторая особенность локальной статической переменной проявляется из-за ее однократной инициализации: в памяти она создается только один раз и продолжает существовать даже после завершения функции, в которой была объявлена. Наглядно это можно показать с помощью такой программы:
<pre>
#include &lt;stdio.h&gt;
 
unsigned int counter()
{
    static unsigned int cnt = 10;
    return ++cnt;
}
 
int main(void) 
{
    unsigned int times;
    times = counter();
    printf("times = %u\n", times);
    printf("counter(): %u\n", counter());
    printf("counter(): %u\n", counter());
    printf("counter(): %u\n", counter());
    return 0;
}
</pre>
Здесь внутри функции counter() объявляется локальная статическая переменная cnt с начальным значением 10. В основной функции main() мы несколько раз вызываем функцию counter() и получаем следующий вывод:
<pre>
times = 11
counter(): 12
counter(): 13
counter(): 14
</pre>
О чем говорит этот результат? О том, что переменная cnt была инициализирована только один раз значением 10, и при последовательных вызовах функции counter() бралось ее текущее значение и увеличивалось на единицу. Также это говорит о том, что переменная cnt не исчезает после завершения работы функции, а продолжает существовать в памяти устройства. И мы теперь знаем, что она располагается в секции .data (так как имеет начальное значение 10).
<h4 align=center>Ключевое слово extern с глобальными переменными</h4>
Посмотрим, как можно воспользоваться глобальной переменной в другом файле текущего проекта.<br>
В модуле modul.c создадим глобальную переменную:
<pre>
int global_var = 5;
</pre>
А в файле lessons.c с функцией main() запишем следующее:
<pre>
    printf("global_var = %d\n", global_var);
</pre>
Получим ошибку, что переменная global_var в файле lessons.c неизвестна. И это неудивительно, так как любое объявление глобальных переменных по умолчанию распространяется только на текущий файл. Чтобы получить доступ к переменной global_var в файле lessons.c нужно дать описание этой переменной. Делается это с помощью ключевого слова <b>extern</b> следующим образом:
<pre>
<b>extern</b> int global_var;
</pre>
После этого программа скомпилируется, выполнится и выведется ее значение на экран: global_var = 5
<p>
Обратите внимание, что с помощью ключевого слова extern мы не объявляем переменную global_var, а лишь говорим компилятору, что эта переменная будет объявлена позже, либо в этом же файле, либо в другом. То есть, это именно описание переменной, а не объявление. Память под нее здесь не резервируется.
<p>
Учитывая все сказанное, мы можем вначале сформировать описание глобальной переменной, а в конце файла объявить ее, например, так:
<pre>
#include &lt;stdio.h&gt;
 
extern int global_var;
extern char global_str[];
 
int main(void) 
{
    printf("global_var = %d\n", global_var);
    puts(global_str);
    return 0;
}
 
char global_str[100] = "Hello";
</pre>
После запуска программы увидим на экране строку «Hello». И, обратите внимание, на важный момент. В описании массива global_str не указывается его размерность и уж, тем более, не прописывается инициализация. Через extern мы лишь задаем тип и имя переменной, чтобы компилятор корректно сформировал представление этой переменной в объектном файле. А объявление переменной должно быть в любом другом месте и модуле проекта. На этапе его сборки линковщик объединит описания переменных с их объявлениями. Кстати, если в конце убрать объявление переменной global_str, то, естественно, получим ошибку на этапе линковки проекта:
<pre>
undefined reference to `global_str'

неопределенная ссылка на `global_str'.
</pre>
<h4 align=center>Ключевое слово extern с функциями</h4>
Аналогичные описания можно определять и для функций. Мы с вами об этом уже говорили, когда рассматривали прототипы функций.
<p>
Если функция определена в другом модуле, например, в файле modul.c:
<pre>
#include &lt;stdlib.h&gt;
 
int global_seed_randint = 0;
 
int randint(int a, int b)
{
    int right = a, left = b;
    if(a > b) {
        right = b;
        left = a;
    }
 
    return rand() % (left - right + 1) + right;
}
</pre>
То для ее использования в файле lessons.c необходимо также дать ее описание (записать прототип) следующим образом:
<pre>
#include &lt;stdio.h&gt;
 
int randint(int, int);
 
int main(void) 
{
    int a = 1, b = 10;
 
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
 
    return 0;
}
</pre>
Имена параметров в прототипах указывать не обязательно. Компилятор все равно их игнорирует. Ему здесь важна лишь сигнатура функции: возвращаемый тип, имя функции и типы параметров. Этого достаточно, чтобы сформировать вызов функции на уровне машинных кодов. А адрес ее вызова подставится позже на этапе линковки проекта.
<p>
Итак, получается, что для описания связи с глобальной переменной необходимо прописывать ключевое слово extern:<br>
extern int global_seed_randint;<br>
а в прототипе функции его нет. Почему? На самом деле его можно добавить и там:<br>
extern int randint(int a, int b);<br>
Но здесь оно необязательно, т.к. компилятор легко может различить прототип от полного объявления функции. А вот с переменной лучше явно указывать extern.

<h4 align=center>Ключевое слово static с глобальными переменными</h4>
А что если мы бы хотели ограничить область видимости глобальной переменной только текущим модулем. Например, сделать так, чтобы переменная global_seed_randint была доступна только в пределах файла modul.c? Для этого достаточно прописать ключевое слово static при объявлении этой переменной:
<pre>
static int global_seed_randint;
</pre>
Тогда при попытке ее использовать в файле lessons.c произойдет ошибка на этапе линковки проекта.
<p>
То есть, ключевое слово static с глобальными переменными играет совсем другую роль, чем с локальными. Если локальные из класса автоматических переменных переходили в класс статических, то с глобальными оно лишь ограничивает их область видимости в пределах текущего модуля. Вот это нужно четко понимать и запомнить.
<p>
По аналогии дела обстоят и с функциями. Если при ее реализации прописать ключевое слово static (в файле modul.c):
<pre>
static int randint(int a, int b)
{
...
}
</pre>
то использовать ее можно только в текущем модуле и нельзя за его пределами. В программировании такое поведение называют <b>внутренним связыванием</b>. И, наоборот, если переменную или функцию можно использовать в других модулях, то говорят, что они имеют <b>внешнее связывание</b>.
<pre>

===========================================================================================================================

</pre>
<a name="malloc"><h3 align=center>Функции malloc(), free(), calloc(), realloc(), memcpy() и memmove()</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/c_funkcii-malloc-free-calloc-realloc-memcpy-i-memmove">Функции malloc(), free(), calloc(), realloc(), memcpy() и memmove()</a>
<p>
Переменные располагаются либо в статической области памяти, если речь идет о глобальных переменных, и существуют на всем протяжении работы программы, либо в ограниченном по объему стековом фрейме, когда речь идет о локальных переменных. При этом вся остальная свободная память устройства, которая не занята другими процессами, работающими параллельно с нашей программой, никак не используется. Переменные в ней не размещаются (если не считать глобальных переменных, но они размещаются раз и навсегда, пока не завершится программа). Так вот, в программировании эта остальная свободная память называется «<b>кучей</b>» или по-английски heap. Язык Си предоставляет возможность самостоятельно выделять память в «куче», использовать ее по своему усмотрению, а затем, также самостоятельно освобождать ранее выделенную память. <b>Для этого в заголовочном файле stdlib.h</b> определены две основные функции:
<pre>
void* malloc(size_t size); // для выделения size байт из кучи

void free(void* ptr); // для освобождения памяти по указателю ptr
</pre>
Если запрашиваемый объем памяти успешно выделяется, то функция malloc() выделяет память длиной для определенного количества байт и <b>возвращает указатель</b> на начало выделенной памяти. Через полученный указатель мы можем помещать данные в выделенную память. Рассмотрим простой пример:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;   // для подключения функции malloc
 
int main(void)
{
    int *ptr = malloc(sizeof(int)); // выделяем память для одного int
    *ptr = 24;      // помещаем значение в выделенную память
 
    printf("%d \n", *ptr);
    free(ptr);
}
</pre>
Здесь с помощью функции malloc выделяется память для одного объекта int. Чтобы узнать, сколько байтов надо выделить, передаем в функцию malloc размер типа int на текущей и в результате получаем указатель ptr, который указывает на выделенную память.<br>
Стоит отметить, что мы также могли бы получить размер через разыменование указателя:
<pre>
int *ptr = malloc(sizeof *ptr);
</pre>
Для универсальности возвращаемого значения в качестве результата функция malloc() (как и calloc() и realloc()) возвращает указатель типа void *. <font color=red>Но в нашем случае создается массив типа int</font>, для управления которым используется указатель типа int *, поэтому выполняется неявное приведение результата функции malloc к типу int *.<br>
Далее через этот указатель с помощью операции разыменования помещаем в выделенный участок памяти число 24: *ptr = 24;
<p>
После завершения работы освобождаем память, передавая указатель в функцию free(): free(ptr);
<p>
Стоит отметить, что теоретически мы можем столкнуться с тем, что функции malloc() не удастся выделить требуемую память, и тогда она возвратит NULL. Чтобы избежать подобной ситуации перед использованием указателя мы можем проверять его на значение NULL:
<pre>
if(ptr != NULL)
    {
        *ptr = 24;      // помещаем значение в выделенную память
        printf("%d \n", *ptr);
    }
    free(ptr);
}
</pre>
Немотря на освобождение памяти с помощью функции free() указатель сохраняет свой адрес, и теоретически мы можем обращаться к памяти по данному указателю. Однако полученные значения уже будут неопределенными и недетеминированными. Поэтому некоторые советуют после освобождения памяти также устанавливать для указателя значение NULL:
<pre>
free(ptr);
ptr = NULL;
</pre>
<h4>Выделение памяти для массива</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
int main(void)
{
    int n = 4;
    int *ptr = malloc(n * sizeof(int)); // выделяем память для 4-х чисел int
    if(ptr)
    {
        // помещаем значения в выделенную память
        ptr[0] = 1;
        ptr[1] = 2;
        ptr[2] = 3;
        ptr[3] = 5;
        // получаем значения
        for(int i = 0; i < n; i++)
        {
            printf("%d", ptr[i]);
        }
    }
 
    free(ptr);
}
</pre>
<font color=red>Почему тут указатель является ссылкой на массив?</font>
<h4>Выделение памяти для структуры</h4>
Аналогичным образом можно выделять память для одной или набора структур:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
struct person
{
    char* name;
    int age;
};
 
int main(void)
{
    // выделяем память для одной структуры person
    struct person *ptr = malloc(sizeof(struct person));
    if(ptr)
    {
        // помещаем значения в выделенную память
        ptr->name = "Tom";
        ptr->age = 38;
 
        // получаем значения
        printf("%s : %d", ptr->name, ptr->age);       // Tom : 38
    }
 
    free(ptr);
    return 0;
}
</pre>
<p>
 Для контроля за использованием памяти на уровне ОС был создан посредник – <b>менеджер памяти</b>. Любая программа, которая хочет получить свой неделимый кусок из набора байт, должна обращаться к этому посреднику через системный вызов и с надеждой ожидать положительного решения своей просьбы. Если менеджер памяти оказался к вам благосклонен и выдал адрес начала неделимого блока из байт, то никакая другая программа его уже не получит. Ваша программа становится полновластным хозяином над этими ячейками памяти. И только после того, как вы благосклонно освободите их, дав свободу с помощью функции free(), ими могут воспользоваться другие программы, заявляя над ними свои права. Вот что в действительности значат невинные на первый взгляд слова «выделение» и «освобождение» памяти.
<p>
Пример использования этих функций:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
int main(void) 
{
    char* ar = malloc(10);              // выделение 10 байт из кучи
    int* ptr_int = malloc(sizeof(int)); // выделение памяти под тип int
    short* ptr_short = malloc(7 * sizeof(short)); // выделение памяти под 7 элементов типа short
 
    free(ar);
    free(ptr_int);
    free(ptr_short);
    return 0;
}
</pre>
в качестве аргумента функции malloc() указывается число байт, которую мы хотим получить из «кучи» в  виде непрерывной области памяти. Если менеджер памяти в «куче» находит такой кусок свободной памяти, то функция malloc() возвращает адрес первой ячейки. Если же возникают проблемы, то возвращается предопределенное значение NULL. Поэтому, после вызова функции malloc(), прежде чем использовать область памяти, нужно проверить значение указателя: оно должно быть не равно NULL. Пока в нашем примере этого нет, т.к. мы просто выделяем, а потом освобождаем память.
<p>
Итак, первая функция malloc() запрашивает у ОС 10 байт непрерывной области и, скорее всего, получит ее, т.к. это совсем небольшой размер. Во втором вызове malloc() запрашивается число байт для хранения целочисленного значения типа int в «куче». Наконец, последний вызов возвращает непрерывную память под 7 элементов типа short. После этого выполняется освобождение ранее выделенной памяти и программа завершается.
<h4>Эффект утечки памяти</h4>
Надо сказать, современные ОС автоматически освобождают все ресурсы, которые использовались программой, при ее завершении. Поэтому, если бы мы не написали функции free(), то в данном конкретном случае никаких последствий бы не было. Но, в общем случае, и к этому нужно приучаться сразу: каждому вызову malloc() должен соответствовать один вызов функции free(). Иначе, программа выделит под себя память, но не освободит ее, когда она уже не нужна. Если к тому же функция malloc() время от времени продолжает вызываться, то выделенная для нужд программы память, будет постоянно нарастать, не освобождаясь. Такой эффект в программировании называется <b>утечкой памяти</b>. 
<p>
Многие современные языки программирования, вроде Python, Java, C#, PHP и другие, имеют встроенный механизм автоматического освобождения памяти, когда она уже не нужна программе. Этот механизм реализован на основе, так называемого, <b>сборщика мусора</b>. Он анализирует все выделенные блоки памяти, и если на какую-либо не ведут программные ссылки (указатели), то делается вывод, что она не нужна и освобождается. 
<h4>Пример использования функций malloc() и free()</h4>
Предположим, нам в программе нужно хранить температуру по дням в течение некоторого периода. Какой это период, никто не знает. Это может быть и 20 дней, а может 100, а возможно пользователю захочется хранить данные за последние 100 000 дней. Как в этом случае нам организовать хранение данных в программе, чтобы с одной стороны не занимать слишком много памяти, а с другой – разместить все необходимые данные? Как вы уже догадались, выход только один: воспользоваться функциями malloc() и free().
<p>
Логика программы будет следующей. Вначале мы объявим две переменные:
<pre>
size_t capacity = 10;
size_t length = 0;
</pre>
Первая capacity будет хранить максимальное число элементов в массиве, а вторая length – число сохраненных в массив значений. Пока length меньше capacity проблем никаких нет. Новые данные можно записывать по порядку в ячейки массива. Но, когда вся отведенная под массив память окажется заполненной, то сделаем «прием с переворотом», а точнее, «прием с копированием». Мы динамически выделим новый кусок памяти, скажем, в два раза большего размера, перенесем туда ранее записанные данные из прежнего массива и освободим из под него память. Это известная концепция, положенная в основу структуры данных, известной под названием <b>динамический массив</b>.<br>
Идею динамического массива можно реализовать следующим образом:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
void* append(short* data, size_t *length, size_t *capacity, short value)
{
    if(<font color=red>*length >= *capacity) { //Звездочки к переменным означают адреса, но почему не по именам переменных</font>.  
        short* ar = malloc(sizeof(short) * 2 * *capacity); //новый массив ar и бронируем памяти в два раза больше
        if(ar == NULL)
            return data;
            
        (*capacity) *= 2; //увеличили размер максимальной длины массива 
        for(int i = 0;i < *length;++i)
            ar[i] = data[i]; //перекинули со старого массива в новый
        
        free(data);
        data = ar; 
    }
 
    data[*length] = value;
    (*length)++;
    
    return data;
}
 
int main(void) 
{
    size_t capacity = 10;
    size_t length = 0;
    
 //из памяти бронируем 20 байт памяти и видимо одновременно объявляем переменную указатель под которую заняли память.
     <b>short* data = malloc(sizeof(short) * capacity);</b>
     
    for(int i = 0; i < 11;++i)
        data = append(data, &length, &capacity, rand() % 40 - 20);
 
    printf("length = %u, capacity = %u\n", length, capacity);
 
    for(int i = 0;i < length;++i)
        printf("%d ", data[i]);
 
    free(data);
    return 0;
}
</pre>
Вначале выделяется память под массив data, содержащий максимум 10 элементов типа short.<br>
Затем, выше, определена функция append() для добавления нового значения в массив data. В качестве аргументов этой функции передается сам массив, адреса переменных length и capacity и новое значение. После добавления функция возвращает адрес массива (на случай, если массив будет увеличен и его начальный адрес изменится). Сама функция append() работает очень просто. Вначале проверяется, нужно ли увеличивать существующий массив и если да, то<br>
1. значение capacity удваивается,<br>
2. создается новый массив удвоенной длины и в него поэлементно копируются значения из прежнего массива.<br>
Затем, освобождается память из под массива data и указателю data присваивается новый адрес массива ar. В последних строчках добавляется новое значение в массив и возвращает его адрес.
<p>
В самой функции main() мы добавляем 11 случайных значений, чтобы посмотреть, как будет работать алгоритм при переполнении массива. После этого на экран выводятся значения переменных length, capacity, а затем, сохраненные значения в массиве data.
<p>
После запуска программы увидим строчки:
<pre>
length = 11, capacity = 20
-19 7 -6 0 -11 -16 18 18 -18 4 5
</pre>
Действительно, массив был динамически увеличен при его заполнении и стал в два раза больше. Так мы реализовали идею динамического массива на языке Си с помощью функций malloc() и free().
<pre>


</pre>
<a name="calloc"><h3 align=center>Функции calloc(), realloc(), memcpy() и memmove()</h3>
На самом деле эту программу можно несколько улучшить, если знать, что существуют некоторые дополнительные функции работы с памятью. В частности, не редко можно встретить использование следующих:
<pre>
<b>- заголовочный файл stdlib.h:
void* calloc(size_t nmemb, size_t size);
void* realloc(void *ptr, size_t length);</b>
</pre>
<b>Первая функция calloc()</b> выделяет память под nmemb элементов, каждый размером size байт, то есть, всего nmemb*size байт, и заполняет ее нулями. Это ключевое ее отличие от функции malloc(). Во всем остальном, они идентичны.
<p>
<b>Следующая функция realloc()</b> служит для изменения размера ранее выделенной памяти, на которую ведет указатель ptr. Новый размер задается вторым параметром length в байтах. В частности, при length=0 функция realloc() отрабатывает аналогично функции free(). Если же length больше ранее выделенной памяти, то функция сначала пытается расширить уже существующую область до большего размера, если ей это не удается, то создается новая с копированием всей прежней информации. Предыдущая область памяти автоматически освобождается.
<pre>
<b>- заголовочный файл string.h:
void* memcpy(void* restrict dst, const void* restrict src, size_t length);
void* memmove(void* dst, const void* src, size_t length);</b>
</pre>
Эти функции определены в заголовочном файле string.h, так как предполагается их использовать с символьными массивами (строками). В частности, копировать одну строку в другую с помощью функции memcpy() или переносить один фрагмент строки в другой с помощью функции memmove(). Ключевое слово <b>restrict</b> в параметрах функции memcpy() указывает компилятору, что указатели dst и src уникальны и ведут каждый на свою независимую область памяти.
<p>
В частности, мы бы могли воспользоваться функцией memcpy() для копирования данных из массива data в новый массив ar следующим образом:
<pre>
memcpy(ar, data, *length * sizeof(short));
</pre>
Но в нашем примере мы можем поступить еще лучше и воспользоваться функцией realloc(), которая и память увеличивает и данные копирует и прежнюю память освобождает:
<pre>
void* append(short* data, size_t *length, size_t *capacity, short value)
{
    if(*length >= *capacity) {
        <b>short* ar = realloc(data, sizeof(short) * 2 * *capacity);</b>
        if(ar == NULL)
            return data;
 
        (*capacity) *= 2;
        data = ar;
    }
 
    data[*length] = value;
    (*length)++;
    
    return data;
}
</pre>
Вот, в целом, набор наиболее употребительных функций для работы с памятью. Если по каким-либо причинам переменные не подходят для хранения данных в программе, то следует посмотреть в сторону этих функций. Как правило, они решают все задачи. Собственно, кроме них все равно ничего принципиально другого нет для представления и хранения данных в памяти устройства. Поэтому, мы либо используем классические переменные, либо выделяем память из кучи и работаем уже с ней.
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
<a name="enum"><h3 align=center>Перечисления (enum)</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/c_perechisleniya-enum-direktiva-typedef">Перечисления (enum). Директива typedef</a>
<p>
Перечисление - это тип данных для задания набора целочисленных констант, например, следующим образом:
<pre>
enum colors {red, green, blue};
</pre>
Здесь enum – это ключевое слово для объявления перечисления; colors – имя перечисления; red, green, blue – целочисленные константы типа int.
<p>
<b>Чем перечисления отличаются от макродиректив или константных переменных?</b>
<pre>
Директивы define:
#define REG     1
#define GREEN   2
#define BLUE    3

Константные переменные:
const int c_red = 1;
const int c_green = 2;
const int c_blue = 3;
</pre>
От константных переменных перечисления отличает то, что их значения формируются в момент компиляции программы (после предпроцессора), то есть, они являются константами времени компиляции. И это очень важный момент. В частности, по этой причине их можно использовать в метках условного оператора switch. А от директив константы в перечислениях отличает безопасность их использования в различных конструкциях языка Си. Именно поэтому такие константы записывают, как правило, малыми буквами, а не большими, как макроимена, так как они не приводят к каким-либо скрытым ошибкам в коде программы. Все это делает перечисления незаменимым инструментом для объявления и использования целочисленных констант.
<p>
<b>Cпособы объявления перечислени:</b><br>
1. enum colors {red, green, blue};<br>
Константы при таком способе принимают значения по порядку начиная с нуля: red = 0, green = 1, blue = 2
<p>
2. Значения констант можно задавать вручную, например, такими способами:
<pre>
enum keys {vk_enter=27, vk_space, vk_del=30}; //vk_space на единицу больше, то есть, 28
enum {
    go = 0x1f00,  //можно определять числа в шестнадцатеричной системе
    stop = 0x0001, 
    forward = go,
    run = 0x00a2,
    back = run -1
};
</pre>
Перечисление без идентификатора (имени) задает константы, причем некоторые из них определены на основе других, ранее объявленных и с использованием арифметических операций. Так тоже можно делать. Главное, чтобы выражение использовало данные времени компиляции. Последнее перечисление без имени обычно прописывают, если целью является только объявление целочисленных констант.
<p>
В языке Си ключевое слово enum <b>с последующим именем</b> образуют новый составной тип данных. То есть, мы вполне можем объявить переменную такого типа следующим образом:
<pre>
enum keys k_var; //переменная k_var имеет тип keys
</pre>
Что это за тип? На уровне машинных кодов компилятор представляет переменную k_var как целочисленную типа int. А раз так, значит, мы вполне можем заменить тип enum keys на int? Формально да, можем, и программа будет работать абсолютно также. Но есть один нюанс. Тип enum keys для компилятора не в точности соответствует типу int. Отличие я покажу на конкретном примере. Пусть переменная k_var используется в операторе switch следующим образом:
<pre>
#include &lt;stdio.h&gt;
 
enum keys {vk_enter=27, vk_space, vk_del=30};
 
int main(void) 
{
    enum keys k_var = vk_enter;
 
    switch(k_var) {
    case vk_enter:
        puts("vk_enter");
        break;
    case vk_space:
        puts("vk_space");
        break;
    }
 
    return 0;
}
</pre>
Если скомпилировать эту программу с указанием флага –Wall (отображение всех предупреждений), то увидим сообщение:
<pre>
warning: enumeration value 'vk_del' not handled in switch
</pre>
Компилятор предупреждает нас, что мы в операторе switch указали не все варианты значений, заданные в перечислении enum keys. При этом программа компилируется и запускается. Это предупреждение появилось из-за того, что тип переменной k_var соответствует enum keys, а не просто int. Если мы пропишем int:<br>
int k_var = vk_enter;<br>
то компилятор не сможет отловить этот момент, никаких предупреждений выдано не будет. Поэтому, на практике все же лучше не пренебрегать перечислимым типом и использовать именно его, а не тип int. Во всем остальном, переменная k_var ведет себя так же, как и обычная целочисленная переменная. В общем случае ей можно присваивать любые целые значения:
<pre>
enum keys k_var = vk_enter * 2 - vk_space * 100;
</pre>
Хотя, так делать не стоит и лучше присваивать константы, записанные в соответствующем перечислении (в данном случае в keys).
<p>
Переменные перечислимого типа можно задавать при объявлении перечисления. Например, так:
<pre>
enum colors {red, green, blue} wnd_colors;
 
enum {
    go = 0x1f00, 
    stop = 0x0001, 
    forward = go,
    run = 0x00a2,
    back = run -1
} actions, commands;
</pre>
В результате получим объявление глобальных переменных wnd_colors, actions и commands.
<pre>

==============================================================================================================================

</pre>
<a name="typedef"><h3 align=center>Директива typedef</h3>
Директива typedef позволяет задавать пользовательское имя типа. Попросту говоря, она любой тип данных позволяет представить своим придуманным именем (псевдонимом). Например, так:
<pre>
typedef unsigned char BYTE;
</pre>
В результате в программе появляется новое имя BYTE как синоним типа unsigned char. Соответственно, его можно использовать всюду как полноценный тип данных, например:
<pre>
typedef unsigned char BYTE;
 
int main(void) 
{
    BYTE byte;
    BYTE ch, var_ch = '0';
    return 0;
}
</pre>
Компилятор вместо слова BYTE подставит unsigned char и программа будет работать с объявленными переменными, как с беззнаковыми байтовыми.
<p>
Кажется что никакой разницы между директивой препроцессора #define и директивой компилятора typedef нет:<br>
#define BYTE unsigned char<br>
И, действительно, программа скомпилировалась без проблем и отработала бы абсолютно также. Но все же, между определением через директиву #define и директиву typedef есть существенная разница. Директива typedef обрабатывается не препроцессором, а самим компилятором, а потому это более тонкое и безопасное действие. Покажу это на следующем примере:
<pre>
#include &lt;stdio.h&gt;
 
#define PTR_INT int*
 
typedef int* PTR;
 
int main(void) 
{
    PTR_INT a, b;      // int* a, b; указатель *a и переменная b
    PTR ptr_a, ptr_b;  // int *ptr_a, *ptr_b; два указателя
    printf("*a = %d, *b = %d\n", *a, *b);
    printf("*ptr_a = %d, *ptr_b = %d\n", *ptr_a, *ptr_b);
    return 0;
}
</pre>
Мы двумя способами переопределяем тип int* для объявления целочисленных указателей. Затем, в функции main() объявляем два указателя a, b с помощью макровызова PTR_INT и еще два указателя ptr_a, ptr_b с помощью введенного типа PTR. В итоге, после обработки текста программы, мы получим следующий эквивалент объявлений:
<pre>
int* a, b;
int *ptr_a, *ptr_b;
</pre>
Как говорится, почувствуйте разницу. Благодаря тому, что typedef – это директива уровня компилятора, он корректно применяет подмененный тип и каждую переменную делает указателем. А макровызов PTR_INT срабатывает на уровне препроцессора, который «в лоб» на уровне текста программы делает подмену. В итоге получаем не совсем корректный результат.
<p>
Довольно часто директиву typedef применяют с составными типами данных. Обычно, это структуры, о которых мы будем говорить на следующем занятии. Но сейчас я приведу пример с составным перечислимым типом:
<pre>
#include &lt;stdio.h&gt;
 
typedef enum {
    buffer_size = 2048,
    element_size = 12,
    window_size = 400
} SIZE_CONSTS;
 
int main(void) 
{
    SIZE_CONSTS sizes = window_size;
    printf("%d\n", sizes);
    printf("%d\n", buffer_size);
    return 0;
}
</pre>
Обратите внимание, в этом случае имя перечисления прописывать не имеет особого смысла. В дальнейшем все равно предполагается использовать имя типа SIZE_CONSTS для объявления переменных перечислимого типа.
<p>
После всех этих примеров, у вас все равно может остаться вопрос, зачем все это нужно? Только лишь для удобства? Или есть другие причины? Да, причины есть, по крайней мере, еще одна. Помните, когда мы с вами рассматривали некоторые функции, то тип данных у них имел вид size_t. Например, такой тип имеет параметр функции malloc():
<p>
void* malloc(size_t size);
<p>
В действительности, это переопределенный тип с помощью оператора typedef. В моей реализации это следующая замена:
<p>
typedef unsigned int size_t;
<p>
Какую роль играет это переопределение? Смотрите, когда компьютеры были максимум 32-разрядные, то типа unsigned int было вполне достаточно для выделения максимально возможного блока памяти. При переходе к 64-разрядным системам этого размера может быть уже недостаточно и потребуется другое переопределение, например:
<pre>
typedef unsigned long long size_t;
</pre>
При этом сама запись типа size_t сохраняется неизменной. А, значит, неизменными остаются и все прототипы функций, которые используют тип size_t, а также все объявления переменных этого типа. Получается некоторая универсальность текста программы. При необходимости, нам достаточно подменить тип size_t с одного на другой и можно просто перекомпилировать ранее написанные программы без дальнейших переделок. В этом удобство и практичность введенного типа size_t и других ему подобных.
<pre>


</pre>
<a name="typedef_ptr"><h4>typedef для указателей на функцию или многомерных массивов</h4>
Наконец, оператор typedef можно использовать для упрощения записи сложных типов данных, например, указателей на функции или многомерные массивы:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
 
int is_even(int x)
{
    return x % 2 == 0;
}
 
typedef int (*PTR_EVEN)(int); //создаем псевдоним PTR_EVEN указателю на функцию int (*PTR_EVEN)(int)  
typedef char (*PTR_AR_2D)[4]; //псевдоним PTR_AR_2D типу данных = символьному двухмерному массиву.
 
int main(void) 
{
    char ar_2d[5][4] = {0};      //двумерный массив, который заполняется нулями
    PTR_AR_2D ptr_2d = ar_2d;    //PTR_AR_2D - это тип данных, определенный в typedef
    ar_2d[1][2] = 5;
   
    PTR_EVEN func_even = is_even; //PTR_EVEN - это тип данных, func_even - имя указателя на функцию
 
    printf("%d\n", func_even(2));
    printf("%d\n", func_even(3));
 
    printf("%d\n", ptr_2d[1][2]);
 
    return 0;
}
</pre>
Как видите, при замене программа становится более читаемой, поэтому, в ряде случаев, такие замены вполне могут быть использованы.
<pre>

===========================================================================================================================


</pre>








</div>
<br><br><br><br></body></html>
