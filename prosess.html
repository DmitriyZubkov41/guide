<html><head>
<style>body {
            margin: 0;
            padding: 0;
        }

        .container {
            display: flex;
            height: 100%;
        }

        .sidebar {
            # background-color: #136a13;
            background-color: Gray;
            box-sizing: border-box;
            position: fixed;
            height: 100%;
        }

        .content {
            flex: 1;
            padding: 20px;
            box-sizing: border-box;
            margin-left: 100px;
            text-align: justify;
        }

        .sidebar a {
            display: block;
            color: #fff;
            text-decoration: none;
            padding: 10px;
        }
</style>
</head>
<body>
<title>Процессы сокеты</title>
<div class="container">
        <!-- Sidebar -->
        <div class="sidebar">
<a href="index.html">Начальная</a><br>
<a href="#process">Процессы</a><br>
<a href="#socet">Сокеты</a>
</div>

<div class="content">
<a name="process"><h3 align=center>Работа с процессами</h3>
В ОС LINUX существует несколько видов можпроцессного обмена, а точнее сказать средств межпроцессного взаимодействия (Interprocess Communication – IPC), которые можно разбить на несколько уровней:<br>
<ol>
  <li> <b>Перенаправление потоков или pipe (они же конвейеры, так же неименованные каналы)</b>
  <p>
Перенаправление ввода / вывода — это функция командной оболочки операционной системы Linux, которая позволяет перенаправить 
стандартные потоки в <font color=red>файлы</font> или наоборот из него. Все данные распределяются между тремя стандартными 
потоками:
<ul>
     <li>stdin, дескриптор 0 — стандартный ввод (клавиатура);
     <li>stdout, дескриптор 1 — стандартный вывод (вывод на экран);
     <li>stderr, дескриптор 2 — стандартная ошибка (вывод ошибок на экран).
</ul>
<p>
 Перенаправление позволяет Вам указать место, куда отправляются стандартные потоки. Для этого Вы должны использовать 
 специальные операторы перенаправления: < (меньше) и > (больше).<br>
Одна <font color=red><b>></b></font> означает запись стандартного потока команды в файл, при этом, <font color=red>что до 
записи было в файле, все удаляется.</font><br>
Две <font color="red"><b>>></b></font> записывает данные в конец файла.
<p>
Примеры:
<ul>
    <li>конструкцию 2>&1 применяют для перенаправления потока ошибок (stderr) в поток стандартного вывода (stdout).
    <li>ls -l > 123.txt Здесь записываем стандартный вывод команды в файл.
    <li>command 2 > file Здесь, если результат command будет ошибка, то сообщение об ошибке выведется не на экран, а запишется 
    в file. Мы перенаправили сообщение об ошибке с экрана в файл.
</ul>
<p>
<b>Перенаправление на стандартный ввод из файла:</b>
<p>
Можно наоборот перенаправлять файл на стандартный ввод, используя оператор <b><font color=red><</font></b>. Пример: <b>cat < error.txt</b> выведет содержимое файла error.txt
<p>
<b>Перенаправление одновременно стандартного ввода и вывода в файл</b>
<p>
    Можно работать одновременно как и со стандартным вводом, так и со стандартным выводом. Пример:
<p>
<fonr color="green">sort < abc.txt > sorted.txt</font>
<p>
 Сначала мы направили содержимое файла abc.txt на команду sort(стандартный ввод). Команда отсортировала список из файла и 
 направила отсортированный список в новый файл sorted.txt(стандартный вывод).
<p>
<b>Перенаправление с помощью «труб» (конвейеров)</b>:
<p>
Так называемый конвейер команд задействуется, когда Вам нужно перенаправить вывод одной команды на ввод другой <font color=red>команды</font>. В основном, он используется во время построения сложных последовательностей команд.
<p>Например, приведенная ниже команда покажет список из пяти первых строк файла /etc/passwd:
<p>
    <font color=green>cat /etc/passwd | head -n 5</font>

<li> <b>Именованные каналы (FIFO: First In First Out)</b><br>
     Данный вид канала создаётся с помощью mknod или mkfifo, и два различных процесса могут обратиться к нему по имени.
<p>
Пример использования именованного канала (FIFO):<br>
<font color="green"># Создаём именованный канал (FIFO) с именем "mypipe"<br>
    mkfifo mypipe.<br>
    # В одном терминале вводим сообщение, которое будет записано в "mypipe"<br>
    echo "Hello from terminal 1" > mypipe.<br>
    # В другом терминале читаем сообщение из "mypipe"<br>
    cat < mypipe.</font>
</ol>

<h3>Сигналы:</h3>
посылаются:
<ul>
<li> с терминала, нажатием специальных клавиш или комбинаций (например, нажатие Ctrl-C генерирует SIGINT, а Ctrl-Z SIGTSTP);
<li> ядром системы:
    <ul>
        <li> при возникновении аппаратных исключений (недопустимых инструкций, нарушениях при обращении в память, системных сбоях и т. п.);
        <li>ошибочных системных вызовах;
        <li>для информирования о событиях ввода-вывода;
    </ul>
<li>  одним процессом другому (или самому себе), с помощью системного вызова kill(), в том числе: из шелла, утилитой /bin/kill.
</ul>
<b>сигнал</b> — это асинхронное уведомление процесса о каком-либо событии. Когда сигнал послан процессу, операционная система прерывает выполнение процесса. Если процесс установил собственный обработчик сигнала, операционная система запускает этот обработчик, передав ему информацию о сигнале. Если процесс не установил обработчик, то выполняется обработчик по умолчанию.
<p>
Все сигналы начинаются на «SIG…» и имеют числовые соответствия, определяемые в заголовочном файле signal.h. Числовые значения сигналов могут меняться от системы к системе, хотя основная их часть имеет в разных системах одни и те же значения. Утилита kill позволяет задавать сигнал как числом, так и символьным обозначением.
<p>
Как я уже писал, одним из средств управления процессами являются сигналы. Некоторые сигналы можно сгенерировать с помощью определенных комбинаций клавиш, но такие комбинации существуют не для всех сигналов. Зато имеется команда kill, которая позволяет послать заданному процессу (указав его PID) любой сигнал:
    <p>
    <font color=green>kill [-SIG] PID [PID..]</font>
    <p>
    где SIG — это номер сигнала или наименование сигнала, причем если указание сигнала опущено, то посылается сигнал 15 (SIGTERM — программное завершение процесса). Часто используется сигнал 9 (KILL), с помощью которого суперпользователь может завершить любой процесс. Но сигнал этот очень “грубый”, если можно так выразиться, потому что он просто «убивает» процесс, не давая ему времени на корректное сохранение всех обработанных данных. Поэтому в большинстве случаев рекомендуется использовать сигналы TERM или QUIT, которые завершают процесс более “мягко”. Если процессу необходимо как-то по-особенному реагировать на сигнал, он может зарегистрировать обработчик, а если обработчика нет, за него отреагирует система.
<p>
    Два сигнала – 9 ( KILL ) и 19 ( STOP ) – всегда обрабатывает система. Первый из них нужен для того, чтобы убить процесс наверняка (отсюда и название). Сигнал STOP приостанавливает процесс: в таком состояниипроцесс не удаляется из таблицы процессов, но и не выполняется до тех пор, пока не получит сигнал 18 ( CONT) – после чего продолжит работу. В Linux сигнал STOP можно передать активному процессу с помощью управляющего символа ” ^Z “.
<p>
<font color=green>kill &lt;PID&gt;</font><br>
&lt;PID&gt; — это идентификатор процесса, которому посылается сигнал 15 ((SIGTERM) - мягкое уничтожение процесса. 
<p>
Команды pkill и killall убивают процессы по имени.<br>
<font color=green>pkill &lt;имя процесса&gt;<br>
killall &lt;<имя процесса&gt;</font>
<p>
<font color=green>kill -s KILL &lt;PID&gt;<br>
    pkill -s KILL &lt;имя процесса&gt;<br>
    killall -s KILL &lt;имя процесса&gt;</font><br>
Сигнал -s KILL — это один из параметров команд kill, pkill и killall, который отправляет сигнал KILL (9), принудительно жёстко завершая процесс.
<p>
Команда pgrep находит процессы по имени.<br>
    <font color=green>pgrep <имя процесса></font>
    
<h4>Управление заданиями</h4>
    <ul>
    <li> bg запускает задания в фоновом режиме.
    <li> fg переводит задания из фонового режима в нормальный.
    <li> jobs показывает все текущие фоновые задания.
    <li> Ctrl + Z останавливает текущую задачу и переводит её в фон.
    <li> & помещает команду в фоновый режим при запуске.
    </ul>
    Пример: запуск процесса в фоновом режиме<br>
    <font color=green>command &</font>
    <p>
    Обычные пользователи могут посылать сигналы только тем процессам, для которых они являются владельцами. Если в команде kill воспользоваться идентификатором процесса (PID), равным -1, то указанный в команде сигнал будет послан всем принадлежащим данному пользователю процессам. Суперпользователь root может посылать сигналы любым процессам. Когда суперпользователь посылает сигнал идентификатору -1, он рассылается всем процессам, за исключением системных. Если этим сигналом будет SIGKILL, то у простых пользователей будут потеряны все открытые ими, но не сохраненные файлы данных.
    <p>
    При обычном запуске процесс работает на переднем плане. то есть процесс “привязывается” к терминалу, с которого он запущен, воспринимая ввод с этого терминала и осуществляя на него вывод. Но можно запустить процесс в фоновом режиме, когда он не связан с терминалом, для чего в конце командной строки запуска программы добавляют символ &.
    <p>
    В оболочке bash имеются две встроенные команды, которые служат для перевода процессов на передний план или возврата их в фоновый режим. Команда fg переводит указанный в аргументе процесс на передний план, а команда bg — переводит процесс в фоновый режим. Одной командой bg можно перевести в фоновый режим сразу несколько процессов, а вот возвращать их на передний план необходимо по одному. Аргументами команд fg и bg могут являться только номера заданий, запущенных из текущего экземпляра shell. Возможные значения заданий можно увидеть, выполнив команду jobs.
    <p>
    При завершении сессии оболочка посылает всем порожденным ею процессам сигнал “отбой”, по которому порожденные ею процессы могут завершиться, что не всегда желательно. Если вы хотите запустить в фоновом режиме программу, которая должна выполняться и после вашего выхода из оболочки, то ее нужно запускать с помощью утилиты nohup:
    <p>
    <b>[root@proxy 1]#</b> <font color=green>nohup команда &</font>
    

<li> <b>удаленные вызовы процедур (Remote Procedure Calls – RPC)</b><br>

RPC — разновидность технологий, которая позволяет компьютерным программам вызывать функции или процедуры в другом адресном пространстве (как правило, на удалённых компьютерах). Обычно, реализация RPC технологии включает в себя два компонента: сетевой протокол (чаще TCP и UDP, реже HTTP) для обмена в режиме клиент-сервер и язык сериализации объектов (или структур, для необъектных RPC).
<li> <b>сокеты Unix</b><br>

Сокеты UNIX бывают 2х типов: локальные и сетевые. При использовании локального сокета, ему присваивается UNIX-адрес и просто будет создан специальный файл (файл сокета) по заданному пути, через который смогут сообщаться любые локальные процессы путём простого чтения/записи из него. Сокеты представляют собой виртуальный объект, который существует, пока на него ссылается хотя бы один из процессов. При использовании сетевого сокета, создается абстрактный объект привязанный к слушающему порту операционной системы и сетевому интерфейсу,  ему присваивается INET-адрес, который имеет адрес интерфейса и слушающего порта.


<h3 align=center>Управление процессами</h3>
<b>Получение информации о процессе</b>
<br>
Перед тем как управлять процессами, нужно научиться получать о процессах необходимую информацию. 
<br>
Чтобы получить список всех процессов, достаточно ввести команду:
<p>
<font color="green">ps aux</font>
<p>
<img src="./images/process.png">
<p>
Прокомментируем некоторые интересные моменты. Можно заметить, что некоторые процессы указаны в квадратных скобках [ ] – это процессы, которые входят непосредственно в состав ядра и выполняют важные системные задачи, например, такие как управление буферным кэшем [pdflush] и организацией свопинга [kswapd]. С ними лучше не экспериментировать – ничего хорошего из этого не выйдет :). Остальная часть процессов относится к пользовательским.
<p>
Какую информацию можно получить по каждому процессу (комментарии к некоторым полям):
<p><pre>
    PID, PPID – идентификатор процесса и его родителя.
    %CPU – доля процессорного времени, выделенная процессу.
    %MEM – процент используемой оперативной памяти.
    VSZ – виртуальный размер процесса.
    TTY – управляющий терминал.
    STAT– статус процесса:
        R – выполняется;
        S – спит;
        Z – зомби;
        < – Повышенный приоритет;
        + – Находится в интерактивном режиме.
    START – время запуска.
    TIME – время исполнения на процессоре.
</pre>
<p>
Команда ps делает моментальный снимок процессов в текущий момент. В отличии от нее, команда top – динамически выводит состояние процессов и их активность в реальном режиме времени.
<p>
Пример вывода команды top:
<p>
<img src="./images/process1.png"><br>
В верхней части вывода отображается астрономическое время, время, прошедшее с момента запуска системы, число пользователей в системе, число запущенных процессов и число процессов, находящихся в разных состояниях, данные об использовании ЦПУ, памяти и свопа. А далее идет таблица, характеризующая отдельные процессы. Число строк, отображаемых в этой таблице, определяется размером окна: сколько строк помещается, столько и выводится.
<p>
Содержимое окна обновляется каждые 5 секунд. Список процессов может быть отсортирован по используемому времени ЦПУ (по умолчанию), по использованию памяти, по PID, по времени исполнения. Переключать режимы отображения можно с помощью следующих клавиатурных команд:
<p>
    <Shift>+<N> — сортировка по PID;<br>
    <Shift>+<A> — сортировать процессы по возрасту;<br>
    <Shift>+<P> — сортировать процессы по использованию ЦПУ;<br>
    <Shift>+<M> — сортировать процессы по использованию памяти;<br>
    <Shift>+<T> — сортировка по времени выполнения.
<p>
С помощью команды <K> можно завершить некоторый процесс (его PID будет запрошен), а с помощью команды <R> можно переопределить значение nice для некоторого процесса.
<p>
Полезную информацию, так же, позволяет получить программа <b>lsof</b>, которая выдает список всех файлов, используемых сейчас процессами, включая каталоги, занятые потому, что какой-либо процесс использует их в качестве текущего или корневого; разделяемые библиотеки, загруженные в память; и т. д.
<p>
Итак, теперь об управлении процессами.
<h4><b>Управление процессами в Linux</b></h4>

Каждому процессу при запуске устанавливается определенный приоритет, который имеет значение от -20 до +20, где +20 – самый низкий. Приоритет нового процесса равен приоритету процесса-родителя. Для изменения приоритета запускаемой программы существует утилита nice. Пример ее использования:
<p>
<b>[root@proxy 1]#</b> <font color=green>nice [- adnice] command [args]</font>
<p>
где adnice — значение (от –20 до +19), добавляемое к значению nice процесса-родителя. Отрицательные значения может устанавливать только суперпользователь. Если опция adnice не задана, то по умолчанию для процесса-потомка устанавливается значение nice, увеличенное на 10 по сравнению со значением nice родительского процесса.
<p>
Команда renice служит для изменения значения nice для уже выполняющихся процессов. Суперпользователь может изменить приоритет любого процесса в системе. Другие пользователи могут изменять значение приоритета только для тех процессов, для которых данный пользователь является владельцем. При этом обычный пользователь может только уменьшить значение приоритета. Поэтому процессы с низким приоритетом не могут породить “высокоприоритетных детей”.
<p>
Запущенный таким образом процесс будет игнорировать посылаемые ему сигналы (не игнорируются только сигналы SIGHUP и SIGQUIT). Хочу так же выделить команду <b>pstree</b>, которая показывает дерево процессов. Очень наглядно, кстати.
<p>
    <b>top</b> — это программа для мониторинга процессов в реальном времени.
<p>
<b>htop</b> — альтернатива top с большим количеством удобных функций.
<p>
    <h3>Горячие клавиши</h3>
htop:
<ul>
<li> F6 или < и > для сортировки процессов;
<li> F9 или k для убийства процесса;
<li> F2 или S для настройки htop;
<li> F1 или h: отображает экран помощи;
<li> F3 или /: открывает диалог поиска, который позволяет искать процессы по имени;
<li> F5 или t: переключает режим «Дерево», который показывает процессы в виде дерева зависимостей;
<li> F10 или q: выходит из htop.
</ul>
top:
<ul>
<li> M: сортирует процессы по использованию памяти;
<li> P: сортирует процессы по использованию ЦПУ;
<li> T: сортирует процессы по времени (совокупное время ЦПУ);
<li> K: убивает процесс; после нажатия K вам будет предложено ввести PID процесса для завершения;
<li> L: позволяет ввести строку поиска, которая будет применена к списку процессов; отображаются только процессы, имена которых совпадают с этой строкой поиска;
<li> H: показывает или скрывает потоки; по умолчанию top отображает отдельные потоки;
<li> U: отображает только процессы одного пользователя; после нажатия U будет предложено ввести имя пользователя;
<li> q: выходит из top;
<li> h: вызывает справку или активирует горячие клавиши.
</ul>

<b>В каких состояниях может находиться процесс в Linux?</b>
<p>
Каждый запущенный процесс в любой момент времени находится в одном из следующих состояний (которое называют еще статусом процесса):
<ul>
<li> <b>Активен (R=Running)</b> – процесс находится в очереди на выполнение, то есть либо выполняется в данный момент, либо ожидает выделения ему очередного кванта времени центрального процессора.
<li> <b>«Спит» (S=Sleeping)</b> – процесс находится в состоянии прерываемого ожидания, то есть ожидает какого-то события, сигнала или освобождения нужного ресурса.
<li> Находится в состоянии <b>непрерываемого ожидания (D=Direct)</b> – процесс ожидает определенного («прямого») сигнала от аппаратной части и не реагирует на другие сигналы;
<li> <b>Приостановлен (T)</b> – процесс находится в режиме трассировки (обычно такое состояние возникает при отладке программ).
<li> <b>«Зомби» (Z=Zombie)</b> – это процесс, выполнение которого завершилось, но относящиеся к нему структуры ядра по каким-то причинам не освобождены.
</ul>
<pre>

</pre>
<a name="socet"><h3 align=center>Сокеты</h3>
Ссылки: книга Чак Уэнсли Дж. Python. создание приложений стр. 79
<p>
Сокет - это конечная точка программы / сети для связи с внешним миром.<br>
Различают сокеты файловые и сетевые.<br>
Файловые сокеты обеспечивают взаимодействие процессов и находятся внутри одного компьютера.
<p>
<ul>
<li> Существует семейство сокетов Unix, которое обозначает­ся именем AF UNIX (более современное имя AF _LOCAL). Как показывает аббревиатура AF (address family), под ним подразумевается семейство адресов UNIX. В языке Python все еще принято использовать обозначение AF _UNIX. Сокеты этого семейства обеспечивают взаимодействие процессов, работающих на
одном и том же компьютере, поэтому относятся к разновидности файловых сокетов.
<p>
<li> Сокеты второй разновидности являются сетевыми и имеют собственное семейство, AF _INET, которое принято также называть семейством адресов Интернета. Предусмо­трено еще одно семейство адресов, AF _INET6, которое используется для адресации в
протоколе Интернета версии 6 (IPvб).
<p>
<li> Кроме того, в версии Python 2.5 была введена поддержка для специально­го типа сокетов Linux. Семейство сокетов AF _NETLINK (не предусматрива­ющее установления логических соединений; ) обеспечивает межпроцессное взаимодействие между пользовательским кодом и кодом ядра с использованием стандартного интерфейса сокетов BSD.<br>
Еще одним средством для Linux (впервые реализованным в версии 2.6) яви­лась поддержка протокола прозрачного межпроцессного взаимодействия (Transparent Interprocess Communication - TIPC). Протокол TIPC используется для обеспечения обмена данными между кластерами компьютеров без использования адресации на основе IP. Поддержка протокола TIPC в языке Python предусмотрена в форме семейства AF _ ТIРС.
</ul>
Вообще говоря, в языке Python поддерживаются только семейства AF _UNIX, AF NETLINK, АF_TIPC и AF_INET (AF_INET6). В этой главе основное внимание уделено сетевому программированию, поэтому в большей ее части используется семейство AF_INET.
<h4>Адреса сокетов: пара "хост-порт"</h4>
Если сам сокет можно сравнить с телефонной розеткой (частью инфраструктуры, обеспечивающей связь), то имя хоста и номер порта подобны применяемым в сочета­нии коду города и номеру телефона. Наличие оборудования и возможности устанав­ливать связь не принесет никакой пользы, если не известно, с кем и как "связываться".<br>
Адрес в Интернете представляет собой пару, состоящую из имени хоста и номера порта. Не зная оба этих компонента, невозможно установить связь по сети.
<p>
Допустимые номера портов изменяются в диапазоне от О до 65535, хотя номера меньше 1024 зарезервированы для системы. При использовании системы, совмести­мой с POSIX (например, Linux, Мае OS Х и т.д.}, список зарезервированных номеров портов (наряду с обозначениями серверов и протоколов, а также типов сокетов) мож­но найти в файле /etc/ service s. Список известных номеров портов находится на веб-сайте http : / /www . iana . org/ assignments /port-nurnЬers.
<pre>



</pre>
</div></body></html>
