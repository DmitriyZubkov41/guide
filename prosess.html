<html><head></head><body>
<title>Процессы</title>
<h2>Работа с процессами</h2>

В ОС LINUX существует несколько видов можпроцессного обмена, а точнее сказать средств межпроцессного взаимодействия (Interprocess Communication – IPC), которые можно разбить на несколько уровней:<br>
<h3><font color="green">Локально (возможны только в пределах компьютера):</font></h3>
<ol>
  <li> <b>Перенаправление потоков или pipe (они же конвейеры, так же неименованные каналы)</b>
  <p>
   Перенаправление ввода / вывода — это функция командной оболочки операционной системы Linux, которая позволяет перенаправить стандартные потоки в <font color=red>файлы</font> или наоборот из него. Все данные распределяются между тремя стандартными потоками:
   <ul>
     <li>stdin, дескриптор 0 — стандартный ввод (клавиатура);
     <li>stdout, дескриптор 1 — стандартный вывод (вывод на экран);
     <li>stderr, дескриптор 2 — стандартная ошибка (вывод ошибок на экран).
   </ul>
<p>
    Перенаправление позволяет Вам указать место, куда отправляются стандартные потоки. Для этого Вы должны использовать специальные операторы перенаправления — < и >.<br>
    Одна <font color=red><b>></b></font> означает запись стандартного потока команды в файл, при этом, <font color=red>что до записи было в файле, все удаляется.</font><br>
Две <font color="red"><b>>></b></font> записывает данные в конец файла.
<p>
Примеры:
<ul>
    <li>конструкцию 2>&1 применяют для перенаправления потока ошибок (stderr) в поток стандартного вывода (stdout).
    <li>ls -l > 123.txt Здесь записываем стандартный вывод команды в файл.
    <li>command 2 > file Здесь, если результат command будет ошибка, то сообщение об ошибке выведется не на экран, а запишется в file. Мы перенаправили сообщение об ошибке с экрана в файл.
</ul>
<p>
<b>Перенаправление на стандартный ввод из файла:</b>
<p>
Можно наоборот перенаправлять файл на стандартный ввод, используя оператор <b><font color=red><</font></b>. Пример: <b>cat < error.txt</b> выведет содержимое файла error.txt
<p>
<b>Перенаправление одновременно стандартного ввода и вывода в файл</b>
<p>
    Можно работать одновременно как и со стандартным вводом, так и со стандартным выводом. Пример:
<p>
<fonr color="green">sort < abc.txt > sorted.txt</font>
<p>
    Сначала мы направили содержимое файла abc.txt на команду sort(стандартный ввод). Команда отсортировала список из файла и направила отсортированный список в новый файл sorted.txt(стандартный вывод).
<p>
<b>Перенаправление с помощью «труб» (конвейеров)</b>:
<p>
Так называемый конвейер команд задействуется, когда Вам нужно перенаправить вывод одной команды на ввод другой <font color=red>команды</font>. В основном, он используется во время построения сложных последовательностей команд.
<p>Например, приведенная ниже команда покажет список из пяти первых строк файла /etc/passwd:
<p>
    <font color=green>cat /etc/passwd | head -n 5</font>

<li> <b>Именованные каналы (FIFO: First In First Out)</b><br>
     Данный вид канала создаётся с помощью mknod или mkfifo, и два различных процесса могут обратиться к нему по имени.
<p>
Пример использования именованного канала (FIFO):<br>
<font color="green"># Создаём именованный канал (FIFO) с именем "mypipe"<br>
    mkfifo mypipe.<br>
    # В одном терминале вводим сообщение, которое будет записано в "mypipe"<br>
    echo "Hello from terminal 1" > mypipe.<br>
    # В другом терминале читаем сообщение из "mypipe"<br>
    cat < mypipe.</font>
</ol>

<h3>Сигналы:</h3>
посылаются:
<ul>
<li> с терминала, нажатием специальных клавиш или комбинаций (например, нажатие Ctrl-C генерирует SIGINT, а Ctrl-Z SIGTSTP);
<li> ядром системы:
    <ul>
        <li> при возникновении аппаратных исключений (недопустимых инструкций, нарушениях при обращении в память, системных сбоях и т. п.);
        <li>ошибочных системных вызовах;
        <li>для информирования о событиях ввода-вывода;
    </ul>
<li>  одним процессом другому (или самому себе), с помощью системного вызова kill(), в том числе: из шелла, утилитой /bin/kill.
</ul>
<b>сигнал</b> — это асинхронное уведомление процесса о каком-либо событии. Когда сигнал послан процессу, операционная система прерывает выполнение процесса. Если процесс установил собственный обработчик сигнала, операционная система запускает этот обработчик, передав ему информацию о сигнале. Если процесс не установил обработчик, то выполняется обработчик по умолчанию.
<p>
Все сигналы начинаются на «SIG…» и имеют числовые соответствия, определяемые в заголовочном файле signal.h. Числовые значения сигналов могут меняться от системы к системе, хотя основная их часть имеет в разных системах одни и те же значения. Утилита kill позволяет задавать сигнал как числом, так и символьным обозначением.
<p>
Как я уже писал, одним из средств управления процессами являются сигналы. Некоторые сигналы можно сгенерировать с помощью определенных комбинаций клавиш, но такие комбинации существуют не для всех сигналов. Зато имеется команда kill, которая позволяет послать заданному процессу (указав его PID) любой сигнал:
    <p>
    <font color=green>kill [-SIG] PID [PID..]</font>
    <p>
    где SIG — это номер сигнала или наименование сигнала, причем если указание сигнала опущено, то посылается сигнал 15 (SIGTERM — программное завершение процесса). Часто используется сигнал 9 (KILL), с помощью которого суперпользователь может завершить любой процесс. Но сигнал этот очень “грубый”, если можно так выразиться, потому что он просто «убивает» процесс, не давая ему времени на корректное сохранение всех обработанных данных. Поэтому в большинстве случаев рекомендуется использовать сигналы TERM или QUIT, которые завершают процесс более “мягко”. Если процессу необходимо как-то по-особенному реагировать на сигнал, он может зарегистрировать обработчик, а если обработчика нет, за него отреагирует система.
<p>
    Два сигнала – 9 ( KILL ) и 19 ( STOP ) – всегда обрабатывает система. Первый из них нужен для того, чтобы убить процесс наверняка (отсюда и название). Сигнал STOP приостанавливает процесс: в таком состояниипроцесс не удаляется из таблицы процессов, но и не выполняется до тех пор, пока не получит сигнал 18 ( CONT) – после чего продолжит работу. В Linux сигнал STOP можно передать активному процессу с помощью управляющего символа ” ^Z “.
<p>
<font color=green>kill &lt;PID&gt;</font><br>
&lt;PID&gt; — это идентификатор процесса, которому посылается сигнал 15 ((SIGTERM) - мягкое уничтожение процесса. 
<p>
Команды pkill и killall убивают процессы по имени.<br>
<font color=green>pkill &lt;имя процесса&gt;<br>
killall &lt;<имя процесса&gt;</font>
<p>
<font color=green>kill -s KILL &lt;PID&gt;<br>
    pkill -s KILL &lt;имя процесса&gt;<br>
    killall -s KILL &lt;имя процесса&gt;</font><br>
Сигнал -s KILL — это один из параметров команд kill, pkill и killall, который отправляет сигнал KILL (9), принудительно жёстко завершая процесс.
<p>
Команда pgrep находит процессы по имени.<br>
    <font color=green>pgrep <имя процесса></font>
    
<h4>Управление заданиями</h4>
    <ul>
    <li> bg запускает задания в фоновом режиме.
    <li> fg переводит задания из фонового режима в нормальный.
    <li> jobs показывает все текущие фоновые задания.
    <li> Ctrl + Z останавливает текущую задачу и переводит её в фон.
    <li> & помещает команду в фоновый режим при запуске.
    </ul>
    Пример: запуск процесса в фоновом режиме<br>
    <font color=green>command &</font>
    <p>
    Обычные пользователи могут посылать сигналы только тем процессам, для которых они являются владельцами. Если в команде kill воспользоваться идентификатором процесса (PID), равным -1, то указанный в команде сигнал будет послан всем принадлежащим данному пользователю процессам. Суперпользователь root может посылать сигналы любым процессам. Когда суперпользователь посылает сигнал идентификатору -1, он рассылается всем процессам, за исключением системных. Если этим сигналом будет SIGKILL, то у простых пользователей будут потеряны все открытые ими, но не сохраненные файлы данных.
    <p>
    При обычном запуске процесс работает на переднем плане. то есть процесс “привязывается” к терминалу, с которого он запущен, воспринимая ввод с этого терминала и осуществляя на него вывод. Но можно запустить процесс в фоновом режиме, когда он не связан с терминалом, для чего в конце командной строки запуска программы добавляют символ &.
    <p>
    В оболочке bash имеются две встроенные команды, которые служат для перевода процессов на передний план или возврата их в фоновый режим. Команда fg переводит указанный в аргументе процесс на передний план, а команда bg — переводит процесс в фоновый режим. Одной командой bg можно перевести в фоновый режим сразу несколько процессов, а вот возвращать их на передний план необходимо по одному. Аргументами команд fg и bg могут являться только номера заданий, запущенных из текущего экземпляра shell. Возможные значения заданий можно увидеть, выполнив команду jobs.
    <p>
    При завершении сессии оболочка посылает всем порожденным ею процессам сигнал “отбой”, по которому порожденные ею процессы могут завершиться, что не всегда желательно. Если вы хотите запустить в фоновом режиме программу, которая должна выполняться и после вашего выхода из оболочки, то ее нужно запускать с помощью утилиты nohup:
    <p>
    <b>[root@proxy 1]#</b> <font color=green>nohup команда &</font>
    

<h4><font color=green>удаленный</font></h4>
<li> <b>удаленные вызовы процедур (Remote Procedure Calls – RPC)</b><br>

RPC — разновидность технологий, которая позволяет компьютерным программам вызывать функции или процедуры в другом адресном пространстве (как правило, на удалённых компьютерах). Обычно, реализация RPC технологии включает в себя два компонента: сетевой протокол (чаще TCP и UDP, реже HTTP) для обмена в режиме клиент-сервер и язык сериализации объектов (или структур, для необъектных RPC).
<li> <b>сокеты Unix</b><br>

Сокеты UNIX бывают 2х типов: локальные и сетевые. При использовании локального сокета, ему присваивается UNIX-адрес и просто будет создан специальный файл (файл сокета) по заданному пути, через который смогут сообщаться любые локальные процессы путём простого чтения/записи из него. Сокеты представляют собой виртуальный объект, который существует, пока на него ссылается хотя бы один из процессов. При использовании сетевого сокета, создается абстрактный объект привязанный к слушающему порту операционной системы и сетевому интерфейсу,  ему присваивается INET-адрес, который имеет адрес интерфейса и слушающего порта.

<h4><font color=green>высокоуровневый:</font></h4>
Обычно – пакеты программного обеспечения, которые реализуют промежуточный слой между системной платформой и приложением. Эти пакеты предназначены для переноса уже испытанных протоколов коммуникации приложения на более новую архитектуру. Примером можно привести: DIPC, MPI и др. (мне не знакомы, честно говоря)
</ol>
Итак. Подведем маленький итог:<br>
В Linux есть процессы,<br>
каждый процесс может запускать подпроцессы (нити),<br>
создание нового процесса создается клонированием исходного,<br>
прородителем всех процессов в системе является процесс init, запускаемый ядром системы при загрузке.<br>
процессы взаимодействуют между собой по средствам можпроцессного взаимодействия:<br>
<ul>
        <li>каналы
        <li>сигналы
        <li>сокеты
        <li>разделяемая память
</ul>
    каждый процесс обладает свойствами (читай: обладает следующим контекстом):<br>
        PID – идентификатор процесса<br>
        PPID – идентификатор процесса, породившего данный<br>
        UID и GID – идентификаторы прав процесса (соответствует UID и GID  пользователя, от которого запущен процесс)<br>
        приоритет процесса<br>
        состояние процесса (выполнение, сон и т.п.)<br>
        так же у процесса есть таблица открытых (используемых) файлов
<p>
Далее поговорим о том, как посмотреть состояние процессов в Linux и о том, как же ими управлять.

<h3 align=center>Управление процессами</h3>
<b>Получение информации о процессе</b>
<br>
Перед тем как управлять процессами, нужно научиться получать о процессах необходимую информацию. 
<br>
Чтобы получить список всех процессов, достаточно ввести команду:
<p>
<font color="green">ps aux</font>
<p>
Прокомментируем некоторые интересные моменты. Можно заметить, что некоторые процессы указаны в квадратных скобках [ ] – это процессы, которые входят непосредственно в состав ядра и выполняют важные системные задачи, например, такие как управление буферным кэшем [pdflush] и организацией свопинга [kswapd]. С ними лучше не экспериментировать – ничего хорошего из этого не выйдет :). Остальная часть процессов относится к пользовательским.
<p>
Какую информацию можно получить по каждому процессу (комментарии к некоторым полям):
<p><pre>
    PID, PPID – идентификатор процесса и его родителя.
    %CPU – доля процессорного времени, выделенная процессу.
    %MEM – процент используемой оперативной памяти.
    VSZ – виртуальный размер процесса.
    TTY – управляющий терминал.
    STAT– статус процесса:
        R – выполняется;
        S – спит;
        Z – зомби;
        < – Повышенный приоритет;
        + – Находится в интерактивном режиме.
    START – время запуска.
    TIME – время исполнения на процессоре.
</pre>
<p>
Команда ps делает моментальный снимок процессов в текущий момент. В отличии от нее, команда top – динамически выводит состояние процессов и их активность в реальном режиме времени.
<p>
Пример вывода команды top:
<p><font color=green><pre>
14:32:49 up 35 days,  6:01,  4 users,  load average: 0.65, 0.51, 0.49
Tasks: 432 total,   1 running, 431 sleeping,   0 stopped,   0 zombie
CPU0  :  1.6%us,  3.6%sy,  0.0%ni, 85.3%id,  9.2%wa,  0.0%hi,  0.3%si,  0.0%st
CPU1  :  0.9%us,  1.9%sy,  0.0%ni, 96.9%id,  0.0%wa,  0.0%hi,  0.3%si,  0.0%st
Mem:   1033596K total,  1016644K used,    16952K free,    82928K buffers
Swap:  2096376K total,    12632K used,  2083744K free,   478220K cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
 2788 root      15  -5     0    0    0 S  2.0  0.0 404:43.97 md3_raid1
 7961 root      20   0  5964 2528 1684 R  2.0  0.2   0:00.14 top
 6629 root      20   0  8612 2884 2096 S  0.7  0.3   0:00.96 dovecot-auth
   57 root      15  -5     0    0    0 S  0.3  0.0   4:36.10 kblockd/0
 8703 ulogd     20   0 17700 4216  656 S  0.3  0.4  87:23.98 ulogd
11336 ldap      20   0  394M  15M 8292 S  0.3  1.5   5:29.28 slapd
25757 ldap      20   0  394M  15M 8292 S  0.3  1.5   5:11.71 slapd
10991 root      20   0  2188 1004  588 S  0.3  0.1   4:23.33 dovecot
    1 root      20   0  1712  516  464 S  0.0  0.0   0:46.17 init
    2 root      15  -5     0    0    0 S  0.0  0.0   0:00.00 kthreadd
    3 root      RT  -5     0    0    0 S  0.0  0.0   0:05.92 migration/0
.....
 2960 root      16  -4  1980  520  392 S  0.0  0.1   0:10.04 udevd
 2993 dovecot   20   0  4412 1800 1476 S  0.0  0.2   0:00.00 pop3-login
 2994 dovecot   20   0  4412 1800 1476 S  0.0  0.2   0:00.02 pop3-login
</pre></font>
В верхней части вывода отображается астрономическое время, время, прошедшее с момента запуска системы, число пользователей в системе, число запущенных процессов и число процессов, находящихся в разных состояниях, данные об использовании ЦПУ, памяти и свопа. А далее идет таблица, характеризующая отдельные процессы. Число строк, отображаемых в этой таблице, определяется размером окна: сколько строк помещается, столько и выводится.
<p>
Содержимое окна обновляется каждые 5 секунд. Список процессов может быть отсортирован по используемому времени ЦПУ (по умолчанию), по использованию памяти, по PID, по времени исполнения. Переключать режимы отображения можно с помощью следующих клавиатурных команд:
<p>
    <Shift>+<N> — сортировка по PID;<br>
    <Shift>+<A> — сортировать процессы по возрасту;<br>
    <Shift>+<P> — сортировать процессы по использованию ЦПУ;<br>
    <Shift>+<M> — сортировать процессы по использованию памяти;<br>
    <Shift>+<T> — сортировка по времени выполнения.
<p>
С помощью команды <K> можно завершить некоторый процесс (его PID будет запрошен), а с помощью команды <R> можно переопределить значение nice для некоторого процесса.
<p>
Полезную информацию, так же, позволяет получить программа <b>lsof</b>, которая выдает список всех файлов, используемых сейчас процессами, включая каталоги, занятые потому, что какой-либо процесс использует их в качестве текущего или корневого; разделяемые библиотеки, загруженные в память; и т. д.
<p>
Итак, теперь об управлении процессами.
<h4><b>Управление процессами в Linux</b></h4>

Каждому процессу при запуске устанавливается определенный приоритет, который имеет значение от -20 до +20, где +20 – самый низкий. Приоритет нового процесса равен приоритету процесса-родителя. Для изменения приоритета запускаемой программы существует утилита nice. Пример ее использования:
<p>
<b>[root@proxy 1]#</b> <font color=green>nice [- adnice] command [args]</font>
<p>
где adnice — значение (от –20 до +19), добавляемое к значению nice процесса-родителя. Отрицательные значения может устанавливать только суперпользователь. Если опция adnice не задана, то по умолчанию для процесса-потомка устанавливается значение nice, увеличенное на 10 по сравнению со значением nice родительского процесса.
<p>
Команда renice служит для изменения значения nice для уже выполняющихся процессов. Суперпользователь может изменить приоритет любого процесса в системе. Другие пользователи могут изменять значение приоритета только для тех процессов, для которых данный пользователь является владельцем. При этом обычный пользователь может только уменьшить значение приоритета. Поэтому процессы с низким приоритетом не могут породить “высокоприоритетных детей”.
<p>
Запущенный таким образом процесс будет игнорировать посылаемые ему сигналы (не игнорируются только сигналы SIGHUP и SIGQUIT). Хочу так же выделить команду pstree, которая показывает дерево процессов. Очень наглядно, кстати.
<p>
    <b>top</b> — это программа для мониторинга процессов в реальном времени.
<p>
<b>htop</b> — альтернатива top с большим количеством удобных функций.
<p>
    <h3>Горячие клавиши</h3>
htop:
<ul>
<li> F6 или < и > для сортировки процессов;
<li> F9 или k для убийства процесса;
<li> F2 или S для настройки htop;
<li> F1 или h: отображает экран помощи;
<li> F3 или /: открывает диалог поиска, который позволяет искать процессы по имени;
<li> F5 или t: переключает режим «Дерево», который показывает процессы в виде дерева зависимостей;
<li> F10 или q: выходит из htop.
</ul>
top:
<ul>
<li> M: сортирует процессы по использованию памяти;
<li> P: сортирует процессы по использованию ЦПУ;
<li> T: сортирует процессы по времени (совокупное время ЦПУ);
<li> K: убивает процесс; после нажатия K вам будет предложено ввести PID процесса для завершения;
<li> L: позволяет ввести строку поиска, которая будет применена к списку процессов; отображаются только процессы, имена которых совпадают с этой строкой поиска;
<li> H: показывает или скрывает потоки; по умолчанию top отображает отдельные потоки;
<li> U: отображает только процессы одного пользователя; после нажатия U будет предложено ввести имя пользователя;
<li> q: выходит из top;
<li> h: вызывает справку или активирует горячие клавиши.
</ul>

<b>В каких состояниях может находиться процесс в Linux?</b>
<p>
Каждый запущенный процесс в любой момент времени находится в одном из следующих состояний (которое называют еще статусом процесса):
<ul>
<li> <b>Активен (R=Running)</b> – процесс находится в очереди на выполнение, то есть либо выполняется в данный момент, либо ожидает выделения ему очередного кванта времени центрального процессора.
<li> <b>«Спит» (S=Sleeping)</b> – процесс находится в состоянии прерываемого ожидания, то есть ожидает какого-то события, сигнала или освобождения нужного ресурса.
<li> Находится в состоянии <b>непрерываемого ожидания (D=Direct)</b> – процесс ожидает определенного («прямого») сигнала от аппаратной части и не реагирует на другие сигналы;
<li> <b>Приостановлен (T)</b> – процесс находится в режиме трассировки (обычно такое состояние возникает при отладке программ).
<li> <b>«Зомби» (Z=Zombie)</b> – это процесс, выполнение которого завершилось, но относящиеся к нему структуры ядра по каким-то причинам не освобождены.
</ul>



</body></html>
