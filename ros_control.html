<html><head></head><body>
<title>Ros control</title>
Чтобы управлять нашим роботом из ros, для этого служит пакет ros control.
<p>
Ссылки: <a href="https://classic.gazebosim.org/tutorials?tut=ros_control">Tutorial: ROS Control и Gazebo (classic.gazebosim.org)</a><br>
<a href="https://wiki.ros.org/ros_control">wiki.ros.org/ros_control</a>
<h2 align=center>ROS Control</h2>
Пакеты ros control включают интерфейсы контроллера, диспетчеры контроллеров, передачи данных и аппаратные интерфейсы.
<p>
<img src="./images/ros_control.png">
<p>
Пакеты ros_control принимают в качестве входных данных данные о совместном состоянии от датчиков привода вашего робота и заданное значение на входе. В них используется общий механизм обратной связи по контуру управления, обычно ПИД-регулятор, для управления выходными данными, обычно усилием, передаваемым на ваши приводы. ros_control усложняется для физических механизмов, которые не имеют взаимно однозначных отображений совместных позиций, усилий и т.д., но эти сценарии учитываются с использованием передач.
<h4>Контроллеры:</h4>
Список доступных плагинов для контроллеров, содержащийся в разделе ros_controllers, на момент написания этой статьи. Вы, конечно, можете создать свой собственный и не ограничиваться приведенным ниже списком.
<ul>
<li> <b>joint_state_controller</b> - Публикует состояние всех ресурсов, зарегистрированных в интерфейсе hardware_interface::JointStateInterface, в топик типа sensor_msgs/JointState.<br>
Состоит из joint_state_controller
<li> <b>position_controllers</b> - командует желаемой позицией аппаратному интерфейсу (HardwareInterface).<br>
Содержит:
<ul>
    <li> joint_position_controller - Получает входные данные о местоположении и отправляет выходные данные о местоположении, просто передавая входные данные с помощью forward_command_controller.
    <li> joint_group_position_controller - Устанавливает несколько положений соединения одновременно.
</ul>
<li> <b>velocity_controllers</b> - задает желаемую скорость аппаратному интерфейсу.
    <ul>
        <li> joint_position_controller - получает входные данные о местоположении и отправляет выходные данные о скорости, используя ПИД-регулятор.
        <li> joint_velocity_controller - Получает входные данные о скорости и отправляет выходные данные о скорости, просто передавая входные данные с помощью forward_command_controller.
        <li> joint_group_velocity_controller - устанавливает несколько скоростей соединения одновременно.
     </ul>
<li> <b>effort_controllers</b> - передает команду на требуемое усилие (силу/крутящий момент) в аппаратный интерфейс.
    <ul>
    <li> joint_position_controller - получает входные данные о положении и отправляет выходные данные об усилии, используя ПИД-регулятор.
    <li> joint_group_position_controller - Устанавливает несколько положений соединения одновременно.
    <li> joint_velocity_controller - получает входные данные о скорости и отправляет выходные данные об усилии, используя ПИД-регулятор.
    <li> joint_effort_controller - Получает входные данные об усилиях и отправляет выходные данные об усилиях, просто передавая входные данные с помощью forward_command_controller.
    <li> join_group_effort_controller - настройка нескольких совместных действий одновременно.
    </ul>
<li> <b>joint_trajectory_controllers</b> - Дополнительная функциональность для построения полной траектории. Взгляните на исходный файл, чтобы понять, как joint_trajectory_controller связан с пространством имен position_controller, velocity_controller и т.д.
       <ul>
       <li> position_controller
       <li> velocity_controller
       <li> effort_controller
       <li> position_velocity_controller
       <li> position_velocity_acceleration_controller
       </ul>
</ul>

<h4>Hardware Interfaces</h4>
Аппаратные интерфейсы используются ROS control совместно с одним из вышеперечисленных контроллеров ROS для отправки и приема команд на аппаратное обеспечение. Список доступных аппаратных интерфейсов (через диспетчер аппаратных ресурсов) на момент написания этой статьи. Если аппаратный интерфейс для вашего робота еще не существует, вы, конечно, можете создать свой собственный и не ограничиваться этим списком:
<ul>
<li> Joint Command Interface - аппаратный интерфейс для поддержки управления массивом соединений. Обратите внимание, что эти команды могут иметь любое семантическое значение, если каждая из них может быть представлена одним символом double, они не обязательно являются командами усилия. Чтобы указать значение этой команды, обратитесь к производным классам.:
      <ul>
      <li> Effort Joint Interface - для управления суставами, основанными на усилиях.
      <li> Velocity Joint Interface - для управления скоростными соединениями.
      <li> Position Joint Interface - для управления позиционными соединениями.
      </ul>
<li> Joint State Interfaces - Аппаратный интерфейс для поддержки считывания состояния массива именованных соединений, каждое из которых имеет определенное положение, скорость и усилие (силу или крутящий момент).
<li> Actuator State Interfaces - Аппаратный интерфейс для поддержки считывания состояния массива именованных исполнительных механизмов, каждый из которых имеет определенное положение, скорость и усилие (силу или крутящий момент).
<li> Actuator Command Interfaces
     <ul>
     <li> Effort Actuator Interface
     <li> Velocity Actuator Interface
     <li> Position Actuator Interface
     </ul>
<li> PosVelJointInterface
<li> PosVelAccJointInterface
<li> Force-torque sensor Interface
<li> IMU sensor Interface     
</ul>
<h4>Transmissions</h4>
Трансмиссия - это элемент в вашем конвейере управления, который преобразует переменные усилия/потока таким образом, чтобы их результат - мощность - оставался постоянным. Реализация интерфейса трансмиссии преобразует переменные усилия/потока в выходные переменные усилия/потока с сохранением мощности.
<p>
<a href="http://ros.org/wiki/urdf/XML/Transmission">transmission в urdf</a>

<h4>Joint Limits</h4>
Интерфейс join_limits_interface содержит структуры данных для представления совместных ограничений, методы для их заполнения из распространенных форматов, таких как URDF и rosparam, и методы для обеспечения соблюдения ограничений для различных видов совместных команд.
<p>
Интерфейс joint_limits_interface не используется самими контроллерами (он не реализует аппаратный интерфейс), но вместо этого работает после обновления контроллеров в методе write() (или эквивалентном) абстракции robot. Принудительное применение ограничений приведет к перезаписи команд, заданных контроллерами, и не будет работать с отдельным буфером необработанных данных.

<h4>Установка пакетов ros control</h4>
<pre>sudo apt-get install ros-noetic-ros-control ros-noetic-ros-controllers</pre>


<h3 align=center><a href="https://classic.gazebosim.org/tutorials?tut=ros_control">Tutorial: ROS Control</a></h3>
В этом руководстве мы настроим имитационные контроллеры для управления суставами вашего робота. Это позволит нам предоставить правильные интерфейсы ROS для таких проектировщиков, как MOVEit!. Мы будем использовать пакеты ros_control, новый стандарт в ROS для интерфейсов контроллеров.
<p>
Имитация работы контроллеров робота в Gazebo может быть выполнена с помощью ros_control и простого адаптера плагинов Gazebo. Ниже представлен обзор взаимосвязи между моделированием, аппаратным обеспечением, контроллерами и передачами.:
<p>
<img src="./images/ros_control1.png">
<p>
В этом руководстве использованы многие концепции, описанные в предыдущих руководствах. Мы снова будем использовать RRBot, который был настроен в руководстве по использованию URDF в Gazebo, в качестве примера для плагинов, описанных здесь.
<p>
Убедитесь, что вы уже установили ros_control, ros_controllers и их зависимости.

<h4>Добавление &lt;transmission&gt; в URDF</h4>
Чтобы использовать ros_control в вашем роботе, вам необходимо добавить несколько дополнительных элементов в ваш URDF. Элемент &lt;transmission&gt; используется для привязки приводов к шарнирам, точный формат XML приведен в <a href="http://ros.org/wiki/urdf/XML/Transmission">спецификации &lt;transmission&gt;</a>.
<p>
------------------------------------------------------------------------<br>
Пример:
<pre>
&lt;transmission name="simple_trans"&gt;
   2   &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
   3   &lt;joint name="foo_joint"&gt;
   4     &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;
   5   &lt;/joint&gt;
   6   &lt;actuator name="foo_motor"&gt;
   7     &lt;mechanicalReduction&gt;50&lt;/mechanicalReduction&gt;
   8     &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;
   9   &lt;/actuator&gt;
  10 &lt;/transmission&gt;</pre>
Атрибут <b>name</b> определяет уникальное имя трансмиссии.<br>
&lt;type&gt; -  Определяет тип передачи.<br>
&lt;joint&gt;<br>
Может быть несколько. Соединение, к которому подключена передача. Соединение определяется его атрибутом name и следующими подэлементами:<br>
&lt;hardwareInterface&gt; Указывает поддерживаемый аппаратный интерфейс joint-space. Обратите внимание, что значение этого тега должно быть EffortJointInterface, когда эта передача загружается в Gazebo, и hardware_interface/EffortJointInterface, когда эта передача загружается в RobotHW<br>
&lt;actuator&gt; Привод (мотор), к которому подключена трансмиссия. Привод определяется с помощью атрибута name и следующих подэлементов:<br>
&lt;mechanicalReduction&gt; (optional)<br>
Указывает на механическое уменьшение нагрузки на шарнир/приводную коробку передач. Этот параметр может потребоваться не для всех коробок передач.<br>
&lt;hardwareInterface&gt; (optional) (one or more occurrences)<br>
Указывает поддерживаемый аппаратный интерфейс joint-space. Обратите внимание, что тег <hardwareInterface> следует указывать только в версиях ROS, предшествующих Indigo. Правильное место для указания этого тега - в теге &lt;joint&gt;.
<p>----------------------------------------------------------------------------------------------------------------<p>

Для целей gazebo_ros_control в его текущей реализации единственной важной информацией в этих тегах передачи являются:
<p>
&lt;joint name=""&gt;<br>
&lt;type&gt; тип передачи. В настоящее время реализован только "transmission_interface/SimpleTransmission". (не стесняйтесь добавлять больше)<br>
&lt;hardwareInterface&gt; - внутри &lt;actuator&gt; and &lt;joint&gt; тегов. это указывает плагину gazebo_ros_control, какой аппаратный интерфейс загружать (интерфейсы положения, скорости или усилия). В настоящее время реализованы только интерфейсы усилия. (не стесняйтесь добавлять больше)
<p>
Остальные имена и элементы в настоящее время игнорируются.

<h4>Добавление gazebo_ros_control plugin</h4>
В дополнение к тегам передачи в ваш URDF необходимо добавить плагин Gazebo, который фактически анализирует теги передачи и загружает соответствующие аппаратные интерфейсы и диспетчер контроллеров. По умолчанию плагин gazebo_ros_control очень прост, хотя он также может быть расширен за счет дополнительной архитектуры плагина, позволяющей опытным пользователям создавать свои собственные аппаратные интерфейсы для роботов между ros_control и Gazebo.
<p>
По умолчанию код плагина (в конце urdf):
<pre>
&lt;gazebo&gt;
  &lt;plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so"&gt;
    &lt;robotNamespace&gt;/MYROBOT&lt;/robotNamespace&gt;
  &lt;/plugin&gt;
&lt;/gazebo&gt;</pre>
Тег &lt;plugin&gt; имеет дочерние теги:
<ul>
<li> &lt;robotNamespace&gt; Пространство имен ROS, которое будет использоваться для этого экземпляра плагина, по умолчанию имеет значение name в теге &lt;robot в URDF/SDF.
<li> &lt;controlPeriod&gt; Период обновления контроллера (в секундах) по умолчанию равен периоду работы Gazebo
<li> &gt;robotParam&lt; Расположение robot_description (URDF) на сервере параметров по умолчанию равно "/robot_description"
<li> &lt;robotSimType&gt; Имя pluginlib пользовательского интерфейса robot sim, который будет использоваться (более подробную информацию смотрите ниже), по умолчанию равно "DefaultRobotHWSim"
</ul>
<p>
<a href="https://classic.gazebosim.org/tutorials?tut=ros_gzplugins">Tutorial: Using Gazebo plugins with ROS</a>
<h4>Поведение gazebo_ros_control по умолчанию</h4>
По умолчанию, без тега &lt;robotSimType&gt;, gazebo_ros_control попытается получить всю информацию, необходимую для взаимодействия с контроллером на базе ros_control, из URDF. Этого достаточно для большинства случаев и хорошо, по крайней мере, для начала.
<p>
Поведение по умолчанию обеспечивает следующие интерфейсы ros_control:
<ul>
<li> hardware_interface::JointStateInterface
<li> hardware_interface::EffortJointInterface
<li> hardware_interface::VelocityJointInterface - не реализован в полной мере
</ul>
<h4>Дополнительно: пользовательские плагины для моделирования gazebo_ros_control</h4>
Плагин gazebo_ros_control Gazebo также предоставляет интерфейс на основе pluginlib для реализации пользовательских интерфейсов между Gazebo и ros_control для моделирования более сложных механизмов (нелинейных пружин, связей и т.д.).
<p>
Эти плагины должны наследовать gazebo_ros_control::RobotHWSim, который реализует имитируемый аппаратный интерфейс ros_control::RobotHW. RobotHWSim предоставляет доступ на уровне API для чтения и управления совместными свойствами в Gazebo simulator.
<p>
Соответствующий подкласс RobotHWSim указан в модели URDF и загружается при загрузке модели робота. Например, следующий XML-файл загрузит плагин по умолчанию (то же поведение, что и при использовании тега <robotSimType>).:
<pre>
&lt;gazebo&gt;
  &lt;plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so"&gt;
    &lt;robotNamespace&gt;/MYROBOT&lt;/robotNamespace&gt;
    &lt;robotSimType&gt;gazebo_ros_control/DefaultRobotHWSim&lt;/robotSimType&gt;
  &lt;/plugin&gt;
&lt;/gazebo&gt;</pre>
<h4>RRBot Example</h4>
Мы добавляем блок &lt;transmission&gt;, аналогичный приведенному ниже, для каждого соединения, которое мы хотим задействовать в Gazebo. Обратите внимание, что &lt;hardwareInterface&gt; должен быть включен как в теги &lt;joint&gt;, так и &lt;actuator&gt; (<a href="https://github.com/ros-controls/ros_control/issues/177">смотрите здесь проблему с ros_control</a>). Откройте свой файл rrbot.xacro, и в нижней части файла вы должны увидеть:
<pre>
&lt;transmission name="tran1"&gt;
    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
    &lt;joint name="joint1"&gt;
      &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;
    &lt;/joint&gt;
    &lt;actuator name="motor1"&gt;
      &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;
      &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
    &lt;/actuator&gt;
  &lt;/transmission&gt;

  &lt;transmission name="tran2"&gt;
    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
    &lt;joint name="joint2"&gt;
      &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;
    &lt;/joint&gt;
    &lt;actuator name="motor2"&gt;
      &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;
      &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
    &lt;/actuator&gt;
  &lt;/transmission&gt;</pre>
Вы также увидите плагин gazebo_ros_control в rrbot.gazebo, который используется во всех тегах &lt;transmission&gt;
<pre>
&lt;gazebo&gt;
  &lt;plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so"&gt;
    &lt;robotNamespace&gt;/rrbot&lt;/robotNamespace&gt;
  &lt;/plugin&gt;
&lt;/gazebo&gt;</pre>
<h4>Создайте пакет ros_controls</h4>
Далее нам нужно будет создать файл конфигурации и файл запуска для наших контроллеров ros_control, которые взаимодействуют с Gazebo.
<p>
<b>Создаём новый пакет:</b>
<pre>
mkdir ~/catkin_ws
cd ~/catkin_ws
catkin_create_pkg MYROBOT_control controller_manager joint_state_controller robot_state_publisher
cd MYROBOT_control
mkdir config
mkdir launch</pre>
Полный рабочий пример пакета, о котором мы говорим в этом разделе, можно найти по адресу <a href="https://github.com/ros-simulation/gazebo_ros_demos/tree/kinetic-devel/rrbot_control">rrbot_control</a>.
<h4>Создаём конфигурационный файл.yaml</h4>
Значения коэффициента усиления и настройки контроллера должны быть сохранены в файле yaml, который загружается на сервер параметров через файл roslaunch. В папке config вашего пакета MYROBOT_control адаптируйте следующий пример RRBot к вашему роботу как MYROBOT_control/config/rrbot_control.yaml.:
<pre>
rrbot:
  # Publish all joint states -----------------------------------
  joint_state_controller:
    type: joint_state_controller/JointStateController
    publish_rate: 50  

  # Position Controllers ---------------------------------------
  joint1_position_controller:
    type: effort_controllers/JointPositionController
    joint: joint1
    pid: {p: 100.0, i: 0.01, d: 10.0}
  joint2_position_controller:
    type: effort_controllers/JointPositionController
    joint: joint2
    pid: {p: 100.0, i: 0.01, d: 10.0}</pre>
Более подробную информацию об этих контроллерах смотрите в следующем разделе.   
<h4>Создание launch файла</h4>
Создайте файл launch для запуска контроллеров ros_control. В папке launch создайте файл MYROBOT_control/launch/MYROBOT_control.launch и вставьте следующий код:
<pre>
&lt;launch&gt;

  &lt;!-- Load joint controller configurations from YAML file to parameter server --&gt;
  &lt;rosparam file="$(find rrbot_control)/config/rrbot_control.yaml" command="load"/&gt;

  &lt;!-- load the controllers --&gt;
  &lt;node name="controller_spawner" pkg="controller_manager" type="spawner" respawn="false"
    output="screen" ns="/rrbot" args="joint1_position_controller joint2_position_controller joint_state_controller"/&gt;

  &lt;!-- convert joint states to TF transforms for rviz, etc --&gt;
  &lt;node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher"
    respawn="false" output="screen"&gt;
    &lt;remap from="/joint_states" to="/rrbot/joint_states" /&gt;
  &lt;/node&gt;

&lt;/launch&gt;</pre>
Первая строка, "rosparam", загружает настройки контроллера на сервер параметров путем загрузки файла конфигурации yaml (обсуждается в следующем разделе).
<p>
Узел controller_spawner запускает два контроллера совместного позиционирования для RRBot, запуская скрипт на python, который выполняет сервисный вызов для диспетчера контроллеров ros_control. Сервисные вызовы сообщают диспетчеру контроллеров, какие контроллеры вам нужны. Он также загружает третий контроллер, который публикует общие состояния всех соединений с помощью hardware_interfaces и объявляет тему в /joint_states. Spawner - это просто вспомогательный скрипт для использования с roslaunch.
<p>
В последней строке запускается узел robot_state_publisher, который просто прослушивает сообщения /join_states от join_state_controller, а затем публикует преобразования в /tf. Это позволяет вам видеть вашего моделируемого робота в Rviz, а также выполнять другие задачи.

<h4>Запускаем контроллеры с помощью roslaunch</h4>
Запустите симуляцию RRBot:
<pre>roslaunch rrbot_gazebo rrbot_world.launch</pre>
Загрузите контроллеры для двух соединений, запустив второй файл запуска:
<pre>roslaunch rrbot_control rrbot_control.launch</pre>

<h4>Использование сервиса вручную</h4>
Если вы сначала загрузите rrbot_control.файлы yaml на сервер параметров, вы можете загрузить контроллеры вручную с помощью запросов на обслуживание. Мы приведем их здесь для справки, хотя обычно предпочитаем roslaunch.<br>
Загрузить контроллеры:
<pre>
rosservice call /rrbot/controller_manager/load_controller "name: 'joint1_position_controller'"
rosservice call /rrbot/controller_manager/load_controller "name: 'joint2_position_controller'"</pre>
Стартовать контроллеры:
<pre>
rosservice call /rrbot/controller_manager/switch_controller "{start_controllers:
 ['joint1_position_controller','joint2_position_controller'], stop_controllers: [], strictness: 2}"</pre>

<h4>Отправка примеров команд вручную</h4>
Отправить им примеры совместных команд для тестирования:
<pre>
rostopic pub -1 /rrbot/joint1_position_controller/command std_msgs/Float64 "data: 1.5"
rostopic pub -1 /rrbot/joint2_position_controller/command std_msgs/Float64 "data: 1.0"</pre>

<h4>Используем RQT Для Отправки Команд</h4>
В этом разделе мы рассмотрим инструменты, которые помогут вам визуализировать производительность вашего контроллера и настроить любые коэффициенты усиления / параметры, которые могут быть у контроллера, в частности, коэффициент усиления PID. Мы будем использовать RQT, пользовательский интерфейс ROS на основе плагинов, поэтому сначала убедитесь, что он установлен.<br>
Старт RQT:
<pre>rosrun rqt_gui rqt_gui</pre>

<h4>Add a Command Publisher</h4>
В меню "Plugins" RQT добавьте плагин "Topics-> Message Publisher'", затем выберите топик из выпадающего списка, которая управляет любым конкретным контроллером, который вы хотите опубликовать. Для RRBot добавьте контроллер:
<pre>/rrbot/joint1_position_controller/command</pre>
Затем нажмите зеленую кнопку со знаком "плюс" в правом верхнем углу экрана.
<p>
Включите публикатора топика, установив флажок слева от названия топика. Установите в столбце "Частота" значение 100 (частота, с которой мы отправляем ит-команды, в данном случае - 100 Гц).
<p>
Затем раскройте тему так, чтобы вы увидели строку "данные". В столбце "выражение", в строке "данные", попробуйте использовать разные значения в радианах между пределами соединения joint1 - в случае RRBot ограничений нет, поскольку соединения непрерывны, поэтому подойдет любое значение. Вы должны быть в состоянии заставить RRBot поворачиваться, если вы выполняете это руководство с этим роботом.
<p>
Затем в том же поле выражения мы заставим его автоматически изменять значения, используя синусоидальную волну. Добавьте следующее:
<pre>sin(i/100)</pre>
Для более совершенного управления вы можете настроить его таким образом, чтобы он подавал синусоидальную волну в точном соответствии с размерами суставов вашего робота:
<pre>sin(i/rate*speed)*diff + offset</pre>
Объяснение переменных:
<ul>
<li> i - переменная RQT для определения времени
<li> rate - частота, с которой вычисляется это выражение. Это должно быть то же число, что и в столбце "Частота" у издателя темы. Рекомендуемое значение - 100.
<li> speed - как быстро вы хотите, чтобы соединение сработало. Начните с 1 для медленной скорости
<li> upper_limit и lower_limits - общие ограничения оборудования, управляемого этим контроллером.
<li> diff = (upper_limit - lower_limit)/2
<li> offset = upper_limit-diff
</ul>
<h4>Визуализируйте работу контроллера</h4>
Добавьте плагин Plot в RQT и добавьте ту же тему, что и та, которую вы выбрали выше, для темы publisher:
<pre>/rrbot/joint1_position_controller/command/data</pre>
Нажмите зеленую кнопку "Добавить". Теперь на экране должна появиться синусоидальная волна.
<p>
Добавьте еще один раздел в плагин Plot, который отслеживает фактическое положение управляемого привода. Вы захотите уменьшить разницу между этими двумя значениями, настроив коэффициенты усиления PID, как показано на следующем шаге. Для RRBot:
<pre>/rrbot/joint1_position_controller/state/process_value</pre>
Ваш экран должен выглядеть примерно так:
<p>
<img src="./images/ros_control2.png">
<p>
Примечание: известно, что после запуска плагина RQT plot в течение некоторого времени (>1 минуты) возникают ошибки. Рисунки начинают странно отображаться. Текущее решение - нажать синюю кнопку обновления в правом верхнем углу плагина.
<h4>Настройка коэффициента усиления PID</h4>
Наконец, мы будем использовать динамическую реконфигурацию для настройки пропорционального, производного и интегрального коэффициентов усиления ПИД-регулятора, предполагая, что это применимо к вашему роботу.
<p>
Добавьте плагин "Dynamic Reconfigure" в RQT и нажмите "Expand All", чтобы просмотреть дополнительные опции. Предполагая, что ваш контроллер использует PID, вам следует использовать параметр "pid". Нажав на нее, вы увидите 5 ползунков, которые позволяют настроить контроллер, как показано на следующем скриншоте. Изменяйте эти значения, пока не добьетесь желаемой производительности вашего контроллера.
<p>
<img src="./images/ros_control3.png">
<p>
<b>Используйте roslaunch, чтобы сохранить вашу перспективу RQT</b>
<br>Предварительно настроенную перспективу RQT для rrbot можно легко запустить с помощью следующей команды:
<pre>roslaunch rrbot_control rrbot_rqt.launch</pre>
Вы можете использовать это в качестве шаблона для работы с вашим собственным роботом.

<h4>Подключите Rviz к Gazebo</h4>
еперь, когда вы используете ros_control для отправки команд вашему роботу в симуляторе, вы также можете использовать ros_control jointstatecontroller для считывания состояния робота из Gazebo. Идея хорошего симулятора заключается в том, что вы должны иметь возможность использовать на своем реальном оборудовании то же программное обеспечение, что и при моделировании. Хорошей отправной точкой для этого является визуализация вашего моделируемого робота в Rviz, аналогично тому, как это делается с реальным оборудованием.
<p>
Предполагая, что вы уже запускаете joint_state_controller, как описано выше в ваших файлах:
<pre>rosrun rviz rviz</pre>
В разделе "Global Options" измените "Fixed Frame" на "world", чтобы устранить все возможные ошибки, которые он может вам выдать.
<p>
Затем добавьте в Rviz тип отображения "RobotModel", и вы увидите, как ваш смоделированный робот в Gazebo визуализируется в Rviz!




<br><br><br><br></body></html>
