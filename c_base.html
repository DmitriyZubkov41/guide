<html><head>
<style>
.menu {
       height: 100%;
       width: 130px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 10px;
           margin-left: 130px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Cи</title>
<div class="menu">
<a href="./index.html">Главная</a>
----------------------
<a href="./c_loop.html">Условия, циклы</a>
<a href="./c_massiv.html">Указатели, массивы, строки</a>
<a href="./c_funk.html">Функции</a>
<a href="./c_struct.html">Структуры</a>
<a href="./c_example.html">Примеры</a>
<a href="./c_example_pointer.html">Примеры по массивам указателям</a>
<a href="./c_example_struct.html">Примеры по структурам</a>
---------------------
Основы языка Си
<a href="#kompilyator">Предпроцессор и компилятор</a>
<a href="#bit">Системы счисления</a>
<a href="#type">Типы переменных</a>
<a href="#getchar">getchar и putchar()</a>
<a href="#printf">printf() и scanf()</a>
<a href="#arifm">Арифметические операции</a>
<a href="#bool">Операции сравнения</a>
<a href="#prioritet">Приоритет операций</a>
<a href="#memory">Управление памятью</a>
</div>

<div class="content">
<h2 align=center><a name="lib">Язык программирования Си</h2>
Учебники: <a href="https://metanit.com/c/tutorial/">Руководство по языку программирования Си</a>
<p>
Для изучения C++ рекомендуют сначала освоить Cи.<br>
Как я понял, наиболее близким к языку на машинном коде является Ассемблер, далее более понятным человеку является язык С и 
самым понятным удобным является С++.
<p><a href="https://habr.com/ru/sandbox/149138/">В чем разница между C и C++?</a>
<h3 align=center>Как работать на Cи</h3>
Язык C является компилируемым. Это означает, что выполнения программы должен быть создан эксешник этой программы. Сама программа, 
написанная на C имеет расширение .c
<p>
Компилятором для С является программа gcc.<br>
В ubuntu, он автоматически установлен. В Windows его нужно скачивать и устанавливать.
<p>
Для скриптов на С создал в домашней папке папку С.<br>
Мой первый скрипт example.c (написан в VSCode):
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;stdio.h&gt;
 
int main(void) 
{
    printf("Hello, world\n");
    return 0;
}
</pre>
</td></tr></table>
Далее  в терминале VSCode выполнил команду:
<pre>
dmitriy@945G-M3:~/C$ gcc example.c
</pre>
Был в той же папке создан файл a.out
<p>
В терминале выполнял команды: a.out и a.exe.<br>
<i>Команда не найдена</i>
<p>
<a href="https://uzverss.livejournal.com/57719.html">О GCC, компиляции и библиотеках часть 1</a>
<p>
Компилятор GCC по умолчанию для unix-систем выдаёт файл с именем a.out, если не используется опция -o.
<p>
<i>Любопытно, компиляторы одни из немногих приложений UNIX для которых не безразлично расширение файлов. По расширению GCC 
определяет что за файл перед ним и, что с ним нужно (можно) сделать. Файлы исходного кода на языке C должны иметь 
расширение .c, 
на языке C++, как вариант, .cpp, заголовочные файлы на языке C .h, объектные файлы .o и так далее. Если использовать 
неправильное расширение, gcc будет работать не корректно (если вообще согласиться, что-либо делать).</i>
<p>
<img src="./images/c_base.png">
<p>
Утилита file выводит информацию о типе (с точки зрения системы) переданного в коммандной строке файла, для некоторых типов 
файлов выводит всякие дополнительные сведения касающиеся содержимого файла.
<p>
Выполнил:
<pre>
dmitriy@945G-M3:~/C$ ./a.out
Hello, world
</pre>
Нужно было после точки указать <b>'/'</b>
<pre>

============================================================================================================================

</pre>
<a name="kompilyator"><h3 align=center>Предпроцессор и компилятор</h3>
<h4>Процесс компиляции с помощью gcc</h4>
Процесс компиляции можно разбить на 4 основных этапа:
<ol>
<li> обработка препроцессором<br>
Препроцессор осуществляет подготовку исходного файла к компиляции - вырезает комментарии, добавляет содержимое заголовочных 
файлов (директива препроцессора #include), реализует раскрытие макросов (символических констант, директива препроцессора 
#define). Затем чистый код, без макросов и директив подается на компилятор, который знать не знает ни о каких макросах и директивах...
<li> собственно компиляция<br>
Компилятор превращает текст программы в машинный код - закодированные в виде битов команды и данные.
<li> ассемблирование
<li> линковка (связывание)
</ol>
<p>
Опции gcc позволяют прервать процесс на любом из этих этапов.
<p>


<pre>


==========================================================================================================================


</pre>
<h3 align=center>Структура программ на языке Cи</h3>
<b>Комментарий</b><br>
Многострочные комментарии в С заключаются в
<pre>
 /*
 это комментарий
 */
 </pre>
Открывается слэшем и закрывается слэшем.<br>
Однострочный комментарий пишется после двойного слэша: <b>// комментарий</b><br>
Обычно однострочный комментарий пишется после команды, чтобы объяснить что эта команда делает.
<h4>Директивы предпроцессора</h4>
<i>#include &lt;stdio.h&gt;</i>
<p>
Все директивы начинаются с символа: <b>#</b><br>
include - это имя директивы<br>
&lt;stdio.h&gt; - это имя библиотеки, нужная для выполнения команды printf()<br>
stdio от standart input output<br>
расширение .h означает header (заголовок)
<h4>Функции</h4>
Первая функция в С всегда называется main
<pre>
int main(void)
{

}
</pre>
Ключевое слово int означает, что функция main возвращает целые числа.
<br>В скобках находятся параметры функции. Слово void означает отсутствие параметров.<br>
В фигурных скобках находится тело функции.
<pre>

========================================================================================================================

</pre>
<a name="bit"><h3 align=center>Системы счисления чисел</h3>
<h4>Перевод в десятичную систему счисления</h4>
Преобразовать число из любой системы счисления в десятичную можно следующим образом: каждый разряд числа необходимо умножить 
на Xn, где X - основание исходного числа, n - номер разряда. Затем суммировать полученные значения.
<p>
<img src="./images/c_base1.png">
<p>
<h4>Представление отрицательных целых чисел в двоичной системе</h4>
Хорошо, мы с вами только что увидели, как можно кодировать целые положительные числа в восьми битах. А что если нам необходимо 
представлять и положительные и отрицательные значения? Как это можно было бы сделать? На самом деле подход очень простой и 
вытекает из только что установленного факта: если из нуля вычесть один, то получим 255. Но ничто нам не мешает вместо 255 
кодировать значение -1:
<p>
0 – 1 = -1
</p>
Соответственно, если крайнюю правую шестеренку провернуть назад еще один раз, то получим уже значение -2:
<p>
Поворачивая еще раз назад, будем получать следующие отрицательные числа -3, -4 и так далее:
<pre>
1 1 1 1 1 1 1 1 = -1
1 1 1 1 1 1 1 0 = -2
1 1 1 1 1 1 0 1 = -3
1 1 1 1 1 1 0 0 = -4
…
</pre>
Спрашивается, на каком наименьшем отрицательном следует остановиться? В практике программирования поступают следующим образом. 
Самый старший бит числа (в данном случае 8-й бит) отводят под знак. Если он равен 1 – число отрицательное, если 0 – число 
положительное. Следовательно, по нашей схеме формирования отрицательных чисел мы дойдем до:
<p>
1 0 0 0 0 0 0 0 = -128
<p>
Соответственно, максимальное положительное число равно:
<p>
0 1 1 1 1 1 1 1 = 127
<p>
Отсюда получаем диапазон для представления отрицательных и положительных чисел в одном байте от -128 до 127.
<p>
Конечно, это совсем небольшой диапазон значений и для большинства практических задач его недостаточно. Как быть? Опять же все 
просто. Можно под хранение целых чисел отвести не один, а два подряд идущих байта:
<p>
Тогда диапазон в целых числах составит от 0 до 65535, а для чисел со знаком [-32768; 32767]
<p>
<b>Переполнение</b><br>
При попытке записать число 256 в один байт, мы получим переполнение и, как результат, значение 0. И, наоборот, если из нуля 
вычесть один, то получим значение 255:
<p>
0 – 1 = 255
<p>
Все эти эффекты переполнения следует учитывать, при работе с целыми числами.
<p>
<b>Шестнадцатеричная система счисления</b><br>
Первое, что нам понадобится – это 16 различных цифр. Первые десять логично взять из уже знакомой нам десятичной системы, а 
именно в виде следующих арабских обозначений:
<p>
0 1 2 3 4 5 6 7 8 9
<p>
Не хватает еще шести. Недолго думая, решили в их качестве воспользоваться первыми шестью буквами латинского алфавита:
<p>
A, B, C, D, E, F
<p>
В результате, цифра A обозначает число 10, B – число 11 и так далее до F – число 15. С помощью этих шестнадцати цифр мы имеем 
возможность описать любую комбинацию из четырех бит:
<pre>
0 0 0 0 = 0

0 1 0 0 = 4

1 0 0 0 = 8

1 1 0 0 = C

0 0 0 1 = 1

0 1 0 1 = 5

1 0 0 1 = 9

1 1 0 1 = D

0 0 1 0 = 2

0 1 1 0 = 6

1 0 1 0 = A

1 1 1 0 = E

0 0 1 1 = 3

0 1 1 1 = 7

1 0 1 1 = B

1 1 1 1 = F
</pre>
Опытные программисты эту таблицу знают наизусть. Поэтому, когда они видят какое-либо шестнадцатеричное число, например, 1A, то 
сразу понимают его двоичное представление на уровне байта:
<p>
1A = 00011010
<p>
Видите, как это просто и удобно. Мы легко можем переходить из двоичной записи в шестнадцатеричную:
<p>
10110001 = B1
<p>
И, наоборот, из шестнадцатеричной в двоичную. Именно в этом главное достоинство шестнадцатеричной формы записи для 
представления данных в вычислительной технике.
<p>
Конечно, при необходимости, любое шестнадцатеричное число можно перевести в десятичный вид. Делается это очень просто. Пусть 
дано некоторое значение, например:
<p>
5FC
<p>
Представим его вначале как сумму степеней 16-ти:
<p>
5FC = 5 * 16 ** 0 + F * 16 ** 1 + C * 16 ** 0
<p>
А, затем, вместо F подставим эквивалент из десятичной системы 15, а вместо C – значение 12, получим в итоге искомое число 1532
<p>
<b>Для того, чтобы преобразовать число из десятичной системы счисления в шестнадцатеричную</b>,<br>
необходимо выполнить следующие действия.
<p>
1.     Делим десятичное число на 16 и записываем остаток от деления.
<p>
2.     Результат деления вновь делим на 16 и опять записываем остаток.
<p>
3.     Повторяем операцию до тех пор пока результат деления не будет равен нулю.
<p>
4.     Запишем полученные остатки в обратном порядке и получим искомое число.
<p>
Переведем число 100010 в шестнадцатеричную систему:
<p>
1000 / 16 = 62 (остаток 8)
<p>
62 / 16 = 3 (остаток 14, в шестнадцатеричной системе – E)
<p>
3 / 16 = 0 (остаток 3)
<p>
Записываем остатки в обратном порядке, получаем результат: 3E8 (в 16 - системе)
<pre>

======================================================================================================================

</pre>
<a name="type"><h3 align=center>Переменные и их базовые типы. Модификаторы unsigned и signed</h3>
Для объявления переменной в языке Си сначала указывается тип данных для переменной, а затем, ее имя. На уровне синтаксиса это 
выглядит следующим образом:
<pre>
&lt;тип переменной&gt; &lt;имя переменной&gt;;
</pre>
Имя переменной – это, по сути, название хранилища (ячейки памяти в 1 байт), где расположено некоторое целое число.
<p>
максимальная длина имени переменной внутри модуля, учитываемое компилятором, составляет 63 символа
<p>
максимальная длина имени внешней переменной (за пределами модуля), учитываемое компилятором, составляет 31 символ
<h4>Типы переменных</h4>
<img src="./images/c_base2.png">
<p>
Здесь под переменную типа char выделяется одна ячейка памяти 8 бит.<br>
int - переменная для целых чисел. Память под нее выделяется 4 ячейки в 32 и 64 - разрядных системах.<br>
double - переменная под вещественные числа.
<p>
Переменная типа char может быть безнаковым числом от 0 до 255 или знаковым от -128 до 127.<br>
Чтобы определить тип числа для char существуют два модификатора:
<p>
unsigned – беззнаковый;<br>
signed – знаковый (появился в стандарте ANSI C90).
<p>
Если при объявлении явно указать:
<p>
unsigned char fl_view;<br>
то переменная fl_view будет описывать целые числа в интервале [0; 255]. Если же указать:
<p>
signed char fl_view;<br>
то переменная fl_view будет описывать целые числа со знаком в интервале [-128; 127].
<p>
Все остальные целочисленные типы (short, int, long, long long) по умолчанию всегда идут как знаковые. 
<p>
Вещественные типы float и double всегда знаковые и применять к ним эти модификаторы нельзя.
<h4>Рекомендации по выбору типов для переменных</h4>
Если нам требуется хранить отдельные символы или работать с отдельными ячейками памяти, то для этого существует только один тип 
char.<br>
Если предполагается оперировать целочисленными значениями, то изначально следует подумать о типе int. Этот тип нам может 
не подойти в двух ситуациях:<br>
если мы создаем в программе большое число целочисленных переменных (от 1000 и более), то следует 
посмотреть в сторону типа short в целях экономии памяти. Конечно, тип short можно использовать, только если его диапазона 
значений достаточно для представления данных в рамках решаемой задачи. Иначе, придется опять же обратиться к типу int, или даже 
типу long.
<p>
Типы long или long long (если его поддерживает компилятор) следует использовать только в случае, если диапазон 
значений int недостаточно.
<p>
Наконец, для описания вещественных чисел (чисел с плавающей точкой), следует изначально рассматривать тип double. И обращаться 
к типу float только если в программе предполагается создавать много вещественных чисел (от 1000 и более).<br>
Тип long double практически не используется за редким исключением сложных математических вычислений.
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
<h3 align=center>Операция присваивания. Числовые и символьные литералы. Операция sizeof</h3>
В языке СИ можно выполнять операции присваивания так:
<pre>
int var, size;
size = var = 100;
</pre>
Конечно, эту же программу мы могли бы записать и так:

int var, size;
var = 100;
size = 100;
Современные компиляторы в обоих случаях сформируют оптимальный машинный код и корректно переведут эту программу в наборы 
машинных инструкций. Поэтому, какой вариант присваивания использовать решает сам программист, исходя из удобства оформления 
программы.
<p>
Сразу же отмечу еще один важный момент, связанный с объявлением переменных. Правило хорошего тона предполагает, что все 
значимые переменные следует объявлять вначале каждого блока операторов (то есть, фигурных скобок). А уже затем, выполнять 
операции с ними. Именно так сделано в нашей программе: сначала идет объявление двух переменных, а ниже описаны действия с ними. 
Благодаря этому упрощается понимание и редактирование программ. При необходимости, каждую переменную можно сопроводить 
поясняющим комментарием. Конечно, это относится только к значимым переменным. Любые другие, временные, можно объявлять в любом 
месте программы, чтобы визуально она не засорялась лишними деталями.
<h4>Инициализация переменных</h4>
В языке Си, равно как и во многих других языках высокого уровня, можно определять значение переменной сразу в момент ее 
объявления. Например, так:
<br>int total = 1024;<br>
Визуально это выглядит как обычное присваивание переменной значения. Но в действительности – это совершенно другая операция, 
которая называется <b>инициализацией переменной</b>. То есть, когда мы объявляем какую-либо переменную (любого типа) и сразу 
указываем для нее некоторые начальные данные, то в этот момент запускается механизм инициализации этой переменной. Компилятор 
четко различает эти две ситуации: инициализация и обычное присваивание. На уровне машинных кодов они также могут быть 
реализованы по разному. Да и синтаксически, как мы в будущем увидим, при инициализации возможные конструкции, которые нельзя 
использовать при присваивании. А пока на данном этапе достаточно знать и запомнить, что есть процесс инициализации переменных, 
а есть присваивание данных и, в общем случае, это разные вещи.

Для полноты картины приведу еще один пример, когда мы комбинируем обычное объявление и инициализацию переменных:
<p>
int total = 1024, buffer;
<p>
<h4>Целочисленные и символьные литералы</h4>
В программировании явно прописанные числовые значения называются <b>числовыми литералами</b> и представляется как целочисленная константа типа int. Почему именно типом int? Так решил создатель языка Си Деннис Ритчи: все целочисленные константы, записанные в программе в десятичном виде, хранить на уровне типа int. Но только в том случае, если число умещается в диапазон этого типа.<br>
Напомню, что в современных 32- и 64-битных компьютерах тип int, как правило, составляет 4 байта (32 бита) и описывает диапазон 
значений:<br>
<b>[-2 147 483 648; 2 147 483 647]</b>
<p>
Если целочисленный литерал положителен и не умещается в этот диапазон, то компилятор подбирает соответствующий размер типов 
данных в порядке возрастания:
<pre>
int --&gt; unsigned int --&gt; long --&gt; unsigned long --&gt; long long --&gt; unsigned long long
</pre>
Если же и самого большого недостаточно (что сложно себе представить в реальных задачах), то компилятор выдаст ошибку.
<p>
Язык Си позволяет определять в программе числовые литералы еще в шестнадцатеричной и восьмеричной форме. Делается это очень 
просто, например:
<pre>
int dec, hex, oct;
dec = 100;
hex = 0x1FA;
oct = 0123;
</pre>
Здесь 100 – это десятичная форма записи; 0x1FA – шестнадцатеричная (число 1FA); 0123 – восьмеричная. То есть, для записи 
шестнадцатеричных чисел перед ними ставится префикс в виде символов «0x», а для записи восьмеричных – префикс в виде нуля. Так 
можно прописывать любые числа в нужном нам формате. Разумеется, на уровне машинных кодов они представляются единым образом в 
виде набора бит и запись числовых литералов в той или иной форме служит исключительно для удобства восприятия программистом. Не 
более того.
<p>
Но с шестнадцатеричными и восьмеричными литералами есть один важный нюанс. Их компилятор изначально представляет не типом int, 
как десятичные, а типом unsigned int. Соответственно, если литерал не умещается в этот тип, то берутся другие больших размеров 
в порядке:
<pre>
unsigned int, unsigned long, unsigned long long
</pre>
При желании мы можем явно указать компилятору тип числового литерала. Для этого используются следующие суффиксы:
<ol>
<li> U или u – использование модификатора unsigned в определении литерала;
<li> L или l – использование типа long при определении литерала;
<li> LL или ll – использование типа long long при определении литерала.
</ol>
Обычно в программах прописывают большие буквы L, так как малые случайно можно спутать с изображением числа 1. Суффикс U можно 
записывать и отдельно, но можно комбинировать с суффиксами L и LL:
<pre>
int dec_i, dec_ui, dec_l, dec_ul;
dec_i = 100;        // тип литерала int
dec_ui = 100U;      // тип литерала unsigned int
dec_l = 100L;       // тип литерала long
dec_ul = 100UL;     // тип литерала unsigned long
</pre>
<b>Тип char</b><br>
Тип char формально определен и как символьный и как целочисленный. Первый вопрос, как такое может быть? На самом деле все очень 
просто. Объявим переменную этого типа, например:
<p>
char ch;
<p>
а, затем, присвоим ей какой-либо символ, например, буквы d:
<p>
ch = 'd';<br>
Обратите внимание, как прописан символ в тексте программы: он заключен в одинарные кавычки (их еще называют апострофами). И 
только так можно определять символьные литералы в языке Си. Когда компилятор видит одинарные кавычки, то он воспринимает 
информацию в них, как символ. Никакие другие кавычки для этого использовать нельзя. Например, двойные зарезервированы для 
определения строк, поэтому запись:
<p>
ch = "d";<br>
приведет к ошибке на этапе компиляции. Если же совсем убрать кавычки, то символ d в программе будет восприниматься как 
переменная:
<p>
ch = d;<br>
Поэтому следует запомнить, что для определения символьного литерала используются только одинарные кавычки.
<h4>Вещественные литералы</h4>
Помимо целочисленных в программе можно прописывать и вещественные литералы. Определять их можно следующими способами:
<pre>
double d1, d2, d3, d4;
d1 = 10.0;
d2 = -7.;
d3 = 1e2;
d4 = 5e-3;
</pre>
Все вещественные литералы компилятор языка Си по умолчанию имеют тип double. Соответственно, математические операции с числами 
10.0 и -7.0 будут выполняться несколько иначе, чем с аналогичными целыми числами. Это следует иметь в виду.
<p>
Последние два варианта – запись числа в экспоненциальной форме:
<p>
&lt;число&gt;e&lt;степень десятки&gt;
<p>
Такую форму удобно использовать в научных расчетах, когда используются или очень маленькие или очень большие числа. В любом 
случае экспоненциальная форма переводится в вещественное число типа double, даже если оно математически является целым, а не 
дробным.
<p>
<i>Перед e всегда должно стоять число</i>
<p>
При желании мы можем явно указать компилятору переводить вещественный литерал в тип float. Для этого после числа следует 
прописать суффикс f, например, так:
<p>
d1 = 10.0f;<br>
В такой записи вещественное число 10.0 будет представляться типом float, а не double. Это бывает полезно, когда используется 
переменная типа float и ей правильно было бы присвоить значение того же типа:
<p>
float var_f;<br>
var_f = 10.0f;<br>
Тогда компилятор не выдаст предупреждение (warning) о возможной потере данных в момент присваивания значения переменной var_f.

<h4>Операция sizeof</h4>
Операция sizeof возвращает число байт, занимаемых в памяти переменной или, отведенных под тип данных. Синтаксис этой операции 
следующий:
<pre>
sizeof(&lt;тип | имя переменной&gt;);

sizeof &lt;имя переменной&gt;;
</pre>
Обратите внимание, во втором случае мы можем записать ключевое слово sizeof без круглых скобок, но тогда эта операция 
применяется только к переменным, но не к типам. Чтобы не запоминать эти тонкости, обычно sizeof записывают с круглыми скобками 
и указывают либо тип данных, либо имя переменных. Например:
<pre>
int size_float = sizeof(float);
int size_var_f = sizeof(var_f);
</pre>
На выходе получаем число байт, которое занимает тип float и переменная var_f. Соответственно:
<p>
int size_ch = sizeof(char);<br>
всегда равно единице.
<p>
<b>Заключение</b><br>
Итак, на этом занятии вы должны хорошо понимать, как работает операция присваивания и инициализация переменных в языке Си. 
Знать, как записываются и представляются на уровне машинных кодов числовые и символьные литералы, а также какие суффиксы у них 
можно пописывать. И, конечно же, уметь применять операцию sizeof для определения размера типа данных или переменной.
<pre>


==============================================================================================================================


</pre>
<h3 align=center>Стандартные потоки ввода/вывода. Функции putchar() и getchar()</h3>
На уровне операционной системы, как правило, имеются три стандартных потока ввода/вывода:
<ul>
<li> stdout – поток вывода информации (как правило, на монитор);
<li> stderr – поток вывода ошибок (как правило, на монитор);
<li> stdin – поток ввода информации (как правило, с клавиатуры).
</ul>
Конечно, все эти потоки можно настроить на любые другие устройства.
<p>
На программном уровне все эти потоки организованы в виде буферов приема или передачи информации. То есть, данные сначала 
поступают в буфер, а затем, уже либо на устройство вывода, либо в переменные программы. Это очень важный момент. Данные 
поступают в программу, например, с клавиатуры, не напрямую, а через буфер ввода. То же самое с выводом. Сначала данные из 
программы попадаю в буфер вывода и только потом, например, отображаются на мониторе или записываются в файл. Запомним этот 
момент. Он нам в будущем пригодится.
<h4>Функции для работы со стандартными потоками</h4>
Язык Си предоставляет набор библиотечных функций для работы со стандартными потоками ввода/вывода. Мы рассмотрим некоторые из 
них, которые наиболее часто используются на практике:
<ul>
<li> putchar() – вывод символа через поток stdout;
<li> printf() – форматный вывод строки через поток stdout;
<li> perror() – вывод ошибок в виде строки через поток stderr;
<li> getchar() – чтение одного байта (символа) из потока stdin;
<li> scanf() – форматный ввод данных из потока stdin.
</ul>
Описания (прототипы) всех этих функций даны в заголовочном файле stdio.h. То есть, для их использования в программе вначале 
должна быть прописана директива:
<p>
#include &lt;stdio.h&gt;
<p>
<a name="getchar"><h4 align=center>Функция getchar()</h4>
Давайте рассмотрим эти функции и начнем с getchar(). Она имеет следующее определение:
<p>
int getchar(void);
<p>
Целочисленный тип int перед функцией означает, что она возвращает целое число, а void в круглых скобках говорит об отсутствии 
каких-либо параметров. Поэтому мы можем вызвать ее в программе следующим образом:
<pre>
#include &lt;stdio.h&gt;
 
int main(void)
{
    int value = getchar();
 
    return 0;
}
</pre>
После запуска этой программы будет ожидаться ввод значения в поток stdin. Так как он по умолчанию ассоциирован с клавиатурой, 
то нам нужно набрать один символ, любой, например, буквы 's' и нажать клавишу Enter. После этого программа продолжится, 
перейдет к следующему оператору return и завершится.
<p>
Я напомню, что функция getchar() предназначена для чтения одного байта из входного потока stdin. И здесь возникает вопрос, 
почему эта функция возвращает целое число типа int, а не данные типа char, который и описывает один байт памяти? Дело в том, 
что стандартный поток ввода работает несколько более сложным образом, нежели просто выдача очередного байта из буфера. В 
частности, он дополнительно генерирует некоторые служебные значения. Например, значение: <b>EOF (End of File – конец файла)</b>
которое определено как -1 в заголовочном файле stdio.h. То есть, помимо байтового диапазона [0; 255] целых чисел функция 
getchar() дополнительно может вернуть значения вне этого диапазона, в частности, -1.
<p>
Вам может показаться странным, что мы говорим про константу EOF, когда речь идет о вводе данных с клавиатуры? Но, во-первых, 
стандартный поток ввода stdin вполне можно связать с файлом и тогда данные будут читаться из него, а не с клавиатуры и при 
достижении конца файла будет сгенерировано значение EOF. И, во-вторых, при вводе с клавиатуры мы также можем симитировать 
достижение конца файла путем ввода специального символа комбинацией клавиш Ctrl+Z для ОС Windows и Ctrl+D для ОС Linux.
<p>
Таким образом, функции getchar() нужно возвращать целые значения, превышающий байтовый диапазон [0; 255]. Поэтому разработчик 
языка Си решил использовать тип int.

<a name="putchar"><h4 align=center>Функция putchar()</h4>
Следующая аналогичная функция – это putchar(), которая служит для вывода одного байта (символа) в выходной поток stdout и 
определена следующим образом:
<p>
int putchar(int ch);
<p>
Она также возвращает целое число типа int и в качестве аргумента принимает целое значение этого же типа int. В 
действительности, тип int здесь использован для сопряжения (по типам данных) с функцией getchar(). Иначе бы можно было 
прописать тип char, так как функция putchar() в качестве аргумента принимает код символа в диапазоне [0;255]. Любое другое 
значение за пределами этого диапазона просто будет приводиться к восьми битам и затем помещаться в выходной поток stdout. 
Возвращает эта функция код символа, переданного в выходной поток:
<pre>
#include &lt;stdio.h&gt;
 
int main(void)
{
    int value = getchar();
    int res = putchar(value);
    printf("\n%d\n", res);
 
    return 0;
}
</pre>
При выполнении этой программы, нам необходимо будет ввести какой-либо символ с клавиатуры, и затем, он продублируется вызовом 
функции putchar(). Возвращаемое значение (код введенного символа) будет выведено на экран с помощью функции printf().

<h4>Буферы приема/передачи стандартных потоков</h4>
На протяжении всего занятия я акцентрирую ваше внимание на наличие буферов приема/передачи информации у стандартных потоков 
ввода/вывода. При запуске программы они пустые, в них нет никаких посторонних значений. Но, в процессе ввода или вывода 
информации они заполняются и это может повлиять на ход исполнения программы.
<p>
Давайте я это покажу на конкретном примере. Запишем два подряд идущих вызова функции getchar() следующим образом:
<pre>
#include &lt;stdio.h&gt;
 
int main(void)
{
    int value1 = getchar();
    int value2 = getchar();
 
    printf("%c %c\n", value1, value2);
 
    return 0;
}
</pre>
И после запуска этой программы введем с клавиатуры два символа: ds. В результате, оба символа помещаются во входной буфер, 
первый считывается при первом вызове функции getchar(), а второй – при втором вызове функции getchar(). Поэтому программа не 
ждет от нас ввода какой-либо дополнительной информации, а сразу переходит к функции printf(). Соответственно в переменной 
value1 будет храниться код символа d, а в переменной value2 – код символа s. Затем, функция printf() выводит на экран оба 
прочитанных символа.
<p>
Вот наглядный эффект работы входного буфера. Мало того, если бы мы ввели не два, а, скажем, три символа, то после чтения первых 
двух, последний так бы и остался во входном буфере до момента завершения программы. При завершении, все буферы автоматически 
очищаются.
<pre>


=======================================================================================================================


</pre>
<a name="printf"><h3 align=center>Функция printf() для форматированного вывода в консоль</h3>
Формальное определение функции printf (print formatted (форматированный вывод)) выглядит следующим образом:
<pre>
 int printf(const char* format, …);
</pre>
Первый параметр format – это указатель на строку. Пока его можно воспринимать просто как строку, в которой определен формат для вывода информации в стандартный поток stdout (монитор). А троеточие определяет произвольное число дополнительных параметров. Обычно, это переменные или выражения, значения которых следует выводить в заданном формате. В качестве возвращаемого типа указан int, то есть функция возвращает целое число. Это число соответствует количеству выведенных символов в стандартный поток stdout (в нашем случае на экран). Обычно, на практике, этим значением пренебрегают и вызывают функцию printf(), как говорят, ради побочного эффекта, т.е. ради передачи данных в выходной поток.
<p>
В самом простом варианте мы с вами использовали эту функцию для вывода строки на экран:
<pre>
#include &lt;stdio.h&gt;
 
int main(void)
{
    printf("Hello, World!\n");
    return 0;
}
</pre>
Итак, первый параметр format функции printf() определяет не просто выводимую строку, а формат выдаваемых данных. И для этого в 
нашем распоряжении имеются, так называемые, спецификаторы преобразования. Основные из них следующие:
<p>
<img src="./images/c_base3.png">
<p>
Примеры:
<p>
<i>int var_i = 1208;<br>
printf("value = %d\n", var_i);</i> - вывод переменной var_i в десятичной форме.<br>
Вывод: <i>value = 1208</i>
<p>
<i>printf("value = %x\n", var_i);</i> - вывод переменной var_i в шестнадцатеричной форме.<br>
Вывод: <i>value = 4b8</i>
<p>
<i>printf("value = %f\n", var_i);</i><br>
для вывода значение переменной var_i как вещественное число, то ошибки никакой не будет, но отображаемое значение будет, 
конечно же, некорректным: <i>value = 0.000000</i>
<p>
Но, если изменить тип переменной var_i на вещественный:
<p>
double var_i = 1208;<br>
то увидим правильное значение:
<p>
value = 1208.000000
<p>
<h4>Суффиксы типов для спецификаторов</h4>
Целочисленные типы char и short, при передаче значений функции printf(), автоматически приводятся к типу int. Поэтому 
спецификатор %d охватывает все три типа: char, short, int. Если же переменная имеет тип long или long long, то перед 
спецификаторами допустимо прописывать малые буквы l и ll соответственно:
<ul>
<li> l – суффикс для типов long или unsigned long;
<li> ll – суффикс для типов long long или unsigned long long.
</ul>
<pre>
printf("value = %lld\n", -12345678901234LL);
printf("value = %llu\n", 12345678901234LL);
</pre>
Если при выводе в спецификаторах убрать буквы ll, то значение будет отображено некорректно:
<p>
printf("value = %d\n", -12345678901234LL);<br>
Увидим:
<pre>
value = -1942892530
</pre>
Аналогично и с вещественными типами: float автоматически преобразовывается в double, поэтому спецификаторы %f, %F, %e и %E 
корректно обрабатывают оба из них. А вот для типа long double следует прописывать суффикс в виде заглавной буквы L:
<p>
L – суффикс для типа long double.<br>
Например:
<pre>
long double var_ld = 0.5;
printf("value = %Lf\n", var_ld);
</pre>
Увидим строку:
<p>
value = 0.500000
<p>
Но, при использовании спецификатора без суффикса L, вывод окажется некорректным:
<p>
printf("value = %f\n", var_ld);<br>
На выходе:
<p>
value = -0.000000
<p>
Так с помощью суффиксов учитываются все базовые типы переменных языка Си.
<h4>Вывод нескольких переменных</h4>
Конечно, с помощью функции printf() можно выводить сразу несколько переменных в одной форматной строке. Делается это очевидным 
образом. Достаточно указать нужное количество спецификаторов, а затем, перечислить такое же количество переменных или 
выражений. Например, для вывода трех переменных разного типа:
<pre>
short var_h = 100;
int var_i = 1024;
long double var_ld = 0.5;
</pre>
Функцию printf() можно записать в виде:
<p>
printf("var_h = %d, var_i = %d, %Lf\n", var_h, var_i, var_ld);
<p>
<h4>Флаги спецификаторов</h4>
Каждый спецификатор может быть дополнительно снабжен, так называемыми, флагами, которые предоставляют возможность более тонкой 
настройки выводимой информации.
<p>
<img src="./images/c_base4.png">
<p>
<pre>
int var_i = -1283;
double var_d = 54.34675;
printf("[%12.7d]\n", var_i);
printf("[%12.2f]\n", var_d);
</pre>
В случае с вещественными числами, значение 12 определяет общую минимальную ширину вывода, а число после точки (2) – точность 
выводимого значения. После запуска программы увидим:
<pre>
[    -0001283]
[       54.35]
</pre>
<pre>


==========================================================================================================================


</pre>
<a name="scanf"><h3 align=center>Функция scanf() для форматированного ввода</h3>
Эта функция выполняет форматированное чтение данных из стандартного входного потока stdin (клавиатуры) в переменные и имеет следующее определение (прототип):
<pre>
int scanf(const char* format, …);
</pre>
Здесь первый параметр format – это указатель на форматную строку, на подобие той, что мы рассматривали в функции printf(). 
Последующее троеточие указывает на произвольное число дополнительных параметров, как правило, переменных. Функция возвращает 
целое значение типа int, равное числу прочитанных элементов из входного потока stdin.
<p>
Чтобы воспользоваться функцией scanf() нужно знать, как правильно задавать формат считываемых данных. Для этого, также как и в 
функции printf(), предусмотрены спецификаторы преобразований. Но они несколько иные.
<p>
<img src="./images/c_base5.png">
<p>
Самый простой вариант использования функции scanf() соответствует чтению отдельных символов из входного потока. Для этого, 
очевидно, следует использовать спецификатор «%c» следующим образом:
<pre>
#include &lt;stdio.h&gt;
 
int main(void)
{
    char byte;
 
    int count = scanf("%c", &byte);
    printf("count = %d, byte = %c\n", count, byte);
 
    return 0;
}
</pre>
Давайте подробно разберемся, как это работает. Так как в форматной строке записан спецификатор «%c», то функция scanf() читает 
один байт из буфера входного потока stdin. Предположим, там находятся числа 100 и 53. Значит, функция читает первое значение 
100. Далее, необходимо этот байт данных скопировать в переменную byte. И здесь возникает вопрос, как это сделать? Вначале, я 
напомню, что любая переменная – это непрерывная последовательность байт. В нашем примере – это одна ячейка, т.к. переменная 
byte имеет тип char. А значение переменной определяется тем, что записано в этих ячейках. То есть, для записи прочитанных 
данных из входного потока stdin в переменную byte достаточно в соответствующую ячейку памяти скопировать эти прочитанные 
данные. Именно поэтому функции scanf() передается не значение переменной (как это было в функции printf()), а адрес переменной. 
Забегая вперед отмечу, что оператор & перед именем переменной, как раз и возвращает адрес этой переменной. Зная этот адрес, 
функция scanf() имеет возможность менять значение переменной byte, записывая определенные данные напрямую в указанную ячейку 
памяти. Так происходит передача данных из входного потока в указанные переменные с помощью функции scanf().
<p>
Если данные были успешно прочитаны и занесены в переменную byte, то функция scanf() возвратит значение 1. Это говорит нам, что 
в одну переменную были успешно занесены данные из потока stdin.
<p>
Давайте для примера запишем два подряд вызова функции scanf() следующим образом:
<pre>
#include &lt;tdio.h&gt;
 
int main(void)
{
    char byte1 = '0', byte2 = '0';
 
    int res1 = scanf("%c", &byte1);
    int res2 = scanf("%c", &byte2);
 
    printf("byte1 = %c, byte2 = %c\n", byte1, byte2);
    
    return 0;
}
</pre>
Если при запуске программы введем сразу два символа, например cd, то во входном буфере окажутся эти символы и второй вызов 
функции scanf() автоматически прочитает букву d. После запуска программы увидим результат:
<p>
byte1 = c, byte2 = d
<p>
То есть, здесь всегда следует помнить о входном буфере и если в нем имеется какая-либо информация, то последующий вызов функции 
scanf() будет читать эти данные, не ожидая ввода с клавиатуры новых данных.
<p>
Конечно, эти два вызова можно объединить в один, например, так:
<pre>
int res = scanf("%c%c", &byte1, &byte2);
printf("res = %d: byte1 = %c, byte2 = %c\n", res, byte1, byte2);
</pre>
После ввода тех же символов cd, увидим строку:
<p>
res = 2: byte1 = c, byte2 = d
<p>
Обратите внимание, переменная res принимает значение 2, т.к. данные были успешно записаны в две переменные byte1 и byte2. Перед 
каждой переменной базового типа не забываем прописывать оператор амперсанд.
<p>
Пока, я думаю, все понятно. Давайте теперь поставим символ пробела между спецификаторами в форматной строке:
<p>
int res = scanf("%c %c", &byte1, &byte2);
<p>
Этот пробел означает любые пробельные символы, которые могут присутствовать между двумя порциями данных. Сразу отмечу, что к 
пробельным относят символы: пробела, перевода строки, табуляции (и реже некоторые другие). Кроме того, этот символ может и 
вовсе отсутствовать. Например, мы можем ввести с клавиатуры два символа следующими способами:
<pre>
cd; c d; c    d; c\nd; c\td
</pre>
Во всех вариантах будут прочитаны два символа c и d и занесены в переменные byte1 и byte2. То есть, форматная строка "%c %c" 
указывает сделать следующее: прочитать первый символ из входного буфера (любой символ), затем, пропустить все пробельные 
символы и прочитать следующий не пробельный.
<p>
А теперь давайте вместо пробела поставим, например, запятую:
<p>
int res = scanf("%c,%c", &byte1, &byte2);
<p>
При таком формате ввода будет ожидаться первый символ (любой), затем обязательно должна идти запятая, а затем еще один любой 
символ. Например, так:
<p>
c,d
<p>
А вот если входные данные не соответствуют формату, например:
<p>
cd
<p>
то функция scanf() успешно прочитает только первый символ, а следующий (второй) оставит во входном потоке, т.к. вместо запятой 
записана буква d. Переменная res в этом случае будет равна уже 1, а в переменной byte2 останется прежнее значение.
<p>
Конечно, мы можем комбинировать разные символы разделители в форматной строке, например, так:
<p>
int res = scanf("%c, %c", &byte1, &byte2);
<p>
Тогда будет читаться первый символ, затем должна идти запятая, возможные пробельные символы, а затем, следующий непробельный 
символ. То есть, теперь возможны такие варианты ввода данных:
<pre>
c,d; c, d; c,\nd, c,\td и т.п.
</pre>
<h4>Чтение числовых значений из входного потока stdin</h4>
Верные утдверждения:
<ul>
<li> scanf("%d%d", &a, &b) одинаков с scanf("%d %d", &a, &b), то есть пробел между спецификаторами можно не ставить.<br>
форматные строки "%d, %d" и "%d,%d" эквивалентны (одинаковы по действию)
<p>
<li> <b>пробел в форматной строке означает наличие пробелов, символов табуляции, символов перевода строки</b>
</ul>
<p>
<b>Как выполняется чтение числовой информации из входного потока.</b>
<p>
Если данные представлены в виде целых десятичных чисел со знаком, то для этого часто используют спецификатор %d. Причем, этот 
спецификатор приводит целые числа к типу int. И это очень важный момент. Сейчас я покажу почему. Запишем нашу программу 
следующим образом:
<pre>
#include &lt;stdio.h&gt;
 
int main(void)
{
    long long var_lli = 0;
 
    int res = scanf("%d", &var_lli);
    printf("res = %d: var_lli = %lld\n", res, var_lli);
 
    return 0;
}
</pre>
Здесь на входе функция scanf() ожидает целое число со знаком, умещающееся в тип int. Если ввести с клавиатуры значение:
<p>
1234567890
<p>
то на выходе увидим строку:
<p>
res = 1: var_lli = 1234567890
<p>
То есть, все было прочитано успешно. Но, если значение увеличить, например, до:
<p>
12345678901234
<p>
то это значение сначала будет приведено к типу int и только затем записано в переменную var_lli типа long long. Поэтому на 
выходе увидим некорректное значение:
<p>
res = 1: var_lli = 1942892530
<p>
Вот почему важно правильно сочетать спецификаторы преобразований с типами переменных.
<p>
Для указания в форматной строке функции scanf() разных типов входных данных применяются следующие модификаторы, перечисленные 
в таблице.
<p>
<img src="./images/c_base6.png">
<p>
Например, если нам нужно прочитать очень длинное целое число и сохранить его в типе long long, то следует в функции scanf() 
использовать модификатор %lld:
<p>
int res = scanf("%lld", &var_lli);
<p>
Теперь, при вводе длинного числа 12345678901234 мы его и увидим в выходной строке:
<p>
res = 1: var_lli = 12345678901234
<p>
И так со всеми остальными типами данных. Причем, обратите внимание, спецификаторы %f, %e, %g выполняют преобразование данных к 
типу float, а не double, как это делает функция printf(). Если в функции scanf() используется переменная типа double, то для 
нее следует применять модификаторы %lf, %le, %lg. Например:
<pre>
#include &lt;stdio.h&gt;
 
int main(void)
{
    long long var_lli = 0;
    double var_d = 0;
 
    int res = scanf("%lld %lf", &var_lli, &var_d);
    printf("res = %d: var_lli = %lld, var_d = %.2f\n", res, var_lli, var_d);
 
    return 0;
}
</pre>
В этом случае ожидается ввод сначала целого числа, а затем, вещественного, которое будет приведено к типу double. В частности, 
при вводе значений:
<p>
123 56.54
<p>
получим на выходе строку:
<p>
res = 2: var_lli = 123, var_d = 56.54
<p>
А вот если в функции scanf() будет указан модификатор для типа float:
<p>
int res = scanf("%lld %f", &var_lli, &var_d);
<p>
то после ввода тех же значений получим строку:
<p>
res = 2: var_lli = 123, var_d = 0.00
<p>
Обратите внимание, что переменная res по-прежнему принимает значение 2, т.к. формально входные данные соответствовали 
форматной строке, но копирование данных типа float в переменную типа double не дало ожидаемого результата. И все из-за 
неверного спецификатора %f.
<p>
Другие модификаторы подобные работают аналогичным образом. Интересной особенностью обладает модификатор *, который позволяет 
пропускать вводимые данные. Например, мы знаем, что на входе ожидаются данные в формате:
<ul>
<li> id - целое число без знака
<p>
<li> price - целое число
<p>
<li> weight - вещественное число
</ul>
<p>
Нас интересуют только поля price и weight. Причем, будем полагать, что числа записаны через разделитель точка с запятой «;». 
Это частый формат csv-файла. Так вот, для считывания только двух последних значений форматную строку в функции scanf() можно 
записать следующим образом:
<pre>
#include &lt;stdio.h&gt;
 
int main(void)
{
    unsigned int price = 0;
    double weight = 0.0;
 
    int res = scanf("%*llu; %u; %lf", &price, &weight);
    printf("res = %d: price = %d, weight = %.2f\n", res, price, weight);
 
    return 0;
}
</pre>
Введем с клавиатуры данные:
<p>
10; 1000; 54.65
<p>
На выходе получим строку:
<pre>
res = 2: price = 1000, weight = 54.65
</pre>
Как видите, функция scanf() возвратила значение 2 и переменные price, weight принимают правильные значения (последние два). 
Первое значение 10 было прочитано, но проигнорировано. Конечно, оно при это должно соответствовать спецификатору %llu, то 
есть, быть десятичным. Если указать, скажем, вещественное значение:
<p>
10.34; 1000; 54.65
<p>
то это будет ошибка формата и последующие два числа прочитаны не будут:
<pre>
res = 0: price = 0, weight = 0.00
</pre>
Вот так, в целом, работает функция scanf(), которая позволяет читать данные из буфера стандартного входного потока stdin 
данные в указанном формате. При этом считывание останавливается либо после получения всех необходимых данных, либо при ошибке 
формата ввода. И следует помнить, что ошибочные данные остаются во входном буфере.
<pre>


======================================================================================================================


</pre>
<a name="arifm"><h3 align=center>Арифметические операции</h3>
При арифметических операциях данные могут иметь разный тип данных.<br>
Если данные имеют тип short и int, то short будет преобразован в тип int и результат также будет иметь тип int.
<p>
<b>short res_2 = 100 - b;</b><br>
Здесь все работает аналогичным образом. Литерал 100 по умолчанию представляется типом int, переменная b также имеет тип int и 
результат тоже сохраняется в памяти как число типа int. А далее, полученное значение типа int присваивается переменной res_2 
типа short. Перед присваиванием также происходит приведение типов, в данном случае значение int к типу short, т.к. тип 
переменной res_2 компилятор поменять самовольно не может. В результате получаем операцию понижения типа, которая может 
привести к потере данных, если присваиваемое значение не укладывается в меньший по размеру тип short. Вот на это всегда 
следует обращать внимание, при реализации арифметических операций. Как только встречается понижение типа данных, потенциально 
возможна потеря данных.
<p>
<b>double res_4 = d * 4;</b><br>
Здесь вещественное число d типа double умножается на целочисленное значение 4. Строго говоря, компьютер не умеет выполнять 
арифметические операции с вещественными и целыми числами. В нем реализована арифметика либо над целыми, либо над вещественными 
числами, не смешивая их. Поэтому здесь число 4 сначала будет приведено к более общему типу double, и только потом выполнена 
операция умножения над вещественными числами.
<p>
<b>Деление двух целых чисел</b><br>
Смотрите, когда происходит деление двух целочисленных значений, то результат также получается целочисленным. Причем, в 
соответствии со стандартом C99, <b>дробная часть просто отбрасывается. Именно так образуются целые значения. То есть, здесь 
нет округления по правилам математики, а просто отбрасывание дробной части, какой бы она ни была. Это следует запомнить.</b> 
Если же один из операндов является вещественным значением, то все числа приводятся к типу double и после этого выполняется 
операция деления. 
<h4>Операция приведения типов</h4>
Как нам разделить две целочисленные переменные, чтобы получилось вещественное число?<br>
Например -5 / 10 = 0 // не -0.5<br>
Чтобы результат от деления целых чисел был правильный (вещественное число), нужно эти два числа привести в тип double. 
Делается это так:
<p>
<b>double res_1 = (double)a / (double)b;      /* -0.5 */</b>
<p>
<b>Унарные и бинарные операции</b>
Унарной операцией называется знак перед одиноким числом.<br>
Бинарная операция расположена между числами.<br>
Унарные операции имеют приоритет перед бинарными операциями.
<p>
Приоритет операций умножения и деления выше, чем у сложения и вычитания. Здесь все ровно так, как нас учат в школе на уроках 
математики. 
<p>
Если нужно изменить порядок вычислений, то есть, приоритеты, то для этого используются круглые скобки, например, следующим 
образом:<br>
int perimetr = 2 * (b + c);<br>
Сначала будет вычислено выражение внутри скобок и только потом умножение на два.
<h4>Деление по модулю</h4>
Операция деления по модулю имеет тот же приоритет, что и операции умножения и деления. Она вычисляет остаток от деления двух 
целых значений (с вещественными числами данный оператор не работает).
<pre>
int res = 10 % 3;       // 1
int res_1 = -10 % 4;    // -2
int res_2 = 10 % -4;    // 2
int res_3 = -10 % -4;   // -2
</pre>
<h4>инкремент и декремент</h4>
Работают они схожим образом, только операция инкремента увеличивает значение на единицу, а декремента – уменьшает на единицу. 
<p>
Операции:
<pre>
count++;
и
count = count + 1;
</pre>
выдают одинаковый результат. Но вариант инкремента более предпочтителен и, как мы далее увидим, обладает дополнительными 
возможностями.
<p>
<h4>префиксная и постфиксная форма записи:</h4>
<pre>
count++;    // постфиксная форма
++count;    // префиксная форма
</pre>
В чем между ними разница?
<pre>
#include &lt;stdio.h&gt;
 
int main(void)
{
    int count = 0, size = 5;
 
    int current = count++;
    int width = ++size;
 
    printf("count = %d, size = %d, current = %d, width = %d\n", 
                                    count, size, current, width);
 
    return 0;
}
</pre>
Вывод:
<p>
count = 1, size = 6, current = 0, width = 6
<p>
Во-первых, обе переменные count и size были увеличены на единицу, что и должно было произойти. А вот дальше видим отличия: 
переменная current принимает значение 0, а переменная width – значение 6. Почему так произошло? Очевидно, что операций 
инкремента, записанная в постфиксной форме, срабатывает после использования переменной count. То есть, сначала была выполнена 
операция присваивания нулевого значения переменной current и только после этого в переменной count значение было увеличено на 
единицу. Именно так работает инкремент в постфиксной форме записи. Во втором случае инкремент записан перед переменной и 
срабатывает до ее использования в арифметических и других операциях. Поэтому, сначала было увеличено значение переменной size 
на единицу и только после этого число 6 было присвоено переменной width. Вот так работает инкремент в префиксной и постфиксной 
формах записи. По аналогии отрабатывает и операция декремента.
<p>
Если записать выражение вида:
<pre>
int p = 2 * size++;
int r = 3 * --width;
</pre>
То в первом случае сначала два будет умножено на size, а затем, size увеличена на единицу. Во второй строчке сначала 
переменная width уменьшается на единицу и только потом умножается на три. Кстати, если записать следующее выражение:
<p>
int p = width * size++;
<p>
то здесь также сначала будет выполнено умножение и только потом увеличение переменной size на единицу. А вот если заключить 
переменные в круглые скобки:
<p>
int p = (width * size)++;
<p>
то при компиляции программы появится ошибка недопустимого леводопустимого (l-value) выражения. Дело в том, что операции 
инкремента и декремента могут быть применены лишь к изменяемой области памяти, например, переменным. Тогда как произведение 
(width * size) следует воспринимать как промежуточное константное значение, которое нельзя изменить с помощью операции 
инкремента.
<p>
<pre>
int i = 5, j = 5;
bool res_4 = i++ > 5; # false
bool res_5 = ++j > 5; # true
</pre>
<p>
<b>Приоритеты:</b>
<p>
<img src="./images/c_base7.png">
<p>
Здесь условно приоритет обозначен числами: чем выше число – тем выше приоритет.
<p>
На практике первые пять из них довольно часто используются (помимо всего прочего) для изменения существующего значения, 
например, переменной. О чем здесь речь? Давайте предположим, что имеется целочисленная переменная с именем count и начальным 
значением 1.<br>
Наша задача изменить ее, скажем, увеличить на три. Очевидно, сделать это можно следующим образом:
<p>
count = count + 3;
<p>
Но это же самое действие в языке Си можно записать и в более краткой форме, а именно:
<br>count += 3;<br>
В данном случае результат действия операции += будет эквивалентно предыдущей строчке программы, то есть, значение переменной 
count увеличится на 3.
<p>
На первый взгляд кажется, что операция += просто подменяет собой запись из операций сложения и последующего присваивания 
(count = count + 3). Однако между этими действиями есть существенное различие. В операторе:<br>
count = count + 3;
переменная count указана дважды, тогда как в операторе:
<br>count += 3;<br>
только один раз. Казалось бы, какая разница сколько раз прописывать переменную в операторах? И вы будете совершенно правы, 
если речь идет об обычных переменных. Однако язык Си позволяет выполнять арифметические операции не только с переменными, но 
вообще с любыми леводопустимыми (l-value) выражениями. Например:
<pre>
&lt;выражение l-value&gt; = &lt;выражение l-value&gt; + 1;
&lt;выражение l-value&gt; += 1;
</pre>
Так вот, выражение l-value вполне может при каждом обращении к ней (то есть, вычислении) выдавать разные области памяти. Тогда 
в первом случае будет получаться один результат, а во втором – другой. 
<p>
Если вам все это пока кажется сложным и непонятным, то на данном этапе достаточно запомнить, что операции count = count + 3 и 
count += 3 в общем случае не взаимозаменяемы и могут приводить к разным результатам вычислений. И лучше для изменения значения 
переменной или, в общем случае, леводопустимого выражения, использовать операцию +=, так как в ней только один раз фигурирует 
это самое выражение.
<h4>Список сокращенных арифметических операций</h4>
Конечно, кроме операции += можно использовать и другие, а именно:
<pre>
+=, -=, *=, /=, %=
</pre>
Это не полный список, но наиболее употребительный. Приоритеты этих операций совпадают с соответствующими приоритетами 
арифметических выражений. И все они выполняются после любых арифметических действий. Например, в операторе:
<p>
count -= 3-5;<br>
сначала будет вычислена разность 3-5 = -2, и только после этого значение -2 вычитается из значения переменной count и 
результирующее значение будет равно 3.
<p>
Аналогично со всеми остальными сокращенными арифметическими операциями.
<pre>


==========================================================================================================================


</pre>
<a name="bool"><h3 align=center>Булевый тип. Операции сравнения. Логические И, ИЛИ, НЕ</h3>
Стандарт C99 предоставляет нам новый тип переменных (новое ключевое слово): <b>_Bool</b>
<p>
Булевы переменные стало возможно определять следующим образом:
<pre>
<b>_Bool</b> fl_view = 0;           // false
</pre>
Позже синтаксис был заменен:
<br>В программах на языке Си в соответствии со стандартом C99 можно использовать более приятную и общеупотребительную запись 
булевого типа bool, но для этого надо подключить заголовочный файл stdbool.h:
<pre>
<b>#include &lt;stdbool.h&gt;</b>
</pre>
В нем не только переопределен тип _Bool как bool, но и введены две константы:
<p>
true = 1; false = 0
<p>
Поэтому логическую переменную fl_view теперь можно определить так:
<p>
bool fl_view = true;
<p>
<h4>Операции сравнения</h4>
Логические переменные используются в операциях сравнения:
<p>
<img src="./images/c_base8.png">
<p>
все операции сравнения являются именно операциями, а не операторами, то есть, они позволяют выполнять некоторое сравнение и 
возвращают вычисленный результат в виде значений: 0 – false; 1 – true.
<pre>
double x = 5.67;
int var_i = 7;
 
bool fl_view = x < 10;      // true
bool res_1 = 5 > 7;         // false
bool res_2 = x+2 >= 10.56;    // false
bool res_3 = var_i == 7;    // true
bool res_4 = var_i != 7;    // false
</pre>
<b>Причем, приоритет операций сравнения выше приоритета операции присваивания. Поэтому сначала выполняются сравнения и только 
потом – присваивания. А арифметические операции выше операций сравнения</b>, поэтому x+2 будет выполнено до сравнения на 
больше или равно. 
<p>
<b>&&</b> операция сравнения И<br>
bool is_range = y >= -2 && y <= 5;<br>
Здесь операция && означает логическое И.
<p>
<b>||</b> Или<br>
bool is_not_range = y < -2 || y > 5;<br>
Операция || означает логическое ИЛИ и возвращает истину (true), если истинно хотя бы одно из подусловий. 
<p>
<b>!</b> НЕ<br>
bool is_not_range = <b>!</b>is_range;<br>
Здесь восклицательный знак – это унарная операция НЕ, которая может быть применена к любому выражению. Принцип ее работы 
заключается в инвертировании булевого значения:
<p>
true -&gt; false; false-&gt;true.
<p>
<h4>Приоритеты операций И, ИЛИ, НЕ</h4>
Приоритеты всех этих трех логических операций следующие:
<p>
Логическое ИЛИ (||) - наименьший
<p>
Логическое И (&&) - средний
<p>
Логическое НЕ (!) - наивысший
<p>
Например:
<pre>
int x = 5;
bool is_correct = x % 2 == 0 || x % 3 == 0 && x > 5;
</pre>
Это составное условие эквивалентно следующему:
<pre>
bool is_correct = x % 2 == 0 || (x % 3 == 0 && x > 5);
</pre>
то есть, сначала проверяется, что число x кратно 2 (четное) ИЛИ число кратно 3 и при этом больше 5. Обратите внимание здесь на 
два важных момента. Во-первых, стандартом языка Си определен строгий порядок проверок слева-направо при вычислении составных 
логических операций. Это значит, мы можем быть абсолютно уверены, что сначала выполнится проверка x % 2 == 0 и только после 
этого следующее подусловие x % 3 == 0 && x > 5. Причем, в нем также сначала проверяется первое x % 3 == 0 и только потом 
второе x > 5. Во-вторых, если в процессе проверки значение всей составной логической операции становится известным, то 
вычисления прерываются и не идут дальше.
<p>
Если нам нужно поменять приоритеты операций, то для этого можно использовать все те же круглые скобки. Например:
<p>
bool is_correct = (x % 2 == 0 || x % 3 == 0) && x > 5;<br>
Теперь это условие будет истинно, если x кратно 2 или 3 и больше 5.
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
<a name="prioritet"><h3 align=center>Обобщающая по приоритету операций</h3>
<img src="./images/c_base7.png">
<p>
Здесь условно приоритет обозначен числами: чем выше число – тем выше приоритет.
<p>
На практике первые пять из них довольно часто используются (помимо всего прочего) для изменения существующего значения, 
например, переменной. О чем здесь речь? Давайте предположим, что имеется целочисленная переменная с именем count и начальным 
значением 1.<br>
Наша задача изменить ее, скажем, увеличить на три. Очевидно, сделать это можно следующим образом:
<p>
count = count + 3;
<p>
Но это же самое действие в языке Си можно записать и в более краткой форме, а именно:
<br>count += 3;<br>
В данном случае результат действия операции += будет эквивалентно предыдущей строчке программы, то есть, значение переменной 
count увеличится на 3.
<p>
На первый взгляд кажется, что операция += просто подменяет собой запись из операций сложения и последующего присваивания 
(count = count + 3). Однако между этими действиями есть существенное различие. В операторе:<br>
count = count + 3;
переменная count указана дважды, тогда как в операторе:
<br>count += 3;<br>
только один раз. Казалось бы, какая разница сколько раз прописывать переменную в операторах? И вы будете совершенно правы, 
если речь идет об обычных переменных. Однако язык Си позволяет выполнять арифметические операции не только с переменными, но 
вообще с любыми леводопустимыми (l-value) выражениями. Например:
<pre>
&lt;выражение l-value&gt; = &lt;выражение l-value&gt; + 1;
&lt;выражение l-value&gt; += 1;
</pre>
Так вот, выражение l-value вполне может при каждом обращении к ней (то есть, вычислении) выдавать разные области памяти. Тогда 
в первом случае будет получаться один результат, а во втором – другой. 
<p>
Если вам все это пока кажется сложным и непонятным, то на данном этапе достаточно запомнить, что операции count = count + 3 и 
count += 3 в общем случае не взаимозаменяемы и могут приводить к разным результатам вычислений. И лучше для изменения значения 
переменной или, в общем случае, леводопустимого выражения, использовать операцию +=, так как в ней только один раз фигурирует 
это самое выражение.
<p>
<b>Приоритет операций сравнения</b><br>
Все операции сравнения являются именно операциями, а не операторами, то есть, они позволяют выполнять некоторое сравнение и возвращают вычисленный результат в виде значений: 0 – false; 1 – true.
<pre>
double x = 5.67;
int var_i = 7;
 
bool fl_view = x < 10;      // true (Приоритет операций сравнения выше приоритета операции присваивания)
bool res_1 = 5 > 7;         // false
bool res_2 = x+2 >= 10.56;    // false (приоритет арифметических операций выше операций сравнения)
bool res_3 = var_i == 7;    // true
bool res_4 = var_i != 7;    // false
</pre>
1. <b>Приоритет операций сравнения выше приоритета операции присваивания</b>. Поэтому сначала выполняются сравнения и только потом – присваивания.
<p>
2. <b>Приоритет арифметических операций выше операций сравнения</b>, поэтому x+2 будет выполнено до сравнения на больше или равно.
<p>
<b>Унарные и бинарные операции</b><br>
Унарной операцией называется знак перед одиноким числом.<br>
Бинарная операция расположена между числами.<br>
Унарные операции имеют приоритет перед бинарными операциями.
<p>
<b>Приоритеты логических операций</b><br>
Приоритеты всех этих трех логических операций следующие:<br>
Логическое ИЛИ (||) - наименьший
<p>
Логическое И (&&) - средний
<p>
Логическое НЕ (!) - наивысший
<p>
Например:
<pre>
int x = 5;
bool is_correct = x % 2 == 0 || x % 3 == 0 && x > 5;
</pre>
Это составное условие эквивалентно следующему:
<p>
bool is_correct = x % 2 == 0 || (x % 3 == 0 && x > 5);
<p>
то есть, сначала проверяется x % 2 (число x кратно 2 (четное)) ИЛИ число кратно 3 и при этом больше 5. Обратите внимание здесь на два важных момента.<br>
Во-первых, стандартом языка Си определен строгий порядок проверок слева-направо при вычислении составных логических операций. Это значит, мы можем быть абсолютно уверены, что сначала выполнится проверка x % 2 == 0 и только после этого следующее подусловие x % 3 == 0 && x > 5. Причем, в нем также сначала проверяется первое x % 3 == 0 и только потом второе x > 5.<br>
Во-вторых, если в процессе проверки значение всей составной логической операции становится известным, то вычисления прерываются и не идут дальше.
<p>
Если нам нужно поменять приоритеты операций, то для этого можно использовать все те же круглые скобки. Например:
<br>
bool is_correct = (x % 2 == 0 || x % 3 == 0) && x > 5;<br>
Теперь это условие будет истинно, если x кратно 2 или 3 и больше 5.
<p>
<b>Приоритет тернарных операций</b>
<p>
<b>Приоритет тернарной условной операции ниже операций сравнения и арифметических операций.</b>
<p>
Внутри тернарной операции можно использовать другую тернарную операцию.
<p>
int a = 2, b = 3, c = -4;<br>
int max = (a > b) ? ((a > c) ? a : c) : (b > c) ? b : c;
<p>
Сначала проверяется условие a > b. Если это так, то далее с помощью вложенной тернарной операции возвращается максимально из двух переменных a и c. Иначе, максимум из переменных b и c. В результате получаем максимальное из трех чисел a, b, c.
Причем здесь обязательно вложенные тернарные операции следует записывать в круглых скобках, так как приоритет операций ? и : очень низкий.
<pre>

============================================================================================================================

</pre>
<a name="memory"><h3 align=center>Управление памятью</h3>
Ссылки: <a href="https://metanit.com/c/patterns/2.1.php">Управление памятью</a>
<p>
Для хранения объектов в программе на языке С в общем случае у нас есть 3 варианта, где хранить объекты:
<ul>
<li> Стек (автоматическая память)
<p>
<li> Статическая память
<p>
<li> Динамическая память (иначе говоря куча или heap)
</ul>
<h4>Хранение данных в стеке</h4>
Стек представляет память фиксированной длины, которая выделяется для каждого потока. В зависимости от операционной системы размер стека может отличаться. При вызове функции в стек помещаются параметры и все автоматические (нестатические) переменные, которые определяются внутри функции. Соответственно, чтобы положить значение переменной стек, достаточно определеить нестатическую переменную внутри функции:
<pre>
int main(void)
{
    int number = 1; // переменная number хранится в стеке
}
</pre>
После вызова функции эта часть стека автоматически очищается.
<h4>Хранение данных в статической памяти</h4>
Статическая память представляет блок память фиксированного размера, выделение которой происходит во время компиляции. Значения в статической памяти хранятся на протяжении всей работы программы. Статическая память обеспечивает быстрый доступ к данным, позволяет избежать фрагментации, характерной при использовании динамической памяти.
<p>
Но стоит отметить, что применение статической памяти имеет определенные недостатки:
<ul>
<li> Прежде всего, размер данных должен быть фиксирован и известен на стадии компиляции.
<p>
<li> Во-вторых, если определен большой массив данных, большая часть которых не используется, тогда память будет расходоваться впустую.
<p>
<li> Третья проблема связана с многопоточным выполнением: статическая память является общей для всех потоков программы, и в этом случае могут потребоваться дополнительные инструменты для разграничения доступа потоков к общим статическим данным.
<p>
<li> Четвертая проблема статической памяти связана с тем, что программа может запускаться чуть дольше, поскольку надо выделить память для статических переменных и констант.
</ul>
<p>
Для помещения переменной в статическую память эта переменная определяется с помощью ключевого слова static. Можно определять статические переменные на уровне функции (такие переменные доступны только в текущей функции) и на уровне файла (доступны только в текущем файле). Также глобальные переменные без слова static также помещаются в статическую память:
<pre>
int n1 = 1;
static int n2= 2;
int main(void)
{
    static int n3 = 3;
}
</pre>
Здесь все три переменных: n1, n2 и n3 помещаются в статическую память. Различие между ними состоит в уровне доступа. n1 доступна во всей программе, в том числе в других файлах, которые при компиляции компилируются в один исполняемый файл или файл библиотеки. n2 доступна только в текущем файле. n3 доступа только в пределах функциии main.
<p>
Например, если мы посмотрим на ассемблерный вывод компилятора GCC для этой программы, то видим, что все три переменных определены в <b>секции .data</b>, которая хранит в ассеблере глобальные данные, доступные для всего файла программы. Однако переменная n1 также определена с директивой .globl, что позволяет увидеть эту переменную в других файлах программы. А к n3 при определении добавляет дополнительно число 0:
<pre>
n3.0: .long 3
</pre>
И в дальнейшем на эту переменную программа будет ссылаться через идентификатор n3.0
<p>
Стоит отметить, что если внутри функции определяются данные, которые имеют фиксированный размер и не изменяются в течение программы, то они также определяются в статической памяти. Например, строки хранятся в статической памяти:
<pre>
int main(void)
{
    char* message = "hello";
}
</pre>
Если посмотреть ассемблерный код, то увидим, что строка "hello" определена в секции rdata и проецируется на метку .LC0, фактически .LC0 определена как глобальная переменная.
<p>
<h4>Хранение данных в динамической памяти (куче)</h4>
При использовании динамической памяти обязанность на выделение и особождение памяти ложиться на программиста. В общем случае с помощью функций malloc/calloc/realloc в С, new, magic_unique в С++ выделяется память в куче (heap), а с помощью функции free() память освобождается:
<pre>
void main()
{
    int* data = malloc(sizeof(int) * 100);    // выделение памяти для 100 значений int
    // работа с data
    free(data);         // освобождение памяти
}
</pre>
Динамическая память позволяет уйти от ограничений размера стека и ограничений фиксированного размера данных статической памяти, однако поскольку программы могут иметь сложную структуру, то должно освобождение памяти может представлять проблему. Кроме того, многократное выделение/особождение памяти может вести к дефрагментации памяти. В итоге даже если суммарный размер свободных фрагментов памяти превышает необходимый, операционная система все равно не сможет выделить память, так как размер наибольшего фрагмента меньше необходимого.
<p>
В общем случае если данные невелики по объему и необходимы в пределах одной функции, то следует их помещать в стек, то есть определять как автоматические переменные и констаты, которые автоматически уничтожаются после завершения функции. Например, следующая программа вполне корректна:
<pre>
#include &lt;stdio.h>
#include &lt;stdlib.h>
 
int main(void)
{
    int n = 100;
    // выделение памяти
    int* nums = malloc(sizeof(int) * n); //под nums выделили 400 байт
    // некоторая работа с nums
    nums[0] = 23; 
    printf("%d\n", nums[0]);
 
    // освобождение памяти
    free(nums);
}
</pre>
Однако эта программа не эффективна. Мы вынуждены вручную управлять памятью. А на выделение и освобождение памяти тратятся дополнительные ресурсы. К тому же массив nums нам необходим локально. И в данном случае эффективнее определить массив как локальную автоматическую переменную:
<pre>
#include &lt;stdio.h>
 
int main(void)
{
    int nums[100];
    // некоторая работа с nums
    nums[0] = 25;
    printf("%d\n", nums[0]);
}
</pre>
Если уж необходимо определение размера массива с помощью переменной, то начиная со стандарта С99 такая возможность поддерживается:
<pre>
#include &lt;stdio.h>
 
int main(void)
{
    int n = 100;
    int nums[n];
    // некоторая работа с nums
    nums[0] = 25;
    printf("%d\n", nums[0]);
}
</pre>
Если данные фиксированного размера нужны в течение всей жизни программы, особенно если данные довольно большие, что есть вероятность, что они не поместятся в стек, то можно поместить данные в статическую память.
<pre>
#include &lt;stdio.h>
 
int nums1[100];     // в статической памяти
 
static int nums2[100];  // в статической памяти
 
int main(void)
{
    static int nums3[100];  // в статической памяти
    // некоторая работа с nums1,nums2, nums3
}
</pre>
Другая проблема, связанная с автоматическими переменными и константами, состоит в том, что при передачи их значений между вызовами функций мы вынуждены использовать параметры, что ведет к издержкам, поскольку данные надо скопировать в параметры функции. И в этом случае глобальные (по сути статические) переменные и константы позволят избежать ненужного копирования, что особенно актуально при передаче больших данных.
<p>
Если автоматические и статические переменные и константы не подходят в силу различных ограничений, тогда применяется динамическая память.
<h3 align=center>Представление чисел в памяти</h3>
Здесь задействованы две разные концепции:
<ul>
<li> Числа хранятся в двоичном формате. 8 бит представляют собой байт, целые числа могут занимать 1, 2, 4 или даже 8 или 1024 байта в зависимости от платформы, на которой они работают.
<li> Порядок байтов в памяти (младший байт первым — LE или старший байт первым — BE)
</ul>
<p>
Итак, 12345678 — это десятичное число, двоичное (основание 2) представление которого — 10111100 01100001 01001110. Проверить это не так просто, в основном потому, что двоичное представление не группируется в одну десятичную цифру. (не существует целого числа x, при котором 2x даёт 10). Шестнадцатеричные числа легче запоминаются.
<p>
Таким образом, шестнадцатеричное число 0x12345678 состоит из байтов 0x12-0x34-0x56-0x78. Теперь легко проверить, является ли первым 0x12 или 0x78.
<p>
(примечание: шестнадцатеричное представление числа 12345678 — 0x00BC614E, где 0xBC — 188, 0x61 — 97, а 0x4E — 78)
<pre>




</pre>
</div></body></html>
