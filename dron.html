<html><head></head><body>
<title>Дрон</title>
<h2 align=center>Сборка настройка запуск дрона</h2>
Ссылки: <a href="https://copter-space.gitbook.io/uchebnik-mashinnoe-zrenie-tom-2/razdel-1/razdel-1.-osnovnye-ponyatiya-i-instrumenty.">Основные понятия и инструменты</a><br>
<a href="https://clover.coex.tech/ru/">Учебник по Клеверу - учебному квадрокоптеру</a><br>
<a href="https://habr.com/ru/articles/434220/">Вход в Aeronet: запуск автономного квадрокоптера в виртуальной среде</a>
<h3>Основные понятия и компоненты дрона:</h3>
<b>Raspberry PI</b> — компактный одноплатный компьютер, применяемый в широком спектре проектов построения робототехнических устройств. В Клевере Raspberry Pi подключается к полетному контроллеру и используется как вспомогательный компьютер. Он позволяет подключаться к дрону по Wi-Fi, программировать автономные полеты, работать с периферией и многое другое.<br>
<img src="./images/dron_raspberry.png">
<p>
<b><a href="https://habr.com/ru/articles/312300/">MAVLink</a> — (Micro Air Vehicle Link)</b><br>
Протокол обмена сообщениями между наземной станцией (Ground Control Station, а также её компонентами) и малыми беспилотными аппаратами (как летающими, так и ездящими, плавающими и т.д.) по радиоканалам. Обычно именно этот протокол используется для телеметрии.
<p>
<b>Mavros</b><br>
Библиотека-связующее звено между аппаратом, работающем по протоколу MAVLink, и ROS. Описание - http://wiki.ros.org/mavros
<p>
Dronekit — пакет программ для разработки приложений для бортового компьютера. Проект распространяется по модели СПО. Основной сайт - dronekit.io.
<p>
OpenCV — (Open Source Computer Vision Library) – набор бибилиотек компьютер
<p>
<b>Полетный контроллер / автопилот</b>
<ol>
<li>. Специализированная плата, спроектированная для управления мультикоптером, самолетом или другим аппаратом. Примеры: Pixhawk, ArduPilot, Naze32, CC3D.
<li>. Программное обеспечение для платы управления мультикоптером. Примеры: PX4, APM, CleanFlight, BetaFlight.
</ol>
Контроллеры полета (FC) - это аппаратное обеспечение, на которое загружается и запускается микропрограмма flight stack для PX4. Они подключены к датчикам, с помощью которых PX4 определяет свое состояние, и к приводам/двигателям, которые используются для стабилизации и перемещения транспортного средства.<br>
<img src="./images/dron_pixracer.png">
<p>
<img src="./images/dron_pixhawk_v6x.DcJp_GVC.jpg">
<p>
<b>Прошивка</b> - программное обеспечение, управляющее работой какого-либо устройства, например, полетного контроллера или регулятора мотора (ESC).
<p>
Бортовой компьютер — дополнительный вычислительный модуль для управления полётом БПЛА (управление полётным контроллером, ориентация в пространстве по изображению с камеры, управление автономным полётом). В УМК ЖУЖА в качестве бортового компьютера используется Raspberry PI.
<p>
<b>Квадрокоптер</b> - Беспилотный летательный аппарат с 4-мя винтами и электронной системой стабилизации.
<p>
<b>Мультикоптер</b> - Беспилотный летательный аппарат с электронной системой стабилизации и числом винтов, равным 3 (трикоптер), 4 (квадрокоптер), 6 (гексакоптер), 8 (октокоптер) или более.
<p>
<b>Мотор</b> - Электродвигатель, который вращает винты мультикоптера. Обычно используются бесколлекторные электродвигатели. Такие двигатели подключаются к ESC.
<p>
<b>ESC / регулятор двигателя / "регуль"</b> - Electronic Speed Controller. Специализированная плата, которая управляет скоростью вращения бесколлекторного электродвигателя. Управляется полетным контроллером при помощи широтно-импульсной модуляции (ШИМ). 
ESC имеет прошивку, которая определяет особенности его работы.<br>
<img src="./images/simulyator_motor.png">
<p>
<b>АКБ / аккумулятор / батарея</b> - Перезаряжаемый источник тока для БПЛА. В квадрокоптерах обычно применяются Li-po (литий-полимерные) аккумуляторы.
<p>
<b>Ячейка / "банка" АКБ</b> - Составная часть АКБ, непосредственный источник тока. Обычно АКБ для БПЛА состоят из нескольких (2–6) ячеек, соединенных последовательно. Максимальное напряжение одной Li-po ячейки – 4.2 В; общее напряжение АКБ равно суммарному напряжению ячеек. Количество ячеек обозначается буквой S, например: 2S, 3S, 4S. В Клевере обычно применяются аккумуляторы 3S.
<p>
<b>Пульт / аппаратура радиоуправления / "аппа"</b> - Пульт для управления квадрокоптером, работающий по радиоканалу. Для работы пульта к полетном контроллеру необходимо подключить ресивер. Клевером, также, можно управлять со смартфона.
<p>
<b>Телеметрия</b>
<ol>
<li>. Передача данных о состоянии квадрокоптера или другого аппарата на расстояние.
<li>. Совокупность данных о состоянии аппарата, так таковая (высота, ориентация, глобальные координаты и т. д.).
<li>. Система для передачи данных о состоянии аппарата или команд для него по воздуху. Примеры: радиомодемы (RFD900, 3DR Radio Modem), Wi-Fi модули (ESP-07). Raspberry Pi на Клевере также может быть использован в качестве модуля для телеметрии: использование QGroundControl через Wi-Fi.
</ol>
<p>
<b>Арминг</b><br>
Armed – состояние коптера готовности к полету. При поднятии стика газа либо при посылке внешней команды с целевой точкой – коптер полетит. Обычно коптер начинает вращать винтами при переходе в состояние "armed" даже если стик газа находится внизу. Противоположным состоянием является Disarmed
<p>
<b>PX4</b><br>
Популярный полетный контроллер с открытым исходным кодом, работающий на платах Pixhawk, Pixracer и других. PX4 рекомендуется для использования на Клевере.
<p>
<b>Raspberry Pi</b><br>
Популярный одноплатный микрокомпьютер, использующийся в конструкторе Клевер.
<p>
<b>Образ SD-карты</b><br>
Полная копия содержимого SD-карты, представленная в виде файла. Такой файл можно загрузить на SD-карту, воспользовавшись специальной утилитой, например Etcher. SD-карта, вставленная в Raspberry Pi является единственным его долговременным хранилищем и полностью определяет, что он будет делать. Конструктор Клевер включает в себя рекомендованный образ для SD-карты.
<p>
<b>APM / ArduPilot</b><br>
Полетный контроллер с открытым исходным кодом, изначально созданный для платы Arduino. Впоследствии был портирован на Pixhawk, Pixracer и другие платы.
<p>
<b>UART</b><br>
Последовательный асинхронный интерфейс передачи данных, применяемый во многих устройствах. Например, GPS антенны, Wi-Fi роутеры или Pixhawk.
<p>
<b>IMU</b><br>
Inertial measurement unit. Комбинация датчиков (гироскоп, акселерометр, магнитометр), которая помогает БПЛА рассчитывать ориентацию и положение в пространстве.
<p>
<b>Estimation</b><br>
Процесс определения ПО полетного контроллера состояния квадрокоптера: положения в пространстве, скоростей, углов наклона и т. д. Для этого используется смешивание данных с установленных датчиков и различные алгоритмы фильтрации, например фильтр Калмана.
<br>В прошивке PX4 есть два модуля для estimation'а: LPE и ECL EKF (EKF2).<br>
В прошивке APM эту функцию выполняет подсистема EKF2.
<p>
<b>Пульт управления</b><br>
<img src="./images/dron_pult.png">


<h3><a href="https://copter-space.gitbook.io/uchebnik-mashinnoe-zrenie-tom-2/razdel-2/podklyuchenie-raspberry-pi-k-polyotnomu-kontrolleru-pixhawk-i-upravlenie-realnym-dronom-s-pomoshyu-r">Подключение Raspberry PI к полётному контроллеру Pixhawk и управление реальным дроном с помощью ROS</a></h3>
Управление реальным дроном по протоколу mavros аналогично управлению виртуальным дроном, однако для реального дрона необходимо осуществить физическое подключение полётного контроллера к бортовому компьютеру (а также собрать и настроить сам дрон).

<h3 align=center>Настройка дрона</h3>
<ol>
<li> <b>QGroundControl</b> – программное обеспечение, необходимое для прошивки, настройки и калибровки полетного контроллера Клевера. Установить.
<li> <b>MicroSD-карта</b><br>
Подготовьте MicroSD-карту для полетного контроллера.
<li> <b>Загрузка прошивки в полетный контроллер</b>
<li> <b>Настройка полетного контроллера</b>
</ol>


<h2 align="center">перевод документации <a href="https://docs.px4.io/main/en/">PX4 Autopilot User Guide</a></h2>
PX4 - это профессиональный автопилот. Разработанный разработчиками мирового класса из промышленности и научных кругов при поддержке активного мирового сообщества, он обеспечивает работу всех видов транспортных средств, от гоночных и грузовых дронов до наземных транспортных средств и подводных аппаратов. <i>Простыми словами PX4 - это симулятор дронов.</i>
<p>
Типы дронов:
<ul>
<li> Multicopters 
<li> Helicopters 
<li> Planes (Fixed-wing) - Летательные аппараты с неподвижным крылом обеспечивают более длительный и быстрый полет, чем мультикоптеры, и, следовательно, лучший охват для наземных исследований и т.д. Однако ими сложнее управлять и приземляться, чем мультикоптерами, и они не подходят, если вам нужно зависать или лететь очень медленно (например, при съемке вертикальных сооружений).
<li> VTOL (Vertical Takeoff and Landing - Вертикальный взлет и посадка) - Гибридные летательные аппараты с неподвижным крылом и мультикоптером предлагают лучшее из обоих миров: взлетать в вертикальном режиме и зависать в воздухе, как мультикоптер, но переходить к прямолинейному полету, как самолет, чтобы покрыть большую площадь. VTOL часто стоят дороже, чем мультикоптеры и самолеты с неподвижным крылом, и их сложнее создавать и настраивать. Они бывают разных типов: конвертопланы, хвостовые оперения, квадропланы и т.д.
<li> Airships/Balloons — Транспортные средства легче воздуха, которые, как правило, позволяют совершать длительные полеты на большой высоте, часто за счет ограниченного контроля скорости и направления полета (или его отсутствия).
<li> Rovers — Наземные транспортные средства, похожие на автомобили. Ими просто управлять, и ими часто интересно пользоваться. Они не могут передвигаться так быстро, как большинство самолетов, но могут перевозить более тяжелую полезную нагрузку и не потребляют много энергии в неподвижном состоянии.
<li> Boats 
<li> Submersibles -подводные дроны
</ul>
<p>
Ground Control Stations (Наземные станции управления GCS) - это наземные системы, которые позволяют операторам UV контролировать беспилотный летательный аппарат и его полезную нагрузку. Ниже перечислены некоторые продукты, которые, как известно, работают с PX4.


<h3 align="center><a href="https://docs.px4.io/main/en/dev_setup/dev_env_linux_ubuntu.html">Среда разработки Ubuntu:</a></h3>
 В следующих инструкциях используется скрипт bash для настройки среды разработки PX4 в Ubuntu Linux LTS версиях, поддерживаемых PX4: Ubuntu 22.04 (Jammy Jellyfish), 20.04 (Focal Fossa) и 18.04 (Bionic Beaver).
<p>
Среда включает в себя:
<ul>
<li> Симулятор Gazebo в Ubuntu 22.04 и Ubuntu 20.04
<li> или классический симулятор Gazebo для Ubuntu 20.04 и Ubuntu 18.04
<li> Набор инструментов для Pixhawk (и другого оборудования на базе NuttX).
</ul>
<h3>Цели моделирования и NuttX (Pixhawk):</h3>
Используйте ubuntu.sh скрипт для настройки среды разработки, которая позволяет выполнять сборку для симуляторов и / или набора инструментов NuttX / Pixhawk.
<p>
Установка набора инструментов:
<ol>
<li> Скачать исходный код PX4:
<p>
<b>git clone https://github.com/PX4/PX4-Autopilot.git --recursive</b>
<li> Запустите ubuntu.sh без аргументов (в оболочке bash), чтобы установить все:
<p>
<b>bash ./PX4-Autopilot/Tools/setup/ubuntu.sh</b>
<p>
Можете использовать опции --no-nuttx и --no-sim-tools, чтобы не использовать NuttX и/или инструменты моделирования.
<li> Перезагрузить компьютер.
</ol>
<p>
Как только вы закончите настройку набора инструментов командной строки:
<ol>
<li> Установите VSCode (если вы предпочитаете использовать IDE вместо командной строки).<br>
<a href="https://docs.px4.io/main/en/dev_setup/vscode.html">Настройка VSCode</a>
<li> Установите ежедневную сборку QGroundControl
</ol>
<h3>QGroundControl</h3>
Ссылки: <a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/">Руководство пользователя QGroundControl</a><br>
<a href="https://docs.qgroundcontrol.com/master/en/qgc-dev-guide/">Руководство по разработке QGroundControl</a>
<p>
Программное обеспечение Dronecode GCS называется QGroundControl ("QGC"). Оно работает на оборудовании Windows, Android, macOS или Linux и поддерживает широкий спектр форм-факторов экрана. Вы можете скачать его (бесплатно) <a href="http://qgroundcontrol.com/downloads/">здесь</a>.
<p>
QGroundControl взаимодействует с дроном с помощью телеметрической радиостанции (двунаправленный канал передачи данных), которая позволяет получать информацию о полете и безопасности в режиме реального времени, а также управлять транспортным средством, камерой и другими полезными устройствами с помощью интерфейса "наведи и щелкни". На оборудовании, которое их поддерживает, вы также можете управлять транспортным средством вручную с помощью джойстиков. QGC также можно использовать для визуального планирования, выполнения и мониторинга автономных миссий, установки геозон и многого другого.
<p>
Настольные версии QGroundControl также используются для установки (прошивки) встроенного ПО PX4 и настройки PX4 на аппаратном обеспечении автопилота/контроллера полета дрона.

<h3 align="center"><a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/getting_started/download_and_install.html">Загрузка и установка</a></h3>
<h3>Системные требования:</h3>
QGC должна хорошо работать на любом современном компьютере или мобильном устройстве. Производительность будет зависеть от системного окружения, приложений сторонних производителей и доступных системных ресурсов. Более мощное оборудование обеспечит лучшую работу. Для большинства приложений подойдет компьютер с объемом оперативной памяти не менее 8 ГБ, твердотельным накопителем, графикой Nvidia или AMD и процессором i5 или выше.
<h3>Установка для Ubuntu Linux</h3>
QGroundControl можно установить / запустить в Ubuntu LTS 20.04 (и более поздних версиях).
<p>
Ubuntu поставляется с менеджером последовательного модема, который препятствует любому использованию последовательного порта (или USB serial), связанному с робототехникой. Перед установкой QGroundControl вам следует удалить диспетчер модемов и предоставить себе разрешения на доступ к последовательному порту. Вам также необходимо установить GStreamer для поддержки потоковой передачи видео.
<p>
Перед первой установкой QGroundControl:<br>
В командной строке введите:
<pre>
sudo usermod -a -G dialout $USER
sudo apt-get remove modemmanager -y
sudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -y
sudo apt install libfuse2 -y
sudo apt install libxcb-xinerama0 libxkbcommon-x11-0 libxcb-cursor-dev -y
</pre>
Выйдите из системы и войдите снова, чтобы разрешить изменение прав пользователя.
<p>
Как установить QGroundControl:
<ol>
<li> Загрузите QGroundControl <a href="https://d176tv9ibo4jno.cloudfront.net/latest/QGroundControl.AppImage">отсюда</a>.
<li> Установите (и запустите) с помощью команд терминала:
<pre>
chmod +x ./QGroundControl.AppImage
./QGroundControl.AppImage</pre>  (или двойной клик)
</ol>

<h3><a href="https://docs.px4.io/main/en/dev_setup/qgc_daily_build.html">QGroundControl Daily Build</a></h3>
Ежедневная сборка QGroundControl включает в себя инструменты разработки, которые скрыты в релизных сборках (QGroundControl), и предоставляет доступ к новым функциям PX4, которые еще не поддерживаются в релизных сборках.
<p>
Его следует использовать вместо стабильной версии при работе с новым кодом, разветвленным из основной ветки main PX4.
<p>
<a href="https://d176tv9ibo4jno.cloudfront.net/builds/master/QGroundControl-x86_64.AppImage">Ссылка на закачку QGroundControl Daily Build для linux</a>
<p>
<font color=red>Скачал файл в Загрузку, а что дальше делать, не сказано.</font>
<p>
<img src="./images/dron1.png">


<h3 align="center"><a href="https://docs.px4.io/main/en/dev_setup/building_px4.html">Сборка программ PX4</a></h3>
Прошивка PX4 может быть собрана из исходного кода на консоли или в среде IDE как для имитируемых, так и для аппаратных целей.
<p>
Вам необходимо создать PX4, чтобы использовать симуляторы, или если вы хотите модифицировать PX4 и создать пользовательскую сборку. Если вы просто хотите опробовать PX4 на реальном оборудовании, то загрузите готовые двоичные файлы с помощью QGroundControl (нет необходимости следовать этим инструкциям).
<p>
Прежде чем следовать этим инструкциям, вы должны сначала установить набор инструментов разработчика для вашей основной операционной системы и целевого оборудования (IDE и QGC). 
<ol>
<li> <b>Загрузить исходный код PX4:</b><br>
Исходный код PX4 хранится на Github в репозитории PX4/PX4-Autopilot. Чтобы загрузить самую последнюю версию (основную ветвь) на свой компьютер, введите в терминал следующую команду:
<p>
<b>git clone https://github.com/PX4/PX4-Autopilot.git --recursive</b>
<p>
Возможно уже скачали репозиторий, когда устанавливали Developer Toolchain.
<li> <b>Первая сборка (с использованием симулятора)</b><br>
Сначала мы создадим имитируемую цель, используя консольную среду. Это позволит нам проверить настройки системы, прежде чем переходить к реальному оборудованию и IDE.
<p>
Перейдите в каталог PX4-Autopilot. В зависимости от вашей операционной системы у вас будет установлена либо Gazebo SITL, либо Gazebo Classic SITL (если вы не знаете, какая из них лучше, вы можете попробовать обе).
</ol>
<p>
Запустите Gazebo SITL, используя следующую команду:
<p>
<b>make px4_sitl gz_x500</b>
<p>
После этого откроется консоль PX4.
<p>
Возможно, вам потребуется запустить QGroundControl, прежде чем продолжить, поскольку конфигурация PX4 по умолчанию требует подключения к наземному управлению перед взлетом. Загрузка и установка <a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/getting_started/download_and_install.html">здесь (Загрузка и установка)</a>.
<p>
Дроном можно управлять, набрав следующую команду (как показано в консоли выше).:
<p>
<b>pxh&gt; commander takeoff</b>
<p>
Дрон взлетит, и вы увидите это в пользовательском интерфейсе симулятора.
<p>
Беспилотник можно посадить, набрав команду commander land, а всю имитацию можно остановить, нажав CTRL+C (или введя команду shutdown).
<p>
Управление симулятором с помощью наземной станции управления приближено к реальному управлению транспортным средством. Нажмите на местоположение на карте во время полета транспортного средства (режим взлета) и включите ползунок. Это изменит положение транспортного средства.

<h3>Платы на основе NuttX / Pixhawk</h3>
<h4>Сборка для NuttX</h4>
Чтобы выполнить сборку для плат на базе NuttX или Pixhawk, перейдите в каталог PX4-Autopilot и затем вызовите make, указав цель сборки для вашей платы.
<p>
Например, для сборки для аппаратного обеспечения Pixhawk 4 можно использовать следующую команду:
<pre>
cd PX4-Autopilot
make px4_fmu-v5_default
</pre>
Успешный запуск завершится с результатом, аналогичным следующему:
<pre>
-- Build files have been written to: /home/youruser/src/PX4-Autopilot/build/px4_fmu-v4_default
[954/954] Creating /home/youruser/src/PX4-Autopilot/build/px4_fmu-v4_default/px4_fmu-v4_default.px4
</pre>
Первая часть параметра build target px4_fmu-v4 указывает на аппаратное обеспечение целевого контроллера полета для встроенного ПО. Суффикс, в данном случае _default, указывает на конфигурацию встроенного ПО, например, на поддержку или отсутствие определенных функций.
<p>
<i>Вы должны использовать поддерживаемую версию GCC для сборки этой платы (например, ту же, что используется CI/docker) или удалить модули из сборки. Сборка с использованием неподдерживаемого GCC может завершиться неудачей, так как PX4 близок к пределу флэш-памяти платы в 1 МБ.</i>

<h3>Полный синтаксис команды make</h3>
В предыдущих разделах было показано, как можно вызвать make для создания нескольких различных целевых объектов, запуска симуляторов, использования IDE и т.д. В этом разделе показано, как создаются параметры make и как найти доступные варианты.
<p>
Полный синтаксис для вызова make с определенным файлом конфигурации и инициализации приведен ниже.:
<pre>
make [VENDOR_][MODEL][_VARIANT] [VIEWER_MODEL_DEBUGGER_WORLD]
</pre>
VENDOR_MODEL_VARIANT: (также известный как CONFIGURATION_TARGET)
<ul>
<li> Vendor (поставщик): Производитель платы: px4, aerotenna, airmind, atlflight, auav, beaglebone, intel, nxp и т.д. Производитель плат серии Pixhawk - px4.
<li> Model: модель платы "model": sitl, fmu-v2, fmu-v3, fmu-v4, fmu-v5, navio2 и т.д.
<li> Variant: Указывает на конкретные конфигурации: например, bootloader, cyphal, которые содержат компоненты, отсутствующие в конфигурации по умолчанию. Чаще всего это default - значение используется по умолчанию и может быть опущено.
</ul>
Вы можете получить список всех доступных параметров CONFIGURATION_TARGET, используя приведенную ниже команду:
<p>
<b>make list_config_targets</b>
</p>
<b>VIEWER_MODEL_DEBUGGER_WORLD:</b>
<ul>
<li> Viewer<br>
Это симулятор ("просмотрщик") для запуска и подключения: gz, gazebo, jmavsim, none.<br>
<b>none</b> может использоваться, если вы хотите запустить PX4 и дождаться запуска симулятора (jmavsim, Gazebo, Gazebo Classic или какого-либо другого симулятора). Например: <b>px4_sitl none_iris</b> запускает PX4 без симулятора (но с планером iris).
<li> <b>MODEL</b><br>
Используемая модель транспортного средства (например, iris (по умолчанию), rover, tailsitter и т.д.), которая будет загружена симулятором. Переменной среды PX4_SIM_MODEL будет присвоено значение выбранной модели, которое затем используется в сценарии запуска для выбора соответствующих параметров.
<li> <b>DEBUGGER</b><br>
Используемый отладчик: none (по умолчанию), ide, gdb, lldb, ddd, valgrind, callgrind. Дополнительные сведения смотреть в разделе <a href="https://docs.px4.io/main/en/debug/simulation_debugging.html">Имитационная отладка</a>.
<li><b>WORLD</b><br>
Только для Gazebo Classic. Укажите загружаемый мир (<a href="https://github.com/PX4/PX4-SITL_gazebo-classic/tree/main/worlds">PX4-Автопилот/Инструменты/моделирование/gazebo-classic/sitl_gazebo-classic/worlds</a>). Значение по умолчанию - <a href="https://github.com/PX4/PX4-SITL_gazebo-classic/blob/main/worlds/empty.world">empty.world</a>. Для получения дополнительной информации смотреть раздел <a href="https://docs.px4.io/main/en/sim_gazebo_classic/#loading-a-specific-world">Gazebo Classic &gt; Loading a Specific World</a>.
</ul>
<p>
Вы можете получить список всех доступных параметров VIEWER_MODEL_DEBUGGER_WORLD, используя приведенную ниже команду:
<p>
<b>make px4_sitl list_vmd_make_targets</b>
<p>
Дополнителеная информация:
<ul>
<li> Большинство значений в CONFIGURATION_TARGET и VIEWER_MODEL_DEBUGGER имеют значения по умолчанию и, следовательно, являются необязательными. Например, gazebo-classic эквивалентно gazebo-classic_iris или gazebo-classic_iris_none.
<li> Вы можете использовать три символа подчеркивания, если хотите указать значение по умолчанию между двумя другими параметрами. Например, gazebo-classic___gdb эквивалентно gazebo-classic_iris_gdb.
<li> Вы можете использовать значение none для VIEWER_MODEL_DEBUGGER, чтобы запустить PX4 и дождаться запуска симулятора. Например, запустите PX4 с помощью make px4_sitl_default none и jMAVSim с помощью ./Tools/simulation/jmavsim/jmavsim_run.sh -l.
</ul>
<p>
Параметры VENDOR_MODEL_VARIANT сопоставляются с конкретными файлами конфигурации px4board в дереве исходных текстов PX4 в каталоге /boards. В частности, VENDOR_MODEL_VARIANT сопоставляется с файлом конфигурации boards/VENDOR/MODEL/VARIANT.px4board (например, px4_fmu-v5_default соответствует boards/px4/fmu-v5/default.px4board).
<h3>Firmware Version & Git Tags (Версия прошивки и Git-теги)</h3>
Firmware Version PX4 и Custom Firmware Version публикуются с помощью сообщения MAVLink AUTOPILOT_VERSION и отображаются на панели QGroundControl Setup &gt; Summary.

<h3 align="center"><a href="https://docs.px4.io/main/en/concept/px4_systems_architecture.html">Архитектура системы PX4</a></h3>
В приведенных ниже разделах представлен общий обзор аппаратного и программного обеспечения PX4 для двух "типичных" систем PX4: одна из них имеет только контроллер полета, а другая - контроллер полета и вспомогательный компьютер (также известный как "компьютер миссии").
<h3>Только полётный контроллер (Flight Controller)</h3>
На приведенной ниже диаграмме представлен общий обзор типичной "простой" системы PX4, основанной на контроллере полета.
<p>
<img src="./images/dron2.png">
<p>
Аппаратное обеспечение состоит из:
<ul>
<li> Контроллера полета (работающего на PX4 flight stack). Часто это включает в себя встроенные IMU, компас и барометр.
<li> ESC двигателя подключены к PWM-выходам (ШИМ-выходы), DroneCAN (DroneCAN обеспечивает двустороннюю связь, а не одностороннюю, как показано на рисунке) или какой-либо другой шине.
<li> Сенсоры (датчики) (GPS, компас, датчики расстояния, барометры, оптический поток, барометры-передатчики ADSB и т.д.), подключаются через I2C, SPI, CAN, UART и т.д.
<li> Камера или другая полезная нагрузка. Камеры могут быть подключены к ШИМ-выходам или через MAVLink.
<li> Телеметрические радиостанции для подключения к компьютеру/программному обеспечению наземной станции.
<li> Радиоуправляемая система управления для ручного управления
</ul>
В левой части диаграммы показан программный пакет, который (приблизительно) выровнен по горизонтали с аппаратными частями диаграммы.
<p>
Компьютер наземной станции обычно запускает QGroundControl (или какое-либо другое программное обеспечение наземной станции). На нем также может работать программное обеспечение для робототехники, такое как MAVSDK или ROS.<br>
PX4 flight stack (пакет управления полетом PX4), работающий на контроллере полета, включает драйверы, модули связи, контроллеры, оценщики и другое промежуточное программное обеспечение и системные модули.
<h3>Полётный контроллер и сопутствующий компьютер</h3>
На приведенной ниже схеме показана система PX4, которая включает в себя как контроллер полета, так и вспомогательный компьютер (здесь называемый "компьютером миссии").
<p>
<img src="./images/dron3.png">
<p>
Контроллер полета управляет обычным полетным стеком PX4, в то время как компьютер-компаньон предоставляет расширенные функции, использующие компьютерное зрение. Обе системы подключены по быстрому последовательному каналу или IP-каналу и, как правило, взаимодействуют по протоколу MAVLink. Связь с наземными станциями и облаком обычно осуществляется через сопутствующий компьютер (например, с помощью маршрутизатора MAVLink (от Intel)).
<p>
Системы PX4 обычно работают под управлением операционной системы Linux на сопутствующем компьютере. Linux - гораздо лучшая платформа для разработки "общего" программного обеспечения, чем NuttX; разработчиков Linux гораздо больше, и уже написано много полезного программного обеспечения (например, для компьютерного зрения, коммуникаций, облачной интеграции, драйверов оборудования). Компьютеры-компаньоны иногда работают под управлением Android по той же причине.
<p>
<b>Flight stack</b> - это набор алгоритмов наведения, навигации и управления автономными беспилотными летательными аппаратами. Он включает в себя контроллеры для самолетов с неподвижным крылом, мультироторных и СВВП, а также средства оценки ориентации и положения.
<p>
<b>middleware </b> (промежуточное программное обеспечение) состоит в основном из драйверов устройств для встроенных датчиков, средств связи с внешним миром (сопутствующий компьютер, GCS и т.д.) и шины сообщений uORB для публикации и подписки.<br>
Кроме того, промежуточное программное обеспечение включает в себя уровень моделирования, который позволяет запускать пилотажный код PX4 в настольной операционной системе и управлять смоделированным на компьютере транспортным средством в имитируемом "мире".
<p>
<b>NuttX</b> - это основная RTOS для запуска PX4 на пульте управления полетом. Она с открытым исходным кодом (лицензия BSD), легкая, эффективная и очень стабильная.<br>
Модули выполняются как задачи: у них есть свои собственные списки файловых дескрипторов, но они используют одно адресное пространство. Задача все равно может запускать один или несколько потоков, которые используют общий список файловых дескрипторов.<br>
Каждая задача / поток имеет стек фиксированного размера, и существует периодическая задача, которая проверяет, осталось ли во всех стеках достаточно свободного места (в зависимости от цвета стека).


<h3 align="center"><a href="https://docs.px4.io/main/en/simulation/">Симуляция</a></h3>
Симуляторы позволяют PX4 flight code управлять дроном, смоделированным на компьютере, в имитируемом "мире". Вы можете взаимодействовать с этим дроном так же, как с реальным, используя QGroundControl, автономный API или радиоконтроллер / геймпад.
<p>
Моделирование - это быстрый, простой и, самое главное, безопасный способ протестировать изменения в коде PX4 перед началом полетов в реальных условиях. Это также хороший способ начать летать с PX4, если у вас еще нет машины для экспериментов.
<p>
PX4 поддерживает как программную симуляцию в цикле (SITL), при которой стек управления полетом выполняется на компьютере (либо на том же компьютере, либо на другом компьютере в той же сети), так и аппаратную симуляцию в цикле (HITL) с использованием встроенного программного обеспечения для моделирования на реальной плате контроллера полета.
<h3>Поддерживаемые тренажеры (симуляторы)</h3>
<ul>
<li> Gazebo<br>
Gazebo заменяет Gazebo Classic, предлагая более продвинутые модели рендеринга, физики и сенсоров. Это единственная версия Gazebo, доступная в Ubuntu Linux 22.04<br>
Мощная среда 3D-моделирования, которая особенно подходит для тестирования способности избегать объектов и компьютерного зрения. Он также может использоваться для моделирования нескольких транспортных средств и обычно используется с ROS, набором инструментов для автоматизации управления транспортными средствами.<br>
Поддерживаемые транспортные средства: Quad, Standard VTOL, Plane (квадроцикл, стандартный СВВП, самолет.
<li> Gazebo Classic<br>
Мощная среда 3D-моделирования, которая особенно подходит для тестирования способности избегать столкновения с объектами и компьютерного зрения. Она также может использоваться для моделирования нескольких транспортных средств и обычно используется с ROS, набором инструментов для автоматизации управления транспортными средствами.<br>
Поддерживаемые транспортные средства: Квадроцикл (Iris), шестигранник (Typhoon H480), Универсальный стандартный СВВП (QuadPlane), Рулевой, Самолет, вездеход, подводная лодка
</ul>
<h3>Симулятор MAVLink API</h3>
Все симуляторы, за исключением Gazebo, взаимодействуют с PX4 с помощью API Simulator MAVLink. Этот API определяет набор сообщений MAVLink, которые передают данные датчиков из моделируемого мира в PX4 и возвращают значения двигателя и привода из кода полета, который будет применен к моделируемому транспортному средству. На рисунке ниже показан поток сообщений.
<img src="./images/dron4.png">
<p>
<i>В сборке SITL для PX4 для обработки этих сообщений используется SimulatorMavlink.cpp, в то время как в аппаратной сборке в режиме HIL используется mavlink_receiver.cpp. Данные датчиков из симулятора записываются в разделы PX4 uORB. Все двигатели / исполнительные механизмы заблокированы, но внутреннее программное обеспечение полностью работоспособно.</i>
<p>
PX4 напрямую использует Gazebo API для взаимодействия с Gazebo, и MAVLink не требуется.
<h3>UDP-порты MAVLink PX4 по умолчанию</h3>
По умолчанию PX4 использует общепринятые UDP-порты для связи MAVLink с наземными станциями управления (например, QGroundControl), внешними API (например, MAVSDK, MAVROS) и интерфейсами симулятора (например, Gazebo). Это следующие порты::
<ul>
<li> Удаленный UDP-порт PX4 14550 используется для связи с наземными станциями управления. Ожидается, что GCS будут прослушивать соединения по этому порту. QGroundControl по умолчанию прослушивает этот порт.
<li>Удаленный UDP-порт PX4 14540 используется для связи с внешними API. Ожидается, что внешние API будут прослушивать соединения через этот порт.
<i>При моделировании нескольких транспортных средств для каждого экземпляра используется отдельный удаленный порт, последовательно выделяемый от 14540 до 14549 (все дополнительные экземпляры используют порт 14549).</i>
<li> Локальный TCP-порт симулятора, 4560, используется для связи с PX4. Симулятор прослушивает этот порт, и PX4 инициирует TCP-соединение с ним.
</ul>
<h3>Среда моделирования SITL</h3>
На диаграмме ниже показана типичная среда моделирования SITL для любого из поддерживаемых симуляторов, использующих MAVLink (т.е. для всех, кроме Gazebo).
<p>
<img src="./images/dron5.png">
<ul>
<li> PX4 использует специальный модуль для моделирования для подключения к локальному TCP-порту симулятора 4560. Затем симуляторы обмениваются информацией с PX4, используя API MAVLink для симулятора, описанный выше. PX4 на SITL и симулятор могут работать как на одном компьютере, так и на разных компьютерах в одной сети.
<li> PX4 использует обычный модуль MAVLink для подключения к наземным станциям и внешним API-интерфейсам разработчиков, таким как MAVSDK или ROS:
<ul>
<li> Наземные станции прослушивают удаленный UDP-порт PX4: 14550
<li> Внешние API-интерфейсы разработчика прослушивают удаленный UDP-порт PX4: 14540. Для моделирования нескольких транспортных средств PX4 последовательно выделяет отдельный удаленный порт для каждого экземпляра с 14540 по 14549 (все дополнительные экземпляры используют порт 14549).
</ul>
<li> PX4 определяет ряд локальных UDP-портов (14580,18570), которые иногда используются при подключении к сети с помощью PX4, запущенного в контейнере или виртуальной машине. Они не рекомендуются для "общего" использования и могут измениться в будущем.
<li> Последовательное соединение может использоваться для подключения аппаратного обеспечения джойстика/геймпада через QGroundControl.
</ul>
<p>
Если вы используете обычную систему сборки SITL make configuration targets (см. следующий раздел), то и SITL, и симулятор будут запущены на одном компьютере, и указанные выше порты будут автоматически настроены. Вы можете настроить дополнительные UDP-соединения MAVLink и иным образом изменить среду моделирования в файлах конфигурации сборки и инициализации.
<h3>Моделирование запуска/построения SITL</h3>
Система сборки позволяет очень просто собрать и запустить PX4 на SITL, запустить симулятор и подключить их. Синтаксис (упрощенный) выглядит следующим образом:
<p>
<b>make px4_sitl simulator[_vehicle-model]</b>
<p>
где simulator - это gz (для Gazebo), gazebo-classic, jmavsim или какой-либо другой симулятор, а модель транспортного средства - это конкретный тип транспортного средства, поддерживаемый этим симулятором (на момент написания статьи Gazebo и jMAVSim поддерживают только мультикоптеры, в то время как Gazebo Classic поддерживает множество различных типов).
<p>
Ниже приведен ряд примеров, и их гораздо больше на отдельных страницах для каждого из симуляторов:
<p>
<pre>
 # Start Gazebo with the x500 multicopter
make px4_sitl gz_x500

# Start Gazebo Classic with plane
make px4_sitl gazebo-classic_plane

# Start Gazebo Classic with iris and optical flow
make px4_sitl gazebo-classic_iris_opt_flow

# Start JMavSim with iris (default vehicle model)
make px4_sitl jmavsim

# Start PX4 with no simulator (i.e. to use your own "custom" simulator)
make px4_sitl none_iris
</pre>
<p>
Моделирование может быть дополнительно настроено с помощью переменных среды:
<p>
PX4_ESTIMATOR: Эта переменная определяет, какой оценщик использовать. Возможные варианты: ekf2 (по умолчанию), lpe (не рекомендуется). Его можно задать с помощью export PX4_ESTIMATOR=lpe перед запуском моделирования.
<p>
Описанный здесь синтаксис упрощен, и есть много других параметров, которые вы можете настроить с помощью make - например, указать, что вы хотите подключиться к IDE или отладчику. Дополнительные сведения см. в разделе: <a href="https://docs.px4.io/main/en/dev_setup/building_px4.html#px4-make-build-targets">Создание кода > PX4 Make Build Targets</a>.

<h3>Запуск моделирования быстрее, чем в реальном времени</h3>
SITL может выполняться быстрее или медленнее, чем в реальном времени, при использовании jMAVSim или Gazebo Classic.
<p>
Коэффициент скорости устанавливается с помощью переменной среды PX4_SIM_SPEED_FACTOR. Например, чтобы запустить симуляцию jMAVSim со скоростью, в 2 раза превышающей скорость реального времени:
<p>
<b>PX4_SIM_SPEED_FACTOR=2 make px4_sitl jmavsim</b>
<p>
Для запуска в два раза меньшей скорости реального времени:
<p>
<b>PX4_SIM_SPEED_FACTOR=0.5 make px4_sitl jmavsim</b>
<p>
Вы можете применить этот коэффициент ко всем запускам SITL в текущем сеансе, используя EXPORT:
<pre>
export PX4_SIM_SPEED_FACTOR=2
make px4_sitl jmavsim
</pre>

<h3>Имитация последовательного шага​</h3>
PX4 SITL и симуляторы (jMAVSim или Gazebo Classic) настроены на совместную работу. Это означает, что PX4 и симулятор ожидают друг от друга сообщений от датчиков и исполнительных механизмов, а не работают на своих собственных скоростях.
<p>
Последовательность шагов для lockstep такова:
<ol>
<li> Моделирование отправляет сообщение датчика HIL_SENSOR, включающее временную метку time_usec, для обновления состояния датчика и времени PX4.
<li> PX4 получает это и выполняет одну итерацию оценки состояния, управления и т.д. И в конечном итоге отправляет сообщение привода HIL_ACTUATOR_CONTROLS.
<li> Симуляция ожидает получения сообщения о приводе/двигателе, затем моделирует физические параметры и вычисляет следующее сообщение датчика для повторной отправки на PX4.
</ol>
Система запускается с периода "свободного хода", когда моделирование отправляет сообщения датчиков, включая время, и, следовательно, запускает PX4 до тех пор, пока оно не инициализируется и не ответит сообщением привода.

<h3>SSH Tunneling</h3>
SSH-туннелирование является гибким вариантом, поскольку компьютер для моделирования и система, использующая его, не обязательно должны находиться в одной сети.
<p>
<i>Аналогичным образом вы можете использовать VPN для создания туннеля к внешнему интерфейсу (в той же или другой сети).</i>
<p>
Один из способов создания туннеля - использовать параметры SSH-туннелирования. Сам туннель можно создать, выполнив следующую команду на localhost, где remote.local - это имя удаленного компьютера:
<p>
<b>ssh -C -fR 14551:localhost:14551 remote.local</b>
<p>
UDP-пакеты необходимо преобразовать в TCP-пакеты, чтобы их можно было передавать по SSH. Утилиту netcat можно использовать на обеих сторонах туннеля - сначала для преобразования пакетов из UDP в TCP, а затем обратно в UDP на другом конце.<br>
<i>QGC должен быть запущен перед запуском netcat.</i>
<p>
На компьютере QGroundControl преобразование пакетов UDP может быть реализовано путем выполнения следующих команд:
<p>
<pre>
mkfifo /tmp/tcp2udp
netcat -lvp 14551 < /tmp/tcp2udp | netcat -u localhost 14550 > /tmp/tcp2udp
</pre>
<p>
На стороне симулятора SSH-туннеля команда выглядит следующим образом:
<p>
<pre>
mkfifo /tmp/udp2tcp
netcat -lvup 14550 < /tmp/udp2tcp | netcat localhost 14551 > /tmp/udp2tcp
</pre>
<p>
Номер порта 14550 действителен для подключения к QGroundControl или другому GCS, но его следует настроить для других конечных точек (например, API разработчика и т.д.).
<p>
Теоретически туннель может работать бесконечно, но в случае возникновения проблемы может потребоваться перезапуск подключений netcat.
<p>
На компьютере QGC можно запустить скрипт QGC_remote_connect.bash для автоматической настройки/выполнения приведенных выше инструкций. Моделирование уже должно быть запущено на удаленном сервере, и у вас должна быть возможность подключиться к этому серверу по SSH.

<h3 align="center"><a href="https://docs.px4.io/main/en/sim_gazebo_gz/">Gazebo Simulation</a></h3>
<i><font color="red">Gazebo ранее был известен как "Gazebo Ignition" (в то время как Gazebo Classic ранее был известен как Gazebo). Дополнительную информацию смотрите в <a href="https://www.openrobotics.org/blog/2022/4/6/a-new-era-for-gazebo">официальном блоге</a>.</font></i>
<p>
Gazebo - это симулятор робототехники с открытым исходным кодом. Он заменяет старый классический симулятор Gazebo и является единственной поддерживаемой версией Gazebo для Ubuntu 22.04 и более поздних версий.<br>
Поддерживаемые транспортные средства: Квадротор, самолет, СВВП, ровер
<h3>Установка на ubuntu</h3>
Gazebo устанавливается по умолчанию в Ubuntu 22.04 в рамках обычной настройки среды разработки.
<p>
Если вы хотите использовать Gazebo в Ubuntu 20.04, вы можете установить его вручную, предварительно выполнив обычный процесс установки (установка gz-garden приведет к удалению Gazebo-Classic!).:
<p><pre>
sudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/gazebo-stable.list &gt; /dev/null
sudo apt-get update
sudo apt-get install gz-garden
</pre>
<h3>Запуск моделирования</h3>
Моделирование Gazebo SITL можно удобно запустить с помощью команды make, как показано ниже:
<p>
<pre>
cd /path/to/PX4-Autopilot
make px4_sitl gz_x500
</pre>
</p>
При этом запускаются как экземпляр PX4 SITL, так и клиент Gazebo.
<p>
Ниже перечислены поддерживаемые средства и команды make. Обратите внимание, что все целевые объекты gazebo make имеют префикс gz_.
<p>
<img src="./images/dron6.png">
<p>
Все модели транспортных средств (и миры) включены в качестве подмодуля из репозитория <a href="https://docs.px4.io/main/en/sim_gazebo_gz/gazebo_models.html">Gazebo Models Repository</a>.
<p>
Приведенные выше команды запускают одно транспортное средство с полным пользовательским интерфейсом. QGroundControl должен иметь возможность автоматического подключения к моделируемому транспортному средству.
<h3>Автономный режим</h3>
Другой способ подключения Gazebo SITL - это автономный режим. В этом режиме PX4 SITL и Gazebo запускаются отдельно на своих собственных терминалах. По умолчанию эти терминалы находятся на одном хосте, но вы также можете подключить экземпляры SITL и Gazebo, работающие на любых двух устройствах в сети (или даже в разных сетях, если вы используете для их подключения VPN).
<p>
Вы запускаете PX4 в автономном режиме, добавив к команде make префикс PX4_GZ_STANDALONE=1:
<p>
<pre>
cd /path/to/PX4-Autopilot
PX4_GZ_STANDALONE=1 make px4_sitl gz_x500
</pre>
Затем PX4 SITL будет ждать, пока не обнаружит экземпляр gz-сервера, а затем подключится к нему.<br>
Если вы еще не запустили gz-сервер при запуске команды make, вы будете видеть следующее предупреждение до тех пор, пока gazebo не будет запущен и экземпляр gz-сервера не будет обнаружен PX4:
<pre>
WARN [gz bridge] Service call timed out as Gazebo has not been detected
</pre>
Самый простой способ запустить симуляцию - использовать скрипт Python simulation-gazebo, который можно найти в репозитории Gazebo Models Repository. Его можно использовать для запуска экземпляра gz-сервера с любым поддерживаемым миром и транспортным средством.
<p>
Скрипт можно использовать без установки каких-либо дополнительных зависимостей, и он будет извлекать поддерживаемые модели и миры PX4 при первом использовании (по умолчанию) и сохранять их в ~/.simulation-gazebo. При повторном вызове скрипт будет использовать этот каталог для получения моделей и миров. Поэтому, если вы хотите использовать свою собственную модель и запускать ее в автономном режиме, вам нужно будет поместить ее исходный код в ~/.simulation-gazebo.
<p>
Вы можете скачать скрипт локально, используя любой метод, который вам нравится, например, wget:
<pre>
wget https://raw.githubusercontent.com/PX4/PX4-gazebo-models/main/simulation-gazebo
</pre>
Скрипт можно запустить с помощью:
<pre>
cd /path/to/script/
python3 simulation-gazebo
</pre>
Дополнительные сведения и аргументы приведены в разделе <a href="https://docs.px4.io/main/en/sim_gazebo_gz/gazebo_models.html">Gazebo models</a>.
<p>
<i>Если команда make px4_sitl gz_x500 выдает ошибку: <b>ninja: error: unknown target 'gz_x500'</b>, запустите команду make distclean, чтобы начать с чистого листа, и попробуйте снова запустить команду make px4_sitl gz_x500</i>

<h3 align="center"><a href="https://docs.px4.io/main/en/sim_gazebo_classic/">Gazebo Classic</a></h3>

















<br><br><br><br><br><br><br></body></html>
