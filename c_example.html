<html><head>
<style>
.menu {
       height: 100%;
       width: 120px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 125px; /* То же, что и ширина боковой панели */
           padding: 0px 0px 0px 10px;
         }
</style>
</head><body>
<title>Примеры</title>
<div class="menu">
<a href="#scanf">scanf()</a>
<a href="#bool">Логические операции</a>
<a href="#ukazat">Указатели</a>
<a href="#tern">Тернарные операции</a>
<a href="#bit">Битовая алгебра</a>
<a href="#makros">Макросы</a>
<a href="#while">Циклы</a>
<a href="#array">Массив</a>
<a href="#stroka">Строки</a>
<a href="#sprintf">sprintf() atoi() atol() atoll() atof()</a>
<a href="#funk">Функции</a>
<a href="#argument">Массивы как параметры функции</a>
<a href="#pointer">Указатели на функцию</a>
<a href="#massiv_pointer">Массив из указателей на функцию</a>
<a href="#rekurs">Рекурсивные функции</a>
<a href="#variad">Вариадические функции</a>
<a href="#malloc">malloc(), free(), calloc(), realloc(), memcpy()</a>
<a href="#enum">enum</a>
<a href="#typedef">typedef</a>
</div>

<div class="content">
Продолжите программу, которая должна читать из входного потока три первых подряд идущих символа с помощью функции getchar(), а 
затем вывести их в выходной поток в обратном порядке (от последнего к первому) с помощью функции putchar().
<p>
P.S. В тестах гарантируется, что во входном потоке присутствуют, как минимум, три символа.
<pre>
Sample Input:
abcd
Sample Output:
cba
</pre>
Моё:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    // здесь продолжайте программу
    int first_simvol = getchar();
    int second_simvol = getchar();
    int thirty_simvol = getchar();
    putchar(thirty_simvol);
    putchar(second_simvol);
    putchar(first_simvol);
    //printf("\n%c%c%c\n", putchar(thirty_simvol), putchar(second_simvol), putchar(first_simvol));
    return 0;
}
</pre>
</td></tr></table>
<p>
1. В команде: printf("\n%c%c%c\n", putchar(thirty_simvol), putchar(second_simvol), putchar(first_simvol));<br>
putchar(int) будет выводиться в символьном виде, так как <b>n%c</b><br>
Если бы было <b>n%d</b>, то выводился бы код символа (число).
<p>
2. Так и не понял: <i>printf("\n%c%c%c\n", putchar(thirty_simvol), putchar(second_simvol), putchar(first_simvol));</i> выводит 
одновременно и символы и после коды этих символов.<br>
Видимо из-за того, что putchar(int) автоматом выводит int в поток вывода и получается, что он 2 раза исполняется. Сначала в 
\n%c, а потом себя исполняет.
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу, которая должна вывести все объявленные переменные (в порядке их объявления) каждую с новой строки. При 
этом никаких пробелов в выводе быть не должно. Воспользуйтесь для такого форматированного вывода функцией printf(). Символьная 
переменная должна быть выведена как символ, вещественная без ограничения точности.<br>
Моё:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    char byte = 65;
    unsigned short height = 1055;
    int distance = 1000000;
    float pi = 3.1415f;

    // здесь продолжайте программу
    printf("%c\n%u\n%d\n%f\n", byte, height, distance, pi);
    return 0;
}
</pre>
</td></tr></table>
<p>
Вывод:<br>
A<br>
1055<br>
1000000<br>
3.141500
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу, которая должна с помощью функции printf() вывести текущее время, хранимое в переменных: h - часы; m - 
минуты; s - секунды в формате: hh:mm:ss<br>
Например, для h = 12, m = 3, s = 9 должно быть: <i>12:03:09</i>
<br>Моё:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    unsigned char h = 11, m = 8, s = 1;
    printf("%02d:%02d:%02d\n", h, m, s);
    // здесь продолжайте программу
    return 0;
}
</pre>
</td></tr></table>
<p>
Вывод:<br>
11:08:01
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу, которая должна с помощью функции printf() вывести текущее время, хранимое в переменных: h - часы; m - 
минуты; s - секунды в формате шестнадцатеричных чисел с выводом префикса 0x: 0xhh:0xmm:0xss<br>
Например, для h = 12, m = 3, s = 9 должно быть: <i>0x0c:0x03:0x09</i>
<br>Моё:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    unsigned char h = 17, m = 45, s = 5;
    printf("%#04x:%#04x:%#04x\n", h, m, s);
    return 0;
}
</pre>
</td></tr></table>
<p>
Вывод:<br>
0x11:0x2d:0x05
<p>
Если записать <i>printf("%#04X:%#04X:%#04X\n", h, m, s);</i>, то вывод будет: <i>0X11:0X2d:0X05</i> (большая X).
<pre>


==========================================================================================================================


</pre>
<a name="scanf"><h3 align=center>scanf() - записываем stdin в переменные</h3>
Продолжите программу, в которой из стандартного входного потока с помощью функции scanf() необходимо прочитать данные, 
следующие через пробел, в объявленные переменные a, b, c, d (в порядке их объявления). Вывести прочитанные значения с помощью 
функции printf() в одну строчку через пробел в порядке считывания. Вещественные числа отображать с точностью до сотых.
<pre>
Sample Input:
65000 32000 0.5 -78.5
Sample Output:
65000 32000 0.50 -78.50
</pre>
Моё:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int a;
    short b;
    float c;
    double d;
    int in_var = scanf("%d %hd %f %lf\n", &a, &b, &c, &d);
    printf("%d %d %.2f %.2f", a, b, c, d);
    return 0;
}
</pre>
</td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу, в которой из стандартного входного потока с помощью функции scanf() необходимо прочитать данные по 
следующей схеме: &lt;целое число>, &lt;целое число&gt;, &lt;пропуск вещественного числа&gt;, &lt;вещественное число&gt;
<p>
То есть, третье значение заносить в переменную не нужно, оно должно пропускаться.<br>
Вывести прочитанные значения с помощью функции printf() в одну строчку через пробел в порядке считывания. Вещественные числа 
отображать с точностью до сотых.
<pre>
Sample Input:
56483, 1234, -4.5, 17.534
Sample Output:
56483 1234 17.53
</pre>
Моё:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int    number1;
    int    number2;
    double number3;
    int res = scanf("%d, %d, %*f, %lf", &number1, &number2, &number3);
    printf("%d %d %.2f\n", number1, number2, number3);
    return 0;
}
</pre>
</td></tr></table>
<pre>
example.c: In function ‘main’:
example.c:8:21: warning: use of assignment suppression and length modifier together in gnu_scanf format [-Wformat=]
    8 |     int res = scanf("%d, %d, <font color=red>%*lf</font>, %lf", &number1, &number2, &number3);
      |                     ^~~~~~~~~~~~~~~~~~~
</pre>
предупреждение: одновременное использование ограничения присваивания и модификатора длины в формате gnu_scanf [-Wformat=]
<p>
В <i>int res = scanf("%d, %d, %*lf, %lf", &number1, &number2, &number3);</i> поменял %*lf на %*f
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает три числа из потока stdin, каждое записанное с новой строки. При этом, первое число - 
целочисленное в диапазоне [-64000; 100000], второе и третье - вещественные. Выполните чтение этих чисел с помощью функции 
scanf() и выведите их на экран в одну строчку через пробел в порядке считывания, причем вещественные числа следует выводить с 
точностью до сотых (два знака после запятой).
<pre>
Sample Input:
100000
-73.12
1.234
Sample Output:
100000 -73.12 1.23
</pre>
Моё:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int    number1;
    double number2;
    double number3;
    int res = scanf("%d %lf %lf", &number1, &number2, &number3);
    printf("\n%d %.2f %.2f\n", number1, number2, number3);
    return 0;
}
</pre>
</td></tr></table>
<p>
В <b>int res = scanf("%d, %lf, %lf", &number1, &number2, &number3);</b> забыл убрать запятые и вывод был: 100000 0.00 0.00
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Необходимо продолжить программу, которая складывает время, указанное в часах, минутах и секундах. Исходное время хранится в 
переменных time_h, time_m, time_s, а добавляемое - в переменных h, m, s. Гарантируется, что сумма времен не превышает одни 
сутки. Вывести полученное суммарное время в консоль в формате: hh:mm:ss<br>
<pre>
Sample Input:2; 45; 10
Sample Output:13:18:15
</pre>
Моё:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    unsigned short time_h = 10; // часы
    unsigned short time_m = 33; // минуты
    unsigned short time_s = 5; // секунды

    unsigned short h, m, s; // добавляемое время: h - часы; m - минуты; s - секунды
    scanf("%hu; %hu; %hu", &h, &m, &s);
    unsigned int summarn_time_in_secund = (time_h + h)*3600 + (time_m + m)*60 + time_s + s;
    unsigned int sec = summarn_time_in_secund % 60;
    unsigned int min = (summarn_time_in_secund / 60) % 60;
    unsigned int hour = summarn_time_in_secund / 3600;
 
    printf("%02d:%02d:%02d\n", hour, min, sec);

    return 0;
}
</pre>
</td></tr></table>
<pre>


------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает целочисленные значения из входного потока в массив, записанных в одну строчку через пробел. 
Чтение происходит до тех пор, пока либо не закончатся данные, либо не будет прочитано 10 чисел. После этого выполните 
проверку: если прочитанные числа неотрицательны (больше или равны 0) и нечетны, то выведите в консоль число 1, иначе - число 
0. Попробуйте реализовать эту программу без применения условных операторов.<br>
Sample Input:3 5 7 11 13 15 17 19 23 25 43 36<br>
Sample Output:1
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
Моё:
#include &lt;stdio.h&gt;

int main(void)
{
    int num, flag =1;
    char x;
    for (int i=1; x!=10 && i<10; i++)
     {
       <b>scanf("%d%c", &num, &x);</b>
       flag = (num >=0 && num % 2 !=0) && flag;
       i++;
     }
    printf("%d\n", flag);
    return 0;
}
</pre>
</td>
<td>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int arr[] = {1,1,1,1,1,1,1,1,1,1};
    int res_odd = 1, res_neg = 1;
    for (int i = 0; i ^ 10; i++)
        scanf("%d", arr+i);
    
    for (int i = 0; i ^ 10; i++)
    {        
        res_odd &=  arr[i] & 1;
        res_neg ^= (arr[i] >> 31) & 1;
    } 
    printf("%d", res_neg & res_odd);
    return 0;
}
</pre></td></tr></table>
<p>
1. <b>Как прекратить считывание данных через scanf(). Несколько часов потратил на это.</b> Проблему решил строкой 
<b>scanf("%d%c", &num, &x);</b> Здесь через %c я считываю символ после числа. Численный код переноса строки равен 10.<br>
Но в stepic для решения этой задачи достаточно, что нажимаю Ctrl+D, тем самым даю команду на прекращение ввода данных. <b>В 
программе этому соответствует условие scanf(% ) !=1.</b> Плюс должен быть объявлен массив 
<pre>


==========================================================================================================================


</pre>
<a name="bool"><h3 align=center>Логические операции</h3>
Напишите программу, которая считывает из входного потока stdin целое число и выводит в консоль значение 100, если число кратно 
5, и 0 в противном случае.
<br>P.S. Программу реализовать без применения условных операторов.
<pre>
Sample Input:
15
Sample Output:
100
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

int main(void)
{
    int num;
    scanf("%d", &num);
    bool a = num % 5 == 0;
    printf("%d", a*100);
    return 0;
}
</pre>
</td>
<td valign=top>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int a;
    
    scanf("%d", &a);
    printf("%d\n", (a % 5 == 0) * 100);
    
    return 0;
}
</pre>
Непонятно: выходит не обязательно для логических операций включать файл stdbool.h<br>
Вроде как, если не используется переменная типа bool, то не надо включать stdbool.h
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая считывает из входного потока stdin вещественное число и выводит в консоль значение 1, если число 
принадлежит диапазону [-5.45; 10.37], и 0 в противном случае.
<pre>
Sample Input:
-5.44
Sample Output:
1
</pre>
Моё:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include <stdio.h>

int main(void)
{
    double num;
    scanf("%lf", &num);
    printf("%d", num >= -5.45 && num <= 10.37);
    return 0;
}
</pre>
</td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------------


</pre>
На плоскости размером rect_width x rect_height (ширина x высота) размещены непересекающиеся прямоугольники одинаковых размеров 
w x h, следующих друг за другом, как показано на рисунке ниже.<br>
Необходимо продолжить программу, вычислив общее число прямоугольников не умещающихся целиком на плоскости. Результат вывести в 
консоль в виде одного целого числа.
<pre>
Sample Input:
23; 44
Sample Output:
38
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int rect_width = 640, rect_height = 480;
    int w = 1, h = 1;
    scanf("%d; %d", &w, &h);
    int count_width = (rect_height % h != 0) * rect_width/w;
    int count_height = (rect_width % w != 0) * rect_height/h;
    int added_element = (rect_height % h != 0) && (rect_width % w != 0);
    int resault = count_width+count_height+added_element;
    printf("count_width=%d, count_height=%d, resultat=%d\n", count_width, count_height, resault);
    return 0;
}
</pre>
</td></tr></table>
<pre>


============================================================================================================================


</pre>
<a name="ukazat"><h3 align=center>Работа с указателями</h3>
Продолжите программу. Объявите указатель ptr_a на переменную a и указатель ptr_b на переменную b. Вычислите произведение 
значений переменных a и b, используя указатели ptr_a и ptr_b. Результат присвойте переменной res и выведите ее в консоль в 
виде целого числа.<br>
Sample Input: 8, 11
Sample Output: 88
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    short a, b;

    scanf("%hd, %hd", &a, &b);

    short *ptr_a = &a;
    short *ptr_b = &b;
    short res = *ptr_a * *ptr_b;
    printf("%d", res);
    
    return 0;
}
</pre>
</td></tr></table>
<pre>


------------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу. Объявите указатель ptr_a на переменную a и указатель ptr_b на переменную b. Поменяйте адреса указателей 
ptr_a и ptr_b между собой, используя третий вспомогательный указатель с обобщенным типом void*. Выведите в консоль в одну 
строчку через пробел целочисленные значения, на которые ссылаются указатели ptr_a и ptr_b именно в таком порядке:
&lt;значение для ptr_a&gt; &lt;значение для ptr_b&gt;<br>
Sample Input: -5, 10<br>
Sample Output:10 -5
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    short a, b;

    scanf("%hd, %hd", &a, &b);

    short *ptr_a = &a;
    short *ptr_b = &b;
    void *p;
    <b>p = ptr_a;</b>
    ptr_a = ptr_b;
    ptr_b = p;
    printf("%d %d", *ptr_a, *ptr_b);
    
    return 0;
}
</pre>
</td></tr></table>
<p>
Сначала делал так: <b>*p = ptr_a;</b> и получалось, что в переменную указателя p заносил адрес указателя ptr_a. Хотя это не условию задания, но формально, если бы тип был не void, то никаких ошибок бы не было. Но видимо в void ничего нельзя заносить. И по заданию, если адрес указателя поменять (не переменную указателя), то правильный синтаксис: <b>p = ptr_a;</b>
<pre>


------------------------------------------------------------------------------------------------------------------------------


</pre>
Объявите указатель с именем ptr_var на переменную var.<br>
Объявите еще один указатель с именем ptr_ch для типа char и присвойте ему адрес, хранимый указателем ptr_var. (Не забудьте 
прописать операцию приведения типов.)<br>
Выведите в консоль целочисленное значение, на которое ссылается указатель ptr_ch.<br>
Sample Input:1037<br>
Sample Output:13
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int var;

    scanf("%d", &var);

    int *ptr_var = &var;
    char *ptr_ch = <b>(char *)</b>ptr_var; //объявили указатель и его адресу назначили адрес другого указателя
    // <b>Правильно вроде как сначало обьявить указатель: char *ptr_ch, а потом только дать другой алрес: ptr_ch = (char *)ptr_var</b>
    
    printf("%d", *ptr_ch);
    
    return 0;
}
</pre>
</td></tr></table>
<p>
Насчет почему из 1037 получаем 13:
<p>
<img src="./images/c_example.png">
<p>
<i>обьясню по-другому (как в уроке рассказывается). 1037 это 256 * 4 + 13, т.е. в 1037 в ОЗУ хранится как 13 4 0 0 (если int 
это 4 последовательные ячейки в 1 байт), как известно из лекции адрес переменной это адрес ее первой ячейки, поэтому запись 
указателя на int в указатель на char позволяет через этот указатель управлять лишь содержимым первой ячейки из 4 ячеек 
переменной int. а в первой ячейке у нас 13. это значение и выводится при разыменовывании указателя ptr_ch.</i>
<pre>


------------------------------------------------------------------------------------------------------------------------------


</pre>
Допишите следующую программу. Необходимо все 8 байт (тип double) переменной value вывести в консоль в виде десятичных чисел, 
записанных в одну строчку через пробел, начиная с первого байта.<br>
Sample Input:0.5
Sample Output:0 0 0 0 0 0 -32 63
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    double value;

    scanf("%lf", &value);

    char *ptr = (char *)&value;
    for(int i = 0; i < sizeof(value); ++i) {
                   printf("%d ", *ptr);
                   ptr++;
         }

    return 0;
}
</pre>
</td></tr></table>
<p>
Не пойму <font color=red>char *ptr = (char *)&value;</font> Почему не char *ptr = (char)&value;<br>
В этом случае <font color=red>warning: initialization of ‘char *’ from ‘char’ makes pointer from integer without a cast [-Wint-
conversion]</font> (инициализация ‘char *’ из ‘char’ преобразует указатель в целое число без приведения)
<p>
И почему -32 63 вывод.
<pre>


---------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает из входного потока целое число в переменную value типа int. Каждые два байта этой 
переменной следует обработать по следующему алгоритму:<br>
1. Представить два байта в виде целого числа.<br>
2. Увеличить каждое полученное двухбайтовое число на единицу.<br>
3. Увеличенное значение снова побайтно перенести в соответствующие ячейки переменной value.<br>
Полученное значение переменной value вывести в консоль в виде одного целого числа.<br>
P. S. При написании программы гарантируется: char = 1 байт; short = 2 байта; int = 4 байта; double = 8 байт.
<br>Sample Input:325476<br>
Sample Output:391013
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int value;
    int x1, x2;
    scanf("%d", &value);

    short *ptr = (short *)&value;//указатель на 2 байта переменной value
    *ptr +=1;                   //значение числа в первых двух байтах увеличили на 1
    *(ptr + 1) +=1;             //значение числа во вторых двух байтах увеличили на 1
    printf("%d", value);
    return 0;
}
</pre>
</td></tr></table>
<p>

<pre>


---------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу. Прочитайте из входного потока целое число в переменную value типа int. Объявите массив с именем ar_d 
типа char и длиной для побайтного хранения числа типа int. Скопируйте значение каждого байта переменной value в массив ar_d 
(значение самой переменной value не менять). Выведите значения элементов массива ar_d в консоль в виде десятичных чисел в одну 
строчку через пробел.
<br>Sample Input:1025<br>
Sample Output:1 4 0 0
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int value;
    scanf("%d", &value);
    <font color=red>//char ar_d[] = {0};</font>
    char ar_d[sizeof(int)];     //массив длиной равной размеру int
    char *ptr = (char *)&value; // указатель на первый байт переменной value
    for (int i=0; i&lt;sizeof(value); i++, ptr++)
     {
        ar_d[i] = *ptr;
        printf("%d\n", ar_d[i]);
     }
    
    return 0;
}
</pre>
</td></tr></table>
<p>
Если массив объявить так: <b>char ar_d[] = {0};</b>, то скрипт выдает правильный результат, но в конце выдает ошибку: 
<pre>
<font color=red>*** stack smashing detected ***: terminated
Аварийный останов (стек памяти сброшен на диск)</font></pre>
Наверное когда массив не имеет определенной длины, это несмотря на конечный цикл, все равно источник проблем.
<p>

<pre>


---------------------------------------------------------------------------------------------------------------------------


</pre>
<pre>


============================================================================================================================


</pre>
<a name="if"><h3 align=center>Условный оператор if. Конструкция if-else</h3>
Напишите программу чтения двух целых чисел из входного потока, записанных в одну строчку через пробел. Если эти числа равны, то 
вывести в консоль любое из этих чисел, а иначе - в порядке возрастания.
<pre>
Sample Input:
11 7
Sample Output:
7 11
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int num1, num2;
    scanf("%d %d", &num1, &num2);
    if (num1 < num2) printf("%d %d", num1, num2);
    else if (num1 == num2) printf("%d", num1);
    else printf("%d %d", num2, num1);
    return 0;
}
</pre>
</td></tr><tr><td valign=top>
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int x, y;
    scanf("%d %d", &x, &y);
    (x == y && printf("%d", x)) || (x < y && printf("%d %d", x, y)) || printf("%d %d",y, x);
    return 0;
}
</pre></td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу чтения трех вещественных чисел из входного потока, записанных в одну строчку через запятую. Необходимо 
определить наименьшее среди них и вывести его в консоль с точностью до сотых.
<pre>
Sample Input:
4.5, 7.8, 0.5
Sample Output:
0.50
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td rowspan=2>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
  double num1, num2, num3;
  scanf("%lf, %lf, %lf", &num1, &num2, &num3);
  if (num1 < num2) {
      if (num1 < num3) printf("%.2f", num1);
      else printf("%.2f", num3);
  }
  else {
      if (num2 < num3) printf("%.2f", num2);
      else printf("%.2f", num3);
  }
  return 0;
}
</pre></td>
<td>
<pre>
#include <stdio.h>

int main(void)
{
    double a, b, c;
    if(scanf("%lf, %lf, %lf", &a, &b, &c) != 3) {
        printf("Input error.");
        return 0;
    }

    // здесь продолжайте программу
    if(a > b) a = b;
    if(a > c) a = c;
    printf("%.2f", a);

    return 0;
}
</pre></tr>
<tr><td>
<pre>
#include <stdio.h>

int main(void)
{
    double a, b, c;
    if(scanf("%lf, %lf, %lf", &a, &b, &c) != 3) {
        printf("Input error.");
        return 0;
    }
    
    double <b>min = a;</b>
    <b>if(b <= a && b <= c)</b>
        min = b;
    else if(c <= a && c <= b)
        min = c;
    printf("%.2lf", min);
        
    return 0;
}
</pre></td></tr></table>
<pre>


========================================================================================================================


</pre>
<a name="tern"><h3 align="center">Тернарные операции</h3>
Продолжите программу. С помощью вложенных тернарных операций реализуйте следующую логику. Если значение переменной type равно 
единице, то вычислите площадь прямоугольника со сторонами w и h (то есть, произведение w⋅h). Иначе, если значение type равно 2, 
то - периметр прямоугольника (по формуле: 2⋅(w+h)). Иначе (если type не 1 и не 2), вернуть значение -1. Результат выведите в 
консоль. Если это результат вычислений, то как вещественное число с точностью до десятых, иначе, просто целое значение -1.
<pre>
Sample Input:
1 0.5 1.2
Sample Output:
0.6
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    short type = 0;
    double w, h;

    if(scanf("%hd %lf %lf", &type, &w, &h) != 3) {
        printf("Input error.");
        return 0;
    }
    type == 1 ? printf("%.1f", w * h) : type == 2 ? printf("%.1f", 2*(w + h)) : printf("-1");
    return 0;
}
</pre></td></tr></table>
<pre>


-------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, в которой объявляется макрос с именем MAX_BUFF_SIZE со значением 1024 и выполняется чтение (в функции 
main()) целочисленного положительного значения в целочисленную переменную buff_size. С помощью тернарного условного оператора 
скорректируйте значение переменной buff_size, чтобы оно не превосходило значения MAX_BUFF_SIZE. Итоговое значение переменной 
buff_size выведите в консоль в виде одного целого числа.<br>
Sample Input:1048<br>
Sample Output:1024
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;
#define MAX_BUFF_SIZE 1024

int main(void)
{
    int buff_size;
    scanf("%d", &buff_size);
    buff_size = buff_size > MAX_BUFF_SIZE ? MAX_BUFF_SIZE : buff_size;
    printf("%d\n", buff_size);
    return 0;
}
</pre></td></tr></table>
Типичная тернарная операция. Плюс макродиректива MAX_BUFF_SIZE
<pre>


--------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу. Определите макро-функцию GET_WIDTH так, чтобы она возвращала значение W, если W <= MAX_WIDTH, иначе - 
значение MAX_WIDTH. Сделайте это с использованием тернарного условного оператора. Вызовите макрос-функцию GET_WIDTH для 
корректировки значения переменной width. Выведите ее значение в консоль в виде строки (без кавычек): "width = &lt;значение&gt;"
<br>Sample Input:100<br>
Sample Output:width = 100
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

#define MAX_WIDTH    1280
//#define GET_WIDTH(W) <font color=red>W =</font> W <= MAX_WIDTH ? W : MAX_WIDTH
#define GET_WIDTH(W) W <= MAX_WIDTH ? W : MAX_WIDTH

int main(void)
{
    int width;
    scanf("%d", &width);
    printf("width = %d\n", GET_WIDTH(width));
    return 0;
}
</pre></td></tr></table>
<p>
На строке #define GET_WIDTH(W) <font color=red>W =</font> W <= MAX_WIDTH ? W : MAX_WIDTH получал ошибку <font color=red>lvalue 
required as left operand of assignment</font> Избавился от нее, когда убрал W = (имя переменной, которой возвращается 
результат).
<pre>


========================================================================================================================


</pre>
<a name="bit"><h3 align=center>Битовая арифметика</h3>
Продолжите программу. Необходимо проверить, что биты 3 и 5 переменной bits включены (установлены в 1). Если это так, то 
выведите в консоль значение переменной bits в виде целого десятичного числа, иначе целое число -1.
<br>P.S. Нумерация бит числа идет в порядке от младшего к старшему и начинается с нуля: 7, 6, 5, 4, 3, 2, 1, 0
<pre>
Sample Input: 43
Sample Output: 43
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include <stdio.h>

int main(void)
{
    unsigned char bits;
    scanf("%hhu", &bits);
    unsigned char mask = 40;
    (bits & mask) == mask ? printf("%d\n", bits) : printf("-1");
    return 0;
}
</pre></td>
<td>
Другое:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    unsigned char bits;
    scanf("%hhu", &bits);

    // здесь продолжайте программу
    printf("%d", (bits & 0b00101000) == 40 ? bits : -1);

    return 0;
}
</pre></td></tr></table>
<p>
Долго не мог понять почему при несовпадении по битам с маской выдавал bits. Оказывается из-за низкого приоритета битовых 
операций. В <b>bits & mask == mask</b> выполнялось сначала сравнение mask с mask. Только когда bits & mask заключил в скобки, 
всё стало нормально работать. 
<pre>


-----------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу. Необходимо включить 4, 2 и 0 биты переменной bits (установить в 1). Результат сохраните в байтовой 
беззнаковой переменной res и выведите ее значение в консоль в виде целого десятичного числа.
<br>P.S. Нумерация бит числа идет в порядке от младшего к старшему и начинается с нуля: 7, 6, 5, 4, 3, 2, 1, 0
<pre>
Sample Input: 128
Sample Output: 149
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include <stdio.h>

int main(void)
{
    unsigned char bits;
    scanf("%hhu", &bits);
    unsigned char mask = 40;
    (bits & mask) == mask ? printf("%d\n", bits) : printf("-1");
    return 0;
}
</pre></td>
<td>
Другое:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    unsigned char bits;
    scanf("%hhu", &bits);
    unsigned char res = bits | 0b010101;
    printf("%d", res);
    // здесь продолжайте программу

    return 0;
}
</pre></td></tr></table>
<p>
Здесь у меня неправильный результат был из-за того что было: <i>unsigned char res = bits | 0<font color=red>0</font>010101;</i>
<br>Поменял на: <i>unsigned char res = bits | 0<font color=green>b</font>010101;</i><br>
Проверил, компилятор считает 0b010101 = 21 (правильно), а 00010101 = 4161 (непонятно почему). В двоичной десятичному 4161 
соответствует 1000001000001.
<pre>


-----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает из входного потока целое неотрицательное число и выполняет целочисленное деление этого числа 
на 4 с использованием сдвиговых битовых операций. Результат выведите в консоль в виде целого десятичного числа.
<br>Sample Input: 7<br>
Sample Output:  1
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
   unsigned char num; 
   scanf("%hhu", &num); 
   printf("%d\n", num >> 2);
}
</pre></td></tr></table>
<p>
Деление - это сдвиг вправо. На 1 единицу - это деление на 2, поэтому, чтобы поделить на 4, то сдвинуть нужно на 2 единицы.
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, в которой вводятся два целых неотрицательных числа в одну строчку через пробел, которые заносятся в 
беззнаковые целочисленные переменные (тип int) с именами flags и mask. Необходимо проверить, включен ли в переменной flags хотя 
бы один соответствующий бит переменной mask. Например:
<pre>
flags = 5; // 00000101
mask = 20; // 00010100
</pre>
В переменной flags включен 2-й бит, который совпадает со 2-м включенным битом из mask, проверка проходит. А если:
<pre>
flags = 5; // 00000101
mask = 18; // 00010010
</pre>
В переменной flags нет ни одного включенного бита, совпадающего хотя бы с одним включенным битом переменной mask, проверка не проходит. Если проверка проходит, то в консоль вывести строку "yes", иначе - строку "no".
<br>Sample Input: 1 3<br>
Sample Output: yes
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int flags, mask;
    scanf("%d %d", &flags, &mask);
    (flags & mask) !=0 ? printf("yes") : printf("no");
    return 0;
}
</pre></td>
<td>
Другое:
<pre>
#include &lt;stdio.h&gt;

int main (void)
{
  unsigned int flags, mask;

  scanf ("%d%d", &flags, &mask);
  printf (flags & mask ? "yes" : "no");

  return 0;
}
</pre></td></tr></table>
<pre>


--------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает из входного потока целое число в переменную count типа int. В каждом байте переменной count 
нужно включить 3-й и 0-й биты (нумерация бит в байте: 7, 6, 5, 4, 3, 2, 1, 0). Вывести в консоль полученное значение count в 
виде одного целого числа.<br>
Sample Input:0<br>
Sample Output:151587081
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int count;
    scanf("%d", &count);
    char *ptr = (char *)&count;           //берем один байт из count
    for (int i=1; i <=sizeof(count); i++) //цикл для обхода по байтам count
      {
        *ptr = *ptr | 0b001001;           //включаем 0 и 3 биты байта
        ptr++;                            // переход на следующий байт
      }
    printf("%d", count);
    return 0;
}
</pre></td></tr></table>
<p>
Можно for (int i=1; i <=sizeof(count); i++) заменить на for (int i=1; i <=sizeof(count); i++, <font color=green>ptr++</font>)
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает из входного потока целое число в переменную count типа int. В каждом байте переменной count 
нужно выключить 7-й, 6-й и 1-й биты (нумерация бит в байте: 7, 6, 5, 4, 3, 2, 1, 0). Вывести в консоль полученное значение 
count в виде одного целого числа.<br>
Sample Input:65535<br>
Sample Output:15677
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int count;
    scanf("%d", &count);
    char *ptr = (char *)&count;                  //берем один байт из count
    for (int i=1; i <=sizeof(count); i++, ptr++) //цикл для обхода по байтам count
      {
        *ptr = *ptr & 0b00111101;           //выключаем 1, 6, 7 биты это 00111101 или 61 в десятичной
      }
    printf("%d", count);
    return 0;
}
</pre></td></tr></table>
<p>
Нужно число 10111100. Почему-то если маска 1b111100 , то <font color=red>error: invalid suffix "b111100" on integer 
constant</font><br>
Разобрался, <b>0b - это приставка, надо вначале писать к полному 8 битовому числу</b>, а не вместо первых двух бит, как я думал.
<pre>


===========================================================================================================================


</pre>
<a name="makros"><h3 align=center>Макродирективы</h3>
Напишите программу, в которой объявляется макроопределение MAX_LENGTH с целочисленным значением 100. В функции main() 
реализовать чтение двух целочисленных положительных чисел, записанных в одну строчку через пробел, в переменные x и y (именно в 
таком порядке). Затем, выполнить проверку: если длина радиус-вектора с координатами (x, y) превышает значение MAX_LENGTH, то в 
консоль вывести сообщение (без кавычек): "Radius length exceeds value of MAX_LENGTH" Иначе вывести в консоль длину радиус-
вектора в виде вещественного числа с точностью до сотых. Напомню, что длина радиус-вектора с координатами (x, y) вычисляется по 
формуле: length= корень квадратный из x*x + y*y<br>
Sample Input: 50 20<br>
Sample Output: 53.85
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int flags, mask;
    scanf("%d %d", &flags, &mask);
    (flags & mask) !=0 ? printf("yes") : printf("no");
    return 0;
}
</pre></td></tr></table>
<p>
Получал ошибку: <font color=red>неопределённая ссылка на «sqrt» collect2: error: ld returned 1 exit status</font><br>
Решение: нужно к компилируемому файлу добавить суффикс -lm: <b>gcc example.c -lm</b>
<pre>


---------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу, в которой нужно определить макро-функцию с именем GET_MAX, возвращающую максимальное из двух чисел. 
Вызовите в функции main макрос GET_MAX следующим образом: double res = GET_MAX(val_1 + 1, val_2 - 1) / (val_1 + val_2);
<br>Выведите в консоль значение переменной res с точностью до сотых.
<br>Sample Input:0.3; -45.3<br>
Sample Output:-0.03
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

#define GET_MAX(a,b) a > b ? a : b 

int main(void)
{
    double val_1, val_2;
    if(scanf("%lf; %lf", &val_1, &val_2) != 2) {
        printf("Input error");
        return 0;
    }
    double res = (GET_MAX(val_1 + 1, val_2 - 1)) / (val_1 + val_2);
    printf("%.2f\n", res);
    return 0;
}
</pre></td></tr></table>
<p>
Непонятно почему без скобок в <b>(</b>GET_MAX(val_1 + 1, val_2 - 1)<b>)</b> / (val_1 + val_2); неправильно считалось.<br>
У других почему-то решение принялось.
<pre>


=========================================================================================================================


</pre>
<a name="while"><h3 align=center>Циклы</h3>
Напишите программу, которая читает из входного потока натуральное число n (целое, положительное), которое содержит от 2-х и 
более цифр. Используя цикл while, вычислить сумму цифр числа n. Результат вывести в консоль в виде одного целого числа.
<br>Sample Input:123<br>
Sample Output:6
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int num, summa=0;
    scanf("%d", &num);
    while(num > 0) {
        summa += num % 10;
        num = num /10;
    }
    printf("%d", summa);
    return 0;
}
</pre></td><td>
Другое:
<pre>
#include &lt;stdio.h&gt;

int main(void) {
    
    int n, s = 0;
    while(scanf("%1d", &n) == 1)
        s += n;
    printf("%d", s);
        
    return 0;
}
</pre></td></tr></table>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Последовательность Фибоначчи образуется так: первые два числа равны 1 и 1, а каждый следующий равен сумме двух предыдущих. То 
есть, имеем последовательность вида: 1, 1, 2, 3, 5, 8, 13, ... Вычислите последовательность Фибоначчи длиной n (n - 
натуральное число, читаемое из входного потока). Выведите числа полученной последовательности в одну строку через пробел.
<br>Sample Input:13<br>
Sample Output:
1 1 2 3 5 8 13 21 34 55 89 144 233
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int num, n=2;
    int summa =0, summa1 =1, summa2 =1;
    scanf("%d", &num);
    printf("1 1 ");
    while(++n <= num) {
        summa = summa1 + summa2;
        printf("%d ", summa);
        summa2 = summa1;
        summa1 = summa;
    }
    
    return 0;
}
</pre></td><td>
Другое:
<pre>
#include &lt;stdio.h&gt;
  
int main(void) {
    int n, curr = 1, prev = 0;
    scanf("%d", &n);
    while (n > 0) {
        prev += curr;
        prev ^= curr;
        curr ^= prev;
        prev ^= curr;
        printf("%d ", prev);
        n--;
    }
    return 0;
}
</pre></td></tr></table>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает из входного потока два натуральных числа n и m, записанных через пробел, причем n < m. Выведите в консоль в одну строчку через пробел все числа кратные 3 (нацело делятся на 3) из интервала [n, m].
<br>Sample Input:100 150<br>
Sample Output:102 105 108 111 114 117 120 123 126 129 132 135 138 141 144 147 150
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int n, m;
    scanf("%d %d", &n, &m);
    while(n <= m) {
        if (n % 3 == 0) {
        printf("%d ", n);
        }
        n +=1;
    }
    return 0;
}
</pre></td></tr></table>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает натуральное число, содержащее одну и более цифр. Определить, что это число является 
палиндромом, то есть, оно не меняет своего значения при просмотре слева-направо и справа-налево. Например: 121, 23032, 11 и 
т.п. Если число является палиндромом, то в консоль вывести строку "yes", иначе - строку "no".
<br>Sample Input:123321<br>
Sample Output:yes
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int number;
    int x = 0;
    scanf("%d", &number);
    int modif_number = number;
    while(modif_number != 0) {
        if (modif_number / 10 != 0) {
            x = x * 10 + (modif_number % 10);
        }
        else {
            x = x *10 + (modif_number % 10);
        }
        modif_number /=10;
    }
    x == number ? printf("yes") : printf("no");
    return 0;
}
</pre></td></tr></table>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите следующую программу. Из входного потока читаются цифры (от 1 до 9), записанные через пробел, пока не встретится число 
0. На основе этих цифр сформировать единое число. Например, если на вход поступают цифры: 5 2 9 3 0<br>
то должно формироваться число: 5293<br>
Выведите полученное число в консоль.<br>
Если цифра 0 встречается сразу (первая), то формируемая переменная должна принимать значение 0.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int number = 0;
    int n=1;
    
    for(;n!=0;) {
        scanf("%d", &n);
        if(n!=0) number = number * 10 + n;
        }
        
    printf("%d", number);
    
    return 0;
}
</pre></td></tr></table>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает из входного потока натуральное число n. На его основе нужно сформировать другое число m, в 
котором цифры числа n будут идти в обратном порядке. Например, при n = 235, получаем m = 532. Или, при n = 1, получаем m = 1.
<br>Sample Input:4235<br>
Sample Output:5324
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int n, m=0;
    scanf("%d", &n);
    
    while(n!=0) {
        m = m *10 + (n % 10);
        n = n / 10;    
        }
    printf("%d", m);
    return 0;
}
</pre></td></tr></table>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает из входного потока шестизначное натуральное число n. Определить, является ли оно 
счастливым. (Счастливым называют такое шестизначное число, в котором сумма его первых трех цифр равна сумме его последних трех 
цифр.). Вывести в консоль "yes", если счастливое и "no" - в противном случае.
<br>Sample Input:123231<br>
Sample Output:yes
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int n;
    int n1=0, n2=0;
    
    scanf("%d", &n);
    
    for(int i = 6; i >=1; i--) {
        if (i >=4) {
            n1 +=n%10;
            n /=10;
            }
        if (i <4) {
            n2 +=n%10;
            n /=10;
            }    
        }
    n1 == n2 ? printf("yes") : printf("no");
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;

int main (void)
{
    int n, res1 = 0, res2 = 0;
    scanf("%d", &n);
    for (int i = 1; n > 0; <b>n /= 10</b>, i++)
    {
        if (i <= 3) res1 += n % 10;
        else res2 += n % 10;
    }
    res1 == res2 ? printf("yes") : printf("no");
    return 0;
}
</pre></tr></table>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
<b>Цикл do-while</b><br>
Напишите программу с использованием цикла do-while, которая читает из входного потока целые числа (по одному) до тех пор, пока 
не встретится число 13. Все положительные прочитанные числа просуммировать (включая число 13) и вывести полученную сумму в 
виде одного целого числа в консоль.
<br>Sample Input:1 4 -3 10 -1 13<br>
Sample Output:28
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int num, summa=0;
    do {
        scanf("%d", &num);
        if (num > 0) summa +=num;
    } while(num !=13);
    printf("%d", summa);
    return 0;
}
</pre></td></tr></table>
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу игры "Угадай число". Задуманное целое число x в диапазоне [1; 1000] считывается из входного потока. 
Начальный диапазон сохраняется в переменных a = 1, b = 1000. Затем, генерируется случайное целое значение m в диапазоне [a; b]. Далее, рассматриваются три возможных исхода:
<pre>
1. Если m == x, то программа завершается и в консоль выводится найденное значение x.
2. Если m < x, то корректируется интервал возможных значений a = m, b - без изменений.
3. Если m > x, то корректируется интервал возможных значений a - без изменений, b = m.
</pre>
Процесс генерации продолжается (по циклу do-while), пока не будет угадано число x. Угаданное значение вывести в консоль в виде 
целого числа.
Sample Input:512<br>
Sample Output:512
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int x, a = 1, b = 1000, m;
    scanf("%d", &x);
    do {
        m = rand() % (b -a + 1) +a;
        if (m < x) {
            a = m;
        }
        if (m>x) {
            b =m;
        }
    } while(m != x);
    printf("%d", m);
    return 0;
}
</pre></td></tr></table>
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, которая читает из входного потока два натуральных числа m, n (m < n), записанных в одну строчку через 
пробел. Необходимо вывести в консоль в одну строчку через пробел все найденные числа-палиндромы в диапазоне [m; n]. Число-
палиндром - это число, которое не меняет своего значения при чтении слева-направо и справа-налево. Например, числа 121, 1, 11, 
43034 - палиндромы.
<br>Sample Input:100 200<br>
Sample Output:101 111 121 131 141 151 161 171 181 191
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

int main(void)
{
    int m, n;
    //int x = 0;
    int modif_number;
    scanf("%d %d", &m, &n);
    for (int i=m; i <=n; i++)
     {
        modif_number = i;
        int x =0;
        while(modif_number != 0)
          {
            if (modif_number / 10 != 0)
               {
                 x = x * 10 + (modif_number % 10);
                 //printf("i=%d x=%d\n", i, x);
               }
            else 
               {
                 x = x *10 + (modif_number % 10);
               }
            modif_number /=10;
          } 
        if (x == i) printf("%d ", i);   
     }
    
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;

int main(void) {
    int n, m;
    scanf("%d %d", &n, &m);
    do {
        int x = n, t = 0;
        while (x > 0) {
            t = t * 10 + x % 10;
            x /= 10;
        }
        if (t == n) {
            printf("%d ", n);
        }
        n++;
    } while (n <= m);
}
</pre></td></tr></table>
<pre>

============================================================================================================================

</pre>
<a name="array"><h3 align=center>Массивы</h3>
Прочитайте из входного потока целые числа в переменные var_1, var_2 и var_3, записанные в одну строчку через запятую. Побайтно 
занесите их значения в массив типа char (в порядке var_1, var_2, var_3). Выведите в одну строчку через пробел по порядку 
значения массива в виде беззнаковых десятичных чисел.<br>
Sample Input:7356, 6575729, 100433564<br>
Sample Output:188 28 113 86 100 0 156 126 252 5 0 0 0 0
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    short var_1;
    int var_2;
    long long var_3;
    scanf("%hd, %d, %lld", &var_1, &var_2, &var_3);
    char array[sizeof(var_1)+sizeof(var_2)+sizeof(var_3)];
    //printf("razmer=%zu\n", sizeof(array));
    char *ptr = (char *)&var_1;
    //*array = (char *)&var_1;
    for (int i=0; i<(sizeof(var_1)+sizeof(var_2)+sizeof(var_3)); i++, ptr++)
    {
        if (i == sizeof(var_1)) ptr = (char *)&var_2;
        else
            if (i == (sizeof(var_1) + sizeof(var_2))) ptr = (char *)&var_3;
        array[i] = *ptr;
        printf("%hhu ", array[i]);
    }
    return 0;
}
</pre></td></tr></table>
<p>
1. Если выводить через printf("%d ", array[i]); то почему некоторые числа со знаком минус, а если выводить как printf("%u ", array[i]); то эти числа из 10 цифр?
<p>
2. Почему нельзя массив использовать в качестве указателя? Пытался сделать *array = (char *)&var_1; но выводит ошибку.
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Пример занесения чисел из входного потока в массив</b><br>
Необходимо из входного потока читать целые числа (по одному), пока не встретится число 78. Все прочитанные числа по порядку 
заносить в массив ar, используя указатель ptr_ar (кроме последнего числа 78). Вывести в консоль прочитанные значения из 
массива ar в одну строчку через пробел в порядке их чтения.<br>
Sample Input:1 6 4 2 0 -100 496 3 5 78 101 102 103<br>
Sample Output:1 6 4 2 0 -100 496 3 5
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    int ar[100], num;
    int * const ptr_ar = ar;
    for (int i=0; i<100; i++)
    {
        scanf("%d", &num);
        if (num !=78)
        {
            ar[i] = num;
            printf("%d ", num);
        }   
        else break;    
    }
    return 0;
}
</pre></td>
<td align=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    int ar[100];
    int * const ptr_ar = ar;
    int x, i = 0;
    while (scanf("%d", &x) == 1 && x != 78) {
        <b>*(ptr_ar + i) = x;</b>
        i++;
    }
    for (int j = 0; j < i; j++) {
        printf("%d ", ar[j]);
    }
    return 0;
}
</pre></td></tr></table>
<p>
В int * <b>const</b> ptr_ar = ar; создали указатель с неизменяемым адресом.
<pre>


--------------------------------------------------------------------------------------------------------------------------


</pre>
Необходимо после каждого элемента со значением 5 массива digs вставлять новые элементы со значениями: -1 - после первой 
найденной пятерки; -2 - после второй пятерки и т.д. Обратите внимание, что при вставке новых значений, последние элементы 
массива digs могут теряться. Также следует учитывать, что элемент со значением 5 может отсутствовать в массиве digs (тогда 
ничего вставлять не нужно). Выведите в консоль по порядку значения всех прочитанных + добавленных элементов массива digs в 
одну строчку через пробел.<br>
Sample Input: 1 2 5 5 3 4 5 6<br>
Sample Output:1 2 5 -1 5 -2 3 4 5 -3
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#define TOTAL     10
int main(void)
{
    int    digs[TOTAL] = {0};
    size_t count = 0;
    size_t sz_ar = sizeof(digs) / sizeof(*digs);
    int    new_digs = -1;
    while(count < sz_ar && scanf("%d", &digs[count]) == 1)
        count++;

    for (int i=0; i&lt;count; i++)
    {
        if (digs[i] == 5)
        {
             //если count уже добрали до TOTAL, то уменьшим
            count = count == TOTAL ? count -1 : count;
            for (int k=count; k > i+1; k--)
            {
                digs[k] = digs[k-1];
            }
            digs[i+1] = new_digs;
            new_digs -=1;
            count +=1;
            if (count > TOTAL) count = TOTAL;
            i++;
         }
    }
    for (int i=0; i < count; i++)
    {
        printf("%d ", digs[i]);
    }
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#define TOTAL     10
int main(void)
{
    int    digs[TOTAL] = {0};
    size_t count = 0;
    size_t sz_ar = sizeof(digs) / sizeof(*digs);
    int    new_digs = -1;
    while(count < sz_ar && scanf("%d", &digs[count]) == 1)
        count++;
int num = -1;
  
  for ( int i = 0; i < count; ++i ) {
    if ( digs[ i ] == 5 ) {
	  <b>count = count < TOTAL ? count + 1 : count;</b>
	  for ( int j = count - 1; j > i; j-- )
	    digs[ j ] = digs[ j - 1 ];   // сдвигаем вправо
	  if ( i + 1 < TOTAL )  
	    digs[ i + 1 ] = <b>num--</b>;  // возможен выход за пределы i + 1  
	}                                       
  }
  
  for ( int i = 0; i < count; i++ )
    printf( "%d ", digs[ i ] );
  return 0;
}
</pre></td></tr></table>
<p>
1. <b>count = count < TOTAL ? count + 1 : count;</b> заменяет мои:<br>
count = count == TOTAL ? count -1 : count;<br>
и<br>
count +=1;<br>
if (count > TOTAL) count = TOTAL;
<p>
2. digs[ i + 1 ] = <b>num--</b><br>
Заменяет мои две строки:<br>
digs[i+1] = new_digs;<br>
new_digs -=1;
<pre>


-------------------------------------------------------------------------------------------------------------------------


</pre>
В программе ниже выполняется считывание целочисленных значений из входного потока с их последовательной записью в массив vls 
размерностью 3 x 5 (3 строки и 5 столбцов). Необходимо объявить еще один массив с именем mean типа double и размерностью 3 
элемента. В элементы массива mean следует записать среднее арифметическое каждой строки массива vls. Выведите в консоль 
значения элементов массива mean (по порядку) в одну строчку через пробел с точностью до сотых.<br>
Sample Input: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15<br>
Sample Output:3.00 8.00 13.00
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#define ROWS    3
#define COLS    5

int main(void)
{
    short vls[ROWS][COLS] = {0};
    short *ptr_vls = &vls[0][0];

    short x;
    for(int i = 0;i < ROWS * COLS && scanf("%hd", &x) == 1; ++i)
        *ptr_vls++ = x;
    ptr_vls = &vls[0][0]; //воткнули указатель на 1 элемент vls 
    double mean[3];
    double summa =0.0;
    int i=0;
    for (int count =0; count <15; count++, ptr_vls++)
         {
              summa +=*ptr_vls;
              //printf("summa=%f\n", summa);
              if(count==4 || count==9 || count==14)
              {
                   mean[i] = summa/5.0;
                   //printf("mean[i]=%.2f\n", mean[i]);
                   summa =0.0;
                   i +=1;
              }
         }   
    for (int i=0; i<3; i++)
    {
        printf("%.2f ", mean[i]);
    }
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#define ROWS    3
#define COLS    5

int main(void)
{
    short vls[ROWS][COLS] = {0};
    short *ptr_vls = &vls[0][0];

    short x;
    for(int i = 0; i < ROWS * COLS && scanf("%hd", &x) == 1; ++i)
        *ptr_vls++ = x;
    
    double mean[3] = {0};
    
    for (int i = 0; i < ROWS; i++)
    {
        for (int j = 0; j < COLS; j++)
            mean[i] += (double)vls[i][j];
        mean[i] /= COLS;
    }
    
    for (int i = 0; i < 3; i++)
        printf("%.2f ", mean[i]);

    return 0;
}
</pre></td></tr></table>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу, в которой из консоли считываются целочисленные значения в два массива с именами a и b, каждый 
размерностью 3 x 4. Объявите еще один целочисленный двумерный массив res той же размерности, значения каждого элемента 
которого должны быть равны сумме соответствующих элементов массивов a и b, то есть, по следующей формуле:
<p>
res[i][j] = a[i][j] + b[i][j]<br>
Выведите в консоль полученный массив res в виде таблицы целых чисел из 3 строк и 4 столбцов. В каждой строке числа должны быть 
записаны через пробел. В начале и конце строк пробелов быть не должно.<br>
Sample Input:<br>
1 2 3 4 5 6 7 8 9 10 11 12<br>
2 3 2 0 5 3 5 8 1 24 32 10 
<br>
Sample Output:
<pre>
3 5 5 4
10 9 12 16
10 34 43 22
</pre>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#define ROWS    3
#define COLS    4

int main(void)
{
    int a[ROWS][COLS] = {0};
    int b[ROWS][COLS] = {0};
    int *ptr_a = &a[0][0];
    int *ptr_b = &b[0][0];

    int x;
    for(int i = 0;i < ROWS * COLS && scanf("%d", &x) == 1; ++i)
        *ptr_a++ = x;
    for(int i = 0;i < ROWS * COLS && scanf("%d", &x) == 1; ++i)
        *ptr_b++ = x;

    int res[3][4];
    for (int row=0; row<3; row++) //по строкам
    {
        for (int cols=0; cols<4; cols++) //по столбцам
        {
            res[row][cols] = a[row][cols] + b[row][cols];
            cols == 3 ? printf("%d\n", res[row][cols]) : printf("%d ", res[row][cols]);
        }
    }
    return 0;
}
</pre></td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу в которой на двумерное игровое поле размерностью 10 x 10 случайным образом размещаются 12 "мин" так, чтобы 
они не соприкасались друг с другом (вокруг клетки с миной не должно быть других мин). Игровое поле должно быть представлено 
двумерным массивом с именем pg, типом char и размерностью 10 х 10. Пустые клетки (без мин) должны принимать значение 0, а 
клетки с минами помечаются символом '*'.<br>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

#define SIZE    10
#define MINES   12

int main(void)
{
    char pg[SIZE][SIZE] = {0};
    srand(time(NULL));
    int range = 10, x, y, count=0;
    while(count < MINES)
    {
        x = rand() % range; 
        y = rand() % range;
        if(pg[x][y]==0 && pg[x+1][y]==0 && pg[x-1][y]==0 && pg[x][y+1]==0 && pg[x][y-1]==0)
        {
            //printf("Есть мина с x=%d y=%d\n", x, y);
            pg[x][y] = 1;
            count +=1;
        }
    }
   for (int row = 0; row < SIZE; row++)
    {
        for (int cols = 0; cols < SIZE; cols++)
        {
            cols == SIZE-1 ? printf("%d\n", pg[row][cols]) : printf("%d ", pg[row][cols]);
        }
    }
    return 0;
}
</pre></td></tr></table>
<p>
1. <pre><font color=red>warning: implicit declaration of function ‘time’ [-Wimplicit-function-declaration]
   15 |     srand(time(NULL));</font></pre>
 Устранил когда включил заголовок #include &lt;time.h&gt;
 <p>
 2. Не решил как одновременно выводить * и 0. Если printf("%c,), то * нормально выводится, но вместо 0 видимо пробел.<br>
Если использовать спецификатор для чисел %d, то 0 нормально, а вместо * число 42. В конце концов решил мину обозначать 1 и 
спецификатор %d.
<pre>

======================================================================================================================


</pre>
<a name="stroka"><h3 align=center>Строки</h3>
Продолжите программу, в которой объявляется строка с именем str и максимальной длиной 100 символов (включая символ конца 
строки). Инициализируйте str строковым литералом "Best string!". Затем, удалите из строки все символы 's'.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    char str[100] = "Best string!";
    //printf("%ld\n", sizeof(str)); // = 100
    for (int i=0; i < sizeof(str); i++)
    {
         if(str[i] == 's')
         {
              for (int k = i; k < 12; k++)
              {
                   str[k] = str[k+1];  
              }
         }
    }
    for (int i = 0; i < sizeof(str); i++)
    {
        printf("%c",str[i]); // Bet tring! 
    }
    return 0;
}
</pre></td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу, в которой объявляется строка с именем str и максимальной длиной 50 символов (включая символ конца 
строки). Инициализируйте str строкой: <b>Best   language  "C"</b><br?
(Обратите внимание на несколько подряд идущих пробелов, они должны все присутствовать в строке.) Затем, все группы подряд 
идущих символов пробелов заменить на символ переноса строки. (Каждая группа пробелов заменяется одним символом переноса 
строки.)
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    char str[50] = "Best   language  \"C\"";
    for(int i=0; i<50; i++)
    {
        if(str[i] == ' ' && str[i-1] != ' ' && str[i+1] == ' ')
         {
             //printf("i=%d\n", i);
             str[i] = '\n'; 
             int start = i+1;
             int count_probel = 0;
             //printf("start=%d\n", start);
             //считаем пробелы, которые удалить
             for(int k=start; str[k]==' '; k++)
             {
                count_probel +=1;
             }
             //теперь удаляем лишние пробелы
             for(int k = start; k<50; k++)
             {
                 str[k] = str[k+count_probel];
                 if(str[k+count_probel] == '\0') break;
             }
             
         }
    }
    for(int i=0; i<50; i++)
    {
        printf("%c", str[i]);
        if(str[i] == '\0') break;
    }
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    char str[50] = {"Best   language  \"C\""};
    int i = 0;
    int flag = 0;
    while(str[i] != '\0'){
        str[i] = str[i + flag];
        if(str[i] == ' ' && str[i - 1] != '\n') str[i] = '\n';
        if(str[i] == ' ' && str[i - 1] == '\n') {
            flag += 1;
            continue;
        }
        i++;
    }
    //без блока вывода
    return 0;
}</pre></td></tr></table>
<p>
В другом решении даже если будет 1 пробел, то все равно перенос строки.<br>
<font color=red>Никак не пойму почему в другом решении после перевода строки нет пробела</font>
<pre>


--------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает из входного потока слова в массив:char data[5][10]; Всего пять слов записанных через 
пробел. Чтение должно выполняться с помощью функции scanf() с учетом максимальной длины хранимого слова (10 символов, включая 
символ конца строки). После чтения пяти фрагментов (функция scanf() должна сработать ровно пять раз), вывести прочитанные 
данные в консоль в формате:
<pre>
[строка 1]
[строка 2]
...
[строка 5]

(Прочитанные строки выводятся каждая с новой строки в квадратных скобках.)
Sample Input:Moscow Ufa Vladivostok Samara Tver
Sample Output:
[Moscow]
[Ufa]
[Vladivost]
[ok]
[Samara]
</pre>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
    char data[5][10];
    for(int i=0; i<5; i++)
    {
        scanf("%9s", data[i]);
        //printf("data=%s\n", data[i]);
    }
    for(int i=0; i<5; i++)
        printf("[%s]\n", data[i]);
    return 0;
}
</pre></td></tr></table>
<p>
Под строки объявлен двухмерный массив из 5 строк и длиной максимум 10 символов.<br>
С помощью <b>scanf("%9s", data[i]);</b> я из stdin = "Moscow Ufa Vladivostok Samara Tver" беру целиком слова (до пробела) и 
записываю в одномерный массив с автоматическим добавлением в конце символа '\0'. 
<pre>


--------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу, которая читает из входного потока строку целиком с помощью функции fgets(). На выходе формируется 
корректная Си строка. Удалите из прочитанной строки все латинские символы 'e' и выведите в консоль полученную строку.<br>
Sample Input:c_lokalnye-i-globalnye-peremennye<br>
Sample Output:c_lokalny-i-globalny-prmnny
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
void strip_string(char* str, int max_len)
{
    int count = 0;
    while(*str++ != '\0' && count++ < max_len);

    if(count > 1) {
        str -= 2;
        if(*str == '\n')
            *str = '\0';
    }
}
int main(void)
{
    char str[100];
    fgets(str, sizeof(str), stdin);
    strip_string(str, sizeof(str));

    for(int i=0; i < sizeof(str) && str[i]!='\0'; i++)
    {
        if(str[i] != 'e') printf("%c", str[i]);
    } 
    return 0;
}
</pre></td></tr></table>
<p>
Функция strip_string заменяет в конце строки символ '\n' на '\0'.
<pre>


--------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая в массив строк cities читает из входного потока названия шести городов, записанных в одну строчку через пробел. Максимальная длина названия города не превышает 50 символов. Из всех названий выбрать два наибольших по длине и вывести в консоль в одну строчку через пробел.<br>
Sample Input:Tver Moskwa Ulianovsk Barnaul Ufa Belgorod<br>
Sample Output:Ulianovsk Belgorod
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char cities[6][50];
    int max_length1=0, max_length2=0;
    char most_city1[50], most_city2[50];
    for(int i=0; i<6; i++)
    {
        scanf("%49s", cities[i]);
        if(strlen(cities[i]) > <font color=red>max_length2</font>)
        {
            if(strlen(cities[i]) > max_length1)
            {
                max_length2 = max_length1;
                strncpy(most_city2, most_city1, 49);
                most_city2[49] = 0;
                max_length1 = strlen(cities[i]);
                strncpy(most_city1, cities[i], 49);
                most_city1[49] = 0;
            }
            else
            {
                max_length2 = strlen(cities[i]);
                strncpy(most_city2, cities[i], 49);
                most_city2[49] = 0;
            }
        }
    }
    printf("%s %s", most_city1, most_city2);
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    char cities[6][50] = {}, result[2][50] = {};

    for (int i = 0; i < 6; i++) {
        scanf("%s", cities[i]);
        if (strlen(cities[i]) > strlen(result[0])) {
            strcpy(result[1], result[0]);
            strcpy(result[0], cities[i]);
        } else if (strlen(cities[i]) > strlen(result[1]))
            strcpy(result[1], cities[i]);   
    }

    printf("%s %s\n", result[0], result[1]);
    return 0;
}
</pre></td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу, которая в массив строк ps (двумерный массив 7 x 50) читает из входного потока фамилии семи сотрудников, записанных в одну строчку через пробел. Считать, что максимальная длина фамилии не превышает 50 символов. Сформировать еще одну строку ps_res, в которую через пробел скопировать фамилии сотрудников (в порядке их считывания). В конце последней фамилии пробела быть не должно, сразу стоять символ '\0'. Вывести строку ps_res в консоль.<br>
Sample Input:Иванов Петров Сидоров Балакирев Старостин Никитин Сергеев<br>
Sample Output:Иванов Петров Сидоров Балакирев Старостин Никитин Сергеев
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char ps[7][50], ps_res[360] = "";
    for(int i=0; i < 7; i++)
    {
        scanf("%49s", ps[i]);
        strncat(ps_res, ps[i], (sizeof(ps_res) - strlen(ps_res) - 1));
        if(i !=6) strncat(ps_res, " ", (sizeof(ps_res) - strlen(ps_res) - 1));
    }
    ps_res[strlen(ps_res)] = '\0';
    <font color=red>for (int i=0; i < 350; i++)
    {
        printf("%s", ps_res[i]);
        if(ps_res[i] == '\0') break;
    }</font>
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char ps[7][50] = {0};
    char ps_res[357] = {0};
    for(int i = 0; i < 7; ++i)
    {
        scanf("%s", ps[i]);
        strcat(ps_res, ps[i]);
        strcat(ps_res, (i == 6) ? "\0" : " ");
    }
    puts(ps_res);
    return 0;
}
</pre></td></tr></table>
<p>
1.Как прочитать stdin через while
<p>
2. Пытался после после строки ps[i] поставить 0: <i>ps[length] = '\0';</i>
<pre>
error: assignment to expression with array type
       ps[length] = '\0';</pre>
Решил проблему, вспомнил что двухмерный массив и конкретный элемент его надо обозначать двумя индексами: ps[i][length] = '\0';
<p>
3. Свойства scanf:<br>
   1.Строка читается не целиком, а лишь до пробельного символа. Пробельным символом считается кроме пробела символ табуляции и символ перевода строки. Как только встретится этот символ, компилятор меняет его символом конца строки - '\0'
<p>
4. Как добавить символ пробела к строке.<br>
Если if(i !=6) strncat(ps_res, ' ', (sizeof(ps_res) - strlen(ps_res) - 1)); то<br>
<font color=red>warning: passing argument 2 of ‘strncat’ makes pointer from integer without a cast [-Wint-conversion]
</font><br>
Решил проблему заменой ' ' на " "
<p>
5. На stepik почему-то пожаловался, что ps_res[350]  недостаточно для семи слов по 50 символов<br>
Изменил ps_res[350] на ps_res[360]. В решениях посмотрел, достаточно 357 символов.
<p>
6. Почему-то на сайте выскочила ошибка: EИванов Петров Сидоров Балакирев Старостин Никитин Сергеев<br>
В начале откуда-то взялся Е. Решил проблему заменой char ps_res[360]; на char ps_res[360] = ""; Видимо при первоначальной инициализации ps_res присутствует шум в памяти под ps_res

<pre>


-----------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу, которая в массив строк ps (двумерный массив 7 x 50) читает из входного потока фамилии семи сотрудников, записанных в одну строчку через пробел. Считать, что максимальная длина фамилии не превышает 50 символов. Сформировать еще одну строку ps_sort, в которую через пробел скопировать фамилии сотрудников по возрастанию их длин. В конце последней фамилии пробела быть не должно, сразу стоять символ '\0'. Вывести строку ps_sort в консоль.<br>
Sample Input:Ivanov Petrova Sidorova Balakirev Bach Stras Lomonosova<br>
Sample Output:Bach Stras Ivanov Petrova Sidorova Balakirev Lomonosova
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char ps[7][50], ps_sort[357] = "";
    for(int i=0; i < 7; i++)
    {
        scanf("%49s", ps[i]);
    }
    int pos;
    for(int i = 0; i < 7; i++)
    {
        pos = i;
        for(int j = i+1; j < 7; j++)
        {
            if(strlen(ps[j]) < strlen(ps[pos]))
            {
                pos = j;
            }
        }
        if(pos != i)
        {
            strcpy(ps_sort, ps[i]);
            strcpy(ps[i], ps[pos]);
            strcpy(ps[pos], ps_sort);
            strcpy(ps_sort, "");
        }
    }
    for(int i = 0; i < 7; i++)
    {
        strcat(ps_sort, ps[i]);
        if(i != 6) strcat(ps_sort, " ");
    }
    ps_sort[strlen(ps_sort)] = '\0';
    printf("%s", ps_sort);
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define N 7
#define LENGHT 50
int main(void)
{
    int err;
    char ps[N][LENGHT];

    char ps_sort[(N+1)*LENGHT] = {0};
    char *ptr_res = ps_sort;
   for (int i = 0; i < N; i++) {
        if ((err=scanf("%s ", ps[i])) != 1) {
            printf("Error input! - %d\n", err);
            return 0;
        }
    }
    for(int l=0; l < LENGHT; l++) {
        for (int i = 0; i < N; i++) {
            if (strlen(ps[i]) == l ) {
                strcat(ptr_res, ps[i]);
                strcat(ptr_res, " ");
            }
        }
    }
    ps_sort[strlen(ps_sort)-1] = 0;
    printf("%s\n", ptr_res);
    return 0;
} 
</pre></td></tr></table>
<p>
Почему-то у меня конец строки нужно добавлять в ps_sort[strlen(ps_sort)], у других в ps_sort[strlen(ps_sort)-1]
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. Определите в строке str количество фрагментов 'is' и выведите в консоль полученное целое число.<br>
Sample Input:My sister is a nervous girl, but she is very kind.<br>
Sample Output:3
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    char *ptr_is = strstr(str, "is");
    int count = 0;
    while(ptr_is != NULL)
    {
        if(strstr(ptr_is, "is") == NULL) break;
        ptr_is = strstr(ptr_is, "is") + 2;
        //printf("ptr_is=%s\n", ptr_is);
        count++;
    }
    printf("%d\n", count);

    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    char* ptr = str;
    int cnt = 0;
    while ((ptr = strstr(ptr, "is")) != NULL){
        cnt++;
        ptr++;
    }
    printf("%d", cnt);
    return 0;
}
</pre></td></tr></table>
<p>
1. Почему *ptr_is целого типа, разве это не значение содержимого памяти на которую указывает ptr_is?
<p>
2. while(strstr(*ptr_is, "is") != NULL) Ошибка:<br>
<font color=red>warning: passing argument 1 of ‘strstr’ makes pointer from integer without a cast [-Wint-conversion]</font><br>
Типа первый аргумент указатель, а не char
<p>
3. Если ptr_is = NULL (нет is), то Ошибка сегментирования.<br> 
Ошибка возникает из-за strstr(ptr_is, "is"). Здесь если ptr_is = NULL то все операции с ptr_is вызывают ошибку.
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. Замените в строке str все дефисы (-) фрагментом "-+-". Выведите полученную строку в консоль. В тестах гарантируется, что результирующая строка умещается в массив str.<br>
Sample Input:https://proproprogs.ru/c_base/cpp-znacheniya-parametrov-funkcii-po-umolchaniyu<br>
Sample Output:https://proproprogs.ru/c_base/cpp-+-znacheniya-+-parametrov-+-funkcii-+-po-+-umolchaniyu
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    char *ptr = str;
    while ((ptr = strstr(ptr, "-")) != NULL)
    {
        int length = strlen(str);
        ptr++;
        int ind_ptr = length - strlen(ptr);
        //нужно строку с указателя сдвинуть вправо на 2
        for(int i = (length + 2); i > ind_ptr + 1; i--)
        {
            str[i] = str[i-2];
        }
        *ptr = '+';
        ptr++;
        *ptr = '-';
        ptr++;
    }
    printf("%s\n", str);
    return 0;
}
</pre></td>
<td valign=top>
Другое
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    char *ptr = str;
    
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == '-') {
            for (int j = strlen(str); j > i; j--) {
                str[j+2] = str[j];
            }
            str[i] = '-';
            str[i+1] = '+';
            str[i+2] = '-';
            i = i+2;
        }
    }

    printf("%s", str);
    return 0;
}
</pre></td></tr>
<tr><td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    ptr_n = str;
    while (ptr_n != NULL){
        ptr_n = strstr(ptr_n, "-");
        if(ptr_n != NULL){
            char str_tmp[100] ={0};
            strcpy(str_tmp, ptr_n);
            strcpy(ptr_n,"-+-");
            ptr_n += 2;
            strcpy(ptr_n, str_tmp);
            ptr_n++;
    }
    printf("%s", str);
    return 0;
}
</pre></td></tr></table>
Моё решение:<br>
С помощью while ((ptr = strstr(ptr, "-")) != NULL) находим '-' и указатель PTR указывает на него.
<p>
Далее с помощью:
<pre>
for(int i = (length + 2); i > ind_ptr + 1; i--)
{
    str[i] = str[i-2];// сдвинули с указателя на 2 ячейки вправо
}
</pre>
сдвигаем после найденного символа на две ячейки вправо.
<p>
Заполняем освободившие ячейки + и -.
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. В строке str необходимо заменить все подряд идущие дефисы (например: --, ---, ---- и т.д.) на один дефис (-). Выведите в консоль полученную строку.<br>
Sample Input:cpp--znacheniya----parametrov-funkcii-po----umolchaniyu<br>
Sample Output:cpp-znacheniya-parametrov-funkcii-po-umolchaniyu
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    char *ptr = str;
    for (int i = 0; str[i] != '\0'; i++)
    {
        if(strstr(str, "--"))
        {
            ptr = strstr(str, "--");
            for (int k = (strlen(str) - strlen(ptr)+1); str[k] !='\0'; k++)
            {
                str[k] = str[k+1];
                //printf("%s\n", str);
            }
        }
    }
    printf("%s\n", str);
    return 0;
}
</pre></td>
<td valign=top>
Другое
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    int len = strlen(str);
    int i = 0;
    
    while(str[i]){
        if(str[i] == '-' && str[i+1] == '-'){
            for (int j = i; j < len; j++){
                str[j] = str[j+1];
            }
            len--;
        }
        else
            i++;
    }
    puts(str);

    return 0;
}
</pre></td></tr></table>
<pre>

----------------------------------------------------------------------------------------------------------------------------


</pre>
С каждой новой строки вводятся названия городов. Напишите программу, которая читает эти строки, кроме пустых (пустая строка должна быть проигнорирована). Программа должна завершаться после чтения максимум 10 городов. Максимальная длина названия каждого города не превышает 50 символов. Сформировать строку, в которой названия городов идут по порядку (считывания) через пробел, кроме тех, что содержат фрагмент "на". Вывести сформированную строку в консоль.<br>
Sample Input:
<pre>
Барнаул
Кишинев
Ярославль
Николаев

Уфа
Москва
Санкт-Петербург

Самара
Воронеж


Смоленск
Sample Output:Кишинев Ярославль Николаев Уфа Москва Санкт-Петербург Самара Воронеж Смоленск
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char city[10][50];
    char str_city[500] = "";
    for(int i=0; i < 10; i++)
    {
        scanf("%49s", city[i]);
        if (!strstr(city[i], "на"))
        {
            strcat(str_city, city[i]);
            strcat(str_city, " ");
        }
    }
    str_city[strlen(str_city)-1] = '\0';
    puts(str_city);
    return 0;
}
</pre></td>
<td valign=top>
Другое
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[500] = {0};
    char tmp[51] = {0};
    
    for(int i = 0; i < 10; i++){
        scanf("%s", tmp);
        if (strlen(tmp) && strstr(tmp, "на") == NULL){
            strcat(str, tmp);
            strcat(str, " ");
            
        }
    }
    str[strlen(str)-1] = '\0';
    printf("%s", str);

    return 0;
}
</pre></td></tr></table>
<pre>

----------------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая читает из входного потока время, представленное в виде строки формата: hh:mm:ss
<br>где hh - часы; mm - минуты; ss - секунды. Например:12:06:30
<br>Необходимо преобразовать эту строку и представить время в формате:ss:mm:hh
<br>Полученную строку вывести в консоль.
<br>Sample Input: 15:24:10<br>
Sample Output: 10:24:15
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char time[3][3];
    char str_time[9] = "";
    for(int i=0; i < 3; i++)
    {
        scanf("%3s", time[i]);
        //puts(time[i]);
        strcat(str_time, time[i]);
    }
    str_time[strlen(str_time)] = '\0';
    printf("%c%c:%c%c:%c%c\n", str_time[6], str_time[7], str_time[3], str_time[4], str_time[0], str_time[1]);
    return 0;
}
</pre></td></tr>
<tr><td valign=top>
Другое
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void) {
    int hh, mm, ss;
    scanf("%d%*c%d%*c%d", &hh, &mm, &ss);
    printf("%02d:%02d:%02d", ss, mm, hh);
    return 0;
}
</pre></td></tr></table>
<pre>

----------------------------------------------------------------------------------------------------------------------------


</pre>
Продолжите программу. В переменной str содержится E-mail адрес. Необходимо проверить его корректность. Для этого в str должен присутствовать один символ '@' (не первый), а после него (не сразу) - символ '.' (не последний). Также в самом E-mail адресе допустимы только символы: a-z, A-Z, 0-9, '.', '_', '-'. Если строка str содержит корректный E-mail адрес, то в консоль вывести 1, иначе 0.<br>
Sample Input:sc_lib@list.ru<br>
Sample Output:1
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    int flag = 0;
    char *ptr = str;
    for (int i = 0; str[i] != '\0'; i++)
    {
        if (str[0] =='@') break;
        ptr = strchr(str, '@');
        ptr++;
        if(*ptr == '.') break;
        if (strchr(ptr, '.') == NULL) break;
        if (strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._,-@", str[i]) == NULL) break;
        if (str[strlen(str)-1] == '.') break;
        flag = 1;
    }
    printf("%d\n", flag);
    return 0;
}
</pre></td></tr></table>
<pre>


=============================================================================================================================


</pre>
<a name="sprintf"><h3 align=center>Строковые функции sprintf(), atoi(), atol(), atoll() и atof()</h3>
Напишите программу, которая читает из входного потока три целых числа, записанных в одну строчку через пробел, в переменные h, m, s. Здесь h - часы; m - минуты; s - секунды. На основе этих значений сформировать строку в формате: hh:mm:ss<br>
Если значение переменных h, m, s выходит за допустимый диапазон (h: [0; 23], m: [0; 59], s: [0; 59]), то вместо соответствующего значения прописать два символа дефиса '--'. Выведите сформированную строку в консоль.<br>
Sample Input:12 68 10<br>
Sample Output:12:--:10
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    int h, m, s;
    char str_time[20];
    <font color=red>char str_h[3] = "", str_m[3] = "", str_s[3] = "";</font>
    scanf("%d %d %d", &h, &m, &s);
    
    //преобразуем в строки, чтобы можно было записать в них --
    sprintf(str_h, "%d", h);
    if (h < 0 || h > 23) strcpy(str_h, "--");       //запись --
    if (h >= 0 && h < 10) sprintf(str_h, "0%d", h); //если время < 10
    sprintf(str_m, "%d", m);
    if (m < 0 || m > 59) strcpy(str_m, "--");
    if (m >= 0 && m < 10) sprintf(str_m, "0%d", m);
    sprintf(str_s, "%d", s);
    if (s < 0 || s > 59) strcpy(str_s, "--");
    if (s >= 0 && s < 10) sprintf(str_s, "0%d", s);
    
    sprintf(str_time, "%s:%s:%s", str_h, str_m, str_s);
    puts(str_time);
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
int main(void) 
{
    int h, m, s;
    scanf("%d %d %d", &h, &m, &s);
    char hh[3] = "--", mm[3] = "--", ss[3] = "--";
    if (h >= 0 && h < 24) sprintf(hh, "%02d", h);
    if (m >= 0 && m < 60) sprintf(mm, "%02d", m);
    if (s >= 0 && s < 60) sprintf(ss, "%02d", s);
    printf("%s:%s:%s", hh, mm, ss);  
    return 0;
}
</pre>
<font color=green>По умолчанию сделал символьные массивы равным "--" и если время корректно, то запись в двухзначном формате %02d</font>
</td></tr></table>
<pre>

-------------------------------------------------------------------------------------------------------------------------

</pre>
В переменную str считывается строка в формате: &lt;наименование товара&gt;: &lt;высота&gt; x &lt;ширина&gt; x &lt;длина&gt;.
(Символ x - латинская буква.) Значения высоты, ширины и глубины представлены целыми числами. Необходимо выделить их из строки и сохранить в целочисленные переменные: h (высота), w (ширина), d (длина).<br>
P. S. В консоль ничего выводить не нужно. Строка str меняться не должна.<br>
Sample Input:флэшка: 10 x 50 x 100<br>
Sample Output:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    int h, w, d, var;
    char *ptr = str;
    ptr = strstr(str, ": ");
    ptr +=2;
    h = atoi(ptr);
    ptr = strstr(ptr, "x ");
    ptr +=2;
    w = atoi(ptr);
    ptr = strstr(ptr, "x ");
    ptr +=2;
    d = atoi(ptr);
    printf("%d %d %d\n", h, w, d);
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    int h, w, d;
    char* ptr;
    
    ptr = strchr(str, ':');
    h = atoi(ptr+1);
    ptr = strchr(str, 'x');
    w = atoi(ptr+1);
    ptr = strrchr(str, 'x');
    d = atoi(ptr+1);
    return 0;
}
</pre></td></tr></table>
<p>
<font color=red>Никак не пойму, почему если нужно значение указателя, то ptr, а не *ptr.
<p>
В другом решении почему-то str = ptr</font>
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. В переменную str считывается строка в формате: csv: &lt;число 1&gt;; &lt;число 2&gt;; &lt;число 3&gt;; ...; &lt;число N&gt;<br>
после точки с запятой может быть любое число пробелов от 0 и выше).<br>
Числа представлены вещественными значениями, а их общее количество может быть любым, но не менее 1 и не более 50. Необходимо выделить из строки все числа и сохранить их в массиве csv типа double в порядке записи в строке.
<br>P. S. В консоль ничего выводить не нужно. Строка str меняться не должна.<br>
Sample Input: csv: 0.5; 24.35; -45.36; 100.0;65.3; -44.3<br>
Sample Output:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int main(void)
{
    char str[200] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    double csv[50];
    char *ptr = str;
    ptr = strstr(str, ":");
    printf("%s\n", ptr);
    csv[0] = atof(ptr+1);
    //printf("%f\n", csv[0]);
    for (int i = 1; strstr(ptr, ";") != NULL; i++, ptr++)
    {
        ptr = strstr(ptr, ";");
        csv[i] = atof(ptr+1);
        //printf("%f\n", csv[i]);
    }
    /*printf("\n");
    for (int i = 0; i < 10; i++)
    {
        printf("%f ", csv[i]);
    } */   
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int main(void)
{
    char str[200] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    double csv[50];
    double *ptr_csv = csv;
    char *ptr = str;
    
    while (strpbrk(ptr, ":;") != NULL ) {
            <font color=green>ptr = strpbrk(ptr, ":;");</font>
            *ptr_csv = atof(++ptr);
            ptr_csv++;
    } 
    return 0;
}
</pre></td></tr></table>
<p>
<pre>warning: passing argument 2 of ‘strstr’ makes pointer from integer without a cast [-Wint-conversion]
   24 |     ptr = strstr(str, ':');</pre>
Заменил ptr = strstr(str, ':'); на ptr = strstr(str, ":");
<p>
Почему 0.5 записывается в csv как 0.0000. Заменил csv[0] = ato<b>i</b>(ptr+1); на csv[0] = ato<b>f</b>(ptr+1);
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. В массиве строк str хранится информация о count товарах, каждый представлен в формате:<br>
<наименование товара>: <идентификатор>; <цена>; <вес><br>
Здесь идентификатор - целое число; цена - вещественное число; вес - вещественное число.<br>
Необходимо удалить из массива str все товары с ценой равной 12300. Выведите в консоль в одну строчку через пробел оставшиеся наименования товаров в массиве str в порядке их следования.<br>
Sample Input: 
<pre>
часы: 10; 5430; 0.3
компьютер: 13; 132045; 1.23
монитор: 1; 12300; 0.74
колонки: 2; 3245; 0.3
стол: 105; 3400; 5.7
Sample Output: часы компьютер колонки стол</pre>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define TOTAL   10

int main(void)
{
    char str[TOTAL][50];
    int count = 0;
    while(count < TOTAL && fgets(str[count], sizeof(str)-1, stdin)) {
        char* ptr_n = strrchr(str[count], '\n');
        if(ptr_n != NULL)
            *ptr_n = '\0';
        count++;
    }

    // здесь продолжайте программу
    for (int i = 0; str[i][0] != '\0'; i++)
    {
        if (atoi(strstr(str[i], ";") + 1) == 12300)
        {
            for(int k = i; str[k][0] != '\0'; k++)
            {
                strcpy(str[k], str[k+1]);
                //printf("str[k]=%s\n", str[k]);
            }
        }    
    }
    char *ptr;
    for (int i = 0; str[i][0] != '\0'; i++)
    {
        ptr = str[i];
        //printf("dddddddd%s\n", ptr);
        while(*ptr != ':')
        {
            printf("%c", *ptr);
            ptr++;
        }
        if (str[i+1][0] != '\0') printf(" ");
    }
    return 0;
}
</pre></td></tr></table>
<p>
1. Ошибка сегментирования (стек памяти сброшен на диск)<br>
Убрал эту ошибку, когда у меня после пустой строки (*ptr == '\0') выход из цикла
<p>
После того как на строку с монитором сдвигаю следующие 2 строки, снова ошибка сегментирования. 
Решил проблему, когда убрал указатели.
<p>
После того как for (int i = 0; str[i][0] != '\0'; i++) заменил на for (int i = 0; i < count; i++) снова появилась ошибка сегментирования<br>
Устранил после того как count после удаления строки уменьшаю на 1.
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, которая читает строку, представленную в формате: <имя студента>: <оценка 1>, <оценка 2>, ..., <оценка N><br>
Все оценки представлены целыми числами. Количество оценок может быть разным у разных студентов, но не более 20. 
Необходимо вычислить среднее арифметическое оценок и полученное вещественное число вывести в консоль с точностью до тысячных.<br>
Sample Input: Балакирев: 2, 2, 2, 5, 5, 2, 2, 5<br>
Sample Output: 3.125
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int main(void)
{
    char str[100];
    //1 способ чтения (fgets):
    <font color=red>while(fgets(str, sizeof(str)-1, stdin))</font>
     {
        char* ptr_n = strrchr(str, '\n');
        if(ptr_n != NULL)
            *ptr_n = '\0';
    }
    //puts(str);
    //2 способ чтения (scanf())
    //scanf("%s\n", str);
    //puts(str);
    //Читает до пробела: (Балакирев)
    
    char *ptr = (strstr(str, ":") + 2);
    int count = 0;
    double result = 0;
    while(ptr != NULL)
    {
        result +=atof(<font color=red>ptr</font>); //лучше result +=atof(<b>++ptr</b>)
        count ++;
        //printf("count=%d, ptr=%s\n", count, ptr);
        ptr = strstr(ptr, " ");
        <font color=red>if (ptr != NULL)</font>
        {
            ptr +=1;
        }
    }
    printf("%.3f\n", result/count);
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int main(void)
{
    char str[200] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr = strchr(str, ':');
    int cnt = 0;
    int sum = 0;

    while(ptr != NULL){
        sum += atoi(++ptr);
        cnt++;
        ptr = strchr(ptr, ',');
    }
    
    printf("%.3f", (double)sum / cnt);
    
    return 0;
}
</pre></td></tr></table>
<p>
1. Считываю строку в str[] через fgets<br>
Если через scanf, то только до пробела и считываю только фамилию.
<p>
2. Почему result = 3.00 а не 3.125?<br>
count неправильно считал, не 8, а 9 получался.
<p>
3. Считывать строку можно было попроще, не через while, а сразу fgets, а потом на str[strlen()] = '\0'
<p>
4. Чтобы не было ошибки сегментирования на ptr ++, когда ptr = NULL, у меня проверяется это равенство, в другом решении делается проще: все операции с указателем выполняются между условием цикла (while(ptr != NULL)) и ptr = strchr(ptr, ',');
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, которая читает из входного потока слово (фамилию студента), а затем, целые числа. Все записано в одну строчку через пробел. Максимальное количество чисел не более 20. Затем, представьте эти числа в виде строки формата:<br>
<фамилия>: <оценка 1>, <оценка 2>, ..., <оценка N><br>
Оценки должны следовать в порядке их считывания. Выведите полученную строку в консоль.
<br>Sample Input: Туполев 5 5 5 4 5 5 3 4<br>
Sample Output: Туполев: 5, 5, 5, 4, 5, 5, 3, 4
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
//#define TOTAL 21
int main(void)
{
    char modif_str[100];
    char str[70];
    int count = 0;
    <font color=red>/*for (;count < TOTAL; count++)
    {
        var = scanf("%s", str[count]);
        printf("count=%d, %d\n", count, var);
        printf("str[%d]=%s\n", count, str[count]);
        //printf("firstsimvol=%c\n", str[count][0]);
        //printf("length=%ld\n", strlen(str[count]));
        if (str[count][strlen(str[count]) + 1] == '\n')
              printf("perevod stroki");
        count++;
        
    }*/</font>
    fgets(str, sizeof(str)-1, stdin);
    modif_str[strlen(modif_str) - 1] = '\0';
    //puts(str);
    int i = 0;
    while(str[i] !='\0')
    {
        if (str[i] == ' ' && count == 0)
        {
            strcat(modif_str, ": ");
            count +=1;
        } 
        else
            if (str[i] == ' ' && count == 1)
            {
                 strcat(modif_str, ", ");
            }
        else
        {
            strncat(modif_str, &str[i], 1);
        }
        i++;
    }
    modif_str[strlen(modif_str)] = '\0';
    puts(modif_str);
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
    char str[100] = {0};
    scanf("%99s", str);
    strcat(str, ": ");
    int x = 0;
    char format[100] = {0};

    while (scanf("%d", &x) == 1)
    {
        <b>sprintf(format, "%d, ", x);
        strcat(str, format);</b>
    }
    
    char *ptr = strrchr(str, ','); //посл. запятая
    if(ptr != NULL)
        *ptr = '\0';
    puts(str);
    return 0;
}
</pre>
Пример формирования строки через sprintf(format, "%d, ", x)</td></tr>
<tr><td colspan=2>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main() {
    char name[50];
    int grades[20];
    int i = 0;

    // Чтение и вывод имени
    scanf("%s", name); printf("%s: ", name);

    // Чтение оценок
    while (scanf("%d", &grades[i]) == 1) i++;
    
    // Вывод оценок
    for (int j = 0; j < i; j++) j == i-1? printf("%d", grades[j]): printf("%d, ", grades[j]) ;
    
    return 0;
}
</pre></td></tr></table>
<p>
1. Потратил много времени считывать строку через scanf в двухмерный массив, но без точного указания строк не смог сделать это.
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. В массиве строк str хранится информация о count товарах, каждый представлен в формате:
<br><наименование товара>: <идентификатор>; <цена>; <вес>
<br>Здесь идентификатор - целое число; цена - целое число; вес - вещественное число. 
<br>Необходимо массив указателей p_sort сформировать так, чтобы они ссылались на отсортированные строки по убыванию веса товара. (Сортировку лучше выполнять непосредственно массива p_sort.) Выведите в консоль в одну строчку через пробел наименования товаров, отсортированные по убыванию веса товара.
<pre>
Sample Input:
часы: 10; 5430; 0.3
компьютер: 13; 132045; 1.23
монитор: 1; 12300; 0.74
колонки: 2; 3245; 0.27
стол: 105; 3400; 5.7

Sample Output: стол компьютер монитор часы колонки
</pre>
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt; // atoi atof
#define TOTAL   10
int main(void)
{
    char str[TOTAL][50], *p_sort[TOTAL];
    int count = 0;
    while(count < TOTAL && fgets(str[count], sizeof(str)-1, stdin))
    {
        char* ptr_n = strrchr(str[count], '\n');
        if(ptr_n != NULL)
            *ptr_n = '\0';
        count++;
    }
    // здесь продолжайте программу
    double max_weight;
    int pos;
    char tmp_str[50];
    char *prt;
    for (int i = 0; i < count; i++)
    {
        prt = (strrchr(str[i], ';') + 1);
        max_weight = atof(prt);
        pos = i;
        for (int k = i+1; k < count; k++)
        {
            prt = (strrchr(str[k], ';') + 1);
            //printf("k=%d, prt=%s\n", k, prt);
            if (atof(prt) > max_weight)
            {
                max_weight = atof(prt);
                pos = k;
            }
        }
        if (pos != i)
        {
            strcpy(tmp_str, str[i]);
            strcpy(str[i], str[pos]);
            strcpy(str[pos], tmp_str);
        }
        //printf("1str[%d]=%s\n", i, str[i]);
    }
    //вывод
    for (int i = 0; i < count; i++)
    {
        //printf("otsort str[%d]=%s\n", i, p_sort[i]);
        p_sort[i] = str[i];
        while(*p_sort[i] != ':')
        {
            printf("%c", *p_sort[i]);
            p_sort[i] ++;
        }
        if (i != (count - 1))
        {
            printf(" ");
        }
    }
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#define TOTAL   10
int main(void)
{
    char str[TOTAL][50], *p_sort[TOTAL];
    int count = 0;
    while(count < TOTAL && fgets(str[count], sizeof(str)-1, stdin))
    {
        char* ptr_n = strrchr(str[count], '\n');
        if(ptr_n != NULL)
            *ptr_n = '\0';
        <b>p_sort[count] = &str[count][0];</b> //почему не &str[count]
        count++;
    }
    // здесь продолжайте программу
    for (int i = count - 1; i > 0; i--) {
        for (int j = 0; j < i; j++) {
            double x = atof((strrchr(p_sort[j], ';') + 1));
            double y = atof((strrchr(p_sort[j+1], ';') + 1));
            if (x < y) {
                char* tmp = p_sort[j];
                p_sort[j] = p_sort[j+1];
                p_sort[j+1] = tmp;
            }
        }
    }
    //вывод
    for (int i = 0; i < count; i++) {
        char *good = p_sort[i];
        while (*good != ':')
            printf("%c", *(good++));
        printf(" ");
    }

    return 0;
}
</pre></td></tr></table>
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, которая читает строку из входного потока (строку целиком до символа переноса строки). Необходимо ее закодировать азбукой Морзе, где каждой букве ставится в соответствие код (в виде фрагмента строки) из точки и тире. После каждой закодированной буквы должен идти пробел (символ окончания кода буквы). После последнего кода пробела быть не должно (в конце строки).<br>
Коды азбуки Морзе приведены ниже для латинского алфавита (большие и малые буквы кодируются одинаково), цифр и символа пробела:
Пробел   -...-<br>
Результат кодирования вывести в консоль виде строки.<br>
P. S. Само кодирование лучше реализовать в виде отдельной функции, которой передается формируемая строка, исходная строка и массив азбуки Морзе.
Sample Input: Sergey Balakirev<br>
Sample Output: ... . .-. --. . -.-- -...- -... .- .-.. .- -.- .. .-. . ...-
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void kodirov_morse(char *str, char *str_morse)
{
    char symbols[] = "AJS2BKT3CLU4DMV5ENW6FOX7GPY8HQZ9IR10 ";
    char symbols_small[] = "ajs2bkt3clu4dmv5enw6fox7gpy8hqz9ir10 ";
    char *morse[] = {".-", ".---",	"...", "..---", "-...", "-.-", "-", 
                 "...--", "-.-.", ".-..", "..-", "....-", "-..", "--", 
                 "...-", ".....", ".", "-.", ".--", "-....", "..-.", 
                 "---", "-..-", "--...", "--.", ".--.", "-.--", 
                 "---..", "....", "--.-", "--..", "----.", "..", ".-.", 
                 ".----", "-----", "-...-"};//пример массива из строковых литералов
    for (int i = 0; i < strlen(str); i++)
    {
        for (int ind = 0; ind < strlen(symbols); ind++)
        {
            if (str[i] == symbols[ind] || str[i] == symbols_small[ind])
            {
               strcat(str_morse, morse[ind]);
               if (i < strlen(str)) strcat(str_morse, " ");
               break;
            }
        }
    }
}

int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    char str_morse[500] = {0};
    kodirov_morse(str, str_morse);
    puts(str_morse);
    return 0;
}
</pre></td></tr></table>
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, которая читает закодированную строку с помощью азбуки Морзе. Коды разделены между собой пробелом. Необходимо ее раскодировать, используя азбуку Морзе из предыдущего занятия:
<pre>
A	.-	J	.---	S	...	2	..---
B	-...	K	-.-	T	-	3	...--
C	-.-.	L	.-..	U	..-	4	....-
D	-..	M	--	V	...-	5	.....
E	.	N	-.	W	.--	6	-....
F	..-.	O	---	X	-..-	7	--...
G	--.	P	.--.	Y	-.--	8	---..
H	....	Q	--.-	Z	--..	9	----.
I	..	R	.-.	1	.----	0	-----
Пробел    -...-
</pre>
<b>Добавление символа как элемент массива в строку</b><br>
Полученное сообщение (строку) вывести в консоль.<br>
P. S. Декодирование лучше реализовать в виде отдельной функции, которой передается формируемая строка, исходная строка и массив азбуки Морзе.<br>
Sample Input: -- --- ... -.-. --- .--<br>
Sample Output: MOSCOW
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void morse_to_str(char *str, char *str_morse)
{
    const char symbols[] = "AJS2BKT3CLU4DMV5ENW6FOX7GPY8HQZ9IR10 ";
    char *morse[] = {".-", ".---", "...", "..---", "-...", "-.-", "-", "...--", "-.-.", ".-..", "..-", "....-",
     "-..", "--", "...-", ".....", ".", "-.", ".--", "-....", "..-.", "---", "-..-", "--...", "--.", ".--.", "-.--",
      "---..", "....", "--.-", "--..", "----.", "..", ".-.", ".----", "-----", "-...-"};
    char word_morse<b>[10]</b> = ""; //<font color=brown>без указания длины массива, указатель на этот массив залез на совсем другую переменную</font>
    char *ptr = word_morse;
    for (int i = 0; i <= strlen(str_morse); i++)
    {
        //вытаскиваем слово из  str_morse
        if (str_morse[i] != 32 && str_morse[i] != '\0') //<b>больше нравится str_morse[i] != ' '</b>
        {
            <b>*ptr = str_morse[i]; //пример как добавить символ, как элемент массива в строку. strcat не работает
            ptr++;</b>
        }
        if (str_morse[i] == 32 || str_morse[i] == '\0')
        {
            *ptr = '\0'; //на этой строке почему-то symbols[2] изменяет свое значение на 0,
            // пока не поменял char word_morse[] = "" на char word_morse[10] = ""
            ptr = &word_morse[0];
            for (int j = 0; j < 37; j++)
            {
                if (!strcmp(morse[j], word_morse))
                {
                    *str = symbols[j];
                    str++;
                    if (i != strlen(str_morse)) strcat(str, " ");
                    if (i == strlen(str_morse)) strcat(str, "\0");
                    break;
                }
            }
            word_morse[0] = '\0';
        }
    }
}

int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';
    char res_str[100] = "";
    morse_to_str(res_str, str);
    puts(res_str);
    return 0;
}
</pre></td></tr></table>
<p>
<h4 align=center>Вставка символьного элемента массива в строку</h4>
Почему не могу вставить символ в строку c помощью strcat(str, arr[i])<br>
if (str_morse[i] != 32) strncat(word_morse, str_morse[i], 1);  <font color=red>warning: passing argument 2 of ‘strncat’ makes pointer from integer without a cast</font><br>
или если: strcat(str, symbols[j]); то <font color=red>warning: passing argument 2 of ‘strcat’ makes pointer from integer without a cast</font><br>
<b>Как я понял через strcat можно добавлять символы как " " или "\0" (строки 51 и 52), но как элементы char массива arr[i] нельзя.<br>
Решил через использование указателя и перемещение его к следующей итерации</b>:
<pre>
*str = symbols[j];
str++;
</pre>
<p>
<h4>Обнуление массива</h4>
Как сделать пустым символьный массив. word_morse[] = "",  word_morse[] = {0} не работают. Ожидается выражение в квадратных скобках.<br>
word_morse = ""  - error: assignment to expression with array type.<br>
Если strcpy(word_morse, " "); то warning: ‘__builtin_memcpy’ writing 2 bytes into a region of size 1 overflows the destination [-Wstringop-overflow=<br>
<b>Сделал так: word_morse[0] = '\0'</b>
<p>
<h4 align=center>Сравнение элемента массива с пробелом</h4>
как элемент массива сравнить с пробелом " " (сравнение с кодом 32 не нравится).<br>
Решение: нужно сравнивать с символом ' '
<p>
4. Несколько часов потратил почему symbols[2] менял значение на пустое. Все из-за команды *ptr = '\0', переменные ptr и symbols никак не связаны, но видимо из-за того что <b>не указал размер массива word_morse указатель ptr ложил '\0' на symbols[2]</b>.
<pre>

==========================================================================================================================

</pre>
<a name="funk"><h3 align=center>Функции</h3>
В программе ниже объявите функцию с именем fact, которая вычисляет факториал, переданного ей целого числа, и возвращает вычисленное значение. Напомню, что факториал любого целого положительного числа n вычисляется по формуле: n!=1⋅2⋅...⋅n<br>
Если n = 0, то по правилам математики 0! = 1. Для отрицательных чисел функция fact должна возвращать число -1.
<br>Вызовите в функции main функцию fact для вычисления факториала числа 6 и выведите результат в консоль в виде целого числа.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
int fact(int n)
{
    int result = 1;
    if (n == 0) result = 1;
    else if (n < 0) result = -1;
    else
    {
        for (int i = 1; i <= n; i++)
        {
            result *=i;
            //printf("i=%d result=%d\n", i, result);
        }
    }    
    return result;        
}

int main(void)
{
    // здесь продолжайте функцию main
    printf("%d\n", fact(6));
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
int fact(int in){
    if(in<0) return -1;
    else if( in<=1 ) return 1;
    else return in*fact(in-1);

}
int main(void)
{
    printf("%d",fact(6));
    return 0;
}
</pre></td></tr></table>
<pre>

----------------------------------------------------------------------------------------------------------------------------

</pre>
 программе ниже необходимо реализовать подсчет среднего арифметического читаемых целых чисел из входного потока. Для этого объявите функцию со следующей сигнатурой:

double get_qm(double qm_1, int m, int x);
Функция get_qm должна вычислять очередное значение среднего арифметического для m прочитанных чисел и возвращать вычисленное значение Qm. В записанном цикле while с помощью функции get_qm вычислите среднее арифметическое всех прочитанных целых чисел из входного потока. Выведите результат вычисления в консоль в виде вещественного числа с точностью до тысячных.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
double get_qm(double qm_1, int m, int x)
{
    return (m - 1) * qm_1 / m  + (double)x/m;   
}

int main(void)
{
    int x;
    int m = 1;
    double qm = 1, qm_1;

    while(scanf("%d", &x) == 1) {
        // здесь продолжайте программу
        qm_1 = qm;
        qm = get_qm(qm_1, m, x);
        m ++;
    }
    printf("%.3f\n", qm);
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
double get_qm(double qm_1, int m, int x)
{
    return (double)(m - 1) / m * qm_1 + (double)x / m;
}

int main(void)
{
    int x;
    int m = 1;
    double qm, qm_1;

    while(scanf("%d", &x) == 1) {
        qm = get_qm(<b>qm</b>, m++, x); //при m=1 почему-то нет ошибки
    }
    printf("%.3lf", qm);
    return 0;
}
</pre></td></tr></table>
<pre>

============================================================================================================================

</pre>
<a name="prototip"><h3 align=center>Прототипы функций</h3>
Продолжите программу. Перед функцией main объявите прототип функции с именем get_geom, которая принимает два целочисленных параметра, вычисляет их среднее геометрическое по формуле и возвращает вычисленное значение g. Реализацию функции get_geom пропишите после функции main. В функции main вызовите функцию get_geom для переменных a и b. Вычисленное значение выведите в консоль в виде вещественного числа с точностью до сотых.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

double get_geom(int, int);

int main(void)
{
    int a, b;
    scanf("%d, %d", &a, &b);

    // здесь продолжайте программу
    printf("%.2f\n", get_geom(a, b));
    return 0;
}
double get_geom(int a, int b)
{
    return pow(a*b,0.5);   
}
</pre></td></tr></table>
<pre>

===========================================================================================================================


</pre>
<a name="argument"><h3 align=center>Указатели как параметры. Передача массивов через аргументы функции</h3>
Напишите программу, которая читает из входного потока в массив типа int десять целочисленных значений, записанных в одну строчку через пробел. Объявите функцию с именем sum_ar и следующими параметрами (порядок параметров должен соблюдаться):
<br>целочисленный массив (тип int);<br>
длина массива (число обрабатываемых элементов).<br>
Функция sum_ar должна вычислять сумму элементов переданного массива и возвращать вычисленное значение в виде целого числа.
В функции main вызовите функцию sum_ar для чисел, прочитанных из входного потока. Возвращенное функцией sum_ar значение выведите в консоль в виде целого числа.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
int sum_ar(int arr[], int count)
{
    int summa = 0;
    for (int i = 0; i < count; i++)
    {
        summa +=arr[i];   
    }
    return summa;
}
int main(void)
{
    // здесь продолжайте функцию main
    int <font color=red>digits[]</font> = {0}, count = 0, number;
    for(;scanf("%d", &digits[count]) == 1 && count < 10; count++)
    {
        //printf("digits[%d]=%d\n", count, digits[count]);
    }
    printf("%d\n", sum_ar(digits, count));
    //printf("222");
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
int sum_ar(int * arr, int length)
{
    int res = 0;
    for (int i = 0; i < length; ++i)
        res += arr[i];
    return res;
}

int main(void)
{
    // здесь продолжайте функцию main
    int arr[10], length = 0;
    
    while (scanf("%d", &arr[length]) == 1)
        ++length;

    printf("%d", sum_ar(arr, length));
    return 0;
}
</pre></td></tr></table>
<p>
1. <b>Как прочитать ввод чисел в массив без указателя?</b><br>
Решил так: for(;scanf("%d", &digits[count]) == 1 && count < 10; count++)
<p>
2. Почему строка: printf("%d\n", sum_ar(digits, count)); выполняется (результат = 14), но далее выскакивает это:
<pre>
<font color=red>*** stack smashing detected ***: terminated
Аварийный останов (стек памяти сброшен на диск)</font></pre>
Но решение на сайте у меня принялось.<br>
Посмотрел у других решения, предупреждение не выходит, если указать явно размер массива: вместо int digits[]</font> = {0} так int digits[10];<br>
Почему так, непонятно. Возможно в ubuntu нельзя объявлять массив без указания длины массива.
<pre>

---------------------------------------------------------------------------------------------------------------------------
</pre>
<b>Считывание чисел через scanf в массив<br>
Формирование строки через sprintf</b><br>
<b>Ошибка сегментирования или segmentation fault</b><br>
Напишите программу, которая читает из входного потока в массив несколько вещественных значений (не менее одного и не более 20), записанных в одну строчку через пробел. Объявите функцию с именем to_csv и следующими параметрами (порядок параметров должен соблюдаться):<br>
указатель на массив символов (корректную C-строку);<br>
массив вещественных чисел (тип double);<br>
длина массива (неотрицательное целое число).<br>
Функция to_csv должна из переданного ей массива вещественных чисел сформировать строку в формате:<br>
"csv: <число 1>; <число 2>; ...; <число N>"<br>
Точность вещественных чисел должна быть два знака после запятой (точки), то есть, до сотых. Например: "csv: 0.56; -65.43; 0.10; 11.00"<br>
Полагается, что длины строки в 100 символов достаточно для хранения сформированной строки из чисел.<br>
Функция to_csv должна возвращать количество (целое число) записанных в строку вещественных чисел.<br>
В функции main вызвать функцию to_csv для вещественных чисел, прочитанных из входного потока и вывести в консоль сформированную строку.<br>
Sample Input: 0.01 5.43 0.785 11.9<br>
Sample Output: csv: 0.01; 5.43; 0.79; 11.90
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt; //strcat И strcpy
int to_csv(char str[100], double arr[], int count)
{
    //printf("adres_str = %p\n", str);
    strcpy(str, "csv:"); // после этой команды адрес str не меняется.
    //str = "csv:"; //эта строка вызывает ошибку сегментирования, смотрел через printf("adres_str = %p\n", str);
    // адрес str улетает куда-то далеко.
    //printf("adres_str = %p\n", str); 
    char format[20];
    for (int i = 0; i < count; i++)
    {
        //<b>Формирование строки через sprintf</b>
        <b>i == count -1 ? sprintf(format, " %.2lf", arr[i]) : sprintf(format, " %.2lf;", arr[i]);
        strcat(str, format);</b>
        //strcat(str, arr[i]); //incompatible type for argument 2 of ‘strcat’ почему нельзя добавить double число
    }
    return count;
}
int main(void)
{
    // здесь продолжайте функцию main
    char str[100];
    double digits[10];
    int    count = 0;
    //<b>Считывание чисел через scanf в массив</b>
    <b>for(;scanf("%lf", &digits[count]) == 1 && count < 20; count++) {}</b>//образец считывания чисел в массив
    /*{
        //printf("digits[%d]=%lf\n", count, digits[count]);
    }*/
    to_csv(str, digits, count);
    puts(str);
    return 0;
}
</pre></td></tr></table>
<p>
1. <pre>
warning: passing argument 1 of ‘to_csv’ makes pointer from integer without a cast [-Wint-conversion]
   48 |     printf("%s\n", to_csv(str[100], digits, count));
      |                           ~~~^~~~~
      |                              |
      |                              char
example.c:22:19: note: expected ‘char *’ but argument is of type ‘char’
   22 | char *to_csv(char str[], double arr[], int count)
      |              ~~~~~^~~~~
</pre>
Исчезла, когда заменил printf("%s\n", to_csv(str<font color=red>[100]</font>, digits, count)); на printf("%s\n", to_csv(<b>str</b>, digits, count));<br>
Скорее всего из-за того, что в "char *to_csv(char str[], double arr[], int count)" char str[] - это строка и str[100] - это действительно символ в str c индексом 100.
<p>
2. Далее скрипт откомпилировался, блок считывания чисел работает, но до printf("count = %d, result=%s\n", i, str);  в функции to_csv дело не доходит: Ошибка сегментирования (стек памяти сброшен на диск)<br>
Как в str добавить arr[i] без ошибки сегментирования?<br>
Решил так:<br>
sprintf(format, " %.2lf", arr[i]);<br>
strcat(str, format);<br>
Теперь ошибка сегментирования возникает в строке strcat(str, format);
<br>Ошибка сегментирования исчезла, когда изменил возвращаемое значение функции: вместо строки возвращать count<br>
Так и не разобрался почему у меня возникала такая ошибка, но отслеживать их можно с помощью printf("<b>%p</b>", str);
<pre>
---------------------------------------------------------------------------------------------------------------------------

</pre>
Допишите программу. Объявите функцию с именем get_data_csv со следующими параметрами (порядок параметров должен соблюдаться):<br>
массив вещественных чисел (double);<br>
максимальная длина массива (неотрицательное целое число);<br>
указатель на корректную Си-строку.<br>
Функция get_data_csv должна из переданной ей строки выделять и сохранять в переданный массив вещественные числа, которые записаны в формате: "csv: <число 1>; <число 2>; ...; <число N>"<br>
Например: "csv: 0.56; -65.43; 0.1; 11.0"<br>
Необходимо выделенные числа сохранять в переданном массиве в количестве не превышающем длину массива 20 элементов. Функция get_data_csv должна возвращать количество (целое число) записанных в массив вещественных чисел.<br>
В функции main вызвать функцию get_data_csv для строки str и вывести в консоль выделенные в массив вещественные числа в одну строчку через пробел с точностью до сотых.<br>
Sample Input: csv: 0.56; -65.43; 0.1; 11.0<br>
Sample Output:0.56 -65.43 0.10 11.00
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; //atof

#define LENGTH 20

int get_data_csv(double digits[], int count, char str[])
{
    /*план: 
    1. указатель через поиск переносим на пробел
    2. далее atof от указателя передвинутого на +1
    (чтобы в пункте 1 не застрял на одном и том же 
    пробеле), запись в массив*/
    for (count = 0; strchr(str, ' ') != NULL; count++)
    {
        str = strchr(str, ' ');
        digits[count] = atof(++str);
        //printf("digits[%d]=%lf\n", count, digits[count]);
        
    }
    return count;
}

int main(void)
{
    char str[100] = {0};
    double digits[LENGTH];
    int count = 0;
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте функцию main
    for (int i = 0; i < get_data_csv(digits, count, str); i++)
    {
        printf("%.2lf ", digits[i]);
    }
    return 0;
}

</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_LENGTH 20

int get_data_csv(double *ar, int max_length, char *str)
{
    int length = 0;
    while (((str = strchr(str, ' ')) != NULL) && (length < max_length))
    {
        ar[length] = atof(str);
        length++;
        str++;
    }
    return length;
}

int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    double ar[MAX_LENGTH] = {0};
    int length = get_data_csv(ar, MAX_LENGTH, str);

    for (int i = 0; i < length; i++)
        printf("%.2f ", ar[i]);

    return 0;
}
</pre></td></tr></table>
<p>
1. Параметр функции - указатель на корректную Си-строку просто char str? Нет, так только переменная длиной один символ.
<p>
2. <pre>error: expected ‘;’, ‘,’ or ‘)’ before numeric constant
   16 | #define LENGTH 20</pre>
Скорее всего из-за заголовка функции int get_data_csv(double digits[], int <font color=red>LENGTH</font>, char str[])<br>
После того как привел к виду int get_data_csv(double digits[], int <b>count</b>, char str[]) ошибка исчезла.
<pre>

-------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. Необходимо объявить функцию с именем transpose, которой передается двумерный массив размером SIZE x SIZE из чисел типа short. Функция transpose должна строки заменять на соответствующие столбцы (транспонирование) переданного массива. В функции main вызовите функцию transpose для массива matrix. Выведите полученный транспонированный массив matrix в консоль в виде таблицы целых чисел SIZE x SIZE элементов.<br>
(Обратите внимание, что между числами в строках должен быть один пробел, а в конце строк - ни одного.) 
<br>Sample Input:
<pre>
1 2 3 4
5 6 7 8
9 8 7 6
5 4 3 2
Sample Output:
1 5 9 5
2 6 8 4
3 7 7 3
4 8 6 2</pre>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё, решил сначала с передачей двух аргументов в transpose и решение не принималось без return:
<pre>
#include &lt;stdio.h&gt;

#define SIZE    4

void transpose(short *ptr, short array[SIZE][SIZE])
{
     for (int x = 0; x < SIZE; x++)
     {
         for (int y = 0; y < SIZE; y++)
         {
             *ptr = array[y][x];
             //y == SIZE -1 ? printf("%d\n", *ptr) : printf("%d ", *ptr);
             ptr++;
         }
     }
}

int main(void)
{
    short matrix[SIZE][SIZE] = {0};
    short* ptr = &matrix[0][0];
    //short* ptr = matrix // <font color=red>warning: initialization of ‘short int *’ from incompatible pointer type ‘short int (*)[4]’</font>
    int count = 0;
    while(count < SIZE * SIZE && scanf("%hd", ptr) == 1) {
        ptr++;
        count++;
    }

    // здесь продолжайте программу
    short new_matrix[SIZE][SIZE];
    ptr = &new_matrix[0][0];
    transpose(ptr, matrix);
    for (int x = 0; x < SIZE; x++)
    {
        for (int y = 0; y < SIZE; y++, ptr++)
        {
            y == (SIZE -1) ? printf("%d\n", new_matrix[x][y]) : printf("%d ", new_matrix[x][y]);
        }
    }
    return 0;
}

</pre></td></tr>
<tr><td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;

#define SIZE    4

void transpose(short arr[SIZE][SIZE]);

int main(void)
{
    short matrix[SIZE][SIZE] = {0};
    short* ptr = &matrix[0][0];
    int count = 0;
    while(count < SIZE * SIZE && scanf("%hd", ptr) == 1) {
        ptr++;
        count++;
    }

    // здесь продолжайте программу
    transpose(matrix);
    
    for (int i = 0; i < SIZE; i++){
        for (int j = 0; j < SIZE; j++){
            printf("%d", matrix[i][j]);
            if (j < SIZE -1)
                printf(" ");
        }
        if (i < SIZE -1)
            printf("\n");
    }

    return 0;
}

void transpose(short arr[SIZE][SIZE]){
    short temp;
    
    for (int i = 0; i < SIZE; i++){
        for (int j = i; j < SIZE; j++){
            temp = arr[i][j];
            arr[i][j] = arr[j][i];
            arr[j][i] = temp;
            
        }
    }
}
</pre></td></tr></table>
<p>
1. Хочу, чтобы функция возвращала измененный массив. Какой тип для функции указать в таком случае.<br>
если short* transpose(short array[SIZE][SIZE]) то:
<pre>
warning: returning ‘short int (*)[4]’ from a function with incompatible return type ‘short int *’ [-Wincompatible-pointer-types]
   24 |     return transpose_array;
      |            ^~~~~~~~~~~~~~~
example.c:24:12: warning: function returns address of local variable [-Wreturn-local-addr]
</pre>
<i>Чтобы вернуть новый массив, придется просто внутри функции выделить память под новый массив и вернуть указатель на нее (главное потом не забыть очистить память):</i>
<pre>
int* Func(int* Array, int size)
{
    int *new_array = new int[size];
    for(int i = 0; i < size; i++) {
       new_array[i] = Array[i] + 1;
    }
    return new_array;
}
</pre>
У меня не получилось.
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. Объявите функцию с именем is_win, которой передается двумерный массив типа char размером SIZE x SIZE элементов. Функция is_win должна проверять и возвращать статус переданного игрового поля игры "Крестики-нолики" в виде целого числа:<br>
0 - игра не окончена;<br>
1 - выиграли "крестики";<br>
2 - выиграли "нолики";<br>
3 - ничья.<br>
Каждый элемент переданного двумерного массива хранит либо символ 'x', либо символ 'o', либо целое число 0, если клетка свободна. В функции main вызовите функцию is_win для массива pole. Выведите в консоль вычисленный статус игрового поля в виде целого числа.
<pre>
Sample Input:
1 0 0
0 1 2
2 0 1
Sample Output: 1
</pre>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

#define SIZE    3

int is_win(char arr[SIZE][SIZE])
{
    //перевод в массив чисел
    <font color=red>for (int x = 0; x < SIZE; x++)
    {
        for (int y = 0; y < SIZE; y++)
        {
            arr[x][y] = (arr[x][y] == 'x') ? '1' : (arr[x][y] == 'o' ? '2' : '0');
            //y == (SIZE - 1) ? printf("%c\n", arr[x][y]) : printf("%c ", arr[x][y]);
        }
    }</font>
    //подсчет суммы по строкам
    int summa_krestikov = 0;
    int summa_zero = 0;
    for (int x = 0; x < SIZE; x++)
    {
        summa_krestikov = 0;
        summa_zero = 0;
        for (int y = 0; y < SIZE; y++)
        {
            if (arr[x][y] == '1') summa_krestikov +=1;
            if (arr[x][y] == '2') summa_zero +=2;
        }
        if (summa_krestikov == SIZE * 1) return 1;
        if (summa_zero == SIZE * 2) return 2;
    }
    //подсчет суммы по столбцам
    for (int y = 0; y < SIZE; y++)
    {
        summa_krestikov = 0;
        summa_zero = 0;
        for (int x = 0; x < SIZE; x++)
        {
            if (arr[x][y] == '1') summa_krestikov +=1;
            if (arr[x][y] == '2') summa_zero +=2;
        }
        if (summa_krestikov == SIZE * 1) return 1;
        if (summa_zero == SIZE * 2) return 2;
    }
    //подсчет суммы по 1 диагонали
    summa_krestikov = 0;
    summa_zero = 0;
    for (int x = 0; x < SIZE; x++)
    {
        if (arr[x][x] == '1') summa_krestikov +=1;
        if (arr[x][x] == '2') summa_zero +=2;
    }
    if (summa_krestikov == SIZE * 1) return 1;
    if (summa_zero == SIZE * 2) return 2;
    //подсчет суммы по 2 диагонали
    summa_krestikov = 0;
    summa_zero = 0;
    for (int x = 0; x < SIZE; x++)
    {
        if (arr[x][SIZE -1 - x] == '1') summa_krestikov +=1;
        if (arr[x][SIZE -1 - x] == '2') summa_zero +=2;
    }
    if (summa_krestikov == SIZE * 1) return 1;
    if (summa_zero == SIZE * 2) return 2;
    //ПОИСК нуля
    for (int x = 0; x < SIZE; x++)
    {
        for (int y = 0; y < SIZE; y++)
        {
            if (arr[x][y] == '0') return 0;
        }
    }
    return 3;
}

int main(void)
{
    char pole[SIZE][SIZE] = {0};
    char* ptr_p = &pole[0][0];
    int count = 0;
    while(count < SIZE * SIZE && scanf("%hhd", ptr_p) == 1) {
        *ptr_p = (*ptr_p == 1) ? 'x' : (*ptr_p == 2) ? 'o': '0';
        ptr_p++;
        count++;
    }
    // здесь продолжайте программу
    printf("%d\n", is_win(pole));
    return 0;
}
</pre></td></tr>
<tr><td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;

#define SIZE    3

int is_win(char*);
int main(void)
{
    char pole[SIZE][SIZE] = {0};
    char* ptr_p = &pole[0][0];
    int count = 0;
    while(count < SIZE * SIZE && scanf("%d", ptr_p) == 1) {
        *ptr_p = (*ptr_p == 1) ? 'x' : (*ptr_p == 2) ? 'o': *ptr_p;
        ptr_p++;
        count++;
    }
    
    printf("%d", is_win(&pole[0][0]));

    // здесь продолжайте программу

    return 0;
}

int is_win(char *pole){
    int isEmpty = 0;
    for(int i = 0; i < SIZE; ++i){
        int sumH = 0;
        int sumV = 0;
        int sumD1 = 0;
        int sumD2 = 0;
        
        for(int j = 0; j < SIZE; ++j){
           
            <font color=green>sumH += *(pole + i * SIZE + j);
            sumV += *(pole + j * SIZE + i);
            sumD1 += *(pole + j * SIZE + j);
            sumD2 += *(pole + j * SIZE + SIZE - j - 1);
            if(*(pole + i * SIZE + j) == 0) isEmpty = 1;</font>
   
        }

        if(sumH == 'x' * 3 || sumV == 'x' * 3 || sumD1 == 'x' * 3 || sumD2 == 'x' * 3){
            return 1;
        }
        if(sumH == 'o' * 3 || sumV == 'o' * 3 || sumD1 == 'o' * 3 || sumD2 == 'o' * 3){
            return 2;
        }
    }
    if(isEmpty != 0) return 0;

    return 3;
}
</pre>
Не надо было переводить массив назад в числа, пример операций с символами.</td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------------


</pre>
<b>typedef</b><br>
<b>Чтение потока слов в двухмерный массив через scanf</b><br>
Напишите программу, которая в функции main читает из входного потока слова (разделены пробелом). Максимальное количество слов не более 20, а максимальная длина каждого слова не более 50 символов.
<p>
Объявите функцию со следующей сигнатурой: int is_correct(const char* str);<br>
Функция is_correct должна проверять, что в строке содержится фрагмент "ra" без учета регистра. Если это так, то она возвращает 1, иначе 0. Определите на эту функцию указатель нового типа FUNC_CORRECT (тип данных).
<p>
Объявите еще одну функцию с сигнатурой: int get_correct_words(const char (*words)[50], int count_words, FUNC_CORRECT filter);<br>
Функция get_correct_words должна подсчитывать количество корректных слов (для которых is_correct возвращает 1) в массиве words и возвращать вычисленное значение.
<p>
В функции  main (для прочитанных из входного потока слов) вызовите функцию get_correct_words с фильтром is_correct и выведите в консоль число корректных слов.<br>
Sample Input: Radio Dennis Ritchie Ken Thompson Raichle Sergey<br>
Sample Output: 2
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

/*
//<font color=red>typedef int (*FUNC_CORRECT)(char *);</font> без <b>const</b>,
в строке: if (filter(words[i])) count_correct +=1;
<font color=red>warning: passing argument 1 of ‘filter’ discards ‘const’ qualifier from pointer target type</font>
*/
typedef int (*FUNC_CORRECT)(const char *); //определили псевдоним FUNC_CORRECT на указатель функции

int is_correct(const char* str)
{
    if(strstr(str, "ra") || strstr(str, "Ra") || strstr(str, "rA") || strstr(str, "RA")) return 1;
    return 0;
}

int get_correct_words(const char <font color=grey>(*words)[50]</font>, int count_words, FUNC_CORRECT filter) // <b>что означает (*words)[50]</b>
{
    int count_correct = 0;
    for(int i = 0; i < count_words; i++)
    {
        //printf("1words[%d]=%s\n", i, words[i]);
        if (filter(words[i])) count_correct +=1; //возникала ошибка, если параметр FUNC_CORRECT записать без const
    }
    return count_correct;
}

int main(void)
{
    FUNC_CORRECT filtr = is_correct; //создаем указатель на функцию is_correct
    char words[20][50] = {0};
    int count_words = 0;
    for(; scanf("%s", words[count_words]) == 1 && count_words < 20; count_words++){}
    printf("%d\n", get_correct_words(words, count_words, filtr));
    return 0;
}
</pre></td></tr></table>
<p>
1. Что при объявлении функции в <i>int get_correct_words(<font color=red><b>const char (*words)[50]</b></font>, int count_words, FUNC_CORRECT filter)</i> означает  const char (*words)[50]
<p>
2. get_correct_words(words, count_words, filtr)) И if (filter(words[i])) count_correct +=1; <font color=red>warning: passing argument 1 of ‘filter’ discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]</font>
<pre>

============================================================================================================================

</pre>
<a name="pointer"><h3 align=center>Указатели на функцию</h3>
Запишите объявление указателя с именем ptr_func на функции, имеющих следующую сигнатуру:<br>
double <имя функции>(int, int);<br>
P. S. Указатель ptr_func следует объявлять в глобальной области видимости и без какой-либо инициализации. Кроме объявления указателя в программе больше ничего делать не нужно.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

<b>double (*ptr_func)(int, int);</b>
int main(void)
{
    return 0;
}
</pre></td></tr></table>
Тип указателя и типы параметров равны типам в самой функции. Имя указателя обрамляем скобками и перед именем ставим звездочку *.
<pre>

----------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. Необходимо дописать функцию copy_string, которая копирует строку из src в dst с учетом ее максимального размера. Последним параметром функции copy_string должен быть указатель на функцию с сигнатурой: int <имя функции>(const char);
Эта дополнительная функция должна возвращать 1, если символ char следует копировать в строку dst, и 0 в противном случае. Объявите в любом допустимом месте программы такую функцию, которая запрещает копирование всех латинских символов: a-z и A-Z.
<p>
В функции copy_string реализовать копирование строки из src в dst с проверкой допустимости копирования символов. Если символ копировать запрещено, то он пропускается. Строка dst должна быть корректной Си-строкой (в конце всегда должен быть символ '\0').<br>
Вызовите функцию copy_string для копирования строки str в строку str2 с запретом копирования любых символов латинского алфавита. Выведите полученную строку str2 в консоль.<br>
Sample Input: HelloСергею Балакиреву и всем остальным ученикам!<br>
Sample Output: Сергею Бал
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void copy_string(char* dst, size_t max_len_dst, const char* src, <b>int (*ptr_funk)(const char)</b>) //указатель на функцию
{
    for (int i = 0, k = 0; i < sizeof(src), src[i] != '\0', k < max_len_dst; i++)
    {
        if (ptr_funk(src[i]))
        {
            dst[k++] = src[i];
            //printf("i=%d k=%d dst[k-1]=%d\n", i, k-1, dst[k-1]);
        } 
    }
    dst[strlen(dst)] = '\0';
    //printf("i=%d, k=%d\n", i, k);
    return; 
}

int key_chr(char x)
{
    if (strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", x) ==NULL) return 1;
    return 0;
}

int main(void)
{
    char str[100] = {0}, str2[20];
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    copy_string(str2, 19, str, key_chr);
    puts(str2);
    return 0;
}
</pre></td></tr>
<tr><td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void copy_string(char* dst, size_t max_len_dst, const char* src, int (*foo)(const char))
{
    // здесь продолжайте функцию
    int cnt = 0;
    
    for (int i = 0; src[i] && cnt < max_len_dst-1; i++){
        if (foo(src[i])){
            dst[cnt++] = src[i];
            
        }
    }
    <font color=green>dst[cnt] = '\0';</font>
}

int main(void)
{
    char str[100] = {0}, str2[20];
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    int not_alphas(char c){
        int res = 1;

        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
            res = 0;

        return res;
    }
    
    copy_string(str2, sizeof(str2), str, not_alphas);
    puts(str2);

    return 0;
}
</pre></td></tr></table>
1. printf("i=%d, k=%d, dst[k]=%s\n", i, k-1, dst[k-1]); Почему-то компилятор считает dst[k-1] числом.
<pre>
format ‘%s’ expects argument of type ‘char *’, but argument 4 has type ‘int’ [-Wformat=]
   23 |             printf("i=%d, k=%d, dst[k]=%s\n", i, k-1, dst[k-1]);
      |                                        ~^             ~~~~~~~~
      |                                         |                |
      |                                         char *           int

</pre>
Так и не понял. Поменял спецификатор %s на %c, можно и %d и ошибки больше не было.
<p> 
2. почему строка должна выводить только до Бал? Ведь если у нас ограничение в 20, то должно выводить Балакир? Не понимаю какому условию соответствует вывод "Сергею Бал".
<br>здесь кодировка UTF-8 и русские символы 2 байта занимают
<pre>

----------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. В функции main из стандартного входного потока читаются целые числа. Необходимо все их сохранять в массиве marks (не более 20). То есть, чисел может быть и больше 20, но сохранять только первые 20 в порядке их считывания.<br>
Допишите функцию sum_ar, которая бы вычисляла сумму чисел переданного ей массива ar. Складывать следует только те числа, для которых переданная функция (через указатель) возвращает истину (не нулевое значение). Полученная сумма должна возвращаться функцией sum_ar.<br>
Указатель на функцию должен инициализироваться любой функцией с сигнатурой: int <имя функции>(int);<br>
В функции main вызовите функцию sum_ar для массива marks, складывая только четные числа (проверка на четность выполняется дополнительной, вспомогательной функцией, которая, затем, передается последним аргументом в функцию sum_ar). Выведите в консоль целое значение, которое вернула функция sum_ar.<br>
Sample Input: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24<br>
Sample Output: 110
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
int sum_ar(const int *ar, size_t len_ar, <b>int (*ptr_funk)(int)</b>)
{
    int result = 0;
    for (int i = 0; i < len_ar; i++)
    {
        if (<b>ptr_funk(ar[i])</b>) result +=ar[i];
    }
    return result;
}

int get_chetniy(int num)
{
    return num % 2 == 0 ? 1 : 0;
}

int main(void)
{
    int marks[20] = {0};
    int x, count = 0;
    while(scanf("%d", &x) == 1) {
        if (count <20) marks[count++] = x;
    }
    printf("%d\n", sum_ar(marks, count, get_chetniy));
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
int sum_ar(const int *ar, size_t len_ar, int (*foo)(int))
{
    // здесь продолжайте функцию
    int sum = 0;

    for (int i = 0; i < len_ar; i++)
        if(foo(ar[i]))
            sum += ar[i];

    return sum;
}

int main(void)
{
    int marks[20] = {0};
    int x;
    int i = 0;
    while(scanf("%d", &x) == 1 && i < sizeof(marks) / sizeof(*marks)) {
        // здесь продолжайте программу
        marks[i] = x;
        i++;
    }
    int is_even(int n){
        <b>return n % 2 == 0;</b>
    }
    
    int res = sum_ar(marks, sizeof(marks) / sizeof(*marks), is_even);
    printf("%d", res);

    return 0;
}
</pre></td></tr></table>
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
Необходимо дописать функцию sort_string, которая бы выполняла сортировку символов переданной строки str (только символов строки, а не всех символов массива) по их возрастанию (неубыванию).
<p>
Критерий возрастания (какой символ считать большим, а какой меньшим) задается дополнительной функцией с сигнатурой: int match_ab(const char a, const char b);<br>
Данная функция должна возвращать 1, если a < b, и 0 в противном случае. И, кроме того, все цифровые символы ('0', ..., '9') должны быть "меньше" любых других символов. То есть, при сортировке сначала в строке будут идти цифровые символы (по возрастанию), а затем все остальные (по возрастанию).<br>
Вызовите функцию sort_string для строки str и с функцией сравнения match_ab. Выведите полученную строку str в консоль.
Sample Input: Phone number: 7845037856221<br>
Sample Output: 0122345567788  :Pbeehmnnoru
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt; //strchr

int match_ab(const char a, const char b)
{
    //если a - цифра
    if (a > 47 && a < 58)
    {
        if (b < 47 || b > 58) return 1;
        else if (a < b) return 1;
    }
    else   // a -не цифра
    {
        if (b > 47 && b < 58) return 0;
        else   //обе не цифры
        {
            if (a < b) return 1;
        }
    }
    return 0;
}

void sort_string(char *str, size_t max_len, int (*ptr_kriteriy)(char, char))
{
    // Ищем наименьший символ и меняем местами с str[i]
    int pos;
    char tmp;
    for (int i = 0; str[i] != '\0'; i++)
    {
        pos = i;
        for (int j = i + 1; str[j] != '\0'; j++)
        {
            if (ptr_kriteriy(str[j], str[pos])) pos = j;
        }
        if (pos != i)
        {
            tmp = str[i];
            str[i] = str[pos];
            str[pos] = tmp;
        }
    } 
}

int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    sort_string(str, 100, match_ab);
    puts(str);
    return 0;
}
</pre></td></tr></table>
<p>
<pre>
int match_ab(const char a, const char b)
{
    <b>if (a == ' ') // "костыль" что бы пробел был после цифр ':'
       return a + 25 > b; // понятне a +=25;</b>
    if (b == ' ') // "костыль" что бы пробел был после цифр ':'
       return a > b + 25;    
    return a > b;
}
</pre>
Так в другом решении.
<pre>

============================================================================================================================

</pre>
<a name="massiv_pointer"><h3 align=center>Массив из указателей на функцию</h3>
Необходимо объявить <b>четыре критериальные функции</b> для отбора целочисленных значений при суммировании в функции sum_ar. Все критериальные функции должны иметь сигнатуру: int <имя функции>(int ); и быть следующими:
<ol>
<li> is_odd: возвращает 1 для нечетных значений и 0 для четных;<br>
<li> is_positive: возвращает 1 для неотрицательных значений и 0 для отрицательных;<br>
<li> is_negative: возвращает 1 для отрицательных значений и 0 для неотрицательных;<br>
<li> deflt: возвращает 1 для любых значений.<br>
</ol>
В функции sum_ar реализовать подсчет целых чисел переданного массива ar, для которых критериальная функция (переданная через указатель) возвращает истину (не нулевое значение). Функция sum_ar должна возвращать вычисленную сумму.<br>
В функции main объявить массив указателей с именем funcs на объявленные критериальные функции (в порядке их перечисления в задании). Затем, сформировать массив marks из прочитанных целочисленных значений в количестве не более 20 (необходима проверка на максимальное количество записываемых данных). После этого в операторе switch выполнить подсчет суммы с указанием соответствующей критериальной функции из массива funcs.<br>
Sample Input: 1 5 4 3 5 6 78 89 56  43  456 45 645 45 44 3 1 4<br>
Sample Output: 884
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

//здесь набор критериальных функций с сигнатурами:
int is_odd(int num)
{
    //printf("num=%d, return=%d\n", num, abs(num) % 2 != 0);
    <font color=red>return abs(num) % 2 != 0;</font>
}
int is_positive(int num)
{
    return num >= 0;
}
int is_negative(int num)
{
    return num < 0;
}
int deflt(int num)
{
    return 1;
}

int sum_ar(const int *ar, size_t len_ar, <b>int (*funks)(int)</b>)
{
    int result = 0;
    for(int i = 0; i < len_ar; i++)
    {
        if(funks(ar[i]))
        {
            result +=ar[i];
        }
    }
    return result;
}

int main(void)
{
    // здесь массив указателей funcs на критериальные функции
    <b>int (*funks[]) (int) = {is_odd, is_positive, is_negative, deflt};</b>
    int marks[20] = {0};
    int item = 0;
    scanf("%d", &item); // выбор критерия суммирования
    int x, count = 0;
    while(scanf("%d", &x) == 1) {
        if (count <20) marks[count++] = x;
    }
    int sum = 0; // переменная для хранения суммы
    switch(item) {
        case 1: sum = sum_ar(marks, count, <b>funks[0]</b>);
        break;
        case 2: sum = sum_ar(marks, count, funks[1]);
        break;
        case 3: sum = sum_ar(marks, count, funks[2]);
        break;
        default: sum = sum_ar(marks, count, funks[3]);
    }
    printf("%d", sum);
    return 0;
}
</pre></td></tr></table>
<p>
1. Как объявить функцию с аргументом = массиву из указателей на функции и как вызвать эту функцию<br>
Объявить функцию:<br>
int sum_ar(const int *ar, size_t len_ar, <b>int (*funks)(int)</b>)<br>
не нужны никакие квадратные скобки, как я вначале с ними пытался сделать. Ничем от обычного указателя не отличается.<br>
Вызов функции: sum_ar(marks, count, <b>funks[0]</b>)<br>
здесь передаем в качестве аргумента определенную функцию из массива с помощью индекса.
<p>
2. В моем компиляторе, чтобы выполнить функцию abs, нужно подсоединить файл stlib.h
<p>
3. Непонятно почему для return num % 2 != 0; если num < 0, то return вернёт -1. Нужно было заключить выражение в скобки: return (num % 2 != 0); Без них возвращал результат num % 2. Проверил, да все верно.
<pre>

============================================================================================================================

</pre>
<a name="rekurs"><h3 align=center>Рекурсивные функции</h3>
Необходимо объявить рекурсивную функцию с именем recursive и одним целочисленным параметром, которая бы выводила в консоль в одну строчку через пробел целые числа в диапазоне от MAX_RECURSION до 1 (включительно).
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

#define MAX_RECURSION    4

void recursive(int num)
{
    if (num < MAX_RECURSION) recursive(num+1);
    printf("%d ", num);
}
int main(void)
{
    recursive(1);
    return 0;
}
</pre></td></tr></table>
<pre>

----------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. Необходимо объявить рекурсивную функцию со следующей сигнатурой:<br>
size_t range_to_ar(int* ptr_a, size_t max_len, int from, int to, size_t count);<br>
Эта функция должна последовательно заносить в переданный массив (через указатель ptr_a) целые числа в диапазоне [from; to] (включая границы) с шагом 1, не превышая длину массива max_len. Функция range_to_ar возвращает число count - записанных в массив значений (не более max_len).<br>
В функции main выведите в консоль в одну строчку через пробел первые cnt значений массива ar.<br>
P. S. В теле функции range_to_ar не использовать какие-либо операторы циклов.<br>
Sample Input: 8<br>
Sample Output: 1 2 3 4 5 6 7 8
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#define MAX_LENGTH    20

size_t range_to_ar(int* ptr_a, size_t max_len, int from, int to, size_t count)
{
    if (from <= to && from <= max_len)
    {
        *ptr_a = from;
        count++;
        count = range_to_ar(++ptr_a, max_len, ++from, to, count);
    }
    return count; //в конечном счете вернет, что вернут в последней рекурсии
}

int main(void)
{
    int max_rec;
    int ar[MAX_LENGTH];
    scanf("%d", &max_rec);

    size_t cnt = range_to_ar(ar, MAX_LENGTH, 1, max_rec, 0);
    //printf("count=%ld\n", cnt);
    for (int i = 0; i < cnt; i++)
    {
        printf("%d ", ar[i]);
    }
    return 0;
}
</pre></td></tr>
<tr><td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#define MAX_LENGTH    20
size_t range_to_ar(int* ptr_a, size_t max_len, int from, int to, size_t count);

int main(void)
{
    int max_rec;
    int ar[MAX_LENGTH];
    scanf("%d", &max_rec);

    size_t cnt = range_to_ar(ar, MAX_LENGTH, 1, max_rec, 0);

    for(int i = 0; i < cnt; i++) {
        printf("%d ", ar[i]);
    }

    return 0;
}

size_t range_to_ar(int* ptr_a, size_t max_len, int from, int to, size_t count) {
    if(from > max_len || from > to) return 0;

    ptr_a[count++] = from++;

    return 1 + range_to_ar(ptr_a, max_len, from, to, count);
}
</pre></td></tr></table>
<pre>

----------------------------------------------------------------------------------------------------------------------------

</pre>
Объявите рекурсивную функцию со следующей сигнатурой: int sum_ar(const short* ar, size_t len, size_t indx);<br>
которая вычисляет сумму значений элементов переданного массива ar и возвращает вычисленное значение.<br>
Вспомогательный параметр indx (с начальным значением 0) служит для перебора элементов массива ar при рекурсивном вызове функции sum_ar.<br>
В функции main вызовите функцию sum_ar и выведите в консоль возвращенной ей значение в виде целого числа.<br>
P. S. В теле функции sum_ar не использовать какие-либо операторы циклов.<br>
Sample Input: 6 4 10 -43 24 76 100 -55 2<br>
Sample Output: 124
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#define MAX_LENGTH    20

int sum_ar(const short* ar, size_t len, size_t indx)
{
    if (indx < len) return ar[indx] + sum_ar(ar, len, indx+1);
    return 0;
}

int main(void)
{
    short ar[MAX_LENGTH];
    int count = 0;
    while(count < MAX_LENGTH && scanf("%hd", &ar[count]) != EOF)
        count++;
    printf("%d\n", sum_ar(ar, count, 0));
    return 0;
}
</pre></td></tr></table>
<p>
return равен сумме следующих индексов массива плюс текущее значение.
<pre>

----------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. Необходимо дописать рекурсивную функцию to_flat, которая в одномерный массив v по порядку заносит целые числа из таблицы чисел table. Таблица представляет собой массив указателей на целочисленные массивы.<br>
В конце каждого одномерного массива всегда стоит число 0 - маркер конца данных. Максимальное число записываемых в массив v данных составляет max_len_v (превышать это значение нельзя). На выходе функция to_flat возвращает количество записанных в массив v числовых значений. Например, для следующих данных:
<pre>
short ar_1[] = {1, 2, 3, 0};
short ar_2[] = {4, 5, 6, 7, 8, 0};
short ar_3[] = {-1, -2, 0};
short ar_4[] = {-3, -4, -5, 0};
short * table[] = {ar_1, ar_4, ar_3, ar_2};
</pre>
Функция to_flat в массив v должна занести числовые значения: 1 2 3 -3 -4 -5 -1 -2 4 5 6 7 8<br>
P. S. Рекурсивная функция to_flat ничего в консоль выводить не должна. Также в теле функции to_flat недопустимо использовать какие-либо операторы циклов.
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#define MAX_LENGTH    20

size_t to_flat(short* v, /* массив, в который заносятся значения */
        size_t max_len_v, /* максимальная длина массива v */
        short* table[], /* массив на массив, из которого читаются значения */
        size_t len, /* длина массива table (первая размерность) */
        size_t count_v, /* число записанных в массив v значений (начальное значение 0) */
        size_t indx_t, /* индекс для перебора указателей (первой размерности) массива table (начальное значение 0) */
        size_t indx) /* индекс для перебора элементов массивов (условно, вторая размерность), 
                        на которые ссылается текущий указатель table[indx_t] (начальное значение 0)*/
{
    if (count_v < max_len_v && <font color=red>!(indx_t == len - 1 && table[indx_t][indx] == 0)</font>)//можно было так count_v < max_len_v && indx_t < len
    {
        if (table[indx_t][indx] !=0) // можно было ещё короче if (table[indx_t][indx])
        {
            v[count_v] = table[indx_t][indx];
            count_v +=1;
            indx +=1;
            return to_flat(v, max_len_v, table, len, count_v, indx_t, indx);
        }
        else
        {
            indx_t +=1;
            indx = 0;
            return to_flat(v, max_len_v, table, len, count_v, indx_t, indx);
        }
    } 
    return count_v;
}

int main(void)
{
    short ar_1[] = {-4, 2, 3, 7, 0};
    short ar_2[] = {11, 6, 10, 8, 13, 98, -5, 0};
    short ar_3[] = {-47, 0};
    short ar_4[] = {8, 11, 56, -3, -2, 0};

    short * table[] = {ar_1, ar_4, ar_3, ar_2};

    short flat[MAX_LENGTH];
    size_t cnt = to_flat(flat, MAX_LENGTH, table, sizeof(table) / sizeof(*table), 0, 0, 0);

    for(int i = 0;i < cnt; ++i)
        printf("%d ", flat[i]);
    //printf("\n%ld\n", cnt);
    return 0;
}
</pre></td></tr></table>
<p>
1. Непонятно почему sizeof(*table) = 8
<pre>

=======================================================================================================================

</pre>
<a name="variad"><h3 align=center>Функции с произвольным количеством параметров</h3>
Объявите в программе вариадическую функцию со следующей сигнатурой: double mean(int total, ...);<br>
Функция mean должна вычислять среднее арифметическое переданных ей total целочисленных значений типа int и возвращать вычисленный результат. В функции main вызовите функцию mean для вычисления среднего арифметического чисел с аргументами: 7, 5, -10, 11, 0, 12, 4, 2<br>
Здесь первое значение 7 - это значение переменной total, остальные семь чисел - вариадические для вычисления среднего арифметического. Выведите возвращенное значение функции mean в консоль в виде вещественного числа с точностью до сотых.
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

double mean(int total, ...)
{
     int result = 0;
     va_list arg;            // указатель на параметр
     va_start(arg, total);   // получение адреса первого вариадического параметра 
     for(int i=0; i < total; ++i)
     {
         result += va_arg(arg, int);  // получение значение вариадического параметра
     }
     va_end(arg); // // завершение процедуры перебора вариадических параметров
    return (double)result / total;
}
int main(void)
{
   printf("%.2lf\n", mean(7, 5, -10, 11, 0, 12, 4, 2));
    return 0;
}
</pre></td></tr></table>
<pre>

--------------------------------------------------------------------------------------------------------------------

</pre>
Объявите вариадическую функцию с именем sumf со следующей сигнатурой: double sumf(const char* format, ...);<br>
Данная функция должна вычислять сумму переданных вариадических значений типа double в соответствии с форматной строкой (format). Правило суммирования следующее. Если текущий символ форматной строки равен '+', то соответствующий вариадический параметр участвует в суммировании, иначе - пропускается. Функция sumf должна возвращать вычисленное значение суммы.<br>
P. S. Посмотрите что будет, если функцию sumf вызвать с целыми числами: double res = sumf("++ + +", 1, 2, 3, 4, 5, 6);
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;

double sumf(const char* format, ...)
{
    va_list arg;
    va_start(arg, format);
    double result = 0;
    for (int i = 0; i < strlen(format); i++)
    {
         if (format[i] == '+')
         {
             result +=va_arg(arg, double);
             //printf("i=%d, result=%lf\n", i, result);    
         }
         else va_arg(arg, double);
    }
    va_end(arg);
    return result;
}
int main(void)
{
    double res = sumf("++ + +", 1.0, 2.0, 3.0, 4.0, 5.0, 6.0);
    printf("%.2f ", res);

    return 0;
}
</pre></td></tr></table>
<pre>

--------------------------------------------------------------------------------------------------------------------

</pre>
Объявите вариадическую функцию с именем ar_scan, в которой должны быть определены следующие параметры (порядок важен):<br>
указатель на массив типа double;<br>
число записываемых из массива в переменные значений (тип size_t);<br>
вариадические параметры (тип double *).<br>
Функция ar_scan должна из переданного массива последовательно читать значения указанного числа элементов (второй параметр) и записывать их в переменные, адреса которых хранятся в вариадических параметрах. В функции main уже реализован вызов функции ar_scan.
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
void ar_scan(double arr[], size_t count, ...)
{
    va_list arg;
    va_start (arg, count);
    for (int i = 0; i < count; i++)
    {
       printf("arr[%d]=%lf\n", i, arr[i]);
       <b>*va_arg(arg, double *)</b> = arr[i]; 
    }
    va_end(arg);
}

int main(void)
{
    double weights[40] = {1.25, 4.34, -5.43, 0.01, -0.8};
    double w1, w2, w3;
    ar_scan(weights, 3, <b>&w1, &w2, &w3</b>);

    printf("%.2f %.2f %.2f", w1, w2, w3);

    return 0;
}
</pre></td></tr></table>
<pre>

--------------------------------------------------------------------------------------------------------------------

</pre>
<b>указатель структуры как параметр функции, вариадические функции, копирование массива в другой, typedef</b><br>
 Объявите структуру с полями:
<pre>
fname: строка максимальной длиной 100 символов (фамилия);
old: целое число (тип char); возраст;
stag: целое число (тип char); стаж;
salary; целое число (тип int); зарплата;
efs; вещественное число (тип double); эффективность труда сотрудника
</pre>
Определите для этой структуры тип PERSON. 
<p>
Объявите функцию с именем fill_data, которая ничего не возвращает и первые два параметра (порядок важен) - это указатель на структуру PERSON и форматная строка. Следующие параметры вариадические (то есть, функция принимает произвольное число параметров). Форматная строка определяет данные, которые записываются в указанную структуру PERSON, а также набор и порядок следования вариадических данных. Форматная строка может включать следующие символы:
<pre>
#f - строка с фамилией;
#o - возраст;
#g - стаж;
#s - зарплата;
#e - эффективность сотрудника.
</pre>
Например: "#f #e#s, #o" соответствует вариадическим параметрам с типами данных: char*, double, int, char<br>
То есть, в форматной строке достаточно выделять спецификаторы #<символ> и их порядок, остальные символы форматной строки значения не имеют.
<p>
В функции main вызовите функцию fill_data с передачей в нее всех необходимых аргументов (значения придумайте сами) и следующей форматной строкой: "#o #e #s #f"<br>
В консоль ничего выводить не нужно.
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;

typedef struct{
    char   fname[100];
    char   old, stag;
    int    salary;
    double efs;
} PERSON;

void fill_data(PERSON *var1, char format[], ...)
{
    char *ptr = format;
    va_list arg;            // указатель на параметр
    va_start(arg, format);
    while(ptr != NULL)
    {
        ptr++;
        if (*ptr == 'f') strcpy(var1->fname, va_arg(arg, char*)); //сравнение с символами, заключать их в одинарные кавычки
        if (*ptr == 'o') var1->old = va_arg(arg, int);
        if (*ptr == 'g') var1->stag = va_arg(arg, int);
        if (*ptr == 's') var1->salary = va_arg(arg, int);
        if (*ptr == 'e') var1->efs = va_arg(arg, double);
        //*ptr = strchr(ptr, '#'); warning: assignment to ‘char’ from ‘char *’ makes integer from pointer without a cast 
        ptr = strchr(ptr, '#'); 
        //printf("1last=%s, old=%d, 1stage=%d, 1salary=%d, efs=%f\n", var1->fname, var1->old, var1->salary, var1->efs);
    }
    va_end(arg);
}

int main(void)
{
    PERSON person = {}; 
    fill_data(&person, "#o #e #s #f", 52, 0.9, 50000, "Зубков");
    //printf("last=%s, old=%d, stage=%d, salary=%d, efs=%f\n", person.fname, person.old, person.stag, person.salary, person.efs);
    return 0;
}
</pre></td></tr></table>
<p>
Ошибка сегментирования (стек памяти сброшен на диск)<br>
Цикл while ПОЧЕМУ_ТО НЕ останавливается.<br>
Оказывается если не нашли символ, значение NULL, ложью не считается и цикл продолжает работать.
<p>
2. В учебнике рекомендуют указатель на найденный символ так указывать: *ptr = strchr(ptr, '#');, но у меня вызвало ошибку.
<pre>


============================================================================================================================

</pre>
<h3 align=center>Ключевое слово static</h3>
Допишите программу без использования глобальных переменных, в которой объявляется функция со следующей сигнатурой: int range(int start, int stop, int step);<br>
При первом запуске она должна настраивать счетчик на формирование последовательности целых чисел от start до stop (включительно) с шагом step. Также первый запуск возвращает первое значение последовательности. При повторных вызовах функции range параметры start, stop, step не должны играть никакого значения. Сама же функция range при каждом новом вызове должна возвращать очередные числа последовательности. Например, при start=5, stop 11, step=2, имеем:<br>
5, 7, 9, 11, 5, 7, 9, 11, 5, 7, 9, 11, 5, 7, 9, 11, 5, 7, 9, 11, ...<br>
То есть, при достижении граничного значения stop, происходит возврат на начальное значение start.<br>
Sample Input: -2 100 7<br>
Sample Output: -2 5 12 19 26 33 40 47 54 61 68 75 82 89 96 -2 5 12 19 26
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
int range(int start, int stop, int step)
{
    static int i = 0;
    if ((start + step * i) >  stop) i = 0;
    return (start + step * i++);
}

int main(void)
{
    int start, stop, step;
    scanf("%d %d %d", &start, &stop, &step);

    for(int i = 0;i < 20; ++i)
        printf("%d ", range(start, stop, step));

    return 0;
}
</pre></td></tr></table>
<p>
1. В первый раз при компиляции: error:
<pre>
initializer element is not constant
   13 |     static int number = start - step;
</pre>
Решил назначением свойств static другой переменной, которой не надо в момент компиляции присваивать переменные.
<pre>

==========================================================================================================================


</pre>
<a name="malloc"><h3 align=center>Функции malloc(), free(), calloc(), realloc(), memcpy() и memmove()</h3>
Объявите указатель с именем data типа данных short и выделите из кучи память под четыре элемента типа short. Затем, через указатель data занесите в эту область памяти значения: -4, 3, 0, 100<br>
Указатель data, при этом не должен менять свой адрес (ссылаться по-прежнему на начало выделенной области).<br>
P. S. В консоль ничего выводить не нужно. Не забудьте в конце освободить память.
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    <b>short *data = malloc(sizeof(short)*4);</b>
    data[0] = -4;
    data[1] = 3;
    data[2] = 0;
    data[3] = 100;
    <b>free(data);</b>
    return 0;
}
</pre></td>
<td vlign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    short* data = malloc(sizeof(short)*4);
    *data = -4;
    *(data + 1) = 3;
    *(data + 2) = 0;
    *(data + 3) = 100;
    free(data);
    return 0;
}
</pre></td></tr></table>
<pre>

-----------------------------------------------------------------------------------------------------------------------------

</pre>
Из входного потока прочитайте вещественные значения, записанные в одну строчку через пробел, и сохраните их в массиве digits типа double. Максимальное количество читаемых значений не более 20 (это нужно контролировать, в потоке чисел может быть больше). В целочисленной переменной count должно храниться количество прочитанных чисел.<br>
Выделите дополнительно память, ровно столько, чтобы в нее помещались все прочитанные вещественные числа (тип double). На выделенную область должен ссылаться указатель ptr_d. Скопируйте из массива digits прочитанные числа в выделенную память. Указатель ptr_d при этом не должен менять свой адрес.<br>
P. S. В консоль ничего выводить не нужно. Не забудьте в конце освободить память.<br>
Sample Input: 0.3 -1.2 7.4 3.2 8.3 1.0 5.4
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;  //malloc
#include &lt;string.h&gt; //memcpy

int main(void)
{
    double digits[20];
    int count = 0;
    for (;scanf("%lf", &digits[count]) == 1 && count < 20; count++){}
    /*{
         printf("digits[%d]=%lf\n", count, digits[count]);
    }*/
    printf("count=%d\n", count);
    double *ptr_d = malloc(sizeof(double)*count);
    //ptr_d = realloc(digits, sizeof(double)*count); //realloc(): invalid pointer
    memcpy(ptr_d, digits, sizeof(double)*count);
    free(ptr_d);
    return 0;
}
</pre></td></tr></table>
<p>
1. realloc(): invalid pointer<br>
<b>По-видимому в функции realloc 1 аргумент - память которую ранее выделили, а не просто память под какой-нибудь массив.</b>

<pre>

-----------------------------------------------------------------------------------------------------------------------------

</pre>
Из входного потока прочитайте целочисленные значения, записанные в одну строчку через пробел, и сохраните их в массиве lengths типа int. Максимальное количество читаемых значений не более 20 (это нужно контролировать, в потоке чисел может быть больше). В целочисленной переменной count должно храниться количество прочитанных чисел.<br>
Выделите память для хранения 20 целочисленных значений (тип int) с помощью функции calloc. На выделенную область должен ссылаться указатель ptr_lens. Скопируйте из массива lengths прочитанные числа в выделенную память, используя функцию memcpy (копировать следует не весь массив lengths, а только часть с хранимыми (прочитанными) данными). Указатель ptr_lens при этом не должен менять свой адрес. Выведите в консоль все 20 чисел типа int из области памяти ptr_lens в одну строчку через пробел.<br>
Sample Input: 1 5 4 3 8 10<br>
Sample Output: 1 5 4 3 8 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;  //calloc
#include &lt;string.h&gt; //memcpy

int main(void)
{
    int lengths[20];
    int count = 0;
    for (; scanf("%d", &lengths[count]) == 1 && count < 20; count++)
    {
        printf("lengths[%d]=%d\n", count, lengths[count]);
    }
    int *ptr_lens = calloc(20, sizeof(int));
    //<font color=brown>printf("sizeof(ptr_lens)=%ld\n", sizeof(ptr_lens)); //почему 8 байт, а не 80?</font>
    memcpy(ptr_lens, lengths, count * sizeof(int));
    for(int i = 0; i < 20; i++)
    {
        printf("%d ", *(ptr_lens+i));     
    }
    free(ptr_lens);
    return 0;
}
</pre></td></tr></table>
<p>
1. Почему размер памяти под ptr_lens = 8 байт, а не 80? printf("sizeof(ptr_lens)=%ld\n", sizeof(ptr_lens));<br>
<b>sizeof(ptr_lens) сообщает только сколько памяти выделено под переменную *ptr_lens, сколько выделено памяти он не скажет.</b>

<pre>

-----------------------------------------------------------------------------------------------------------------------------

</pre>
Продолжите программу. Необходимо объявить функцию со следующей сигнатурой: void* expand_array(short* ptr, size_t* len, short fill);<br>Здесь *len - длина массива (число его элементов). Данная функция должна удваивать размер области памяти, выделенной под указатель ptr, в новую область копировать прежние данные, а остальные заполнять значениями fill. Прежняя область должна освобождаться (если была выделена новая). Значение размера *len нужно также увеличить в два раза. В конце функция expand_array должна вернуть адрес удвоенной области памяти.
<p>
В функции main вызовите функцию expand_array для удвоения памяти, на которую ведет указатель ptr_d, и значением fill = -1. В результате указатель ptr_d должен ссылаться на удвоенную область памяти. Затем, через указатель ptr_d выведите в консоль в одну строчку через пробел все целые числа типа short, хранящиеся в удвоенной области памяти.<br>
Sample Input: 6 3 -2 4 10 100 35 3545<br>
Sample Output: 6 3 -2 4 10 100 35 3545 0 0 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1
<p>
<table border=1 style="border-collapse:collapse;"   cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;  //calloc

#define TOTAL   10

void* expand_array(short* ptr, size_t* len, short fill)
{
    short *arr = realloc(ptr, *len*2*sizeof(*ptr));
    *len *=2;
    for (int i = *len/2; i < *len; i++)
    {
        arr[i] = fill;
    }
    return arr;
}

int main(void)
{
   short * ptr_d = calloc(TOTAL,  sizeof(short));
   size_t len = TOTAL;
   if(ptr_d == NULL)
        return 0;

    int count = 0;
    while(count < TOTAL && scanf("%hd", &ptr_d[count]) == 1)
        count++;
    ptr_d = expand_array(ptr_d, &len, -1);
    //expand_array(ptr_d, &len, -1);
    for (int i = 0; i < len; i++)
    {
        printf("%d ", ptr_d[i]);
    }
    free(ptr_d);
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#define TOTAL   10

void* expand_array(short* ptr, size_t* len, short fill)
{
    short *ar = realloc(ptr, *len * 2 * sizeof(short));
    if(ar == NULL)
        return ptr;

    for(int i = *len; i < *len * 2; ++i)
        ar[i] = fill;

    (*len) *= 2;
    ptr = ar;
    return ptr;
}

int main(void)
{
    short *ptr_d = calloc(TOTAL, sizeof(short));

    size_t len = TOTAL;
    if(ptr_d == NULL)
        return 0;

    int count = 0;
    while(count < TOTAL && scanf("%hd", &ptr_d[count]) == 1)
        count++;

    ptr_d = expand_array(ptr_d, &len, -1);
    for(int i = 0; i < len; ++i)
        printf("%d ", ptr_d[i]);

    free(ptr_d);
    return 0;
}
</pre></td></tr></table>
<p>
1. Попытки передать аргументом len*sizeof(short):<br>
ptr_d = expand_array(ptr_d, <font color=red>len*sizeof(short)</font>, -1);<br>
note: expected ‘size_t *’ {aka ‘long unsigned int *’} but argument is of type ‘long unsigned int’
<p>
если: ptr_d = expand_array(ptr_d, <font color=red>&(len*sizeof(short))</font>, -1); error: lvalue required as unary ‘&’ operand
   33 |     ptr_d = expand_array(ptr_d, &(len*sizeof(short)), -1);
<p>
если: ptr_d = expand_array(ptr_d, <font color=red>&len*sizeof(short)</font>, -1);
<pre>
error: invalid operands to binary * (have ‘size_t *’ {aka ‘long unsigned int *’} and ‘long unsigned int’)
   33 |     ptr_d = expand_array(ptr_d, &len*sizeof(short), -1);</pre> 
<p>
ptr_d = expand_array(ptr_d, <font color=red>*len*sizeof(short)</font>, -1);<br>
error: invalid type argument of unary ‘*’ (have ‘size_t’ {aka ‘long unsigned int’})
<p>
В конце концов плюнул на передачу нужного аргумента, преобразовывать к нужной формуле стал в теле вызывающей функции.
<pre>

-----------------------------------------------------------------------------------------------------------------------------

</pre>
Объявите функцию со следующей сигнатурой: char * merge_string(const char* str1, const char* str2);<br>
Данная функция должна выделить память под новую строку так, чтобы в нее помещались все символы первой (str1) и второй (str2) строк. Затем, в новую строку скопировать сначала содержимое первой строки (только символы строки), а следом за ней содержимое второй строки. В конце не забудьте добавить символ '\0', чтобы сформировать корректную Си-строку. После объединения функция merge_string должна вернуть адрес сформированной строки.
<p>
В функции main вызовите функцию merge_string для объединения строк str_1 и str_2 (именно в таком порядке). Выведите в консоль полученную строку. Не забудьте в конце программы освободить выделенную память.
<pre>
Sample Input:
First,
Second
Sample Output: First,Second</pre>
<p>
<table border=1 style="border-collapse:collapse;"   cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;


void get_ln(char* buffer, size_t max_len)
{
    fgets(buffer, max_len-1, stdin);
    char* ptr_n = strrchr(buffer, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';
}

char * merge_string(const char* str1, const char* str2)
{
    char *summ_stroka = malloc(strlen(str1) + strlen(str2) + 1);
    memcpy(summ_stroka, str1, strlen(str1));
    strncat(summ_stroka, str2, strlen(str2));
    strcat(summ_stroka, "\0");
    return summ_stroka;
}

int main(void)
{
    char str_1[200] = {0};
    char str_2[200] = {0};

    get_ln(str_1, sizeof(str_1));
    get_ln(str_2, sizeof(str_2));
    char *tmp = merge_string(str_1, str_2);
    puts(tmp);
    free(tmp);
    return 0;
}
</pre></td>
<td valign=top>
Другое:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//rename function because name conflict
void get_line(char* buffer, size_t max_len)
{
    fgets(buffer, max_len-1, stdin);
    char* ptr_n = strrchr(buffer, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';
}
char * merge_string(const char* str1, const char* str2)
{
    size_t len_str1 = strlen(str1);
    size_t len_str2 = strlen(str2);
    char *new_str = calloc(len_str1 + len_str2 + 1 , 1);
    if(!new_str) return NULL;
    strcpy(new_str, str1);
    strcat(new_str, str2);
    return new_str;
}
int main(void)
{
    char str_1[200] = {0};
    char str_2[200] = {0}, *m_str;

    get_line(str_1, sizeof(str_1));
    get_line(str_2, sizeof(str_2));
    
    m_str = merge_string(str_1, str_2);
    if(!m_str) return 1;
    puts(m_str);
    free(m_str);
    return 0;
}
</pre></td></tr></table>
<pre>

==============================================================================================================================

</pre>
<a name="enum"><h3 align=center>Перечисления enum</h3>
Напишите программу, в которой объявляется перечисление с идентификатором menu_item и константами: item_exit = 1, item_c = 2, item_python = 3, item_java = 4<br>
В функции main прочитайте из входного потока целочисленное значение и сравните его с одной из констант перечисления. Сравнение следует выполнить с помощью оператора switch. При совпадениях в консоль выведите следующие строки (без кавычек):
<pre>
item_exit: "Выход";
item_c: "Язык Си";
item_python: "Язык Python";
item_java: "Язык Java".
</pre>
Если ни одна из констант не была выбрана, то вывести строку: "Не верный пункт меню"
<pre>
Sample Input: 2
Sample Output: Язык Си</pre>
<p>
<table border=1 style="border-collapse:collapse;"   cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

enum menu_item {item_exit = 1, item_c = 2, item_python = 3, item_java = 4};

int main(void)
{
    //enum menu_item {item_exit = 1, item_c = 2, item_python = 3, item_java = 4};
    int number;
    scanf("%d", &number);
    switch(number) {
    case item_exit :
        puts("Выход");
        break;
    case item_c :
        puts("Язык Си");
        break;
    case item_python :
        puts("Язык Python");
        break;
    case item_java :
        puts("Язык Java");
        break;
    default : 
        puts("Не верный пункт меню");
    }
    return 0;
}
</pre></td></tr></table>
<p>
На сайте не принимали решение пока строку enum menu_item {item_exit = 1, item_c = 2, item_python = 3, item_java = 4}; не перетащил в блок вне функции.<br>
В https://stackoverflow.com/questions/49574063/why-is-enum-data-type-always-declared-out-of-main-in-c пишут, что обычно помещают в блок вне функций по причине, что могут использоваться в нескольких функциях.
<pre>


-------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Перечисление enum в качестве параметра функции</b><br>
Напишите программу, в которой объявляется перечисление с идентификатором calc_types и константами: _perimetr=1, _square=2<br>
Объявите функцию с именем calc_rect, которая имеет следующие параметры (порядок важен):<pre>
ширина прямоугольника width (тип double);
высота прямоугольника height (тип double);
тип вычислений type (тип calc_types).
</pre>
Функция должна вычислять либо площадь прямоугольника (если types равен _square), либо его периметр (если types равен _perimetr) и возвращать вычисленное значение (тип double). 
<p>
В функции main прочитайте из входного потока одно целое число (для type) и два вещественных числа (width и height), записанных в одну строчку через пробел. Вызовите функцию calc_rect с передачей ей прочитанных значений в качестве аргументов. Выведите в консоль вычисленное значение с точностью до десятых.
<pre>
Sample Input: 1 3.5 7.8
Sample Output: 22.6
</pre>
<p>
<table border=1 style="border-collapse:collapse;"   cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

enum calc_types {_perimetr=1, _square=2};

double calc_rect(double width, double height, <b>enum</b> calc_types type)
{
    if (type == _perimetr)
    {
        //printf("perimetr=%.1f\n", 2 * (width + height));
        return 2 * (width + height);
    }
    if (type == _square)
    {
        //printf("S=%.1f\n", width * height);
        return width * height;
    } 
}

int main(void)
{
    int type;
    double height, width;
    scanf("%d %lf %lf", &type, &width, &height);
    printf("%.1f\n", calc_rect(width, height, type));
    return 0;
}
</pre></td></tr></table>
<p>
double calc_rect(double width, double height, calc_types type) error: unknown type name ‘calc_types’<br>
Решил заменой на double calc_rect(double width, double height, enum calc_types type)
<pre>


-------------------------------------------------------------------------------------------------------------------------

</pre>
<a name="typedef"><h3 align=center>Инструкция typedef</h3>
Напишите программу, в которой объявляется перечисление без идентификатора и константами: _do=1, _re=2, _mi=3, _fa=4, _sol=5, _la=6, _si=7<br>
Определите тип этого перечисления как NOTES. Объявите функцию с именем get_major, которая имеет один параметр с типом NOTES. Функция должна возвращать 1, если были переданы значения констант: _do, или _mi, или _sol. В противном случае функция get_major возвращает 0.
<p>
В функции main прочитайте из входного потока пять целых чисел в диапазоне [1; 7], записанных в одну строчку через пробел. Выведите в консоль (в одну строчку через пробел) только те числа, для которых функция get_major вернула истинное значение (единицу).<br>
Sample Input: 1 2 3 2 5<br>
Sample Output: 1 3 5
<p>
<table border=1 style="border-collapse:collapse;"   cellpadding=10><tr><td valign=top>
Моё:
<pre>
#include &lt;stdio.h&gt;

typedef enum {_do=1, _re=2, _mi=3, _fa=4, _sol=5, _la=6, _si=7} NOTES;

int get_major(NOTES number)
{
    if (number == _do || number == _mi || number == _sol) return 1; //короче так: <font color=green>return n == _do || n == _mi || n == _sol;</font>
    return 0;   
}

int main(void)
{
    int arr[5] = {0};
    for (int i = 0; i < 5 && scanf("%d ", &arr[i]) == 1; i++)
    {
        //NOTES numb = arr[i];
        if (get_major(arr[i])) printf("%d ", arr[i]); 
    }
    return 0;
}
</pre></td></tr></table>
<pre>
error: expected expression before ‘NOTES’
   35 |         if (get_major(<font color=red>NOTES</font> arr[i])) printf("%d ", arr[i]);</pre>
Решил заменой на: 
<pre>
NOTES numb = arr[i];
        if (get_major(numb)) printf("%d ", numb);
а еще лучше на: if (get_major(arr[i])) printf("%d ", arr[i])
</pre>
<b>При вызове функции перед аргументами не надо ставить их типы.</b>
<pre>


==========================================================================================================================

</pre>

</div>
<br><br><br><br></body></html>
