<html><head></head><body>
<title>Создание виртуального робота</title>
<h2 align=center>Создание виртуального робота или написание urdf-файла</h2>
Ссылки: <a href="https://habr.com/ru/articles/467241/">Робот-тележка на ROS. Часть 4. Создаем симуляцию робота, используя редакторы rviz и gazebo</a><br>
<a href="https://studylib.ru/doc/168370/surcukov-m.m.-vvodnoe-rukovodstvo-po-rabote-s-gazebo---m">Сурцуков М.М. Вводное руководство по работе с Gazebo , М</a><br>
<a href="http://sdformat.org/tutorials?cat=specification&">SDFormat Specification</a><br>
<a href="https://gazebosim.org/docs/citadel/sdf_worlds/">SDF worlds</a><br>
<a href="https://wiki.ros.org/urdf/Tutorials">urdfTutorials</a><br>
<a href="https://github.com/AntonSHBK/mobile_robot_base_ros1/blob/main/docs/Ru.md">Простая имитационная модель мобильного робота в ROS и Gazebo</a>
<p>
Cуществует два стандарта описания роботов: .sdf и .urdf; первый является более новым и более удобным для использования, поэтому большинство объектов на данный момент существует именно в формате .sdf.
<p>
В <a href="https://studylib.ru/doc/168370/surcukov-m.m.-vvodnoe-rukovodstvo-po-rabote-s-gazebo---m">Сурцуков М.М. Вводное руководство по работе с Gazebo , М</a> робот описывается с помощью sdf-файла, как написано близкого родственника urdf-формату.<br>
sdf-файлы пишутся на языке xml (с помощью тегов).
<p>
Описание тегов sdf-формата на официальной странице <a href="http://sdformat.org/spec">SDFormat</a>.
<p>
Тэг link определяет базовый структурный элемент, их может быть несколько в одной модели.<br>
Внутри тэга link тэги:
<ul>
<li> pose в формате xyz rpy для определения позиции относительно начала координат модели, этот тэг используется очень часто и определяет позицию относительно родительского тэга.
<li> <b>collision</b><br>
Может быть много внутри одного линка. Используется  для просчета  столкновений,  в  нем  можно  использовать  как  стандартные примитивы,  так  и  импортировать  модель  форматов  .daeили  .stl.  Здесь  же описываются свойства поверхности вроде трения. Добавив сюда pose можно сдвинуть мэш относительно родительского линка.
<li> <b>visual</b><br>
(их так же может быть много) добавляется для рендеринга, здесь также можно  использовать  как  стандартные  примитивы,  так  и  импортировать модель  форматов  .daeили  .stl.  Здесь  же  добавляются  текстуры. Добавив сюда pos eможно сдвинуть мэш относительно родительского линка
<li> <b>inertial</b><br>
(он  в  линке  один)  описывает  физические  инерциальные  свойства линка: его массу, тензор инерции и т.д. Добавив сюда pose можно сдвинуть координаты центра масс относительно родительского линка.
</ul>
Тэги link, collision, visual обязательно  должны  быть  снабжены  уникальными именами.


<h3>Утилита xacro</h3>
Ссылки: <a href="http://www.ros.org/wiki/xacro">xacro</a><br>
<a href="https://studylib.ru/doc/168370/surcukov-m.m.-vvodnoe-rukovodstvo-po-rabote-s-gazebo---m">Сурцуков М.М. Вводное руководство по работе с Gazebo , М</a>
<p>
Название xacro происходит  от XmlmACROs.  Это  простая  утилита, однако,она существенно помогает в создании сложных xmlфайлов в том числе sdfи urdf. Xacro позволяет импортировать один sdfфайл в другой, определять переменные, создавать макросы, производить не сложные арифметические вычисления и т.д.

<h3><a href="https://github.com/AntonSHBK/mobile_robot_base_ros1/blob/main/docs/Ru.md">Простая имитационная модель мобильного робота в ROS и Gazebo</a></h3>
Ссылки: <a href="https://wiki.ros.org/urdf/Tutorials">urdfTutorials</a><br>
<a href="https://wiki.ros.org/urdf/Examples">Примеры urdf-файлов</a>
<p>
URDF (Unified Robot Description Format) — это XML-формат, используемый для описания всех аспектов робототехнических систем в ROS. Он описывает физические свойства модели, включая размеры, форму, материалы, а также динамические и кинематические аспекты. URDF обычно используется для статических и неизменяемых описаний.
<p>
<b>XACRO</b> - язык, облегчающий разработку urdf-файлов.<br>
Ссылки: <a href="http://wiki.ros.org/xacro#Tutorials">ros_xacro</a>
<p>
XACRO является расширением URDF и предоставляет возможность создавать более чистые и модульные описания, используя макросы XML для упрощения и повторного использования кода. XACRO улучшает управляемость и поддержку сложных файлов URDF, что делает его идеальным для больших робототехнических систем.
<p>
<b>SDF</b> (Simulation Description Format) — это формат, разработанный специально для описания объектов и сред, используемых в симуляционных программах типа Gazebo. В отличие от URDF, SDF поддерживает описание не только роботов, но и целых сред, динамических свойств объектов, освещения, физики и других аспектов, что делает его особенно подходящим для комплексных симуляций.<br>
Ссылки: <a href="http://sdformat.org/">SDF на сайте Gazebo</a><br>
<a href="https://github.com/osrf/gazebo_models">Примеры моделей SDF</a>
<p>
<b>Инструменты:</b><br>
Инструмент командной строки check_urdf пытается проанализировать файл как описание URDF и либо выводит описание результирующей кинематической цепи, либо сообщение об ошибке.
<p>
Например, чтобы запустить этот инструмент в pr2 urdf, сначала создайте файл urdf, выполнив:<br>
<b>rosrun xacro xacro.py `rospack find pr2_description`/robots/pr2.urdf.xacro -o /tmp/pr2.urdf</b>
<p>
Затем запустите проверку, выполнив команду:<br>
<b>rosrun urdfdom check_urdf /tmp/pr2.urdf</b>
<p>
Visual Studio Code имеет расширение ROS, которое поддерживает визуализацию URDF.<br>
Чтобы получить диаграмму graphviz вашего urdf-файла, выполните следующие действия:<br>
<b>urdf_to_graphiz pr2.urdf</b>
<p>
<b>Создание urdf-файла</b><br>
RDF - это XML, который является текстовым форматом. Таким образом, вы можете создавать файлы в любом текстовом редакторе. Рекомендуется использовать IDE с хорошей поддержкой XML.
<p>
Если уже существует CAD-модель робота, есть несколько инструментов, которые можно использовать для преобразования CAD-модели в URDF. 


<h2>Перевод официальной документации</h2>
<h3 align=center><a href="https://wiki.ros.org/urdf/Tutorials/Building%20a%20Visual%20Robot%20Model%20with%20URDF%20from%20Scratch">Building a Visual Robot Model with URDF from Scratch</a></h3>
В этом уроке мы создадим визуальную модель робота, которая отдаленно напоминает R2D2. В следующих уроках вы узнаете, как сформулировать модель, добавить некоторые физические свойства, сгенерировать более точный код с помощью xacro и заставить его двигаться в Gazebo. Но сейчас мы сосредоточимся на корректировке визуальной геометрии.
<p>
Прежде чем продолжить, убедитесь, что у вас установлен пакет joint_state_publisher. Если вы установили urdf_tutorial с помощью apt-get, это уже должно быть сделано. Если нет, пожалуйста, обновите свою установку, чтобы включить этот пакет (используйте rosdep для проверки).
<p>
<b>docker run --rm -it rosgazebo1 /bin/bash</b><br>
<b>roscd joint_state_publisher</b><br>
<img src="./images/urdf2.png">
<p>
Все модели роботов, упомянутые в этом руководстве (и исходные файлы), можно найти в пакете urdf_tutorial.
<p>
Сначала мы рассмотрим одну простую фигуру в файле 01-myfirst.urdf. Вот, пожалуй, самое простое, что вы можете сделать в формате urdf.:<br>
<img src="./images/urdf.png">
<p>
Если перевести XML на английский, то это робот с именем myfirst, который содержит только одну link (также известную как part), визуальный компонент которой представляет собой цилиндр длиной 0,6 метра и радиусом 0,2 метра. Может показаться, что в этом простом примере типа “hello world” слишком много вложенных тегов, но, поверьте мне, это будет сложнее.
<p>
Чтобы изучить модель, запустите файл:
<p>
<b>passwd</b><br>
<b>/etc/init.d/ssh start</b>
<p>
В другом терминале:<br>
<b>ssh -X root@172.17.0.2</b><br>
<b>roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf</b><br>
<img src="./images/urdf3.png">
<p>
Создаю папку для проектов (рабочую область):<br>
<b>mkdir -p ~/catkin_ws/src</b><br>
<b>cd ~/catkin_ws/</b><br>
<b>catkin_make</b><br>
<b>source devel/setup.bash</b><br>
<b>echo "source ~/catkin_ws/devel/setup.bash" >> ~/.bashrc</b><br>
<b>source ~/.bashrc</b><br>
Проверил:<br>
<b>echo $ROS_PACKAGE_PATH</b><br>
Всё верно: <i>/root/catkin_ws/src:/opt/ros/noetic/share</i><br>
Повторил: <b>roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf</b><br>
<img src="./images/urdf4.png">
<p>
Посмотрел содержимое ~/catkin_ws/src. Есть только turtlebot3_simulations, когда в /opt/ros/noetic/share лежит дохрена каталогов, правда turtlebot3_simulations почему-то нет. Может перезагрузка нужна?<br>
Сохранил изменения в контейнере в новый образ rosurdf<br>
<b>docker commit fe0e4de1668c rosurdf</b>
<p>
Закрыл все терминалы и по-новому:<br>
<b>docker run --rm -it rosurdf /bin/bash</b><br>
<b>passwd</b><br>
<b>/etc/init.d/ssh start</b><br>
Другой терминал: <b>ssh -X root@172.17.0.2</b>
<pre>
root@f9a1a97b3272:~/catkin_ws/src# ls
CMakeLists.txt  turtlebot3_simulations</pre>
Содержимое не изменилось. И <b>roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf</b>, сообщение на команду не изменилось.
<p>
Нашёл ошибку, оказывается roslaunch надо выполнять из каталога urdf_tutorials. Об этом даже чуть ниже у меня написано из перевода документации.
<p>
<b>roscd urdf_tutorial</b>
<i>root@f9a1a97b3272:/opt/ros/noetic/share/urdf_tutorial#</i> <b>roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf</b><br>
<img src="./images/urdf5.png">
<p>
Команда делает три вещи.
<ol>
<li> Загружает указанную модель на сервер параметров
<li> Запускает узлы для публикации sensor_msgs/JointState и преобразований (подробнее об этом позже)
<li> Запускает Rviz с файлом конфигурации
</ol>
Обратите внимание, что приведенная выше строка roslaunch предполагает, что вы запускаете ее из каталога пакетов urdf_tutorial (т.е. каталог urdf является прямым дочерним по отношению к текущему рабочему каталогу). Если это не так, относительный путь к 01-myfirst.urdf будет неверным, и вы получите сообщение об ошибке, как только roslaunch попытается загрузить urdf на сервер параметров.<br>
Слегка измененный аргумент позволяет этому работать независимо от текущего рабочего каталога:<br>
<b>roslaunch urdf_tutorial display.launch model:='$(find urdf_tutorial)/urdf/01-myfirst.urdf'</b><br>
обратите внимание на одинарные кавычки, заключенные в значение аргумента.
<p>
Вам придется изменить все примеры строк roslaunch, приведенные в этих руководствах, если вы не запускаете их из расположения пакета urdf_tutorial.
<p>
<i><font color=red>Все равно непонятно, почему в src только один пакет turtlebot3_simulations, а где остальные?</font></i><br>
Наверное в src находятся только пакеты пользователя.
<p>
На что следует обратить внимание:

fixed frame - это рамка преобразования, в которой расположен центр сетки. Здесь это рамка, определенная нашей единственной ссылкой, base_link.<br>
По умолчанию начало визуального элемента (цилиндра) находится в центре его геометрии. Следовательно, половина цилиндра находится под сеткой.
<h4>Несколько фигур</h4>
Теперь давайте посмотрим, как добавить несколько snapes/links (фигур/ссылок). Если мы просто добавим больше link elements (элементов связи) в urdf, синтаксический анализатор не будет знать, куда их поместить. Поэтому нам придется добавить joints (соединения). Элементы соединения могут относиться как к гибким, так и к негибким соединениям. Мы начнем с негибких, или неподвижных, соединений.
<p>
<b>09.09.2024:</b><br>
<b>docker run --rm -it rosurdf /bin/bash</b><br>
<b>passwd</b><br>
<b>/etc/init.d/ssh start</b>
<p>
Другой терминал:<br>
<b>ssh -X root@172.17.0.2</b><br>
<b>roscd urdf_tutorial<br>
cat urdf/02-multipleshapes.urdf</b>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot name="multipleshapes"&gt;
  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="right_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_right_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="right_leg"/&gt;
  &lt;/joint&gt;

&lt;/robot&gt;
</pre>
Обратите внимание, как мы определили прямоугольник размером 0,6 м х 0,1 м х 0,2 м<br>
Соединение (joint) определяется в терминах родительского (parent) и дочернего(child) элементов. В конечном счете, URDF представляет собой древовидную структуру с одной корневой ссылкой (root link). Это означает, что положение ножки (leg’s position) зависит от положения базовой ссылки (base_link’s position).
<p>
<b>roslaunch urdf_tutorial display.launch model:=urdf/02-multipleshapes.urdf</b>
<p>
<img src="./images/urdf6.png">
<p>
Обе фигуры пересекаются друг с другом, поскольку имеют одну и ту же исходную точку. Если мы хотим, чтобы они не пересекались, мы должны определить больше исходных точек.
<h4>origins:</h4>
Нога R2D2 прикреплена к верхней половине своего туловища сбоку. Итак, именно здесь мы указываем происхождение СОЕДИНЕНИЯ (joint). Кроме того, он крепится не к середине голени, а к верхней части, поэтому мы также должны сместить начало координат для голени. Мы также поворачиваем ногу, чтобы она стояла вертикально.
<p>
Второй терминал подключить удалённо к контейнеру не разрешают, потому закрыл rviz и:<br>
<b>cat urdf/03-origins.urdf</b>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot name="origins"&gt;
  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;>
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="right_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_right_leg" type="fixed"&gt;>
    &lt;parent link="base_link"/&gt;
    &lt;child link="right_leg"/&gt;
    &lt;origin xyz="0 -0.22 0.25"/&gt;
 &lt;/joint&gt;

&lt;/robot&gt;
</pre>
ДДавайте начнем с изучения происхождения сустава (joint). Оно определяется в терминах родительской системы отсчета. Таким образом, мы находимся на расстоянии -0,22 метра в направлении y (слева от нас, но справа относительно осей) и 0,25 метра в направлении z (вверх). Это означает, что исходная точка дочерней ссылки будет находиться вверху и справа, независимо от визуального тега (тег visual) исходной точки дочерней ссылки. Поскольку мы не указали атрибут rpy (roll pitch yaw), дочерняя система координат (child frame) по умолчанию будет иметь ту же ориентацию, что и родительская система координат (parent frame).
<p>
Теперь, если посмотреть на визуальное начало отрезка, то оно имеет смещение как по оси xyz, так и по оси rpy. Это определяет, где должен находиться центр визуального элемента относительно его начала координат. Поскольку мы хотим, чтобы нога была прикреплена вверху, мы смещаем начало координат вниз, установив смещение z равным -0,3 метра. И поскольку мы хотим, чтобы длинная часть ноги была параллельна оси z, мы поворачиваем визуальную часть PI/2 вокруг оси Y.
<p>
<b>roslaunch urdf_tutorial display.launch model:=urdf/03-origins.urdf</b>
<p>
<img src="./images/urdf7.png">
<p>
Файл запуска запускает пакеты, которые будут создавать TF-фреймы для каждой link в вашей модели на основе вашего URDF. Rviz использует эту информацию, чтобы определить, где отображать каждую фигуру.<br>
Если TF-кадр не существует для данной link URDF, то он будет помещен в начало координат белым цветом
<h4>Material Girl:</h4>
Мой робот не красный. Давайте рассмотрим тег &lt;material&gt;
<p>
Код urdf/04-materials.urdf:
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot name="materials"&gt;

  &lt;material name="blue"&gt;
    &lt;color rgba="0 0 0.8 1"/&gt;
  &lt;/material&gt;

  &lt;material name="white"&gt;
    &lt;color rgba="1 1 1 1"/&gt;
  &lt;/material&gt;


  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="right_leg"&gt;>
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_right_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="right_leg"/&gt;
    &lt;origin xyz="0 -0.22 0.25"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_left_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="left_leg"/&gt;
    &lt;origin xyz="0 0.22 0.25"/&gt;
  &lt;/joint&gt;

&lt;/robot&gt;
</pre>
Корпус теперь синий. Мы определили новый материал под названием “blue”, для которого красный, зеленый, синий и альфа-каналы определены как 0,0, 0,8 и 1 соответственно. Все значения могут находиться в диапазоне [0,1]. Затем на этот материал ссылается визуальный элемент base_link. Аналогично определяется белый материал
<p>
Можно также тег material определять внутри тега visual и даже ссылаться на него в других links.
<p>
Вы также можете использовать текстуру, чтобы указать файл изображения, который будет использоваться для раскрашивания объекта.
<p>
<b>roslaunch urdf_tutorial display.launch model:=urdf/04-materials.urdf</b>
<p>
<img src="./images/urdf8.png">

<h4>Конечная модель</h4>
Теперь мы дополним модель еще несколькими фигурами: ногами, колесами и головой. В частности, мы добавим сферу и несколько сеток (meshes). Мы также добавим несколько других деталей, которые будем использовать позже.
<p>
Код urdf/05-visual.urdf:
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot name="visual"&gt;

&lt;material name="blue"&gt;
    &lt;color rgba="0 0 0.8 1"/&gt;
  &lt;/material&gt;
  &lt;material name="black"&gt;
    &lt;color rgba="0 0 0 1"/&gt;
  &lt;/material&gt;
  &lt;material name="white"&gt;
    &lt;color rgba="1 1 1 1"/&gt;
  &lt;/material&gt;

  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="right_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_right_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="right_leg"/&gt;
    &lt;origin xyz="0 -0.22 0.25"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_base"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.4 0.1 0.1"/&gt;
      &lt;/geometry&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="right_base_joint" type="fixed"&gt;
    &lt;parent link="right_leg"/&gt;
    &lt;child link="right_base"/&gt;
    &lt;origin xyz="0 0 -0.6"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_front_wheel"&gt;
    &lt;visual&gt;
      &lt;origin rpy="1.57075 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.1" radius="0.035"/&gt;
      &lt;/geometry&gt;
      &lt;material name="black"/&gt;
      &lt;origin rpy="0 0 0" xyz="0 0 0"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="right_front_wheel_joint" type="fixed"&gt;
    &lt;parent link="right_base"/&gt;
    &lt;child link="right_front_wheel"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.133333333333 0 -0.085"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_back_wheel"&gt;
    &lt;visual&gt;
      &lt;origin rpy="1.57075 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.1" radius="0.035"/&gt;
      &lt;/geometry&gt;
      &lt;material name="black"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="right_back_wheel_joint" type="fixed"&gt;
    &lt;parent link="right_base"/&gt;
    &lt;child link="right_back_wheel"/&gt;
    &lt;origin rpy="0 0 0" xyz="-0.133333333333 0 -0.085"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_left_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="left_leg"/&gt;
    &lt;origin xyz="0 0.22 0.25"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_base"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.4 0.1 0.1"/&gt;
      &lt;/geometry&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="left_base_joint" type="fixed"&gt;
    &lt;parent link="left_leg"/&gt;
    &lt;child link="left_base"/&gt;
    &lt;origin xyz="0 0 -0.6"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_front_wheel"&gt;
    &lt;visual&gt;
      &lt;origin rpy="1.57075 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.1" radius="0.035"/&gt;
      &lt;/geometry&gt;
      &lt;material name="black"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="left_front_wheel_joint" type="fixed"&gt;
    &lt;parent link="left_base"/&gt;
    &lt;child link="left_front_wheel"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.133333333333 0 -0.085"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_back_wheel"&gt;
    &lt;visual&gt;
      &lt;origin rpy="1.57075 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.1" radius="0.035"/&gt;
      &lt;/geometry&gt;
      &lt;material name="black"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="left_back_wheel_joint" type="fixed"&gt;
    &lt;parent link="left_base"/&gt;
    &lt;child link="left_back_wheel"/&gt;
    &lt;origin rpy="0 0 0" xyz="-0.133333333333 0 -0.085"/&gt;
  &lt;/joint&gt;

  &lt;joint name="gripper_extension" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="gripper_pole"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.19 0 0.2"/&gt;
  &lt;/joint&gt;

  &lt;link name="gripper_pole"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.2" radius="0.01"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0 " xyz="0.1 0 0"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="left_gripper_joint" type="fixed"&gt;
    &lt;origin rpy="0 0 0" xyz="0.2 0.01 0"/&gt;
    &lt;parent link="gripper_pole"/&gt;
    &lt;child link="left_gripper"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_gripper"&gt;
    &lt;visual&gt;
      &lt;origin rpy="0.0 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;mesh filename="package://urdf_tutorial/meshes/l_finger.dae"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="left_tip_joint" type="fixed"&gt;
    &lt;parent link="left_gripper"/&gt;
    &lt;child link="left_tip"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_tip"&gt;
    &lt;visual&gt;
      &lt;origin rpy="0.0 0 0" xyz="0.09137 0.00495 0"/&gt;
      &lt;geometry&gt;
        &lt;mesh filename="package://urdf_tutorial/meshes/l_finger_tip.dae"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="right_gripper_joint" type="fixed"&gt;
    &lt;origin rpy="0 0 0" xyz="0.2 -0.01 0"/&gt;
    &lt;parent link="gripper_pole"/&gt;
    &lt;child link="right_gripper"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_gripper"&gt;
    &lt;visual&gt;
      &lt;origin rpy="-3.1415 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;mesh filename="package://urdf_tutorial/meshes/l_finger.dae"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="right_tip_joint" type="fixed"&gt;
    &lt;parent link="right_gripper"/&gt;
    &lt;child link="right_tip"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_tip"&gt;
    &lt;visual&gt;
      &lt;origin rpy="-3.1415 0 0" xyz="0.09137 0.00495 0"/&gt;
      &lt;geometry&gt;
        &lt;mesh filename="package://urdf_tutorial/meshes/l_finger_tip.dae"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="head"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;sphere radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="head_swivel" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="head"/&gt;
    &lt;origin xyz="0 0 0.3"/&gt;
  &lt;/joint&gt;

  &lt;link name="box"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.08 0.08 0.08"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="tobox" type="fixed"&gt;
    &lt;parent link="head"/&gt;
    &lt;child link="box"/&gt;
    &lt;origin xyz="0.1814 0 0.1414"/&gt;
  &lt;/joint&gt;
&lt;/robot&gt;
</pre>
<img src="./images/urdf9.png">
<p>
<img src="./images/urdf10.png">
<p>
Приведенные здесь сетки (meshes) были позаимствованы из PR2. Это отдельные файлы, для которых вы должны указать путь. Вам следует использовать обозначение package://NAME_OF_PACKAGE/path. Сетки для этого учебного пособия находятся в пакете urdf_tutorial, в папке под названием meshes.
<p>
Сетки могут быть импортированы в различных форматах. Довольно часто используется STL, но движок также поддерживает DAE, который может содержать собственные цветовые данные, что означает, что вам не нужно указывать цвет/материал. Часто они хранятся в отдельных файлах. Эти сетки ссылаются на файлы .tif, также находящиеся в папке meshes.
<p>
Размер сеток также может быть определен с помощью относительных параметров масштабирования или ограничивающего прямоугольника.
<p>
Мы могли бы также сослаться на сетки в совершенно другом пакете, т.е. package://pr2_description/meshes/gripper_v0/l_finger.dae, который будет работать, если установлен пакет pr2_description.

<h3 align=center><a href="https://wiki.ros.org/urdf/Tutorials/Building%20a%20Movable%20Robot%20Model%20with%20URDF">Building a Movable Robot Model with URDF</a></h3>
В этом учебнике мы изменим модель R2D2, так чтобы он имел подвижные суставы (joints). Мы рассмотрим 3 других важных типа суставов: continuous, revolute и prismatic.
<p>
urdf-файл с подвижными суставами находится в urdf/06-flexible.urdf
<p>
Чтобы визуализировать эту модель и управлять ею, запустите ту же команду, что и в предыдущем руководстве:<br>
<b>roslaunch urdf_tutorial display.launch model:=urdf/06-flexible.urdf</b><br>
однако теперь также появится графический интерфейс, который позволит вам управлять значениями всех нефиксированных соединений. Поиграйте с моделью и посмотрите, как она движется. Затем мы сможем взглянуть на то, как мы этого добились.
<ol>
<li> Head:
<pre>
&lt;joint name="head_swivel" type="continuous"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="head"/&gt;
    &lt;axis xyz="0 0 1"/&gt;
    &lt;origin xyz="0 0 0.3"/&gt;
  &lt;/joint&gt;
</pre>
Соединение между туловищем и головой является непрерывным, что означает, что оно может поворачиваться под любым углом от отрицательной до положительной бесконечности. Колеса также смоделированы таким образом, что они могут вращаться в обоих направлениях бесконечно.
<p>
Единственная дополнительная информация, которую мы должны добавить, - это ось вращения, здесь она задается триплетом xyz, который определяет вектор, вокруг которого будет вращаться голова. Поскольку мы хотим, чтобы она вращалась вокруг оси z, мы задаем вектор "0 0 1".
<li> The Gripper
<pre>
&lt;joint name="left_gripper_joint" type="revolute"&gt;
    &lt;axis xyz="0 0 1"/&gt;
    &lt;limit effort="1000.0" lower="0.0" upper="0.548" velocity="0.5"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.2 0.01 0"/&gt;
    &lt;parent link="gripper_pole"/&gt;
    &lt;child link="left_gripper"/&gt;
&lt;/joint&gt;
</pre>
Как правое, так и левое захватные соединения (gripper joints) выполнены в виде поворотных соединений. Это означает, что они вращаются так же, как и неразъемные соединения, но имеют строгие ограничения. Следовательно, мы должны указать верхний и нижний пределы соединения (в радианах). Мы также должны указать максимальную скорость и усилие для этого соединения, но фактические значения не имеют значения для наших целей.
<li> The Gripper Arm
<pre>
&lt;joint name="gripper_extension" type="prismatic"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="gripper_pole"/&gt;
    &lt;limit effort="1000.0" lower="-0.38" upper="0" velocity="0.5"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.19 0 0.2"/&gt;
  &lt;/joint&gt;</pre>
 Захватный рычаг (gripper arm) - это другой тип шарнира, а именно призматический шарнир. Это означает, что он перемещается вдоль оси, а не вокруг нее. Именно это поступательное движение позволяет нашей модели робота выдвигать и втягивать свой захватный рычаг.
<p>
Пределы призматического рычага задаются таким же образом, как и для поворотного шарнира, за исключением того, что единицами измерения являются метры, а не радианы.
<li> Other Types of Joints<br>
Существуют два других вида соединений, которые перемещаются в пространстве. В то время как призматическое соединение может перемещаться только в одном измерении, плоское соединение может перемещаться в плоскости или в двух измерениях. Кроме того, плавающее соединение не имеет ограничений и может перемещаться в любом из трех измерений. Эти соединения не могут быть заданы только одним номером и поэтому не включены в данное руководство.
<li> Specifying the Pose<br>
Когда вы перемещаете ползунки в графическом интерфейсе, модель перемещается в Rviz. Как это делается? Сначала графический интерфейс анализирует URDF и находит все нефиксированные соединения и их границы. Затем он использует значения ползунков для публикации сообщений sensor_msgs/JointState. Затем они используются robot_state_publisher для вычисления всех преобразований между различными частями. Полученное дерево преобразований затем используется для отображения всех фигур в Rviz.
<li> Теперь, когда у вас есть наглядно функциональная модель, вы можете добавить некоторые физические свойства или начать использовать xacro для упрощения вашего кода.
</ol>

<h3 align=center><a href="https://wiki.ros.org/urdf/Tutorials/Adding%20Physical%20and%20Collision%20Properties%20to%20a%20URDF%20Model">Adding Physical and Collision Properties to a URDF Model</a></h3>
Узнайте, как придать звеньям противоударные и инерционные свойства, а также как придать сочленениям динамику.
<ol>
<li> Collision<br>
До сих пор мы задавали наши ссылки только с помощью одного подэлемента, visual, который определяет (что неудивительно), как выглядит робот. Однако, чтобы заставить работать функцию обнаружения столкновений или имитировать робота в чем-то вроде Gazebo, нам также нужно определить элемент столкновения.<br>
Файл urdf/07-physics.urd с collision и физическими свойствами.
<pre>
&lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"&gt;
        &lt;color rgba="0 0 .8 1"/&gt;
      &lt;/material&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
  &lt;/link&gt;</pre>
Тег collision является прямым подэлементом объекта link, находящимся на том же уровне, что и тег visual.<br>
Элемент collision определяет свою форму так же, как и визуальный элемент, с помощью тега geometry. Формат тега geometry здесь точно такой же, как и в визуальном элементе.<br>
Вы также можете указать источник таким же образом, как и подэлемент тега коллизии (как в случае с визуальным элементом).
<p>
Во многих случаях вам захочется, чтобы геометрия столкновения и начало координат в точности совпадали с визуальной геометрией и началом координат. Однако есть два основных случая, когда этого делать не следует.
<ol>
<li> Quicker Processing (Более быстрая обработка) - обнаружение коллизий для двух сеток требует гораздо больших вычислительных затрат, чем для двух простых геометрий. Следовательно, вы можете захотеть заменить сетки более простыми геометриями в элементе collision.
<li>Safe Zones Безопасные зоны - возможно, вы захотите ограничить передвижение вблизи чувствительного оборудования. Например, если мы не хотим, чтобы что-либо столкнулось с головой R2D2, мы могли бы определить геометрию столкновения как цилиндр, охватывающий его голову, чтобы предотвратить попадание чего-либо слишком близко к его голове.
</ol>
<li> Physical Properties<br>
Чтобы ваша модель работала должным образом, вам необходимо определить несколько физических свойств вашего робота, то есть свойств, которые потребовались бы физическому движку, такому как Gazebo
<p>
<b>Инерция</b><br>
Для каждого моделируемого элемента связи требуется тег inertial. Вот простой тег:
<pre>
&lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"&gt;
        &lt;color rgba="0 0 .8 1"/&gt;
      &lt;/material&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
    &lt;inertial&gt;
      &lt;mass value="10"/&gt;
      &lt;inertia ixx="0.4" ixy="0.0" ixz="0.0" iyy="0.4" iyz="0.0" izz="0.2"/&gt;
    &lt;/inertial&gt;
  &lt;/link&gt;ision&gt;
  &lt;/link&gt;
</pre>
<ul>
<li> Этот элемент также является подэлементом объекта link.
<li> Масса определяется в килограммах.
<li> Матрица инерции вращения 3х3 задается с помощью элемента инерции. Поскольку она симметрична, то может быть представлена только 6 элементами, как таковыми.<br>
<img src="./images/urdf11.png">
<li> Эта информация может быть предоставлена вам с помощью программ моделирования, таких как MeshLab. Инерция геометрических примитивов (цилиндр, прямоугольник, сфера) может быть вычислена с использованием списка тензоров момента инерции в Википедии (и используется в приведенном выше примере).
<li> Тензор инерции зависит как от массы, так и от распределения массы объекта. Хорошим первым приближением является предположение о равном распределении массы по объему объекта и вычисление тензора инерции на основе формы объекта, как описано выше.
<li> сли вы не уверены, что именно установить, то матрица с ixx/iyy/izz=1e-3 или меньше часто является разумным выбором по умолчанию для линков среднего размера (это соответствует коробке с длиной стороны 0,1 м и массой 0,6 кг). Идентификационная матрица - особенно неудачный выбор, поскольку она часто бывает слишком высокой (она соответствует коробке с длиной стороны 0,1 м и массой 600 кг!).
<li> Вы также можете указать исходный тег, чтобы указать центр тяжести и инерциальную систему отсчета (относительно системы отсчета ссылки).
<li> При использовании контроллеров реального времени нулевые (или почти нулевые) инерционные элементы могут привести к тому, что модель робота рухнет без предупреждения, и все ссылки будут отображаться так, чтобы их происхождение совпадало с мировым происхождением.
</ul>
<p>
<b>Contact Coefficients</b><br>
Вы также можете определить, как ведут себя ссылки, когда они соприкасаются друг с другом. Для этого используется подэлемент тега collision, называемый contact_coefficients. Необходимо указать три атрибута:
<ul>
<li> mu - Friction coefficient
<li> kp - Stiffness coefficient
<li> kd - Dampening coefficient
</ul>
<p>
<b>Joint Dynamics</b><br>
То, как движется сустав, определяется тегом dynamics для этого сустава. Здесь есть два атрибута:
<ul>
<li> friction - физическое статическое трение. Для призматических соединений единицами измерения являются ньютоны. Для вращающихся соединений единицами измерения являются ньютон-метры.
<li> damping - величина физического демпфирования. Для призматических соединений единицами измерения являются Ньютон-секунды на метр. Для вращающихся шарниров - ньютон-метровые секунды на радиан.
</ul>
Если этот параметр не указан, то по умолчанию эти коэффициенты равны нулю.
<li> Другие теги<br>
В области чистого URDF (т.е. без учета тегов, относящихся к Gazebo), остаются два тега, которые помогают определить соединения: тег calibration и тег safety controller. Ознакомьтесь со <a href="https://wiki.ros.org/urdf/XML/joint">спецификацией</a>, поскольку они не включены в это руководство.
</ol>

<h3 align=center><a href="https://wiki.ros.org/urdf/Tutorials/Using%20Xacro%20to%20Clean%20Up%20a%20URDF%20File">Using Xacro to Clean Up a URDF File</a></h3>
Узнайте несколько приемов, позволяющих уменьшить объем кода в URDF-файле с помощью Xacro.
<p>
К настоящему времени, если вы выполняете все эти действия дома, создавая собственного робота, вам, возможно, надоест заниматься всевозможными математическими расчетами, чтобы получить очень простые описания роботов для правильного анализа. К счастью, вы можете использовать пакет xacro, чтобы упростить себе жизнь. Он делает три вещи, которые очень полезны:
<ul>
<li> Constants
<li> Simple Math
<li> Macros
</ul>
В этом руководстве мы рассмотрим все эти сочетания клавиш, которые помогут уменьшить общий размер файла URDF и упростят его чтение и обслуживание.
<p>
<b>1. Using Xacro</b><br>
Как следует из названия, xacro - это макроязык для XML. Программа xacro запускает все макросы и выдает результат. Типичное использование выглядит примерно так:<br>
<b>xacro --inorder model.xacro > model.urdf</b><br>
В дистрибутивах ROS melodic и более поздних версиях вам следует опустить аргумент {--inorder}.
<p>
Вы также можете автоматически сгенерировать urdf в файле запуска. Это удобно, поскольку он постоянно обновляется и не занимает место на жестком диске. Однако для создания этого файла требуется время, поэтому имейте в виду, что запуск файла запуска может занять больше времени. (Я смотрю на твое описание pr2_description):
<pre>
&lt;param name="robot_description"
  command="xacro --inorder '$(find pr2_description)/robots/pr2.urdf.xacro'" /&gt;</pre>
В верхней части файла URDF необходимо указать пространство имен (namespace), чтобы файл был правильно обработан. Например, это первые две строки правильного файла xacro:
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="firefighter"&gt;
</pre>
<b>2. Constants</b><br>
Давайте бегло взглянем на наш base_link в R2D2:
<pre>
&lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"/&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
  &lt;/link&gt;
  </pre>
Приведенная здесь информация немного избыточна. Мы указываем длину и радиус цилиндра дважды. Что еще хуже, если мы хотим изменить это, нам нужно сделать это в двух разных местах.
<p>
К счастью, xacro позволяет вам указывать свойства, которые действуют как константы. Вместо приведенного выше кода мы можем написать этот:
<pre>
&lt;xacro:property name="width" value="0.2" /&gt;
&lt;xacro:property name="bodylen" value="0.6" /&gt;
&lt;link name="base_link"&gt;
    &lt;visual&gt;
        &lt;geometry&gt;
            &lt;cylinder radius="${width}" length="${bodylen}"/&gt;
        &lt;/geometry&gt;
        &lt;material name="blue"/&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
        &lt;geometry&gt;
            &lt;cylinder radius="${width}" length="${bodylen}"/&gt;
        &lt;/geometry&gt;
    &lt;/collision&gt;
&lt;/link&gt;
</pre>
<ul>
<li> Эти два значения указаны в первых двух строках. Они могут быть определены практически в любом месте (при условии корректного XML), на любом уровне, до или после их использования. Обычно они располагаются вверху.
<li> Вместо определения радиуса в теге geometry, мы используем знак доллара и скобки {}, чтобы вставить значение радиуса.
<li> Этот код сгенерирует тот же код, что и показанный выше.
</ul>
Значение содержимого ${} construct are then used to replace the ${}. This means you can combine it with other text in the attribute.
<pre>
&lt;xacro:property name=”robotname” value=”marvin” /&gt;
&lt;link name=”${robotname}s_leg” /&gt;
</pre>
Будет сгенерирован:
<pre>
&lt;link name=”marvins_leg” /&gt;
</pre>
However, the contents in the ${} don’t have to only be a property, which brings us to our next point...
<p>
<b>3. Математика</b><br>
Вы можете создавать сколь угодно сложные выражения в конструкции ${}, используя четыре основные операции (+,-,*,/), унарный минус и круглые скобки. Примеры:
<pre>
&lt;cylinder radius="${wheeldiam/2}" length="0.1"/&gt;
&lt;origin xyz="${reflect*(width+.02)} 0 0.25" /&gt;
</pre>
Все в математике использует числа с плавающей точкой, следовательно:
<p>
&lt;link name="${5/6}"/&gt;
<p>
вычисляется как:
<p>
&lt;link name="0.833333333333"/&gt;
<p>
В Jade и более поздних дистрибутивах вы можете использовать не только перечисленные выше базовые операции, в частности sin и cos.
<p>
<b>4. Macros</b><br>
Здесь самый большой и полезный компонент пакета xacro.
<ol>
<li> Simple Macro<br>
Давайте рассмотрим простое использование macro.
<pre>
&lt;xacro:macro name="default_origin"&gt;
    &lt;origin xyz="0 0 0" rpy="0 0 0"/&gt;
&lt;/xacro:macro&gt;
&lt;xacro:default_origin /&gt;
</pre>
(This is useless, since if the origin is not specified, it has the same value as this.) Будет сгенерирован следующий код:
<pre>&lt;origin rpy="0 0 0" xyz="0 0 0"/&gt;</pre>
<ul>
<li> Технически name не является обязательным элементом, но вам необходимо указать его, чтобы иметь возможность его использовать.
<li> Каждая вставка &lt;xacro:$NAME /&gt; заменяется содержимым тега xacro:macro
<li> Обратите внимание, что даже при том, что это не совсем одно и то же (два атрибута поменялись местами), сгенерированный XML эквивалентен
<li> Если xacro с указанным именем не найден, он не будет развернут и не выдаст ошибку.
</ul><p>
<li> Parameterized Macro<br>
Вы также можете настроить параметры макросов, чтобы они не генерировали каждый раз один и тот же текст. В сочетании с математическими функциями это еще более эффективно.
<p>
Для начала давайте рассмотрим пример простого макроса, используемого в R2D2.
<pre>
&lt;xacro:macro name="default_inertial" params="mass"&gt;
        &lt;inertial&gt;
                &lt;mass value="${mass}" /&gt;
                &lt;inertia ixx="1.0" ixy="0.0" ixz="0.0"
                     iyy="1.0" iyz="0.0"
                     izz="1.0" /&gt;
        &lt;/inertial&gt;
    &lt;/xacro:macro&gt;
</pre>
Это может быть использовано с кодом:<br>
&lt;xacro:default_inertial mass="10"/&gt;<br>
Параметры действуют точно так же, как свойства, и вы можете использовать их в выражениях
<p>
Вы также можете использовать целые блоки в качестве параметров:
<pre>
&lt;xacro:macro name="blue_shape" params="name *shape"&gt;
    &lt;link name="${name}"&gt;
        &lt;visual&gt;
            &lt;geometry&gt;
                &lt;xacro:insert_block name="shape" /&gt;
            &lt;/geometry&gt;
            &lt;material name="blue"/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;xacro:insert_block name="shape" /&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
    &lt;/link&gt;
&lt;/xacro:macro&gt;

&lt;xacro:blue_shape name="base_link"&gt;
    &lt;cylinder radius=".42" length=".01" /&gt;
&lt;/xacro:blue_shape&gt;
</pre>
<ul>
<li> Чтобы указать параметр блока, поставьте звездочку перед его именем.
<li> Блок может быть вставлен с помощью команды insert_block
<li> Вставляйте блок столько раз, сколько пожелаете
</ul>
</ol>
<p>
<b>5. Practical Usage</b><br>
Язык xacro достаточно гибок в том, что он позволяет вам делать. Вот несколько полезных способов использования xacro в модели R2D2, в дополнение к инерционному макросу по умолчанию, показанному выше.
<p>
Чтобы увидеть модель, сгенерированную с помощью файла xacro, запустите ту же команду, что и в предыдущих руководствах:
<p>
<b>roslaunch urdf_tutorial display.launch model:=urdf/08-macroed.urdf.xacro</b>
<p>
(Все это время в файле запуска выполнялась команда xacro, но поскольку макросов для расширения не было, это не имело значения)
<ol>
<li> Leg macro<br>
Часто требуется создать несколько похожих объектов в разных местах. Часто требуется обеспечить некоторую симметрию в расположении. Вы можете использовать макрос и простую математику, чтобы сократить объем кода, который вам нужно написать, как мы делаем с двумя ногами R2.
<pre>
&lt;xacro:macro name="leg" params="prefix reflect"&gt;
    &lt;link name="${prefix}_leg"&gt;
        &lt;visual&gt;
            &lt;geometry&gt;
                &lt;box size="${leglen} 0.1 0.2"/&gt;
            &lt;/geometry&gt;
            &lt;origin xyz="0 0 -${leglen/2}" rpy="0 ${pi/2} 0"/&gt;
            &lt;material name="white"/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;box size="${leglen} 0.1 0.2"/&gt;
            &lt;/geometry&gt;
            &lt;origin xyz="0 0 -${leglen/2}" rpy="0 ${pi/2} 0"/&gt;
        &lt;/collision&gt;
        &lt;xacro:default_inertial mass="10"/&gt;
    &lt;/link&gt;

    &lt;joint name="base_to_${prefix}_leg" type="fixed"&gt;
        &lt;parent link="base_link"/&gt;
        &lt;child link="${prefix}_leg"/&gt;
        &lt;origin xyz="0 ${reflect*(width+.02)} 0.25" /&gt;
    &lt;/joint&gt;
    &lt;!-- A bunch of stuff cut --&gt;
&lt;/xacro:macro&gt;
&lt;xacro:leg prefix="right" reflect="1" /&gt;
&lt;xacro:leg prefix="left" reflect="-1" /&gt;
</pre>
<ul>
<li> Обычный трюк 1: Используйте имя prefix, чтобы получить два объекта с одинаковыми именами.
<li> Обычная хитрость 2: Используйте математику для расчета начала соединения. В случае, если вы меняете размер вашего робота, изменение свойства с помощью математических методов для расчета смещения соединения избавит вас от многих проблем.
<li> Обычный трюк № 3: Используйте параметр reflect и установите для него значение 1 или -1. Посмотрите, как мы используем параметр reflect, чтобы расположить ноги по обе стороны от тела в исходной точке base_to_${префикс}_leg.
</ul>
<li> Другие уловки<br>
Не стесняйтесь добавлять сюда свои собственные трюки.
</ol>



<h3 align=center><a href="https://wiki.ros.org/urdf/Tutorials/Using%20a%20URDF%20in%20Gazebo">URDF в Gazebo</a></h3>
Предварительное руководство о том, как создавать своего робота и управлять им в Gazebo.
<p>
Пожалуйста, скачайте руководство по моделированию URDF с github или с помощью aptitude, например, для ROS kinetic:
<p>
<b>sudo apt-get install ros-kinetic-urdf-sim-tutorial</b>
<p>
Я (10.09.2024):<br>
Стандартные команды для выполнения графических программ на локальном компьютере с удаленного контейнера:<br>
docker run --rm -it rosurdf /bin/bash<br>
passwd<br>
/etc/init.d/ssh start
<p>
Другой терминал:<br>
ssh -X root@172.17.0.2
<p>
Теперь скачиваю учебник:
<p>
sudo apt-get install ros-noetic-urdf-sim-tutorial
<p>
Уже был установлен этот учебник.<br>
Где именно установлен этот urdf-sim-tutorial, не нашёл. Ладно, не важно.<br>
<font color=brown>Нашёл, пакет называется urdf_sim_tutorial и находится он в /opt/ros/noetic/share/</font>
<ol>
<li> <b>Nonfunctional Gazebo Interface</b><br>
Мы можем создать модель, которую мы уже создали, в Gazebo, используя gazebo.launch:<br>
<b>roslaunch urdf_sim_tutorial gazebo.launch</b>
<p>
Я:<br>
cd root/catkin_ws
catkin_make
<p>
Проверил, в папке src ничего не изменилось, только пакет turtlebot3_simulations. После:
<p>
<b>roslaunch urdf_sim_tutorial gazebo.launch</b>
<p>
Сообщения:
<pre>[ WARN] [1725956442.259207689]: The root link base_link has an inertia specified in the URDF, but KDL does not support a root link with an inertia.  As a workaround, you can add an extra dummy link to your URDF.</pre>
Видимо из-за того, что gazebo не поддерживает urdf, потому некоторые моменты типа инерции не будет выполнять.
<p>
<img src="./images/urdf12.png">
<p>
 Этот файл запуска:
<ul>
<li> Загружает urdf из <a href="https://wiki.ros.org/urdf/Tutorials/Using%20Xacro%20to%20Clean%20Up%20a%20URDF%20File">руководства по макросам</a> в описание параметра (parameter description).
<li> Запускает пустой gazebo мир world
<li> Запускает скрипт для считывания urdf из параметра и создания его в gazebo.
</ul>
Однако он ничего не делает, и в нем отсутствует много ключевой информации, необходимой ROS для использования этого робота. Ранее мы использовали joint_state_publisher для указания положения каждого сустава. Однако робот сам должен предоставлять эту информацию в реальном мире или в gazebo. Однако, не уточняя этого, Gazebo не знает, публиковать ли эту информацию.
<p>
Чтобы сделать робота интерактивным (с вами и ROS), нам нужно указать две вещи: плагины и передачи )Plugins and Transmissions).
<p>
<li> <b>Gazebo Plugin</b><br>
Чтобы заставить ROS взаимодействовать с Gazebo, мы должны динамически подключиться к библиотеке ROS, которая будет указывать Gazebo, что делать. Теоретически это позволяет другим операционным системам роботов взаимодействовать с Gazebo обычным способом. На практике это просто ROS.
<p>
Чтобы связать Gazebo и ROS, мы указываем плагин в URDF, прямо перед закрывающим тегом &lt;/robot&gt;:
<pre>
&lt;gazebo&gt;
    &lt;plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so"&gt;
      &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;
    &lt;/plugin&gt;
  &lt;/gazebo&gt;</pre>
Вы можете увидеть это в https://github.com/ros/urdf_sim_tutorial/blob/master/urdf/09-publishjoints.urdf.xacro и, запустив:<br>
<b>roslaunch urdf_sim_tutorial gazebo.launch model:=urdf/09-publishjoints.urdf.xacro</b>
<p>
Однако это пока не принесет ничего нового. Для этого нам нужно указать больше информации за пределами URDF
<p>
<li> <b>Spawning Controllers</b><br>
Теперь, когда мы связали ROS и Gazebo, нам нужно указать некоторые фрагменты кода ROS, которые мы хотим запустить в Gazebo, которые мы обычно называем контроллерами. Изначально они загружаются в пространство параметров ROS. У нас есть <a href="https://github.com/ros/urdf_sim_tutorial/blob/master/config/joints.yaml">yaml-файл joints.yaml</a>, который определяет наш первый контроллер.
<pre>
type: "joint_state_controller/JointStateController"
publish_rate: 50</pre>
Этот контроллер находится в пакете joint_state_controller и публикует состояние суставов робота в ROS непосредственно из Gazebo.
<p>
В <a href="https://github.com/ros/urdf_sim_tutorial/blob/master/launch/09-joints.launch">09-joints.launch</a> вы можете увидеть, как мы должны загрузить этот yaml-файл в namespace r2d2_joint_state_controller. Затем мы вызываем скрипт [[controller_manager]]/spawner с namespace, который загружает его в Gazebo.
<p>
Вы можете запустить его, но он все еще не совсем готов: <b>roslaunch urdf_sim_tutorial 09-joints.launch</b>
<br>Это запустит контроллер и фактически опубликует его в разделе /joint_states .... но в нём ничего не будет.
<pre>
header:
  seq: 652
  stamp:
    secs: 13
    nsecs: 331000000
  frame_id: ''
name: []
position: []
velocity: []
effort: []</pre>
Что еще вам нужно для gazebo? Ну, он хочет знать, о каких joints публиковать информацию.
<p>
<li> <b>Transmissions</b><br>
Для каждого нефиксированного соединения нам нужно указать передачу (transmission), которая сообщает Gazebo, что делать с соединением. Давайте начнем с головного соединения. Добавьте в свой URDF следующее:
<pre>
&lt;transmission name="head_swivel_trans"&gt;
    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
    &lt;actuator name="$head_swivel_motor"&gt;
      &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
    &lt;/actuator&gt;
    &lt;joint name="head_swivel"&gt;
      &lt;hardwareInterface&gt;hardware_interface/PositionJointInterface&lt;/hardwareInterface&gt;
    &lt;/joint&gt;
  &lt;/transmission&gt;
</pre>
Для ознакомления просто рассмотрите большую часть этого фрагмента кода как стандартный.<br>
Первое, на что следует обратить внимание, - это элемент joint. Имя должно соответствовать объявленному ранее joint.<br>
Аппаратный интерфейс будет важен при изучении плагинов.
<p>
Вы можете запустить этот URDF с нашей предыдущей конфигурацией запуска:<br>
<b>roslaunch urdf_sim_tutorial 09-joints.launch model:=urdf/10-firsttransmission.urdf.xacro</b>
<p>
Открылись rviz и gazebo с нашим роботом.
<p>
<img src="./images/urdf13.png">
<p>
и
<p>
<img src="./images/urdf14.png">
<p>
Теперь head отображается правильно в RViz, потому что head joint указан в сообщениях join_states.
<pre>
header:
  seq: 220
  stamp:
    secs: 4
    nsecs: 707000000
  frame_id: ''
name: ['head_swivel']
position: [-2.9051283156888985e-08]
velocity: [7.575990694887896e-06]
effort: [0.0]
</pre>
Мы могли бы продолжить добавлять передачи для всех нефиксированных соединений (и мы это сделаем), чтобы все соединения были должным образом опубликованы. Но в жизни есть нечто большее, чем просто просмотр роботов. Мы хотим управлять ими. Итак, давайте установим еще один контроллер.<p>
<li> <b>Joint Control</b> (управление суставами)<br>
Добавим контроллер:
<pre>
type: "position_controllers/JointPositionController"
joint: head_swivel</pre>
Это указывает на необходимость использования JointPositionController из пакета position_controllers для управления передачей head_swivel. Обратите внимание, что аппаратный интерфейс в URDF для этого соединения соответствует типу контроллера.
<p>
Теперь мы можем запустить это с добавленной конфигурацией, как и раньше:<br>
<b>roslaunch urdf_sim_tutorial 10-head.launch</b>
<p>
Теперь нода Gazebo подписана на новый топик и мы можем контролировать позицию головы (head) публикацией значений в ros топик:<br>
<b>rostopic pub /r2d2_head_controller/command std_msgs/Float64 "data: -0.707"</b>
<p>
Когда эта команда будет опубликована, положение немедленно изменится на указанное значение. Это связано с тем, что мы не указали никаких ограничений для соединения в нашем urdf. Однако, если мы изменим соединение, оно будет перемещаться постепенно.
<pre>
&lt;joint name="head_swivel" type="continuous"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="head"/&gt;
    &lt;axis xyz="0 0 1"/&gt;
    &lt;origin xyz="0 0 ${bodylen/2}"/&gt;
    &lt;limit effort="30" velocity="1.0"/&gt;
  &lt;/joint&gt;
</pre>
<i>Я: запустил новый терминал контейнера командой: docker exec -it 9826cde6760f bash<br>
Непонятно только, где я этот терминал запустил: в контейнере удаленного компьютера или локально в симуляторе этого компьютера. Выполнил команду: rostopic pub /r2d2_head_controller/command std_msgs/Float64 "data: -0.707"<br>
В графических симуляторах ничего не шевельнулось и не поменялось и непонятно, что должно было произойти.
<p>
Закрыл всю графику и выполнил: <b>roslaunch urdf_sim_tutorial 10-head.launch model:=urdf/11-limittransmission.urdf.xacro</b><br>
Открылись симуляторы. В другом терминале снова: <b>rostopic pub /r2d2_head_controller/command std_msgs/Float64 "data: -0.707"</b><br>
<font color=red>Снова ничего не поменялось, непонятно.</font></i><p>
<li><b>Another Controller</b><br>
Аналогичным образом мы можем изменить URDF для соединений захвата (Gripper joints). Однако вместо того, чтобы индивидуально управлять каждым соединением захвата с помощью отдельной темы ROS, мы могли бы сгруппировать их вместе. Для этого нам просто нужно указать другой контроллер в <a href="https://github.com/ros/urdf_sim_tutorial/blob/master/config/gripper.yaml">параметрах ROS (ROS parameters), код файла urdf_sim_tutorial/config/gripper.yaml</a>:
<pre>
type: "position_controllers/JointGroupPositionController"
joints:
 - gripper_extension
 - left_gripper_joint
 - right_gripper_joint</pre>
Чтобы запустить робот:<br>
<b>roslaunch urdf_sim_tutorial 12-gripper.launch</b>
<p>
Таким образом, мы можем вместо этого указать позицию руки с захватом (gripper) с помощью массива значений с плавающей запятой. Вывести руку с захватом и открыть клешни, публикуем сообщение:
<pre>
rostopic pub  /r2d2_gripper_controller/command std_msgs/Float64MultiArray "layout:
  dim:
  - label: ''
    size: 3
    stride: 1
  data_offset: 0
data: [0, 0.5, 0.5]"</pre>
Чтобы скрыть руку с клешнями, сообщение:
<pre>
rostopic pub  /r2d2_gripper_controller/command std_msgs/Float64MultiArray "layout:
  dim:
  - label: ''
    size: 3
    stride: 1
  data_offset: 0
data: [-0.4, 0, 0]"</pre>
На этот раз у меня всё работает.<p>
<li> <b>The Wheels on the Droid Go Round and Round</b><br>
Чтобы управлять роботом, мы задаем еще одну передачу для каждого из колес в макросе wheel (колесо).
<pre>
&lt;transmission name="${prefix}_${suffix}_wheel_trans"&gt;
      &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
      &lt;actuator name="${prefix}_${suffix}_wheel_motor"&gt;
        &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
      &lt;/actuator&gt;
      &lt;joint name="${prefix}_${suffix}_wheel_joint"&gt;
        &lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface&lt;/hardwareInterface&gt;
      &lt;/joint&gt;
    &lt;/transmission&gt;</pre>
Это точно так же, как и другие передачи, за исключением:
<ul>
<li> Он использует macro параметры к специфичным именам.
<li> он использует VelocityJointInterface.
</ul>
Поскольку колеса фактически будут касаться земли и, таким образом, взаимодействовать с ней физически, мы также указываем некоторую дополнительную информацию о материале, из которого изготовлены колеса.
<pre>
&lt;gazebo reference="${prefix}_${suffix}_wheel"&gt;
      &lt;mu1 value="200.0"/&gt;
      &lt;mu2 value="100.0"/&gt;
      &lt;kp value="10000000.0" /&gt;
      &lt;kd value="1.0" /&gt;
      &lt;material&gt;Gazebo/Grey&lt;/material&gt;
    &lt;/gazebo&gt;</pre>
Посмотрите http://gazebosim.org/tutorials/?tut=ros_urdf для большей информации.
<p>
Мы могли бы указать контроллеры для каждого отдельного колеса, но что в этом интересного? Вместо этого мы хотим управлять всеми колесами вместе. Для этого нам понадобится гораздо больше <a href="https://github.com/ros/urdf_sim_tutorial/blob/master/config/diffdrive.yaml">параметров ROS</a>.
<pre>
type: "diff_drive_controller/DiffDriveController"
  publish_rate: 50

  left_wheel: ['left_front_wheel_joint', 'left_back_wheel_joint']
  right_wheel: ['right_front_wheel_joint', 'right_back_wheel_joint']

  wheel_separation: 0.44

  # Odometry covariances for the encoder output of the robot. These values should
  # be tuned to your robot's sample odometry data, but these values are a good place
  # to start
  pose_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.03]
  twist_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.03]

  # Top level frame (link) of the robot description
  base_frame_id: base_link

  # Velocity and acceleration limits for the robot
  linear:
    x:
      has_velocity_limits    : true
      max_velocity           : 0.2   # m/s
      has_acceleration_limits: true
      max_acceleration       : 0.6   # m/s^2
  angular:
    z:
      has_velocity_limits    : true
      max_velocity           : 2.0   # rad/s
      has_acceleration_limits: true
      max_acceleration       : 6.0   # rad/s^2
</pre>
DiffDriveController подписывается на стандартное сообщение Twist cmd_vel и соответствующим образом перемещает робота.<br>
<b>roslaunch urdf_sim_tutorial 13-diffdrive.launch</b>
<p>
В дополнение к загрузке симуляторов также открывается панель управления роботом, позволяющую вам управлять роботом R2D2, одновременно наблюдая за его реальным поведением (в Gazebo) и визуализируемым поведением (в RViz).<br>
<i>Всё работает</i>
</ol>



















<br><br><br><br><br><br></body></html>
