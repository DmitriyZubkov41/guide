<html><head>
<style>
.menu {
       height: 100%;
       width: 160px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       /*background-color: #111;  Черный */
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  color: #818181;
  display: block;
          }     
.content {
           margin-left: 160px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>URDF документация</title>
<div class="menu">
<a href="#top">Начало</a><br>
<a href="#1">Теги URDF</a><br>
<a href="#begin">Описание простого робота</a><br>
<a href="#joint">Подвижные суставы</a><br>
<a href="#inertia">Противоударные и инерционные свойства</a><br>
<a href="#xacro">XACRO</a><br>
<a href="#gazebo">URDF в Gazebo</a><br>
<a href="#PR2">Understanding the PR2 Robot Description</a><br>
<a href="#example">Пример создания собственного файла urdf</a><br>
<a href="#parse">Parse a urdf file</a><br>
<a href="#publisher">Использование robot state publisher на вашем собственном роботе</a><br>
<a href="#kdl">Start using the KDL parser</a><br>
<a href="#urdf_publisher">Using urdf with robot_state_publisher</a>
</div>
<div class="content" >
<h2 align=center><a name="top">Документация по urdf</h2>
Ссылки: <a href="https://studylib.ru/doc/168370/surcukov-m.m.-vvodnoe-rukovodstvo-po-rabote-s-gazebo---m">Сурцуков М.М. Вводное руководство по работе с Gazebo , М</a><br>
<a href="https://wiki.ros.org/urdf/XML">XML Specifications</a><br>
<a href="http://sdformat.org/spec">SDFormat документация по тегам</a><br>
<a href="https://gazebosim.org/docs/citadel/sdf_worlds/">SDF worlds</a><br>
<a href="https://wiki.ros.org/urdf/Tutorials">urdfTutorials</a><br>
<a href="https://github.com/AntonSHBK/mobile_robot_base_ros1/blob/main/docs/Ru.md">Простая имитационная модель мобильного робота в ROS и Gazebo</a>
<p>
Cуществует два стандарта описания роботов: .sdf и .urdf; первый является более новым и более удобным для использования, поэтому большинство объектов на данный момент существует именно в формате .sdf.
<p>
sdf-файлы пишутся на языке xml (с помощью тегов).
<p>
Описание тегов sdf-формата на официальной странице <a href="http://sdformat.org/spec">SDFormat</a>.
<p>
Тэг link определяет базовый структурный элемент, их может быть несколько в одной модели.<br>
Внутри тэга link тэги:
<ul>
<li> pose в формате xyz rpy для определения позиции относительно начала координат модели, этот тэг используется очень часто и определяет позицию относительно родительского тэга.
<li> <b>collision</b><br>
Может быть много внутри одного линка. Используется  для просчета  столкновений,  в  нем  можно  использовать  как  стандартные примитивы,  так  и  импортировать  модель  форматов  .daeили  .stl.  Здесь  же описываются свойства поверхности вроде трения. Добавив сюда pose можно сдвинуть мэш относительно родительского линка.
<li> <b>visual</b><br>
(их так же может быть много) добавляется для рендеринга, здесь также можно  использовать  как  стандартные  примитивы,  так  и  импортировать модель  форматов  .daeили  .stl.  Здесь  же  добавляются  текстуры. Добавив сюда pos eможно сдвинуть мэш относительно родительского линка
<li> <b>inertial</b><br>
(он  в  линке  один)  описывает  физические  инерциальные  свойства линка: его массу, тензор инерции и т.д. Добавив сюда pose можно сдвинуть координаты центра масс относительно родительского линка.
</ul>
Тэги link, collision, visual обязательно  должны  быть  снабжены  уникальными именами.
<p>
Из <a href="https://habr.com/ru/articles/802069/">Контроллер управления по типу Аккерманна на базе 4-колёсной мобильной платформы (ROS Noetic)</a>:
<p>
<i>Проектируемая конструкция робота URDF должна включать в себя следующие элементы:
<ul>
<li> Соединения для поворота колёс: Для передних колёс, <b>которые поворачиваются для управления направлением</b>, должны быть определены <b>соединения типа revolute, позволяющие вращение вокруг вертикальной оси</b>.
<p>
<li>Суставы для вращения колёс: Все колёса (и передние, и задние) должны иметь соединения, позволяющие им вращаться для имитации движения, тип continuous.
<p>
<li>Трансмиссии (Transmissions): В URDF необходимо описать передачи, соединяющие каждое соединение с соответствующим контроллером в ros-controls. Это включает в себя определение типа актуатора (например, электродвигатель) и метода управления (например, по скорости, позиции или усилию).<br>
...........................<br>
Чтобы добавить трансмиссии для каждого колеса в urdf файл робота, необходимо расширить определение робота, включив в него элементы &lt;transmission&gt;. Эти элементы связывают суставы (&lt;joint&gt;) с актуаторами через интерфейсы hardware_interface, позволяя ros_control управлять физическими или симуляционными актуаторами.<br>
Эти блоки &lt;transmission&gt; добавляются в конец urdf (xacro) файла (в нашем случае xacro), после определений всех суставов (&lt;joint&gt;) и перед закрывающим тегом &lt;/robot&gt;. Они указывают, что для каждого колеса используется своя трансмиссия, связывающая суставы с актуаторами через определенные интерфейсы. Для передних управляемых колес используется PositionJointInterface, что подразумевает управление позицией (углом поворота), а для задних ведущих колес — VelocityJointInterface, управляющий скоростью вращения колес.
</ul></i>



<h3><a href="https://github.com/AntonSHBK/mobile_robot_base_ros1/blob/main/docs/Ru.md">Простая имитационная модель мобильного робота в ROS и Gazebo</a></h3>
Ссылки: <a href="https://wiki.ros.org/urdf/Tutorials">urdfTutorials</a><br>
<a href="https://wiki.ros.org/urdf/Examples">Примеры urdf-файлов</a>
<p>
URDF (Unified Robot Description Format) — это XML-формат, используемый для описания всех аспектов робототехнических систем в ROS. Он описывает физические свойства модели, включая размеры, форму, материалы, а также динамические и кинематические аспекты. URDF обычно используется для статических и неизменяемых описаний.
<p>
<b>XACRO</b> - язык, облегчающий разработку urdf-файлов.<br>
Ссылки: <a href="http://wiki.ros.org/xacro#Tutorials">ros_xacro</a>
<p>
XACRO является расширением URDF и предоставляет возможность создавать более чистые и модульные описания, используя макросы XML для упрощения и повторного использования кода. XACRO улучшает управляемость и поддержку сложных файлов URDF, что делает его идеальным для больших робототехнических систем.
<p>
<b>SDF</b> (Simulation Description Format) — это формат, разработанный специально для описания объектов и сред, используемых в симуляционных программах типа Gazebo. В отличие от URDF, SDF поддерживает описание не только роботов, но и целых сред, динамических свойств объектов, освещения, физики и других аспектов, что делает его особенно подходящим для комплексных симуляций.<br>
Ссылки: <a href="http://sdformat.org/">SDF на сайте Gazebo</a><br>
<a href="https://github.com/osrf/gazebo_models">Примеры моделей SDF</a>
<p>
<b>Инструменты:</b><br>
Инструмент командной строки check_urdf пытается проанализировать файл как описание URDF и либо выводит описание результирующей кинематической цепи, либо сообщение об ошибке.
<p>
Например, чтобы запустить этот инструмент в pr2 urdf, сначала создайте файл urdf, выполнив:<br>
<b>rosrun xacro xacro.py `rospack find pr2_description`/robots/pr2.urdf.xacro -o /tmp/pr2.urdf</b>
<p>
Затем запустите проверку, выполнив команду:<br>
<b>rosrun urdfdom check_urdf /tmp/pr2.urdf</b>
<p>
Visual Studio Code имеет расширение ROS, которое поддерживает визуализацию URDF.<br>
Чтобы получить диаграмму graphviz вашего urdf-файла, выполните следующие действия:<br>
<b>urdf_to_graphiz pr2.urdf</b>
<p>
<b>Создание urdf-файла</b><br>
RDF - это XML, который является текстовым форматом. Таким образом, вы можете создавать файлы в любом текстовом редакторе. Рекомендуется использовать IDE с хорошей поддержкой XML.
<p>
Если уже существует CAD-модель робота, есть несколько инструментов, которые можно использовать для преобразования CAD-модели в URDF. 


<h2>Перевод официальной документации</h2>

<h3 align=center><a name="1" href="https://wiki.ros.org/urdf/XML">Теги urdf</a></h3>
<ul>
<li> <b>Тег &lt;robot&gt;</b><br>
Корневой тег, а все остальные элементы должны быть находиться внутри него.<br>
Атрибут <b>name</b><br>
Главный файл должен иметь атрибут name. Атрибут name необязателен для включаемых файлов. Если имя атрибута указано в дополнительном включаемом файле, оно должно иметь то же значение, что и в главном файле.
<pre>
 &lt;robot name="pr2"&gt;
  &lt;!-- pr2 robot links and joints and more --&gt;
&lt;/robot&gt;</pre>
<li> <b>Тег &lt;link&gt;</b><br>
Элемент link описывает твердое тело, обладающее инерцией, визуальными признаками и свойствами столкновения (inertia, visual features, and collision properties).<br>
Атрибут <b>name</b><br>
является обязательным. Имя самой link.
<p>
Внутренние теги:
<ul>
<li> <b>&lt;inertial&gt;</b> (необязательный: по умолчанию используется нулевая масса и нулевая инерция, если не указано иное).
<ul>
<li> <b>&lt;origin&gt;</b> (необязательно: по умолчанию используется идентификатор, если он не указан. Положение (перемещение, поворот) описывает положение и ориентацию фрейма C (центра масс link'а) относительно фрейма L.)<br>
В <b>&lt;origin&gt;</b> входит<b>xyz</b> (необязательный: по умолчанию используется нулевой вектор. Представляет собой вектор положения от Lo (начало координат (link-frame origin)) до Co (link центра масс) в виде x Lx + y Ly + z Lz, где Lx, Ly, Lz - ортогональные единичные векторы of link-frame L.)<br>
И <b>rpy</b> (необязательный: по умолчанию используется identify)<br>
<li> <b>&lt;mass&gt;</b> Масса link представлена атрибутом <b>value</b> этого элемента<br>
<li> <b>&lt;inertia&gt;</b>
</ul>
<li> <b>&lt;visual&gt;</b> (необязательный)<br>
Визуальные свойства ссылки. Этот элемент определяет форму объекта (прямоугольник, цилиндр и т.д.) для целей визуализации.<br> Примечание: для одной и той же ссылки может существовать несколько экземпляров тегов &lt;visual&gt;. Объединение геометрии, которую они определяют, формирует визуальное представление ссылки.<br>
&nbsp;<b>name</b> (необязательный)<br>
Задает имя для части геометрии ссылки. Это полезно для того, чтобы иметь возможность ссылаться на определенные фрагменты геометрии ссылки.<br>
&nbsp;<b>&lt;origin&gt;</b> (необязательный, используется значение identity, если оно не указано)<br>
Опорная система координат элемента visual по отношению к опорной системе координат link.<br>
&nbsp;&nbsp;<b>xyz</b> (необязательно: по умолчанию используется нулевой вектор)<br>
Представляет собой смещение x, y, z.<br>
&nbsp;&nbsp;<b>rpy</b> (необязательно: по умолчанию используется значение identity, если оно не указано)<br>
Представляет углы roll, pitch and yaw (крена, тангажа и рыскания) по фиксированной оси в радианах<br>
&nbsp;<b>&lt;geometry&gt;</b> (обязательный)<br>
Форма визуального объекта. Это может быть один из следующих вариантов:
<ul>
<li> box
<li> cylinder
<li> sphere
<li> mesh<br>
Элемент trimesh, указанный именем файла, и необязательный масштаб, который масштабирует выровненный по оси ограничивающий прямоугольник сетки. Допускается использование любого геометрического формата, но совместимость с конкретными приложениями зависит от реализации. Для наилучшего сочетания текстур и цветов рекомендуется использовать формат Collada.файлы dae. Файл mesh не передается между компьютерами, использующими одну и ту же модель. Это должен быть локальный файл. В качестве префикса к имени файла укажите package://&lt;имя_пакета&gt;/&lt;путь&gt;, чтобы указать путь к файлу сетки относительно пакета &lt;имя_пакета&gt;.
</ul>
&nbsp;<b>&lt;material&gt;</b> (не обязательный)

<li> <b>&lt;collision&gt;</b> (не обязательный)<br>
Для одной и той же link может существовать несколько экземпляров тегов &lt;collision&gt;.
</ul>

<li> Тег <a href="https://wiki.ros.org/urdf/XML/joint"><b>&lt;joint&gt;</b></a><br>
Внутри тега  &lt;joint&gt; могут быть теги:<br>
<b>&lt;origin&gt;</b><br>
Это преобразование родительской ссылки в дочернюю. Соединение расположено в начале дочернего звена, как показано на рисунке ниже.
<p>
<img src="./images/urdf24.png">
<p>
<b>&lt;axis&gt;</b> (не обязательный: по умолчанию (1,0,0))<br>
Ось соединения, указанная в системе координат соединения. Это ось вращения для поворотных соединений, ось перемещения для призматических соединений и нормаль к поверхности для плоских соединений. Ось указана в системе координат соединения. В неподвижных и плавающих соединениях поле оси не используется.
<p>
<li> Тег <a href="https://wiki.ros.org/urdf/XML/sensor/proposals"><b>&lt;sensor&gt;</b></a>

<li> Тег <a href="https://wiki.ros.org/urdf/XML/Transmission"><b>&lt;transmission&gt;</b></a><br>
Элемент трансмиссии является расширением к модели URDF robot description, которая используется для описания взаимосвязи между приводом и шарниром (actuator and a joint). Это позволяет моделировать такие понятия, как передаточные числа и параллельные соединения (gear ratios and parallel linkages). Трансмиссия преобразует усилия/переменные потока (efforts/flow) таким образом, что их результат - мощность - остается постоянным. Несколько приводов (actuators) могут быть соединены с несколькими joints посредством сложной передачи (transmission).<br>
Пример:
<pre>
&lt;transmission name="simple_trans"&gt;
  &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
  &lt;joint name="foo_joint"&gt;
    &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;
  &lt;/joint&gt;
  &lt;actuator name="foo_motor"&gt;
    &lt;mechanicalReduction&gt;50&lt;/mechanicalReduction&gt;
    &lt;hardwareInterface&gt;EffortJointInterface&lt;/hardwareInterface&gt;
  &lt;/actuator&gt;
&lt;/transmission&gt;</pre>

<li> Тег <a href="https://wiki.ros.org/urdf/XML/model_state"><b>&lt;model_state&gt;</b></a><br>
Практически не используется.
</ul>



<h3 align=center><a  name="begin" href="https://wiki.ros.org/urdf/Tutorials/Building%20a%20Visual%20Robot%20Model%20with%20URDF%20from%20Scratch">Building a Visual Robot Model with URDF from Scratch</a></h3>
В этом уроке мы создадим визуальную модель робота, которая отдаленно напоминает R2D2. В следующих уроках вы узнаете, как сформулировать модель, добавить некоторые физические свойства, сгенерировать более точный код с помощью xacro и заставить его двигаться в Gazebo. Но сейчас мы сосредоточимся на корректировке визуальной геометрии.
<p>
Прежде чем продолжить, убедитесь, что у вас установлен пакет joint_state_publisher. Если вы установили urdf_tutorial с помощью apt-get, это уже должно быть сделано. Если нет, пожалуйста, обновите свою установку, чтобы включить этот пакет (используйте rosdep для проверки).
<p>
<b>docker run --rm -it rosgazebo1 /bin/bash</b><br>
<b>roscd joint_state_publisher</b><br>
<img src="./images/urdf2.png">
<p>
Все модели роботов, упомянутые в этом руководстве (и исходные файлы), можно найти в пакете urdf_tutorial.
<p>
Сначала мы рассмотрим одну простую фигуру в файле 01-myfirst.urdf. Вот, пожалуй, самое простое, что вы можете сделать в формате urdf.:
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot name="myfirst"&gt;
  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
&lt;/robot&gt;</pre>
Если перевести XML на английский, то это робот с именем myfirst, который содержит только одну link (также известную как part), визуальный компонент которой представляет собой цилиндр длиной 0,6 метра и радиусом 0,2 метра. Может показаться, что в этом простом примере типа “hello world” слишком много вложенных тегов, но, поверьте мне, это будет сложнее.
<p>
Чтобы изучить модель, запустите файл:
<p>
<b>passwd</b><br>
<b>/etc/init.d/ssh start</b>
<p>
В другом терминале:<br>
<b>ssh -X root@172.17.0.2</b><br>
<b>roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf</b><br>
<img src="./images/urdf3.png">
<p>
Создаю папку для проектов (рабочую область):<br>
<b>mkdir -p ~/catkin_ws/src</b><br>
<b>cd ~/catkin_ws/</b><br>
<b>catkin_make</b><br>
<b>source devel/setup.bash</b><br>
<b>echo "source ~/catkin_ws/devel/setup.bash" >> ~/.bashrc</b><br>
<b>source ~/.bashrc</b><br>
Проверил:<br>
<b>echo $ROS_PACKAGE_PATH</b><br>
Всё верно: <i>/root/catkin_ws/src:/opt/ros/noetic/share</i><br>
Повторил: <b>roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf</b><br>
<img src="./images/urdf4.png">
<p>
Посмотрел содержимое ~/catkin_ws/src. Есть только turtlebot3_simulations, когда в /opt/ros/noetic/share лежит дохрена каталогов, правда turtlebot3_simulations почему-то нет. Может перезагрузка нужна?<br>
Сохранил изменения в контейнере в новый образ rosurdf<br>
<b>docker commit fe0e4de1668c rosurdf</b>
<p>
Закрыл все терминалы и по-новому:<br>
<b>docker run --rm -it rosurdf /bin/bash</b><br>
<b>passwd</b><br>
<b>/etc/init.d/ssh start</b><br>
Другой терминал: <b>ssh -X root@172.17.0.2</b>
<pre>
root@f9a1a97b3272:~/catkin_ws/src# ls
CMakeLists.txt  turtlebot3_simulations</pre>
Содержимое не изменилось. И <b>roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf</b>, сообщение на команду не изменилось.
<p>
Нашёл ошибку, оказывается roslaunch надо выполнять из каталога urdf_tutorials. Об этом даже чуть ниже у меня написано из перевода документации.
<pre>
<b>roscd urdf_tutorial</b>
<i>root@f9a1a97b3272:/opt/ros/noetic/share/urdf_tutorial#</i> <b>roslaunch urdf_tutorial display.launch model:=urdf/01-myfirst.urdf</b></pre>
<img src="./images/urdf5.png">
<p>
Команда делает три вещи.
<ol>
<li> Загружает указанную модель на сервер параметров
<li> Запускает узлы для публикации sensor_msgs/JointState и преобразований (подробнее об этом позже)
<li> Запускает Rviz с файлом конфигурации
</ol>
Обратите внимание, что приведенная выше строка roslaunch предполагает, что вы запускаете ее из каталога пакетов urdf_tutorial (т.е. каталог urdf является прямым дочерним по отношению к текущему рабочему каталогу). Если это не так, относительный путь к 01-myfirst.urdf будет неверным, и вы получите сообщение об ошибке, как только roslaunch попытается загрузить urdf на сервер параметров.<br>
Слегка измененный аргумент позволяет этому работать независимо от текущего рабочего каталога:<br>
<b>roslaunch urdf_tutorial display.launch model:='$(find urdf_tutorial)/urdf/01-myfirst.urdf'</b><br>
обратите внимание на одинарные кавычки, заключенные в значение аргумента.
<p>
Вам придется изменить все примеры строк roslaunch, приведенные в этих руководствах, если вы не запускаете их из расположения пакета urdf_tutorial.
<p>
<i><font color=red>Все равно непонятно, почему в src только один пакет turtlebot3_simulations, а где остальные?</font></i><br>
Наверное в src находятся только пакеты пользователя.
<p>
На что следует обратить внимание:

fixed frame - это рамка преобразования, в которой расположен центр сетки. Здесь это рамка, определенная нашей единственной ссылкой, base_link.<br>
По умолчанию начало визуального элемента (цилиндра) находится в центре его геометрии. Следовательно, половина цилиндра находится под сеткой.
<h4>Несколько фигур</h4>
Теперь давайте посмотрим, как добавить несколько snapes/links (фигур/ссылок). Если мы просто добавим больше link elements (элементов связи) в urdf, синтаксический анализатор не будет знать, куда их поместить. Поэтому нам придется добавить joints (соединения). Элементы соединения могут относиться как к гибким, так и к негибким соединениям. Мы начнем с негибких, или неподвижных, соединений.
<p>
<b>09.09.2024:</b><br>
<b>docker run --rm -it rosurdf /bin/bash</b><br>
<b>passwd</b><br>
<b>/etc/init.d/ssh start</b>
<p>
Другой терминал:<br>
<b>ssh -X root@172.17.0.2</b><br>
<b>roscd urdf_tutorial<br>
cat urdf/02-multipleshapes.urdf</b>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot name="multipleshapes"&gt;
  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="right_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_right_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="right_leg"/&gt;
  &lt;/joint&gt;

&lt;/robot&gt;
</pre>
Обратите внимание, как мы определили прямоугольник размером 0,6 м х 0,1 м х 0,2 м<br>
Соединение (joint) определяется в терминах родительского (parent) и дочернего(child) элементов. В конечном счете, URDF представляет собой древовидную структуру с одной корневой ссылкой (root link). Это означает, что положение ножки (leg’s position) зависит от положения базовой ссылки (base_link’s position).
<p>
<b>roslaunch urdf_tutorial display.launch model:=urdf/02-multipleshapes.urdf</b>
<p>
<img src="./images/urdf6.png">
<p>
Обе фигуры пересекаются друг с другом, поскольку имеют одну и ту же исходную точку. Если мы хотим, чтобы они не пересекались, мы должны определить больше исходных точек.
<h4>origins:</h4>
Нога R2D2 прикреплена к верхней половине своего туловища сбоку. Итак, именно здесь мы указываем происхождение СОЕДИНЕНИЯ (joint). Кроме того, он крепится не к середине голени, а к верхней части, поэтому мы также должны сместить начало координат для голени. Мы также поворачиваем ногу, чтобы она стояла вертикально.
<p>
Второй терминал подключить удалённо к контейнеру не разрешают, потому закрыл rviz и:<br>
<b>cat urdf/03-origins.urdf</b>
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot name="origins"&gt;
  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;>
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="right_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_right_leg" type="fixed"&gt;>
    &lt;parent link="base_link"/&gt;
    &lt;child link="right_leg"/&gt;
    &lt;origin xyz="0 -0.22 0.25"/&gt;
 &lt;/joint&gt;

&lt;/robot&gt;
</pre>
Давайте начнем с изучения происхождения сустава (joint). Оно определяется в терминах родительской системы отсчета. Таким образом, мы находимся на расстоянии -0,22 метра в направлении y (слева от нас, но справа относительно осей) и 0,25 метра в направлении z (вверх). Это означает, что исходная точка дочерней ссылки будет находиться вверху и справа, независимо от визуального тега (тег visual) исходной точки дочерней ссылки. Поскольку мы не указали атрибут rpy (roll pitch yaw), дочерняя система координат (child frame) по умолчанию будет иметь ту же ориентацию, что и родительская система координат (parent frame).
<p>
Теперь, если посмотреть на визуальное начало отрезка, то оно имеет смещение как по оси xyz, так и по оси rpy. Это определяет, где должен находиться центр визуального элемента относительно его начала координат. Поскольку мы хотим, чтобы нога была прикреплена вверху, мы смещаем начало координат вниз, установив смещение z равным -0,3 метра. И поскольку мы хотим, чтобы длинная часть ноги была параллельна оси z, мы поворачиваем визуальную часть PI/2 вокруг оси Y.
<p>
<b>roslaunch urdf_tutorial display.launch model:=urdf/03-origins.urdf</b>
<p>
<img src="./images/urdf7.png">
<p>
Файл запуска запускает пакеты, которые будут создавать TF-фреймы для каждой link в вашей модели на основе вашего URDF. Rviz использует эту информацию, чтобы определить, где отображать каждую фигуру.<br>
Если TF-кадр не существует для данной link URDF, то он будет помещен в начало координат белым цветом
<h4>Material Girl:</h4>
Мой робот не красный. Давайте рассмотрим тег &lt;material&gt;
<p>
Код urdf/04-materials.urdf:
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot name="materials"&gt;

  &lt;material name="blue"&gt;
    &lt;color rgba="0 0 0.8 1"/&gt;
  &lt;/material&gt;

  &lt;material name="white"&gt;
    &lt;color rgba="1 1 1 1"/&gt;
  &lt;/material&gt;


  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="right_leg"&gt;>
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_right_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="right_leg"/&gt;
    &lt;origin xyz="0 -0.22 0.25"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_left_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="left_leg"/&gt;
    &lt;origin xyz="0 0.22 0.25"/&gt;
  &lt;/joint&gt;

&lt;/robot&gt;
</pre>
Корпус теперь синий. Мы определили новый материал под названием “blue”, для которого красный, зеленый, синий и альфа-каналы определены как 0,0, 0,8 и 1 соответственно. Все значения могут находиться в диапазоне [0,1]. Затем на этот материал ссылается визуальный элемент base_link. Аналогично определяется белый материал
<p>
Можно также тег material определять внутри тега visual и даже ссылаться на него в других links.
<p>
Вы также можете использовать текстуру, чтобы указать файл изображения, который будет использоваться для раскрашивания объекта.
<p>
<b>roslaunch urdf_tutorial display.launch model:=urdf/04-materials.urdf</b>
<p>
<img src="./images/urdf8.png">

<h4>Конечная модель</h4>
Теперь мы дополним модель еще несколькими фигурами: ногами, колесами и головой. В частности, мы добавим сферу и несколько сеток (meshes). Мы также добавим несколько других деталей, которые будем использовать позже.
<p>
Код urdf/05-visual.urdf:
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot name="visual"&gt;

&lt;material name="blue"&gt;
    &lt;color rgba="0 0 0.8 1"/&gt;
  &lt;/material&gt;
  &lt;material name="black"&gt;
    &lt;color rgba="0 0 0 1"/&gt;
  &lt;/material&gt;
  &lt;material name="white"&gt;
    &lt;color rgba="1 1 1 1"/&gt;
  &lt;/material&gt;

  &lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="right_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_right_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="right_leg"/&gt;
    &lt;origin xyz="0 -0.22 0.25"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_base"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.4 0.1 0.1"/&gt;
      &lt;/geometry&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="right_base_joint" type="fixed"&gt;
    &lt;parent link="right_leg"/&gt;
    &lt;child link="right_base"/&gt;
    &lt;origin xyz="0 0 -0.6"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_front_wheel"&gt;
    &lt;visual&gt;
      &lt;origin rpy="1.57075 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.1" radius="0.035"/&gt;
      &lt;/geometry&gt;
      &lt;material name="black"/&gt;
      &lt;origin rpy="0 0 0" xyz="0 0 0"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="right_front_wheel_joint" type="fixed"&gt;
    &lt;parent link="right_base"/&gt;
    &lt;child link="right_front_wheel"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.133333333333 0 -0.085"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_back_wheel"&gt;
    &lt;visual&gt;
      &lt;origin rpy="1.57075 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.1" radius="0.035"/&gt;
      &lt;/geometry&gt;
      &lt;material name="black"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="right_back_wheel_joint" type="fixed"&gt;
    &lt;parent link="right_base"/&gt;
    &lt;child link="right_back_wheel"/&gt;
    &lt;origin rpy="0 0 0" xyz="-0.133333333333 0 -0.085"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_leg"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.6 0.1 0.2"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0" xyz="0 0 -0.3"/&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="base_to_left_leg" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="left_leg"/&gt;
    &lt;origin xyz="0 0.22 0.25"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_base"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.4 0.1 0.1"/&gt;
      &lt;/geometry&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="left_base_joint" type="fixed"&gt;
    &lt;parent link="left_leg"/&gt;
    &lt;child link="left_base"/&gt;
    &lt;origin xyz="0 0 -0.6"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_front_wheel"&gt;
    &lt;visual&gt;
      &lt;origin rpy="1.57075 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.1" radius="0.035"/&gt;
      &lt;/geometry&gt;
      &lt;material name="black"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="left_front_wheel_joint" type="fixed"&gt;
    &lt;parent link="left_base"/&gt;
    &lt;child link="left_front_wheel"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.133333333333 0 -0.085"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_back_wheel"&gt;
    &lt;visual&gt;
      &lt;origin rpy="1.57075 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.1" radius="0.035"/&gt;
      &lt;/geometry&gt;
      &lt;material name="black"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="left_back_wheel_joint" type="fixed"&gt;
    &lt;parent link="left_base"/&gt;
    &lt;child link="left_back_wheel"/&gt;
    &lt;origin rpy="0 0 0" xyz="-0.133333333333 0 -0.085"/&gt;
  &lt;/joint&gt;

  &lt;joint name="gripper_extension" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="gripper_pole"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.19 0 0.2"/&gt;
  &lt;/joint&gt;

  &lt;link name="gripper_pole"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.2" radius="0.01"/&gt;
      &lt;/geometry&gt;
      &lt;origin rpy="0 1.57075 0 " xyz="0.1 0 0"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="left_gripper_joint" type="fixed"&gt;
    &lt;origin rpy="0 0 0" xyz="0.2 0.01 0"/&gt;
    &lt;parent link="gripper_pole"/&gt;
    &lt;child link="left_gripper"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_gripper"&gt;
    &lt;visual&gt;
      &lt;origin rpy="0.0 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;mesh filename="package://urdf_tutorial/meshes/l_finger.dae"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="left_tip_joint" type="fixed"&gt;
    &lt;parent link="left_gripper"/&gt;
    &lt;child link="left_tip"/&gt;
  &lt;/joint&gt;

  &lt;link name="left_tip"&gt;
    &lt;visual&gt;
      &lt;origin rpy="0.0 0 0" xyz="0.09137 0.00495 0"/&gt;
      &lt;geometry&gt;
        &lt;mesh filename="package://urdf_tutorial/meshes/l_finger_tip.dae"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="right_gripper_joint" type="fixed"&gt;
    &lt;origin rpy="0 0 0" xyz="0.2 -0.01 0"/&gt;
    &lt;parent link="gripper_pole"/&gt;
    &lt;child link="right_gripper"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_gripper"&gt;
    &lt;visual&gt;
      &lt;origin rpy="-3.1415 0 0" xyz="0 0 0"/&gt;
      &lt;geometry&gt;
        &lt;mesh filename="package://urdf_tutorial/meshes/l_finger.dae"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="right_tip_joint" type="fixed"&gt;
    &lt;parent link="right_gripper"/&gt;
    &lt;child link="right_tip"/&gt;
  &lt;/joint&gt;

  &lt;link name="right_tip"&gt;
    &lt;visual&gt;
      &lt;origin rpy="-3.1415 0 0" xyz="0.09137 0.00495 0"/&gt;
      &lt;geometry&gt;
        &lt;mesh filename="package://urdf_tutorial/meshes/l_finger_tip.dae"/&gt;
      &lt;/geometry&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;link name="head"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;sphere radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="white"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;
  &lt;joint name="head_swivel" type="fixed"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="head"/&gt;
    &lt;origin xyz="0 0 0.3"/&gt;
  &lt;/joint&gt;

  &lt;link name="box"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;box size="0.08 0.08 0.08"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"/&gt;
    &lt;/visual&gt;
  &lt;/link&gt;

  &lt;joint name="tobox" type="fixed"&gt;
    &lt;parent link="head"/&gt;
    &lt;child link="box"/&gt;
    &lt;origin xyz="0.1814 0 0.1414"/&gt;
  &lt;/joint&gt;
&lt;/robot&gt;
</pre>
<img src="./images/urdf9.png">
<p>
<img src="./images/urdf10.png">
<p>
Приведенные здесь сетки (meshes) были позаимствованы из PR2. Это отдельные файлы, для которых вы должны указать путь. Вам следует использовать обозначение package://NAME_OF_PACKAGE/path. Сетки для этого учебного пособия находятся в пакете urdf_tutorial, в папке под названием meshes.
<p>
Сетки могут быть импортированы в различных форматах. Довольно часто используется STL, но движок также поддерживает DAE, который может содержать собственные цветовые данные, что означает, что вам не нужно указывать цвет/материал. Часто они хранятся в отдельных файлах. Эти сетки ссылаются на файлы .tif, также находящиеся в папке meshes.
<p>
Размер сеток также может быть определен с помощью относительных параметров масштабирования или ограничивающего прямоугольника.
<p>
Мы могли бы также сослаться на сетки в совершенно другом пакете, т.е. package://pr2_description/meshes/gripper_v0/l_finger.dae, который будет работать, если установлен пакет pr2_description.

<h3 align=center><a name="joint" href="https://wiki.ros.org/urdf/Tutorials/Building%20a%20Movable%20Robot%20Model%20with%20URDF">Building a Movable Robot Model with URDF</a></h3>
В этом учебнике мы изменим модель R2D2, так чтобы он имел подвижные суставы (joints). Мы рассмотрим 3 других важных типа суставов: continuous, revolute и prismatic.
<p>
urdf-файл с подвижными суставами находится в urdf/06-flexible.urdf
<p>
Чтобы визуализировать эту модель и управлять ею, запустите ту же команду, что и в предыдущем руководстве:<br>
<b>roslaunch urdf_tutorial display.launch model:=urdf/06-flexible.urdf</b><br>
однако теперь также появится графический интерфейс, который позволит вам управлять значениями всех нефиксированных соединений. Поиграйте с моделью и посмотрите, как она движется. Затем мы сможем взглянуть на то, как мы этого добились.
<ol>
<li> Head:
<pre>
&lt;joint name="head_swivel" type="continuous"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="head"/&gt;
    &lt;axis xyz="0 0 1"/&gt;
    &lt;origin xyz="0 0 0.3"/&gt;
  &lt;/joint&gt;
</pre>
Соединение между туловищем и головой является непрерывным, что означает, что оно может поворачиваться под любым углом от отрицательной до положительной бесконечности. Колеса также смоделированы таким образом, что они могут вращаться в обоих направлениях бесконечно.
<p>
Единственная дополнительная информация, которую мы должны добавить, - это ось вращения, здесь она задается триплетом xyz, который определяет вектор, вокруг которого будет вращаться голова. Поскольку мы хотим, чтобы она вращалась вокруг оси z, мы задаем вектор "0 0 1".
<li> The Gripper
<pre>
&lt;joint name="left_gripper_joint" type="revolute"&gt;
    &lt;axis xyz="0 0 1"/&gt;
    &lt;limit effort="1000.0" lower="0.0" upper="0.548" velocity="0.5"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.2 0.01 0"/&gt;
    &lt;parent link="gripper_pole"/&gt;
    &lt;child link="left_gripper"/&gt;
&lt;/joint&gt;
</pre>
Как правое, так и левое захватные соединения (gripper joints) выполнены в виде поворотных соединений. Это означает, что они вращаются так же, как и неразъемные соединения, но имеют строгие ограничения. Следовательно, мы должны указать верхний и нижний пределы соединения (в радианах). Мы также должны указать максимальную скорость и усилие для этого соединения, но фактические значения не имеют значения для наших целей.
<li> The Gripper Arm
<pre>
&lt;joint name="gripper_extension" type="prismatic"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="gripper_pole"/&gt;
    &lt;limit effort="1000.0" lower="-0.38" upper="0" velocity="0.5"/&gt;
    &lt;origin rpy="0 0 0" xyz="0.19 0 0.2"/&gt;
  &lt;/joint&gt;</pre>
 Захватный рычаг (gripper arm) - это другой тип шарнира, а именно призматический шарнир. Это означает, что он перемещается вдоль оси, а не вокруг нее. Именно это поступательное движение позволяет нашей модели робота выдвигать и втягивать свой захватный рычаг.
<p>
Пределы призматического рычага задаются таким же образом, как и для поворотного шарнира, за исключением того, что единицами измерения являются метры, а не радианы.
<li> Other Types of Joints<br>
Существуют два других вида соединений, которые перемещаются в пространстве. В то время как призматическое соединение может перемещаться только в одном измерении, плоское соединение может перемещаться в плоскости или в двух измерениях. Кроме того, плавающее соединение не имеет ограничений и может перемещаться в любом из трех измерений. Эти соединения не могут быть заданы только одним номером и поэтому не включены в данное руководство.
<li> Specifying the Pose<br>
Когда вы перемещаете ползунки в графическом интерфейсе, модель перемещается в Rviz. Как это делается? Сначала графический интерфейс анализирует URDF и находит все нефиксированные соединения и их границы. Затем он использует значения ползунков для публикации сообщений sensor_msgs/JointState. Затем они используются robot_state_publisher для вычисления всех преобразований между различными частями. Полученное дерево преобразований затем используется для отображения всех фигур в Rviz.
<li> Теперь, когда у вас есть наглядно функциональная модель, вы можете добавить некоторые физические свойства или начать использовать xacro для упрощения вашего кода.
</ol>



<h3 align=center><a name="inertia" href="https://wiki.ros.org/urdf/Tutorials/Adding%20Physical%20and%20Collision%20Properties%20to%20a%20URDF%20Model">Adding Physical and Collision Properties to a URDF Model</a></h3>
Узнайте, как придать звеньям противоударные и инерционные свойства, а также как придать сочленениям динамику.
<ol>
<li> Collision<br>
До сих пор мы задавали наши ссылки только с помощью одного подэлемента, visual, который определяет (что неудивительно), как выглядит робот. Однако, чтобы заставить работать функцию обнаружения столкновений или имитировать робота в чем-то вроде Gazebo, нам также нужно определить элемент столкновения.<br>
Файл urdf/07-physics.urd с collision и физическими свойствами.
<pre>
&lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"&gt;
        &lt;color rgba="0 0 .8 1"/&gt;
      &lt;/material&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
  &lt;/link&gt;</pre>
Тег collision является прямым подэлементом объекта link, находящимся на том же уровне, что и тег visual.<br>
Элемент collision определяет свою форму так же, как и визуальный элемент, с помощью тега geometry. Формат тега geometry здесь точно такой же, как и в визуальном элементе.<br>
Вы также можете указать источник таким же образом, как и подэлемент тега коллизии (как в случае с визуальным элементом).
<p>
Во многих случаях вам захочется, чтобы геометрия столкновения и начало координат в точности совпадали с визуальной геометрией и началом координат. Однако есть два основных случая, когда этого делать не следует.
<ol>
<li> Quicker Processing (Более быстрая обработка) - обнаружение коллизий для двух сеток требует гораздо больших вычислительных затрат, чем для двух простых геометрий. Следовательно, вы можете захотеть заменить сетки более простыми геометриями в элементе collision.
<li>Safe Zones Безопасные зоны - возможно, вы захотите ограничить передвижение вблизи чувствительного оборудования. Например, если мы не хотим, чтобы что-либо столкнулось с головой R2D2, мы могли бы определить геометрию столкновения как цилиндр, охватывающий его голову, чтобы предотвратить попадание чего-либо слишком близко к его голове.
</ol>
<li> Physical Properties<br>
Чтобы ваша модель работала должным образом, вам необходимо определить несколько физических свойств вашего робота, то есть свойств, которые потребовались бы физическому движку, такому как Gazebo
<p>
<b>Инерция</b><br>
Для каждого моделируемого элемента связи требуется тег inertial. Вот простой тег:
<pre>
&lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"&gt;
        &lt;color rgba="0 0 .8 1"/&gt;
      &lt;/material&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
    &lt;inertial&gt;
      &lt;mass value="10"/&gt;
      &lt;inertia ixx="0.4" ixy="0.0" ixz="0.0" iyy="0.4" iyz="0.0" izz="0.2"/&gt;
    &lt;/inertial&gt;
  &lt;/link&gt;ision&gt;
  &lt;/link&gt;
</pre>
<ul>
<li> Этот элемент также является подэлементом объекта link.
<li> Масса определяется в килограммах.
<li> Матрица инерции вращения 3х3 задается с помощью элемента инерции. Поскольку она симметрична, то может быть представлена только 6 элементами, как таковыми.<br>
<img src="./images/urdf11.png">
<li> Эта информация может быть предоставлена вам с помощью программ моделирования, таких как MeshLab. Инерция геометрических примитивов (цилиндр, прямоугольник, сфера) может быть вычислена с использованием списка тензоров момента инерции в Википедии (и используется в приведенном выше примере).
<li> Тензор инерции зависит как от массы, так и от распределения массы объекта. Хорошим первым приближением является предположение о равном распределении массы по объему объекта и вычисление тензора инерции на основе формы объекта, как описано выше.
<li> сли вы не уверены, что именно установить, то матрица с ixx/iyy/izz=1e-3 или меньше часто является разумным выбором по умолчанию для линков среднего размера (это соответствует коробке с длиной стороны 0,1 м и массой 0,6 кг). Идентификационная матрица - особенно неудачный выбор, поскольку она часто бывает слишком высокой (она соответствует коробке с длиной стороны 0,1 м и массой 600 кг!).
<li> Вы также можете указать исходный тег, чтобы указать центр тяжести и инерциальную систему отсчета (относительно системы отсчета ссылки).
<li> При использовании контроллеров реального времени нулевые (или почти нулевые) инерционные элементы могут привести к тому, что модель робота рухнет без предупреждения, и все ссылки будут отображаться так, чтобы их происхождение совпадало с мировым происхождением.
</ul>
<p>
<b>Contact Coefficients</b><br>
Вы также можете определить, как ведут себя ссылки, когда они соприкасаются друг с другом. Для этого используется подэлемент тега collision, называемый contact_coefficients. Необходимо указать три атрибута:
<ul>
<li> mu - Friction coefficient
<li> kp - Stiffness coefficient
<li> kd - Dampening coefficient
</ul>
<p>
<b>Joint Dynamics</b><br>
То, как движется сустав, определяется тегом dynamics для этого сустава. Здесь есть два атрибута:
<ul>
<li> friction - физическое статическое трение. Для призматических соединений единицами измерения являются ньютоны. Для вращающихся соединений единицами измерения являются ньютон-метры.
<li> damping - величина физического демпфирования. Для призматических соединений единицами измерения являются Ньютон-секунды на метр. Для вращающихся шарниров - ньютон-метровые секунды на радиан.
</ul>
Если этот параметр не указан, то по умолчанию эти коэффициенты равны нулю.
<li> Другие теги<br>
В области чистого URDF (т.е. без учета тегов, относящихся к Gazebo), остаются два тега, которые помогают определить соединения: тег calibration и тег safety controller. Ознакомьтесь со <a href="https://wiki.ros.org/urdf/XML/joint">спецификацией</a>, поскольку они не включены в это руководство.
</ol>




<h3 align=center><a name="xacro" href="https://wiki.ros.org/urdf/Tutorials/Using%20Xacro%20to%20Clean%20Up%20a%20URDF%20File">Using Xacro to Clean Up a URDF File</a></h3>
Узнайте несколько приемов, позволяющих уменьшить объем кода в URDF-файле с помощью Xacro.
<p>
К настоящему времени, если вы выполняете все эти действия дома, создавая собственного робота, вам, возможно, надоест заниматься всевозможными математическими расчетами, чтобы получить очень простые описания роботов для правильного анализа. К счастью, вы можете использовать пакет xacro, чтобы упростить себе жизнь. Он делает три вещи, которые очень полезны:
<ul>
<li> Constants
<li> Simple Math
<li> Macros
</ul>
В этом руководстве мы рассмотрим все эти сочетания клавиш, которые помогут уменьшить общий размер файла URDF и упростят его чтение и обслуживание.
<p>
<b>1. Using Xacro</b><br>
Как следует из названия, xacro - это макроязык для XML. Программа xacro запускает все макросы и выдает результат. Типичное использование выглядит примерно так:<br>
<b>xacro --inorder model.xacro > model.urdf</b><br>
В дистрибутивах ROS melodic и более поздних версиях вам следует опустить аргумент {--inorder}.
<p>
Вы также можете автоматически сгенерировать urdf в файле запуска. Это удобно, поскольку он постоянно обновляется и не занимает место на жестком диске. Однако для создания этого файла требуется время, поэтому имейте в виду, что запуск файла запуска может занять больше времени. (Я смотрю на твое описание pr2_description):
<pre>
&lt;param name="robot_description"
  command="xacro --inorder '$(find pr2_description)/robots/pr2.urdf.xacro'" /&gt;</pre>
В верхней части файла URDF необходимо указать пространство имен (namespace), чтобы файл был правильно обработан. Например, это первые две строки правильного файла xacro:
<pre>
&lt;?xml version="1.0"?&gt;
&lt;robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="firefighter"&gt;
</pre>
<b>2. Constants</b><br>
Давайте бегло взглянем на наш base_link в R2D2:
<pre>
&lt;link name="base_link"&gt;
    &lt;visual&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
      &lt;material name="blue"/&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
      &lt;geometry&gt;
        &lt;cylinder length="0.6" radius="0.2"/&gt;
      &lt;/geometry&gt;
    &lt;/collision&gt;
  &lt;/link&gt;
  </pre>
Приведенная здесь информация немного избыточна. Мы указываем длину и радиус цилиндра дважды. Что еще хуже, если мы хотим изменить это, нам нужно сделать это в двух разных местах.
<p>
К счастью, xacro позволяет вам указывать свойства, которые действуют как константы. Вместо приведенного выше кода мы можем написать этот:
<pre>
&lt;xacro:property name="width" value="0.2" /&gt;
&lt;xacro:property name="bodylen" value="0.6" /&gt;
&lt;link name="base_link"&gt;
    &lt;visual&gt;
        &lt;geometry&gt;
            &lt;cylinder radius="${width}" length="${bodylen}"/&gt;
        &lt;/geometry&gt;
        &lt;material name="blue"/&gt;
    &lt;/visual&gt;
    &lt;collision&gt;
        &lt;geometry&gt;
            &lt;cylinder radius="${width}" length="${bodylen}"/&gt;
        &lt;/geometry&gt;
    &lt;/collision&gt;
&lt;/link&gt;
</pre>
<ul>
<li> Эти два значения указаны в первых двух строках. Они могут быть определены практически в любом месте (при условии корректного XML), на любом уровне, до или после их использования. Обычно они располагаются вверху.
<li> Вместо определения радиуса в теге geometry, мы используем знак доллара и скобки {}, чтобы вставить значение радиуса.
<li> Этот код сгенерирует тот же код, что и показанный выше.
</ul>
Значение содержимого ${} construct are then used to replace the ${}. This means you can combine it with other text in the attribute.
<pre>
&lt;xacro:property name=”robotname” value=”marvin” /&gt;
&lt;link name=”${robotname}s_leg” /&gt;
</pre>
Будет сгенерирован:
<pre>
&lt;link name=”marvins_leg” /&gt;
</pre>
However, the contents in the ${} don’t have to only be a property, which brings us to our next point...
<p>
<b>3. Математика</b><br>
Вы можете создавать сколь угодно сложные выражения в конструкции ${}, используя четыре основные операции (+,-,*,/), унарный минус и круглые скобки. Примеры:
<pre>
&lt;cylinder radius="${wheeldiam/2}" length="0.1"/&gt;
&lt;origin xyz="${reflect*(width+.02)} 0 0.25" /&gt;
</pre>
Все в математике использует числа с плавающей точкой, следовательно:
<p>
&lt;link name="${5/6}"/&gt;
<p>
вычисляется как:
<p>
&lt;link name="0.833333333333"/&gt;
<p>
В Jade и более поздних дистрибутивах вы можете использовать не только перечисленные выше базовые операции, в частности sin и cos.
<p>
<b>4. Macros</b><br>
Здесь самый большой и полезный компонент пакета xacro.
<ol>
<li> Simple Macro<br>
Давайте рассмотрим простое использование macro.
<pre>
&lt;xacro:macro name="default_origin"&gt;
    &lt;origin xyz="0 0 0" rpy="0 0 0"/&gt;
&lt;/xacro:macro&gt;
&lt;xacro:default_origin /&gt;
</pre>
(This is useless, since if the origin is not specified, it has the same value as this.) Будет сгенерирован следующий код:
<pre>&lt;origin rpy="0 0 0" xyz="0 0 0"/&gt;</pre>
<ul>
<li> Технически name не является обязательным элементом, но вам необходимо указать его, чтобы иметь возможность его использовать.
<li> Каждая вставка &lt;xacro:$NAME /&gt; заменяется содержимым тега xacro:macro
<li> Обратите внимание, что даже при том, что это не совсем одно и то же (два атрибута поменялись местами), сгенерированный XML эквивалентен
<li> Если xacro с указанным именем не найден, он не будет развернут и не выдаст ошибку.
</ul><p>
<li> Parameterized Macro<br>
Вы также можете настроить параметры макросов, чтобы они не генерировали каждый раз один и тот же текст. В сочетании с математическими функциями это еще более эффективно.
<p>
Для начала давайте рассмотрим пример простого макроса, используемого в R2D2.
<pre>
&lt;xacro:macro name="default_inertial" params="mass"&gt;
        &lt;inertial&gt;
                &lt;mass value="${mass}" /&gt;
                &lt;inertia ixx="1.0" ixy="0.0" ixz="0.0"
                     iyy="1.0" iyz="0.0"
                     izz="1.0" /&gt;
        &lt;/inertial&gt;
    &lt;/xacro:macro&gt;
</pre>
Это может быть использовано с кодом:<br>
&lt;xacro:default_inertial mass="10"/&gt;<br>
Параметры действуют точно так же, как свойства, и вы можете использовать их в выражениях
<p>
Вы также можете использовать целые блоки в качестве параметров:
<pre>
&lt;xacro:macro name="blue_shape" params="name *shape"&gt;
    &lt;link name="${name}"&gt;
        &lt;visual&gt;
            &lt;geometry&gt;
                &lt;xacro:insert_block name="shape" /&gt;
            &lt;/geometry&gt;
            &lt;material name="blue"/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;xacro:insert_block name="shape" /&gt;
            &lt;/geometry&gt;
        &lt;/collision&gt;
    &lt;/link&gt;
&lt;/xacro:macro&gt;

&lt;xacro:blue_shape name="base_link"&gt;
    &lt;cylinder radius=".42" length=".01" /&gt;
&lt;/xacro:blue_shape&gt;
</pre>
<ul>
<li> Чтобы указать параметр блока, поставьте звездочку перед его именем.
<li> Блок может быть вставлен с помощью команды insert_block
<li> Вставляйте блок столько раз, сколько пожелаете
</ul>
</ol>
<p>
<b>5. Practical Usage</b><br>
Язык xacro достаточно гибок в том, что он позволяет вам делать. Вот несколько полезных способов использования xacro в модели R2D2, в дополнение к инерционному макросу по умолчанию, показанному выше.
<p>
Чтобы увидеть модель, сгенерированную с помощью файла xacro, запустите ту же команду, что и в предыдущих руководствах:
<p>
<b>roslaunch urdf_tutorial display.launch model:=urdf/08-macroed.urdf.xacro</b>
<p>
(Все это время в файле запуска выполнялась команда xacro, но поскольку макросов для расширения не было, это не имело значения)
<ol>
<li> Leg macro<br>
Часто требуется создать несколько похожих объектов в разных местах. Часто требуется обеспечить некоторую симметрию в расположении. Вы можете использовать макрос и простую математику, чтобы сократить объем кода, который вам нужно написать, как мы делаем с двумя ногами R2.
<pre>
&lt;xacro:macro name="leg" params="prefix reflect"&gt;
    &lt;link name="${prefix}_leg"&gt;
        &lt;visual&gt;
            &lt;geometry&gt;
                &lt;box size="${leglen} 0.1 0.2"/&gt;
            &lt;/geometry&gt;
            &lt;origin xyz="0 0 -${leglen/2}" rpy="0 ${pi/2} 0"/&gt;
            &lt;material name="white"/&gt;
        &lt;/visual&gt;
        &lt;collision&gt;
            &lt;geometry&gt;
                &lt;box size="${leglen} 0.1 0.2"/&gt;
            &lt;/geometry&gt;
            &lt;origin xyz="0 0 -${leglen/2}" rpy="0 ${pi/2} 0"/&gt;
        &lt;/collision&gt;
        &lt;xacro:default_inertial mass="10"/&gt;
    &lt;/link&gt;

    &lt;joint name="base_to_${prefix}_leg" type="fixed"&gt;
        &lt;parent link="base_link"/&gt;
        &lt;child link="${prefix}_leg"/&gt;
        &lt;origin xyz="0 ${reflect*(width+.02)} 0.25" /&gt;
    &lt;/joint&gt;
    &lt;!-- A bunch of stuff cut --&gt;
&lt;/xacro:macro&gt;
&lt;xacro:leg prefix="right" reflect="1" /&gt;
&lt;xacro:leg prefix="left" reflect="-1" /&gt;
</pre>
<ul>
<li> Обычный трюк 1: Используйте имя prefix, чтобы получить два объекта с одинаковыми именами.
<li> Обычная хитрость 2: Используйте математику для расчета начала соединения. В случае, если вы меняете размер вашего робота, изменение свойства с помощью математических методов для расчета смещения соединения избавит вас от многих проблем.
<li> Обычный трюк № 3: Используйте параметр reflect и установите для него значение 1 или -1. Посмотрите, как мы используем параметр reflect, чтобы расположить ноги по обе стороны от тела в исходной точке base_to_${префикс}_leg.
</ul>
<li> Другие уловки<br>
Не стесняйтесь добавлять сюда свои собственные трюки.
</ol>




<h3 align=center><a name="gazebo" href="https://wiki.ros.org/urdf/Tutorials/Using%20a%20URDF%20in%20Gazebo">URDF в Gazebo</a></h3>
Предварительное руководство о том, как создавать своего робота и управлять им в Gazebo.
<p>
Пожалуйста, скачайте руководство по моделированию URDF с github или с помощью aptitude, например, для ROS kinetic:
<p>
<b>sudo apt-get install ros-kinetic-urdf-sim-tutorial</b>
<p>
Я (10.09.2024):<br>
Стандартные команды для выполнения графических программ на локальном компьютере с удаленного контейнера:<br>
docker run --rm -it rosurdf /bin/bash<br>
passwd<br>
/etc/init.d/ssh start
<p>
Другой терминал:<br>
ssh -X root@172.17.0.2
<p>
Теперь скачиваю учебник:
<p>
sudo apt-get install ros-noetic-urdf-sim-tutorial
<p>
Уже был установлен этот учебник.<br>
Где именно установлен этот urdf-sim-tutorial, не нашёл. Ладно, не важно.<br>
<font color=brown>Нашёл, пакет называется urdf_sim_tutorial и находится он в /opt/ros/noetic/share/</font>
<ol>
<li> <b>Nonfunctional Gazebo Interface</b><br>
Мы можем создать модель, которую мы уже создали, в Gazebo, используя gazebo.launch:<br>
<b>roslaunch urdf_sim_tutorial gazebo.launch</b>
<p>
Я:<br>
cd root/catkin_ws
catkin_make
<p>
Проверил, в папке src ничего не изменилось, только пакет turtlebot3_simulations. После:
<p>
<b>roslaunch urdf_sim_tutorial gazebo.launch</b>
<p>
Сообщения:
<pre>[ WARN] [1725956442.259207689]: The root link base_link has an inertia specified in the URDF, but KDL does not support a 
root link with an inertia.  As a workaround, you can add an extra dummy link to your URDF.</pre>
Видимо из-за того, что gazebo не поддерживает urdf, потому некоторые моменты типа инерции не будет выполнять.
<p>
<img src="./images/urdf12.png">
<p>
 Этот файл запуска:
<ul>
<li> Загружает urdf из <a href="https://wiki.ros.org/urdf/Tutorials/Using%20Xacro%20to%20Clean%20Up%20a%20URDF%20File">руководства по макросам</a> в описание параметра (parameter description).
<li> Запускает пустой gazebo мир world
<li> Запускает скрипт для считывания urdf из параметра и создания его в gazebo.
</ul>
Однако он ничего не делает, и в нем отсутствует много ключевой информации, необходимой ROS для использования этого робота. Ранее мы использовали joint_state_publisher для указания положения каждого сустава. Однако робот сам должен предоставлять эту информацию в реальном мире или в gazebo. Однако, не уточняя этого, Gazebo не знает, публиковать ли эту информацию.
<p>
Чтобы сделать робота интерактивным (с вами и ROS), нам нужно указать две вещи: плагины и передачи )Plugins and Transmissions).
<p>
<li> <b>Gazebo Plugin</b><br>
Чтобы заставить ROS взаимодействовать с Gazebo, мы должны динамически подключиться к библиотеке ROS, которая будет указывать Gazebo, что делать. Теоретически это позволяет другим операционным системам роботов взаимодействовать с Gazebo обычным способом. На практике это просто ROS.
<p>
Чтобы связать Gazebo и ROS, мы указываем плагин в URDF, прямо перед закрывающим тегом &lt;/robot&gt;:
<pre>
&lt;gazebo&gt;
    &lt;plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so"&gt;
      &lt;robotNamespace&gt;/&lt;/robotNamespace&gt;
    &lt;/plugin&gt;
  &lt;/gazebo&gt;</pre>
Вы можете увидеть это в https://github.com/ros/urdf_sim_tutorial/blob/master/urdf/09-publishjoints.urdf.xacro и, запустив:<br>
<b>roslaunch urdf_sim_tutorial gazebo.launch model:=urdf/09-publishjoints.urdf.xacro</b>
<p>
Однако это пока не принесет ничего нового. Для этого нам нужно указать больше информации за пределами URDF
<p>
<li> <b>Spawning Controllers</b><br>
Теперь, когда мы связали ROS и Gazebo, нам нужно указать некоторые фрагменты кода ROS, которые мы хотим запустить в Gazebo, которые мы обычно называем контроллерами. Изначально они загружаются в пространство параметров ROS. У нас есть <a href="https://github.com/ros/urdf_sim_tutorial/blob/master/config/joints.yaml">yaml-файл joints.yaml</a>, который определяет наш первый контроллер.
<pre>
type: "joint_state_controller/JointStateController"
publish_rate: 50</pre>
Этот контроллер находится в пакете joint_state_controller и публикует состояние суставов робота в ROS непосредственно из Gazebo.
<p>
В <a href="https://github.com/ros/urdf_sim_tutorial/blob/master/launch/09-joints.launch">09-joints.launch</a> вы можете увидеть, как мы должны загрузить этот yaml-файл в namespace r2d2_joint_state_controller. Затем мы вызываем скрипт [[controller_manager]]/spawner с namespace, который загружает его в Gazebo.
<p>
Вы можете запустить его, но он все еще не совсем готов: <b>roslaunch urdf_sim_tutorial 09-joints.launch</b>
<br>Это запустит контроллер и фактически опубликует его в разделе /joint_states .... но в нём ничего не будет.
<pre>
header:
  seq: 652
  stamp:
    secs: 13
    nsecs: 331000000
  frame_id: ''
name: []
position: []
velocity: []
effort: []</pre>
Что еще вам нужно для gazebo? Ну, он хочет знать, о каких joints публиковать информацию.
<p>
<li> <b>Transmissions</b><br>
Для каждого нефиксированного соединения нам нужно указать передачу (transmission), которая сообщает Gazebo, что делать с соединением. Давайте начнем с головного соединения. Добавьте в свой URDF следующее:
<pre>
&lt;transmission name="head_swivel_trans"&gt;
    &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
    &lt;actuator name="$head_swivel_motor"&gt;
      &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
    &lt;/actuator&gt;
    &lt;joint name="head_swivel"&gt;
      &lt;hardwareInterface&gt;hardware_interface/PositionJointInterface&lt;/hardwareInterface&gt;
    &lt;/joint&gt;
  &lt;/transmission&gt;
</pre>
Для ознакомления просто рассмотрите большую часть этого фрагмента кода как стандартный.<br>
Первое, на что следует обратить внимание, - это элемент joint. Имя должно соответствовать объявленному ранее joint.<br>
Аппаратный интерфейс будет важен при изучении плагинов.
<p>
Вы можете запустить этот URDF с нашей предыдущей конфигурацией запуска:<br>
<b>roslaunch urdf_sim_tutorial 09-joints.launch model:=urdf/10-firsttransmission.urdf.xacro</b>
<p>
Открылись rviz и gazebo с нашим роботом.
<p>
<img src="./images/urdf13.png">
<p>
и
<p>
<img src="./images/urdf14.png">
<p>
Теперь head отображается правильно в RViz, потому что head joint указан в сообщениях join_states.
<pre>
header:
  seq: 220
  stamp:
    secs: 4
    nsecs: 707000000
  frame_id: ''
name: ['head_swivel']
position: [-2.9051283156888985e-08]
velocity: [7.575990694887896e-06]
effort: [0.0]
</pre>
Мы могли бы продолжить добавлять передачи для всех нефиксированных соединений (и мы это сделаем), чтобы все соединения были должным образом опубликованы. Но в жизни есть нечто большее, чем просто просмотр роботов. Мы хотим управлять ими. Итак, давайте установим еще один контроллер.<p>
<li> <b>Joint Control</b> (управление суставами)<br>
Добавим контроллер:
<pre>
type: "position_controllers/JointPositionController"
joint: head_swivel</pre>
Это указывает на необходимость использования JointPositionController из пакета position_controllers для управления передачей head_swivel. Обратите внимание, что аппаратный интерфейс в URDF для этого соединения соответствует типу контроллера.
<p>
Теперь мы можем запустить это с добавленной конфигурацией, как и раньше:<br>
<b>roslaunch urdf_sim_tutorial 10-head.launch</b>
<p>
Теперь нода Gazebo подписана на новый топик и мы можем контролировать позицию головы (head) публикацией значений в ros топик:<br>
<b>rostopic pub /r2d2_head_controller/command std_msgs/Float64 "data: -0.707"</b>
<p>
Когда эта команда будет опубликована, положение немедленно изменится на указанное значение. Это связано с тем, что мы не указали никаких ограничений для соединения в нашем urdf. Однако, если мы изменим соединение, оно будет перемещаться постепенно.
<pre>
&lt;joint name="head_swivel" type="continuous"&gt;
    &lt;parent link="base_link"/&gt;
    &lt;child link="head"/&gt;
    &lt;axis xyz="0 0 1"/&gt;
    &lt;origin xyz="0 0 ${bodylen/2}"/&gt;
    &lt;limit effort="30" velocity="1.0"/&gt;
  &lt;/joint&gt;
</pre>
<i>Я: запустил новый терминал контейнера командой: docker exec -it 9826cde6760f bash<br>
Непонятно только, где я этот терминал запустил: в контейнере удаленного компьютера или локально в симуляторе этого компьютера. Выполнил команду: rostopic pub /r2d2_head_controller/command std_msgs/Float64 "data: -0.707"<br>
В графических симуляторах ничего не шевельнулось и не поменялось и непонятно, что должно было произойти.
<p>
Закрыл всю графику и выполнил: <b>roslaunch urdf_sim_tutorial 10-head.launch model:=urdf/11-limittransmission.urdf.xacro</b><br>
Открылись симуляторы. В другом терминале снова: <b>rostopic pub /r2d2_head_controller/command std_msgs/Float64 "data: -0.707"</b><br>
<font color=red>Снова ничего не поменялось, непонятно.</font></i><p>
<li><b>Another Controller</b><br>
Аналогичным образом мы можем изменить URDF для соединений захвата (Gripper joints). Однако вместо того, чтобы индивидуально управлять каждым соединением захвата с помощью отдельной темы ROS, мы могли бы сгруппировать их вместе. Для этого нам просто нужно указать другой контроллер в <a href="https://github.com/ros/urdf_sim_tutorial/blob/master/config/gripper.yaml">параметрах ROS (ROS parameters), код файла urdf_sim_tutorial/config/gripper.yaml</a>:
<pre>
type: "position_controllers/JointGroupPositionController"
joints:
 - gripper_extension
 - left_gripper_joint
 - right_gripper_joint</pre>
Чтобы запустить робот:<br>
<b>roslaunch urdf_sim_tutorial 12-gripper.launch</b>
<p>
Таким образом, мы можем вместо этого указать позицию руки с захватом (gripper) с помощью массива значений с плавающей запятой. Вывести руку с захватом и открыть клешни, публикуем сообщение:
<pre>
rostopic pub  /r2d2_gripper_controller/command std_msgs/Float64MultiArray "layout:
  dim:
  - label: ''
    size: 3
    stride: 1
  data_offset: 0
data: [0, 0.5, 0.5]"</pre>
Чтобы скрыть руку с клешнями, сообщение:
<pre>
rostopic pub  /r2d2_gripper_controller/command std_msgs/Float64MultiArray "layout:
  dim:
  - label: ''
    size: 3
    stride: 1
  data_offset: 0
data: [-0.4, 0, 0]"</pre>
На этот раз у меня всё работает.<p>
<li> <b>The Wheels on the Droid Go Round and Round</b><br>
Чтобы управлять роботом, мы задаем еще одну передачу для каждого из колес в макросе wheel (колесо).
<pre>
&lt;transmission name="${prefix}_${suffix}_wheel_trans"&gt;
      &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;
      &lt;actuator name="${prefix}_${suffix}_wheel_motor"&gt;
        &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;
      &lt;/actuator&gt;
      &lt;joint name="${prefix}_${suffix}_wheel_joint"&gt;
        &lt;hardwareInterface&gt;hardware_interface/VelocityJointInterface&lt;/hardwareInterface&gt;
      &lt;/joint&gt;
    &lt;/transmission&gt;</pre>
Это точно так же, как и другие передачи, за исключением:
<ul>
<li> Он использует macro параметры к специфичным именам.
<li> он использует VelocityJointInterface.
</ul>
Поскольку колеса фактически будут касаться земли и, таким образом, взаимодействовать с ней физически, мы также указываем некоторую дополнительную информацию о материале, из которого изготовлены колеса.
<pre>
&lt;gazebo reference="${prefix}_${suffix}_wheel"&gt;
      &lt;mu1 value="200.0"/&gt;
      &lt;mu2 value="100.0"/&gt;
      &lt;kp value="10000000.0" /&gt;
      &lt;kd value="1.0" /&gt;
      &lt;material&gt;Gazebo/Grey&lt;/material&gt;
    &lt;/gazebo&gt;</pre>
Посмотрите http://gazebosim.org/tutorials/?tut=ros_urdf для большей информации.
<p>
Мы могли бы указать контроллеры для каждого отдельного колеса, но что в этом интересного? Вместо этого мы хотим управлять всеми колесами вместе. Для этого нам понадобится гораздо больше <a href="https://github.com/ros/urdf_sim_tutorial/blob/master/config/diffdrive.yaml">параметров ROS</a>.
<pre>
type: "diff_drive_controller/DiffDriveController"
  publish_rate: 50

  left_wheel: ['left_front_wheel_joint', 'left_back_wheel_joint']
  right_wheel: ['right_front_wheel_joint', 'right_back_wheel_joint']

  wheel_separation: 0.44

  # Odometry covariances for the encoder output of the robot. These values should
  # be tuned to your robot's sample odometry data, but these values are a good place
  # to start
  pose_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.03]
  twist_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.03]

  # Top level frame (link) of the robot description
  base_frame_id: base_link

  # Velocity and acceleration limits for the robot
  linear:
    x:
      has_velocity_limits    : true
      max_velocity           : 0.2   # m/s
      has_acceleration_limits: true
      max_acceleration       : 0.6   # m/s^2
  angular:
    z:
      has_velocity_limits    : true
      max_velocity           : 2.0   # rad/s
      has_acceleration_limits: true
      max_acceleration       : 6.0   # rad/s^2
</pre>
DiffDriveController подписывается на стандартное сообщение Twist cmd_vel и соответствующим образом перемещает робота.<br>
<b>roslaunch urdf_sim_tutorial 13-diffdrive.launch</b>
<p>
В дополнение к загрузке симуляторов также открывается панель управления роботом, позволяющую вам управлять роботом R2D2, одновременно наблюдая за его реальным поведением (в Gazebo) и визуализируемым поведением (в RViz).<br>
<i>Всё работает</i>
</ol>



<h3 align=center><a name="gazebo1"href="https://classic.gazebosim.org/tutorials/?tut=ros_urdf">Tutorial: Using a URDF in Gazebo</a></h3>
Чтобы использовать URDF-файл в Gazebo, необходимо добавить некоторые дополнительные теги, специфичные для моделирования, для правильной работы с Gazebo. В этом руководстве описаны необходимые шаги для успешного использования вашего робота на основе URDF в Gazebo, что избавит вас от необходимости создавать отдельный SDF-файл с нуля и дублировать форматы описания. После этого Gazebo автоматически преобразует URDF в SDF.
<p>
Хотя URDF являются полезным и стандартизированным форматом в ROS, им не хватает многих функций, и они не были обновлены в соответствии с растущими потребностями робототехники. URDF может определять кинематические и динамические свойства только одного робота в отдельности. URDF не может указать положение самого робота в мире. Это также не универсальный формат описания, поскольку он не может указывать петли соединения (параллельные соединения) (joint loops (parallel linkages), а также ему не хватает трения и других свойств. Кроме того, он не может указывать объекты, которые не являются роботами, такие как освещение, карты высот и т.д.
<p>
Что касается реализации, то синтаксис URDF нарушает правильное форматирование из-за интенсивного использования атрибутов XML, что, в свою очередь, делает URDF более негибким. Также отсутствует механизм обратной совместимости.
<p>
Чтобы решить эту проблему, для использования в Gazebo был создан новый формат, называемый форматом описания моделирования (SDF), который устраняет недостатки URDF. SDF - это полное описание всего, начиная с уровня мира и заканчивая уровнем робота. Он масштабируем и позволяет легко добавлять и изменять элементы. Формат SDF сам по себе описывается с помощью XML, что облегчает простой инструмент обновления для переноса старых версий на новые. Он также не требует описания.
<p>
Есть несколько шагов, чтобы заставить робота URDF правильно работать в Gazebo. Ниже приведен обзор шагов, которые затем будут подробно рассмотрены в остальной части этого руководства:
<ul>
<li> Тег &lt;inertia&gt; внутри каждого тега &lt;link&gt; является обязательным и должен быть правильно указан и сконфигурирован.
<li> Опциональные теги:
  <ul>
     <li> Тег &lt;gazebo&gt; внутри каждого &lt;link&gt;
        <ul>
            <li> Преобразование визуальных цветов в формат gazebo
            <li> Конвертирует файлы stl в файлы dae для получения лучших текстур
            <li> Добавляет сенсорные плагины
        </ul>
      <li> Тег &lt;gazebo&gt; внутри каждого &lt;joint&gt;
          <ul>
              <li> Устанавливает правильную динамику демпфирования (столкновения с препятствиями-?)
              <li> Добавляет плагины управления актуаторами (actuator control plugins)
          </ul>
      <li> Тег &lt;gazebo&gt; внутри &lt;robot&gt;
      <li> Добавьте &lt;link name="world"/&gt;, если робот должен быть жестко привязан к world/base_link
  </ul>
</ul>
<h4>Тег &lt;gazebo&gt;</h4>
Тег &lt;gazebo&gt; является дополнительным тегом к URDF, используемым для задания дополнительных свойств, необходимых для моделирования в Gazebo. Он позволяет указать свойства, найденные в формате SDF, которые не включены в формат URDF. Ни один из элементов в элементе &lt;gazebo&gt; не является обязательным, поскольку значения по умолчанию будут включены автоматически. Существует три различных типа элементов &lt;gazebo&gt; - один для тега &lt;robot&gt;, один для тегов &lt;link&gt; и один для тегов &lt;joint&gt;. В этом руководстве мы обсудим атрибуты и элементы каждого типа тега &lt;gazebo&gt;.
<p>
Первым шагом к тому, чтобы ваш робот начал работать в Gazebo, является получение рабочего файла URDF из соответствующих руководств ROS по URDF. Протестируйте свой URDF, просмотрев его в Rviz, прежде чем приступать к настройке вашего робота в Gazebo. В этом уроке мы будем использовать простого демонстрационного робота по имени RRBot. Не стесняйтесь использовать этого робота или вашего собственного бота.
<p>
RRBot, или "Revolute-Revolute Manipulator Robot" (Вращающийся робот-манипулятор), представляет собой простую 3-рычажную 2-шарнирную руку, которую мы будем использовать для демонстрации различных функций Gazebo и URDFs. По сути, это двойной перевернутый маятник, который демонстрирует некоторые забавные концепции управления в симуляторе.
<p>
Чтобы получить RRBot, клонируйте gazebo_ros_demos с гитхаба в рабочая область (catkin_ws)/src и пересоберите ваше рабочее пространство:
<pre>
cd ~/catkin_ws/src/
git clone https://github.com/ros-simulation/gazebo_ros_demos.git
cd ..
catkin_make
</pre>
Чтобы проверить, все ли работает, запустите RRBot в Rviz:
<pre>roslaunch rrbot_description rrbot_rviz.launch</pre>
Должны увидеть похожее на это:
<p>
<img src="./images/urdf22.png">
<p>
Если у вас ничего не получится, попробуйте отключить все старые процессы roscore с помощью killall roscore и перезапустить RViz.
<p>
Вы также должны иметь возможность манипулировать ползунками в окне Joint State Publisher, чтобы перемещать два соединения.
<p>
В руководстве <a href="https://classic.gazebosim.org/tutorials?tut=ros_control">gazebo_ros_control</a> объясняется, как использовать Rviz для мониторинга состояния вашего моделируемого робота, публикуя /joint_states непосредственно из Gazebo. В предыдущем примере RRBot в Rviz получает свои /joint_states из фейковой ноды joint_states_publisher (окно с ползунками).

<h4>Изучение URDF RRBot:</h4>
Оставшаяся часть этого руководства будет посвящена различным аспектам RRBot URDF. Продолжайте и просмотрите файл rrbot.xacro прямо сейчас:
<pre>rosed rrbot_description rrbot.xacro</pre>
Мы используем Xacro, чтобы упростить некоторые вычисления link и joint. Мы также включаем два дополнительных файла:
<ul>
<li> rrbot.gazebo - файл, относящийся к Gazebo, который содержит большинство наших XML-элементов, относящихся к Gazebo, включая теги
<li> materials.xacro - это простой файл цветов Rviz для хранения значений rgba, который на самом деле не нужен, но является хорошим решением
</ul>
<h4>Просмотр в Gazebo:</h4>
Вы также должны иметь возможность запустить RRBot в Gazebo:
<pre>roslaunch rrbot_gazebo rrbot_world.launch</pre>
В запущенном окне Gazebo вы должны увидеть робота, стоящего вертикально. Несмотря на то, что по умолчанию в физическом симуляторе нет преднамеренных помех, числовые ошибки должны начать накапливаться и привести к падению двойного перевернутого маятника через несколько секунд. 
<p>
В конечном итоге arm должен полностью остановиться. Мы рекомендуем вам настроить и протестировать различные аспекты URDF в следующих уроках, которые помогут вам узнать больше о моделировании роботов URDF.
<h4>Заголовок urdf-файла</h4>
В Gazebo и требуемом формате URDF было внесено много изменений в API, одним из которых стало то, что схема namespaces Gazebo больше не нужна. Если в вашем URDF есть что-то вроде:
<pre>
&lt;robot xmlns:sensor="http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor"
       xmlns:controller="http://playerstage.sourceforge.net/gazebo/xmlschema/#controller"
       xmlns:interface="http://playerstage.sourceforge.net/gazebo/xmlschema/#interface"
       xmlns:xacro="http://playerstage.sourceforge.net/gazebo/xmlschema/#xacro"
       name="pr2" &gt;</pre>
Вы можете удалить их. Все, что вам нужно в теге корневого элемента, - это имя робота и, при необходимости, xml-пространство имен для xacro, если вы его используете:
<pre>&lt;robot name="rrbot" xmlns:xacro="http://www.ros.org/wiki/xacro"&gt;</pre>
<h4>Тег &lt;gazebo&gt;</h4>
Если тег &lt;gazebo&gt; используется без свойства reference="", то предполагается, что элемент &lt;gazebo&gt; используется для всей модели робота. В следующей таблице перечислены элементы для &lt;gazebo&gt;:
<p>
<img src="./images/urdf23.png">
<br>Если установлено значение true, модель остается неподвижной. В противном случае модель моделируется в движке dynamics engine.
<p>
Элементы в теге &lt;gazebo&gt;, которых нет в приведенной выше таблице, непосредственно вставляются в тег SDF &lt;model&gt; для сгенерированного SDF. Это особенно полезно для плагинов, как описано в <a href="https://classic.gazebosim.org/tutorials?tut=ros_gzplugins">руководстве по подключению двигателей и датчиков ROS</a>.
<h4>Фиксируем модель к World</h4>
Если вы хотите, чтобы ваша URDF-модель была постоянно прикреплена к мировому каркасу (world frame)(плоскости земли), вы должны создать link "world" и joint, которое закрепит ее на основании вашей модели. RRBot выполняет это следующим образом:
<pre>
&lt;!-- Used for fixing robot to Gazebo 'base_link' --&gt;
  &lt;link name="world"/&gt;

  &lt;joint name="fixed" type="fixed"&gt;
    &lt;parent link="world"/&gt;
    &lt;child link="link1"/&gt;
  &lt;/joint&gt;</pre>
Однако, если у вас есть мобильная база или какой-то движущийся робот, вам это не нужно.

<h4>&lt;collision&gt; and &lt;visual&gt; теги</h4>
Эти теги работают в Gazebo практически так же, как и в Rviz. Важно, чтобы вы указали оба тега, поскольку, в отличие от некоторых приложений ROS, Gazebo не будет использовать ваши &lt;visual&gt; элементы в качестве &lt;collision&gt;, если вы явно не укажете тег &lt;collision&gt;. Вместо этого Gazebo будет считать вашу ссылку "invisible" (невидимой) для лазерных сканеров и проверки коллизий.




<h3 align=center><a name="PR2"href="https://wiki.ros.org/urdf/Tutorials/UnderstandingPR2URDF">Understanding the PR2 Robot Description</a></h3>
В этом руководстве объясняется схема файла URDF Xacro верхнего уровня для сложного робота, такого как PR2.
<p>
В этом руководстве по-прежнему используется описание в pr2_defs, которое теперь заменено описанием в pr2_description. Несмотря на схожесть, между этим URDF и текущим URDF, используемым в PR2, произошли изменения. В частности, XML-схемы, указанные в элементе &lt;robot&gt;, больше не требуются Gazebo, и все ссылки на плагины Gazebo неверны, поскольку их API значительно изменился.<br>
Полный макрофайл PR2 URDF можно найти в пакете pr2_description в файле robots/pr2.urdf.xacro.<br>
Давайте разберем этот длинный файл по частям:
<pre>
&lt;robot xmlns:sensor="http://playerstage.sourceforge.net/gazebo/xmlschema/#sensor"
       xmlns:controller="http://playerstage.sourceforge.net/gazebo/xmlschema/#controller"
       xmlns:interface="http://playerstage.sourceforge.net/gazebo/xmlschema/#interface"
       xmlns:xacro="http://playerstage.sourceforge.net/gazebo/xmlschema/#interface"
       name="pr2" &gt;
</pre>
Корневым элементом для XML должен быть тег robot с атрибутом name. Здесь объявлены пространства имен (namespaces) XML.<br>
<i>Далее ничего не понял.</i>



<h3 align=center><a name="example" href="https://wiki.ros.org/urdf/Tutorials/Create%20your%20own%20urdf%20file">Пример создания собственного файла urdf</a></h3>
<ol>
<li> <b>Создаём древовидную структу</b><br>
В этом руководстве мы создадим URDF-описание "робота", показанного на рисунке ниже.
<p>
<img src="./images/urdf15.png">
<p>
Робот на изображении представляет собой древовидную структуру. Давайте начнем с самого простого и создадим описание этой древовидной структуры, не заботясь о размерах и т.д. Запустите свой любимый текстовый редактор и создайте файл с именем my_robot.urdf:
<pre>
&lt;robot name="test_robot"&gt;
  &lt;link name="link1" /&gt;
  &lt;link name="link2" /&gt;
  &lt;link name="link3" /&gt;
  &lt;link name="link4" /&gt;

  &lt;joint name="joint1" type="continuous"&gt;
    &lt;parent link="link1"/&gt;
    &lt;child link="link2"/&gt;
  &lt;/joint&gt;

  &lt;joint name="joint2" type="continuous"&gt;
    &lt;parent link="link1"/&gt;
    &lt;child link="link3"/&gt;
  &lt;/joint&gt;

  &lt;joint name="joint3" type="continuous"&gt;
    &lt;parent link="link3"/&gt;
    &lt;child link="link4"/&gt;
  &lt;/joint&gt;
&lt;/robot&gt;</pre>
Итак, создать структуру очень просто! Теперь давайте посмотрим, сможем ли мы проанализировать этот urdf-файл. Существует простой инструмент командной строки, который проанализирует urdf-файл для вас и сообщит, правильный ли синтаксис.
<p>
Возможно, вам потребуется установить urdfdom как вышестоящий, независимый от ROS пакет:<br>
<b>sudo apt-get install liburdfdom-tools</b>
<p>
Теперь нужно выполнить проверочные команды:
<pre>
<b>rosmake urdfdom_model              # only needed if installed from source
check_urdf my_robot.urdf              # hydro and later</b></pre>
<i>Я:<br>
cd catkin_ws<br>
mkdir myrobot<br>
sudo apt-get install liburdfdom-tools<br>
Уже был установлен.<br>
rosmake urdfdom_model<br>
<img src="./images/urdf16.png"><br>
cd myrobot<br>
mkdir urdf<br>
cd urdf<br>
nano my_robot.urdf<br>
Вставил и сохранил код из вышеприведенного my_robot.urdf</i>
<pre>
cd ../..                # перешел в catkin_ws
rosmake urdfdom_model   # Ошибка повторилась
check_urdf my_robot.urdf #Ошибка
cd myrobot/urdf
check_urdf my_robot.urdf</pre>
Теперь все верно.<br>
<img src="./images/urdf17.png"><p>
<li> <b>Добавить размеры</b><br>
Итак, теперь, когда у нас есть базовая древовидная структура, давайте добавим соответствующие размеры. Как вы заметили на изображении робота, опорная система координат (reference frame) каждого звена (link, выделен зеленым цветом) расположена в нижней части звена и совпадает с системой координат соединения (joint). Итак, чтобы добавить размеры в наше дерево, все, что нам нужно указать, - это смещение от link до стыка(ов) ее дочерних элементов. Для этого мы добавим поле &lt;origin&gt; к каждому стыку (joint).
<p>
Давайте посмотрим на joint 2. joint 2 смещено в направлении Y от link1, немного смещено в отрицательном направлении X от link1 и повернуто на 90 градусов вокруг оси Z. Итак, нам нужно добавить следующий элемент <origin>:
<pre>&lt;origin xyz="-2 5 0" rpy="0 0 1.57" /&gt;</pre>
Если вы повторите это для всех элементов, наш URDF будет выглядеть следующим образом:
<pre>
&lt;robot name="test_robot"&gt;
  &lt;link name="link1" /&gt;
  &lt;link name="link2" /&gt;
  &lt;link name="link3" /&gt;
  &lt;link name="link4" /&gt;


  &lt;joint name="joint1" type="continuous"&gt;
    &lt;parent link="link1"/&gt;
    &lt;child link="link2"/&gt;
    &lt;origin xyz="5 3 0" rpy="0 0 0" /&gt;
  &lt;/joint&gt;

  &lt;joint name="joint2" type="continuous"&gt;
    &lt;parent link="link1"/&gt;
    &lt;child link="link3"/&gt;
    &lt;origin xyz="-2 5 0" rpy="0 0 1.57" /&gt;
  &lt;/joint&gt;

  &lt;joint name="joint3" type="continuous"&gt;
    &lt;parent link="link3"/&gt;
    &lt;child link="link4"/&gt;
    &lt;origin xyz="5 0 0" rpy="0 0 -1.57" /&gt;
  &lt;/joint&gt;
&lt;/robot&gt;
</pre>
Обновите свой файл my_robot.urdf и запустите его через синтаксический анализатор:<br>
<b>check_urdf my_robot.urdf</b><br>
<i>Я: изменил код и проверил, помоему никакой разницы с предыдущей проверкой нет. Наверное потому, что не показывает размеры</i><p>
<li> <b>Завершение кинематики</b><br>
Чего мы еще не указали, так это вокруг какой оси вращаются суставы. Как только мы добавим это, у нас фактически будет полная кинематическая модель этого робота! Все, что нам нужно сделать, это добавить элемент &lt;axis&gt; к каждому суставу. Ось определяет ось вращения в локальном кадре.
<p>
Итак, если вы посмотрите на joint2, то увидите, что он вращается вокруг положительной оси Y. Итак, просто добавьте следующий xml-код к элементу joint2:
<pre>&lt;axis xyz="0 1 0" /&gt;</pre>
Аналогично, соединение 1 вращается вокруг следующей оси:
<pre>&lt;axis xyz="-0.707 0.707 0" /&gt;</pre>
Обратите внимание, что рекомендуется нормализовать ось.
<p>
Если мы добавим это ко всем суставам робота, наш URDF будет выглядеть следующим образом:
<pre>
&lt;robot name="test_robot"&gt;
  &lt;link name="link1" /&gt;
  &lt;link name="link2" /&gt;
  &lt;link name="link3" /&gt;
  &lt;link name="link4" /&gt;

  &lt;joint name="joint1" type="continuous"&gt;
    &lt;parent link="link1"/&gt;
    &lt;child link="link2"/&gt;
    &lt;origin xyz="5 3 0" rpy="0 0 0" /&gt;
    &lt;axis xyz="-0.9 0.15 0" /&gt;
  &lt;/joint&gt;

  &lt;joint name="joint2" type="continuous"&gt;
    &lt;parent link="link1"/&gt;
    &lt;child link="link3"/&gt;
    &lt;origin xyz="-2 5 0" rpy="0 0 1.57" /&gt;
    &lt;axis xyz="-0.707 0.707 0" /&gt;
  &lt;/joint&gt;

  &lt;joint name="joint3" type="continuous"&gt;
    &lt;parent link="link3"/&gt;
    &lt;child link="link4"/&gt;
    &lt;origin xyz="5 0 0" rpy="0 0 -1.57" /&gt;
    &lt;axis xyz="0.707 -0.707 0" /&gt;
  &lt;/joint&gt;
&lt;/robot&gt;</pre>
<i>Изменил my_robot.urdf, проверил.</i>
<p>
Вот и все, вы создали свое первое описание робота URDF! Теперь вы можете визуализировать файл urdf, используя graphiz:<br>
<b>urdf_to_graphiz my_robot.urdf</b>
<p>
и откройте созданный файл с помощью вашего любимого средства просмотра pdf:<br>
<b>evince test_robot.pdf</b>
<p>
<i>Я:<br>
urdf_to_graphiz my_robot.urdf<br>
Поскольку в моем контейнере не был установлен evince, то:<br>
sudo apt update<br>
sudo apt install evince<br>
Далее:<br>
evince test_robot.pdf</i>
<p>
<img src="./images/urdf18.png">
<p>
Теперь вы готовы перейти к следующему уроку и начать использовать <a href="https://wiki.ros.org/urdf/Tutorials/Parse%20a%20urdf%20file">парсер URDF в вашем коде на C++</a>.
</ol>


<h3 align="center"><a name="parse" href="https://wiki.ros.org/urdf/Tutorials/Parse%20a%20urdf%20file">Parse a urdf file</a></h3>
В этом руководстве вы узнаете, как использовать синтаксический анализатор urdf
<ol>
<li> <b>Reading a URDF file</b><br>
Этот урок начинается с того места, на котором закончился предыдущий. У вас все еще должен быть свой my_robot.urdf Ниже приведен файл urdf с описанием робота:
<p>
<img src="./images/urdf19.png">
<p>
Давайте сначала создадим пакет с зависимостью от анализатора urdf в нашей песочнице:
<pre>
cd ~/catkin_ws/src
catkin_create_pkg testbot_description urdf
cd testbot_description</pre>
Теперь создайте папку /urdf для хранения файла urdf, который мы только что создали:
<pre>
mkdir urdf
cd urdf</pre>
Это следует из соглашения всегда сохранять URDF-файл вашего робота в пакете ROS с именем MYROBOT_description и во вложенной папке с именем /urdf. Другие стандартные вложенные папки пакета описания вашего робота включают /meshes, /media и /cad, например:
<p>
<img src="./images/urdf20.png">
<p>
Далее скопируйте ваш файл my_robot.urdf в пакет и папку, которые мы только что создали:<br>
<b>cp /path/to/.../testbot_description/urdf/my_robot.urdf .</b><br>
<i>Я: перешёл в ~/catkin_ws/myrobot/urdf Затем:<br>
cp my_robot.urdf ~/catkin_ws/src/testbot_description/urdf</i>
<p>
Создайте папку src/ и запустите свой редактор, чтобы создать файл с именем src/parser.cpp
<p>
<i>Я:<br>
cd .. #перешёл в  testbot_description<br>
mkdir src<br>
cd src<br>
nano parser.cpp</i>
<pre>
#include <urdf/model.h>
#include "ros/ros.h"

int main(int argc, char** argv){
  ros::init(argc, argv, "my_parser");
  if (argc != 2){
    ROS_ERROR("Need a urdf file as argument");
    return -1;
  }
  std::string urdf_file = argv[1];

  urdf::Model model;
  if (!model.initFile(urdf_file)){
    ROS_ERROR("Failed to parse urdf file");
    return -1;
  }
  ROS_INFO("Successfully parsed urdf file");
  return 0;
}</pre>
Реальное действие происходит в строках 12-13. Здесь мы создаем объект синтаксического анализа и инициализируем его из файла, указав имя файла. Метод initFile возвращает значение true, если файл URDF был успешно проанализирован.
<p>
Теперь попробуем запустить этот код. Сначала добавьте следующие строки в ваш CMakeList.txt файл:
<pre>
add_executable(parser src/parser.cpp)
 target_link_libraries(parser ${catkin_LIBRARIES})</pre>
Соберите свой пакет и запустите его:
<pre>
cd ~/catkin_ws   
$ catkin_make
$ .&lt;path&gt;/parser &lt;path&gt;my_robot.urdf
# Example: ./devel/lib/testbot_description/parser ./src/testbot_description/urdf/my_robot.urdf</pre>
<i>Я пытался выполнить: .src/testbot_description/src/parser src/testbot_description/urdf/my_robot.urdf и получал сообщение, что файл или директория не существует. Пока не выполнил, как в учебнике:</i><br>
<b>./devel/lib/testbot_description/parser ./src/testbot_description/urdf/my_robot.urdf</b>
<p>
<img src="./images/urdf21.png">
</ol>


<h3 align=center><a name="publisher" href="https://wiki.ros.org/robot_state_publisher/Tutorials/Using%20the%20robot%20state%20publisher%20on%20your%20own%20robot">Использование robot state publisher на вашем собственном роботе</a></h3>
В этом руководстве объясняется, как вы можете опубликовать состояние вашего робота в tf, используя robot state publisher.
<p>
Когда вы работаете с роботом, у которого много соответствующих систем координат, опубликовать их все в tf становится довольно сложной задачей. Robot state publisher - это инструмент, который выполнит эту работу за вас.
<p>
Программа robot state publisher поможет вам транслировать состояние вашего робота в библиотеку tf transform. Программа robot state publisher содержит внутреннюю кинематическую модель робота; таким образом, учитывая положение суставов робота, программа robot state publisher может вычислить и транслировать 3D-изображение каждого звена робота.<p>
<ol>
<li> <b>Выполнение как нода ROS</b>
<ol>
<li> robot_state_publisher<br>
Проще всего запустить robot state publisher в качестве узла. Для обычных пользователей рекомендуется использовать именно это. Для запуска robot state publisher необходимы две вещи:
<ul>
<li> Описание робота в формате urdf xml, загруженно на сервер параметров (<a href="https://wiki.ros.org/Parameter%20Server">Parameter Server</a>).
<li> Источник, который публикует позиции суставов как sensor_msgs/JointState.
</ul>
Пожалуйста, прочтите следующие разделы о том, как настроить параметры и топики для robot_state_publisher.
<p>
Топики, на которые подписаны: joint_states (<a href="http://docs.ros.org/en/api/sensor_msgs/html/msg/JointState.html">sensor_msgs/JointState</a>)<br>
<i>joint position information</i>
<p>
Параметры:<br>
robot_description (urdf map)<br>
Описание робота в формате urdf xml. Доступ к нему осуществляется через <a href="http://docs.ros.org/api/urdf/html/classurdf_1_1Model.html#a0e3b0a0974fb948dd9228c50c5d6783c">`urdf_model::initParam`</a>
<p>
<i>tf_prefix (string)</i><br>
Установите префикс tf для публикации преобразований с учетом пространства имен. Более подробную информацию смотрите в разделе <a href="https://wiki.ros.org/tf/Theory">tf_prefix</a>.
<p>
<i>publish_frequency (double)</i><br>
Частота публикации состояния издателя, по умолчанию: 50 Гц.<p>
<li> Пример файла launch<br>
Как только вы настроите описание робота в формате XML и источник информации о совместном местоположении, просто создайте файл запуска, подобный этому:
<pre>
&lt;launch&gt;
   &lt;!-- Load the urdf into the parameter server. --&gt;
   &lt;param name="my_robot_description" textfile="$(find mypackage)/urdf/robotmodel.xml"/&gt;
    
   &lt;node pkg="robot_state_publisher" type="robot_state_publisher" name="rob_st_pub" &gt;
      &lt;remap from="robot_description" to="my_robot_description" /&gt;
      &lt;remap from="joint_states" to="different_joint_states" /&gt;
    &lt;/node&gt;
  &lt;/launch&gt;
</pre>
</ol>
<li> <b>Выполненять как библиотеку</b><br>
Опытные пользователи также могут запускать robot state publisher как библиотеку из своего собственного кода на C++. После включения заголовка:<br>
<b>include &lt;robot_state_publisher/robot_state_publisher.h&gt;</b>
<p>
все, что вам нужно, - это конструктор, который использует <a href="https://wiki.ros.org/kdl">дерево KDL</a><br>
<b>RobotStatePublisher(const KDL::Tree& tree);</b>
<p>
и теперь каждый раз, когда вы хотите опубликовать состояние своего робота, вы вызываете функции publishTransforms:
<pre>
// publish moving joints
  void publishTransforms(const std::map&lt;std::string, double&gt;& joint_positions,
                         const ros::Time& time);

  // publish fixed joints
  void publishFixedTransforms();
</pre>
Первый аргумент - это карта с названиями соединений и позициями соединений, а второй аргумент - это время, в которое были записаны позиции соединений. Ничего страшного, если карта не содержит всех названий соединений. Также допустимо, если на карте указаны названия некоторых соединений, которые не являются частью кинематической модели. Но обратите внимание, что если вы не сообщите издателю состояния соединения о некоторых соединениях в вашей кинематической модели, то ваше дерево tf будет неполным.
</ol>




<h3 align=center><a name="kdl" href="https://wiki.ros.org/kdl_parser/Tutorials/Start%20using%20the%20KDL%20parser">Start using the KDL parser</a></h3>
В этом руководстве вы узнаете, как создать дерево KDL из файла URDF<p>
<ol>
<li> <b>Building the KDL parser</b><br>
<b>rosdep install kdl_parser</b>
<p>
Это приведет к установке всех внешних зависимостей для kdl_parser. Чтобы собрать пакет, запустите:<br>
<b>rosmake kdl_parser</b><p>
<li> <b>Using in your code</b><br>
Чтобы начать использовать синтаксический анализатор KDL в вашем коде на C++, включите следующий файл:<br>
<b>#include <&lt;kdl_parser/kdl_parser.hpp&gt;</b>
<p>
Теперь можно действовать по-разному. Вы можете создать дерево KDL из urdf в различных формах:
<ol>
<li> Из файла:
<pre>
KDL::Tree my_tree;
   if (!kdl_parser::treeFromFile("filename", my_tree)){
      ROS_ERROR("Failed to construct kdl tree");
      return false;
   }
</pre>
Чтобы создать файл PR2 URDF, выполните следующую команду:<br>
<b>rosrun xacro xacro.py `rospack find pr2_description`/robots/pr2.urdf.xacro > pr2.urdf</b>
<li> Из сервера параметров:
<pre>
KDL::Tree my_tree;
   ros::NodeHandle node;
   std::string robot_desc_string;
   node.param("robot_description", robot_desc_string, std::string());
   if (!kdl_parser::treeFromString(robot_desc_string, my_tree)){
      ROS_ERROR("Failed to construct kdl tree");
      return false;
   }
</pre>
<li> From an xml element:
<pre>
KDL::Tree my_tree;
   TiXmlDocument xml_doc;
   xml_doc.Parse(xml_string.c_str());
   xml_root = xml_doc.FirstChildElement("robot");
   if (!xml_root){
      ROS_ERROR("Failed to get robot from xml document");
      return false;
   }
   if (!kdl_parser::treeFromXml(xml_root, my_tree)){
      ROS_ERROR("Failed to construct kdl tree");
      return false;
   }
</pre>
<li> From a URDF model:
<pre>
KDL::Tree my_tree;
   urdf::Model my_model;
   if (!my_model.initXml(....)){
      ROS_ERROR("Failed to parse urdf robot model");
      return false;
   }
   if (!kdl_parser::treeFromUrdfModel(my_model, my_tree)){
      ROS_ERROR("Failed to construct kdl tree");
      return false;
   }
</pre>   
</ol>
Для получения более подробной информации ознакомьтесь с <a href="http://www.ros.org/doc/api/kdl_parser/html/namespacekdl__parser.html">документацией по API</a>.
</ol>




<h3 align=center><a name="urdf_publisher" href="https://wiki.ros.org/urdf/Tutorials/Using%20urdf%20with%20robot_state_publisher">Using urdf with robot_state_publisher
</a></h3>
В этом руководстве приведен полный пример модели робота с URDF, использующей robot_state_publisher. Сначала мы создаем модель URDF со всеми необходимыми компонентами. Затем мы пишем узел, который публикует JointState и преобразует его. Наконец, мы соединяем все детали воедино.<p>
<ol>
<li> <b>Create the URDF File</b><br>
Вот файл URDF для 7-канальной модели, приблизительно соответствующей R2-D2. Сохраните <a href="https://wiki.ros.org/urdf/Tutorials/Using%20urdf%20with%20robot_state_publisher?action=AttachFile&do=get&target=model.xml">следующую ссылку: model.xml</a> на свой компьютер.<p>
<li> <b>Публикация состояния</b><br>
Теперь нам нужен способ указать, в каком состоянии находится робот. Для этого мы должны указать все три соединения и общую одометрию. Начните с создания пакета:<br>
<b>cd catkin_ws/src<br>
catkin_create_pkg r2d2 roscpp rospy tf sensor_msgs std_msgs</b>
<p>
Затем запустите свой любимый текстовый редактор и вставьте следующий код в файл src/state_publish:
<pre>
#include &lt;string&gt;
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/JointState.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;

int main(int argc, char** argv) {
    ros::init(argc, argv, "state_publisher");
    ros::NodeHandle n;
    ros::Publisher joint_pub = n.advertise&lt;sensor_msgs::JointState&gt;("joint_states", 1);
    tf::TransformBroadcaster broadcaster;
    ros::Rate loop_rate(30);

    const double degree = M_PI/180;

    // robot state
    double tilt = 0, tinc = degree, swivel=0, angle=0, height=0, hinc=0.005;

    // message declarations
    geometry_msgs::TransformStamped odom_trans;
    sensor_msgs::JointState joint_state;
    odom_trans.header.frame_id = "odom";
    odom_trans.child_frame_id = "axis";

    while (ros::ok()) {
        //update joint_state
        joint_state.header.stamp = ros::Time::now();
        joint_state.name.resize(3);
        joint_state.position.resize(3);
        joint_state.name[0] ="swivel";
        joint_state.position[0] = swivel;
        joint_state.name[1] ="tilt";
        joint_state.position[1] = tilt;
        joint_state.name[2] ="periscope";
        joint_state.position[2] = height;


        // update transform
        // (moving in a circle with radius=2)
        odom_trans.header.stamp = ros::Time::now();
        odom_trans.transform.translation.x = cos(angle)*2;
        odom_trans.transform.translation.y = sin(angle)*2;
        odom_trans.transform.translation.z = .7;
        odom_trans.transform.rotation = tf::createQuaternionMsgFromYaw(angle+M_PI/2);

        //send the joint state and transform
        joint_pub.publish(joint_state);
        broadcaster.sendTransform(odom_trans);

        // Create new robot state
        tilt += tinc;
        if (tilt&lt;-.5 || tilt&gt;0) tinc *= -1;
        height += hinc;
        if (height&gt;.2 || height&lt;0) hinc *= -1;
        swivel += degree;
        angle += degree/4;

        // This will adjust as needed per iteration
        loop_rate.sleep();
    }


    return 0;
}
</pre>
<li> <b>Launch файл</b><br>
Этот файл запуска предполагает, что вы используете имя пакета "r2d2" и имя узла "state_publisher", и вы сохранили этот urdf в пакете "r2d2".
<pre>
&lt;launch&gt;
        &lt;param name="robot_description" command="cat $(find r2d2)/model.xml" /&gt;
        &lt;node name="robot_state_publisher" pkg="robot_state_publisher" type="robot_state_publisher" /&gt;
        &lt;node name="state_publisher" pkg="r2d2" type="state_publisher" /&gt;
&lt;/launch&gt;
</pre>
<li> <b>Просмотр результатов</b><br>
Сначала нам нужно отредактировать CMakeLists.txt в пакете, в котором мы сохранили приведенный выше исходный код. Не забудьте добавить зависимость tf в дополнение к другим зависимостям:
<pre>find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs tf)</pre>
Обратите внимание, что roscpp используется для анализа кода, который мы написали, и создания узла state_publisher. Нам также нужно добавить следующее в конец CMakelists.txt, чтобы сгенерировать узел state_publisher.:
<pre>
include_directories(include ${catkin_INCLUDE_DIRS})
add_executable(state_publisher src/state_publisher.cpp)
target_link_libraries(state_publisher ${catkin_LIBRARIES})
</pre>
Теперь мы должны перейти в каталог рабочей области и собрать его с помощью:<br>
<b>catkin_make</b>
<p>
Теперь запустите пакет (при условии, что наш файл запуска называется display.launch).:<br>
<b>roslaunch r2d2 display.launch</b>
<p>
Запустите rviz, выполнив команду в новом терминале:<br>
<b>rosrun rviz rviz</b>
<p>
Выберите odom в качестве фиксированной системы координат (fixed frame) (в разделе Global Options). Затем выберите "Add Display" и добавьте Robot Model Display и TF DisplayTF (см. http://wiki.ros.org/rviz/UserGuide).
</ol>

</div>
<br><br><br><br><br><br></body></html>
