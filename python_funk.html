<html><head>
<style>
.menu {
       height: 100%;
       width: 145px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 10px;
           margin-left: 150px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Функции</title>
<div class="menu">
<a href="index.html">Начальная</a>
<a href="python_base.html">Основы языка python</a>
<a href="python_collection.html">Коллекции</a>
<a href="python_funk_progr.html">Функциональное программирование</a>
<a href="python_oop.html">ООП в python</a>
<a href="python_library.html">Библиотеки</a>
<a href="python_parsing">Парсинг страниц</a>
<a href="python_example.html">Примеры</a>
<p>
<b>Функции:</b>
<a href="#potok">Вызов методов цепочкой</a>
<a href="#re">Модуль re</a>
<a href="#regul">Регулярные выражения</a>
<a href="#def">Функции</a>
<a href="#space">Пространство имён и область видимости</a>
<a href="#recurs"><b>Рекурсивные функции:</b></a>
<a href="#lambda">lambda - функции:</a>
<a href="#zamik">Замыкания</a>
<a href="#decorator">Декораторы</a>
<a href="#file">Работа с файлами</a>
<a href="#except">Исключения: try except</a>
</div>
<div class="content">
<h3 align=center><a name="potok">Вызов методов цепочкой</h3>
Ссылка: <a href="https://pyneng.readthedocs.io/ru/latest/book/04_data_structures/method_chaining.html">Вызов методов цепочкой</a><p>
Часто с данными надо выполнить несколько операций, пример скрипта:
<pre>
line = "switchport trunk allowed vlan 10,20,30"
words = line.split()
vlans_str = words[-1]
vlans = vlans_str.split(",")
print(vlans)</pre>
В этом случае переменные используются для хранения промежуточного результата и последующие методы/действия выполняются уже с 
переменной. Это совершенно нормальный вариант кода, особенно поначалу, когда тяжело воспринимать более сложные выражения.
<p>
Однако в Python часто встречаются выражения, в которых действия или методы применяются один за другим в одном выражении. 
Например, предыдущий код можно записать так:
<pre>
line = "switchport trunk allowed vlan 10,20,30"
vlans = line.split()[-1].split(",")
print(vlans)</pre>
Так как тут нет выражений в скобках, которые бы указывали приоритет выполнения, все выполняется слева направо. Сначала 
выполняется line.split() - получаем список, затем к полученному списку применяется [-1] - получаем последний элемент списка, 
строку 10,20,30. К этой строке применяется метод split(",") и в итоге получаем список ['10', '20', '30'].
<p>
Главный нюанс при написании таких цепочек предыдущий метод/действие должен возвращать то, что ждет следующий метод/дествие. И 
обязательно чтобы что-то возвращалось, иначе будет ошибка.
<pre>


===============================================================================================================



</pre>
<a name="re"><h3 align=center>Модуль re</h3>
Функции этого модуля:
<p>
<ol>
<li> <b>re.match(pattern, stroka)</b><br>
Ищет совпадает ли шаблон (pattern) с началом нашей строки.
<p>
<li> <b>re.fullmatch(pattern, string)</b><br>
Проверить, подходит ли строка string под шаблон pattern
<p>
<pre>
>>> match = re.fullmatch(r'\d\d\D\d\d', r'12-12')
>>> print('YES' if match else 'NO')
YES
>>> match = re.fullmatch(r'\d\d\D\d\d', r'Т. 12-12')
>>> print('YES' if match else 'NO')
NO
</pre>
<p>


<li> <b>re.split(pattern, string, maxsplit=0)</b><br>
Этот метод разделяет строку по заданному шаблону.
<pre>
result = re.split(r'y', 'Analytics')
print result

Результат:
['Anal', 'tics']</pre>

В примере мы разделили слово «Analytics» по букве «y». Метод split() принимает также аргумент maxsplit со значением по 
умолчанию, равным 0. В данном случае он разделит строку столько раз, сколько возможно, но если указать этот аргумент, то 
разделение будет произведено не более указанного количества раз. Давайте посмотрим на примеры Python RegEx:
<pre>
result = re.split(r'i', 'Analytics Vidhya')
print result

Результат:
['Analyt', 'cs V', 'dhya'] # все возможные участки.</pre>
<pre>
result = re.split(r'i', 'Analytics Vidhya',maxsplit=1)
print result

Результат:
['Analyt', 'cs Vidhya']</pre>
Мы установили параметр maxsplit равным 1, и в результате строка была разделена на две части вместо трех.
<p>
Если в шаблоне нет группирующих скобок, то re.split работает очень похожим образом на str.split. А вот если группирующие 
скобки в шаблоне есть, то между каждыми разрезанными строками будут все соответствия каждой из подгрупп.
<pre>
import re 
print(re.split(r'(\s*)([+*/-])(\s*)', r'12  +  13*15   - 6')) 
# -> ['12', '  ', '+', '  ', '13', '', '*', '', '15', '   ', '-', ' ', '6']</pre>
В некоторых ситуация эта возможность бывает чрезвычайно удобна! Например, достаточно из предыдущего примера убрать лишние 
группы, и польза сразу станет очевидна!
<pre>
import re 
print(re.split(r'\s*([+*/-])\s*', r'12  +  13*15   - 6')) 
# -> ['12', '+', '13', '*', '15', '-', '6']</pre>
<p> 

<li> <b>re.search(pattern, string)</b><br>
Найти в строке string первую строчку, подходящую под шаблон pattern<br>
Примеры:
<pre>
>>> import re
>>> match = re.search(r'\d\d\D\d\d', r'Телефон 123-12-12')
>>> print(match[0] if match else 'Not found')
23-12
>>> match = re.search(r'\d\d\D\d\d', r'Телефон 1231212') 
>>> print(match[0] if match else 'Not found')
Not found</pre>
<p>
<li> <b>re.findall(pattern, string)</b><br>
Найти в строке string все непересекающиеся шаблоны pattern
<pre>
>>> print(re.findall(r'\d\d\.\d\d\.\d{4}', r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017'))
['19.01.2018', '01.09.2017']</pre>
<p>
Если в шаблоне есть группирующие скобки, то вместо списка найденных подстрок будет возвращён список кортежей, в каждом из 
которых только соответствие каждой группе. Это не всегда происходит по плану, поэтому обычно нужно использовать негруппирующие 
скобки (?:...).
<pre>
import re 
print(re.findall(r'([a-z]+)(\d*)', r'foo3, im12, go, 24buz42')) 
# -> [('foo', '3'), ('im', '12'), ('go', ''), ('buz', '42')]</pre>
<p>
<li> <b>re.finditer(pattern, string)</b><br>
Итератор по всем непересекающимся шаблонам pattern в строке string (выдаются match-объекты)
<p>
<pre>
for m in re.finditer(r'\d\d\.\d\d\.\d{4}', r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017'): 
    print('Дата', m[0], 'начинается с позиции', m.start()) 
# -> Дата 19.01.2018 начинается с позиции 20 
# -> Дата 01.09.2017 начинается с позиции 45 </pre>
<p>
<li> <b>re.sub(pattern, replace, string, count=0, flags=0)</b><br>
заменяет символы по заданному паттерну на заданные символы и возвращает исправленную строку.
<br>Параметры:
<p>
pattern - регулярное выражение<br>
replace - на что нужно заменить pattern<br>
string - строка, к которой нужно применить регулярное выражение<br>
count - необязательный аргумент, максимальное число вхождений, подлежащих замене. Если этот параметр опущен или равен нулю, то 
произойдет замена всех вхождений.<br>
flags - флаги<br>
Возвращаемое значение:
<p>
Если совпадения есть - изменённая строка<br>
string, если совпадений нет
<p>
<pre>
print(re.sub(r'\d\d\.\d\d\.\d{4}', 
             r'DD.MM.YYYY', 
             r'Эта строка написана 19.01.2018, а могла бы и 01.09.2017')) 
# -> Эта строка написана DD.MM.YYYY, а могла бы и DD.MM.YYYY </pre>
<p>
<li> <b>stroka.re.group()</b><br>
Искомая подстрока найдена. Чтобы вывести её содержимое, применим метод group() (мы используем «r» перед строкой шаблона, чтобы 
показать, что это «сырая» строка в Python):
<pre>
result = re.match(r'AV', 'AV Analytics Vidhya AV')
print result.group(0)

Результат:
AV</pre>
<p>
<li> <b>re.compile(pattern, repl, string)</b><br>
Мы можем собрать регулярное выражение в отдельный объект, который может быть использован для поиска. Это также избавляет от 
переписывания одного и того же выражения.
<pre>
pattern = re.compile('AV')
result = pattern.findall('AV Analytics Vidhya AV')
print result
result2 = pattern.findall('AV is largest analytics community of India')
print result2

Результат:
['AV', 'AV']
['AV']</pre>
</ol>
<p>
Также есть методы start() и end() для того, чтобы узнать начальную и конечную позицию найденной строки.
<pre>
result = re.match(r'AV', 'AV Analytics Vidhya AV')
print result.start()
print result.end()

Результат:
0
2
</pre>
<pre>


</pre>
<h3 align=center><a name="regul">Регулярные выражения</h3>
Ссылка: <a href="https://habr.com/ru/articles/349860/">Регулярные выражения в Python от простого к сложному.</a><br>
<a href="https://tproger.ru/translations/regular-expression-python">Python RegEx: практическое применение регулярок</a><br>
<a href="https://ru.wikipedia.org/wiki/Регулярные_выражения#Обратная_связь">Регулярные выражения</a>
<p>
Регулярное выражение — это строка, задающая шаблон поиска подстрок в тексте. Одному шаблону может соответствовать много разных 
строчек. Термин «Регулярные выражения» является переводом английского словосочетания «Regular expressions». Перевод не очень 
точно отражает смысл, правильнее было бы «шаблонные выражения».
<p>
Регулярные выражения это, по существу, крошечный язык программирования, встроенный в Python и доступный при помощи модуля 
re. Используя его, вы указывается правила для множества возможных строк, которые вы хотите проверить; это множество может 
содержать английские фразы, или адреса электронной почты, или TeX команды, или все что угодно.
<p>
<h4 align=center>Метасимволы</h4>
Это набор символов:
<pre><b>. ^ $ * + ? { [ ] \ | ( )</b></pre>
<p>
1. Квадратные скобки: <b>[</b> и <b>]</b><br>
Первые метасимволы, что мы рассмотрим это [ и ]. Они используются для <b>определения множества символов (классов)</b>, с которыми вы ищите совпадение. Символы могут быть перечислены по отдельности, или в виде некоторого диапазона символов, обозначенного первым и последним символом, разделенных знаком '-'. Например, [abc] будет соответствовать любому из символов a, b или c; это то же самое, что выражение [a-c], использующее диапазон для задания того же множества символов. Если вы хотите сопоставить только строчные буквы, РВ будет иметь вид [a-z].
<p>
Метасимволы не активны внутри классов. Например, [akm$] будет соответствовать любому из символов 'a', 'k', 'm' или '$'. Знак 
'$' это обычно метасимвол (как видно из списка символов выше), но внутри класса символов он лишается своей особой природы.
<p>
внутри скобок нужно экранировать только ] и \
<p>
Для того, чтобы находить соответствие символам вне этого класса, в начале класса добавляется символ '^'. Например, выражение 
[^5]  соответствует любому символу, кроме '5'.
<p>
2. <b>Обратная косая черта: \</b><br>
Пожалуй, наиболее важным является метасимвол обратной косой черты \.<br>
Как и в строковых литералах Python, за бэкслешем могут следовать <b>различные символы, обозначающие разные специальные последовательности</b>.<br>
Он также используется <b>для экранирования метасимволов</b>, чтобы их можно было использовать в шаблонах; например, если нужно найти соответствие [ или \, для того чтобы лишить их своей особой роли метасимволов, перед ним нужно поставить обратную косую черту: \[ или \\.
<p>
Для того, чтобы не было таких нагромождений слешей, перед открывающей кавычкой нужно поставить символ r, что скажет питону «не 
рассматривай \ как экранирующий символ (кроме случаев экранирования открывающей кавычки)». Соответственно можно будет писать 
r'\\par'
<p>
Некоторые из специальных последовательностей, начинающихся с '\' представляют предопределенные наборы символов, часто бывающие 
полезными, такие как набор цифр, набор букв, или множества всего, что не является пробелами, символами табуляции и т. д. 
(whitespace). Полный список последовательностей и расширенных определений классов для Юникод-строк смотрите в последней части 
Regular Expression Syntax.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>

<tr><td>\d</td><td width=65%>любая цифра; эквивалент класса [0-9]</td><td>СУ<b>\d\d</b> &rarr; <font color=green>СУ35</font>, <font 
color=green>СУ11</font>1, АЛ<font color=green>СУ14</font></td></tr>

<tr><td>\D</td><td>любой нечисловой символ; эквивалент класса [^0-9]</td><td>926<b>\D</b>123 &rarr; <font color=green>926)123</
font>, 1<font color=green>926-123</font>4</td></tr>

<tr><td>\s</td><td>соответствует любому символу whitespace; эквивалент [ \t\n\r\f\v]</td><td>бор<b>\s</b>ода &rarr; <font 
color=green>бор ода</font>, <font color=green>бор<br>
ода</font>, борода</td></tr>

<tr><td>\S</td><td>любой не-whitespace символ; эквивалент [^ \t\n\r\f\v]</td><td><b>\S</b>123 &rarr; <font color=green>X123</
font>, <font color=green>я123</font>, <font color=green>!123</font>456, 1 + 123456</td></tr>

<tr><td>\w</td><td>Любая буква (то, что может быть частью слова), а также цифра и _, эквивалент [a-zA-Z0-9_]</td><td>
<b>\w\w\w</b> &rarr; <font color=green>Год</font>, <font color=green>f_3</font>, <font color=green>qwer</font>t
<p>
используя \w, вытащить два последовательных символа, кроме пробельных, из каждого слова:
<pre>
result = re.findall(r'\w\w', 'AV is largest Analytics community')
print result
Результат:
['AV', 'is', 'la', 'rg', 'es', 'An', 'al', 'yt', 'ic', 'co', 'mm', 'un', 'it']</pre></td></tr>

<tr><td>\W</td><td>наоборот; эквивалент [^a-zA-Z0-9_]</td><td>сом<b>\W</b> &rarr; <font color=green>сом!</font>, <font 
color=green>сом?</font></td></tr>

<tr><td>\b</td><td>Начало или конец слова (слева пусто или не-буква, справа буква и наоборот). В отличие от предыдущих 
соответствует позиции, а не символу</td><td><b>\b</b>вал &rarr; <font color=green>вал</font>, перевал, Перевалка</td></tr>

<tr><td>\B</td><td>Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы</td><td><b>\B</b>вал &rarr; 
пере<font color=green>вал</font>, вал, Пере<font color=green>вал</font>ка<br>
<b>\B</b>вал<b>\B</b> &rarr; перевал, вал, Пере<font color=green>вал</font>ка</td></tr>
</table>
<p>
Эти последовательности могут быть включены в класс символов. Например, [\s,.] является характер класс, который будет 
соответствовать любому whitespace-символу или запятой или точке.
<p>
3. Точка: <b>.</b><br>
Один любой символ, кроме новой строки \n.<br>
Пример:<br>
м.л.ко, применяем к <font color=green>молоко</font>, <font color=green>малако</font>,
И<font color=green>м0л0ко</font>Ихлеб
<p>
4. Символ: <b>^</b><br>
Служит для указания, что следующий символ не входит в шаблон.
<p>
Также ^ означает начало текста (или строки при модификаторе ?m)
<p>
Вытащим первое слово, используя ^:
<pre>
result = re.findall(r'^\w+', 'AV is largest Analytics community of India')
print result
Результат:
['AV']</pre>
<p>
===========================================================
<p>
5. <b>Квантификаторы</b><br>
<b>+ ? * {}</b> используются в квантификаторах (указаниях количества повторений). Квантификатор после символа, символьного 
класса или группы определяет, сколько раз предшествующее выражение может встречаться. Следует учитывать, что квантификатор 
может относиться более чем к одному символу в регулярном выражении, только если это символьный класс или группа.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>
<tr><td><b>+</b></td><td>Одно или более, синоним {1,}</td><td>a\)+ &rarr; <font color=green>a)</font>, <font color=green>a))
</font>, <font color=green>a)))</font>, b<font color=green><b>a)</b></font>])</td></tr>

<tr><td><b>?</b></td><td>Ноль или одно вхождение, синоним {0,1}</td><td>валы<b>?</b> &rarr; <font color=green>вал, валы, 
вал</font>ов<br>Символ в паттерне перед ? может или быть или отсутствовать в строке.</td></tr>

<tr><td><b>*</b></td><td>Ноль или более, синоним {0,}</td><td>СУ\d*	&rarr; <font color=green>СУ, СУ1, СУ12</font></td></tr>
</table>

<p>
<h4>Жадность в регулярках и границы найденного шаблона</h4>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>
<tr><td>*?<br>
+?<br>
??<br>
{m,n}?<br>
{,n}?<br>
{m,}?</td><td width=40%>По умолчанию квантификаторы жадные — захватывают максимально возможное число символов.
<b>Добавление ?</b> делает их ленивыми, они захватывают минимально возможное число символов</td><td>\(.*\)	&rarr; <font 
color=green>(a + b) * (c + d) * (e + 
f)</font><br>
\(.*?\) &rarr; <font color=green>(a + b)</font> * (c + d) * (e + f)</td></tr>
</table>
<p>
Как указано выше, по умолчанию квантификаторы жадные. Этот подход решает очень важную проблему — проблему границы шаблона. 
Скажем, шаблон \d+ захватывает максимально возможное количество цифр. Поэтому можно быть уверенным, что перед найденным 
шаблоном идёт не цифра, и после идёт не цифра.
<p>
6. Фигурные скобки: <b>{n}</b><br>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>

<tr><td>{n}</td><td>Ровно n повторений</td><td>d{4} означает 4 цифры: &rarr; 1, 12, 123, <font color=green>1234</font>, 12345
</td></tr>

<tr><td>{m,n}</td><td>От m до n повторений включительно</td><td>\d{2,4}  &rarr; 1, <font color=green>12</font>, 
<font color=green>123</font>, <font color=green>1234</font>, 12345</td></tr>

<tr><td>{m,}</td><td>Не менее m повторений</td><td>\d{3,}  &rarr; <1, 12, <b><font color=green>123</font>, 
<font color=green>1234</font>, <font color=green>12345</font></b></td></tr>

<tr><td>{,n}</td><td>Не более n повторений</td><td>\d{,2}  &rarr; 1, <font color=green>12</font>, <font color=green>12</font>3
</td></tr>
</table>
<p>
7. Знак доллара <b>$</b><br>
Конец строки
<p>
Если мы используем $ вместо ^, то мы получим последнее слово, а не первое:
<pre>
result = re.findall(r'\w+$', 'AV is largest Analytics community of India')
print result
Результат:
[‘India’]</pre>
<p>
<h4>Использование дополнительных флагов в питоне</h4>
Каждой из функций, перечисленных выше, можно дать дополнительный параметр flags, что несколько изменит режим работы регулярок. 
В качестве значения нужно передать сумму выбранных констант, вот они:
<ol>
<li> re.ASCII<br>
По умолчанию \w, \W, \b, \B, \d, \D, \s, \S соответствуют все юникодные символы с соответствующим качеством.<br>
Например, \d соответствуют не только арабские цифры, но и вот такие: ٠١٢٣٤٥٦٧٨٩. re.ASCII ускоряет работу, если все 
соответствия лежат внутри ASCII.
<p>
<li> re.IGNORECASE<br>
Не различать заглавные и маленькие буквы. Работает медленнее, но иногда удобно
<li> re.MULTILINE<br>
Специальные символы ^ и $ соответствуют началу и концу каждой строки
<p>
<li> re.DOTALL<br>
По умолчанию символ \n конца строки не подходит под точку. С этим флагом точка — вообще любой символ
</ol>
<pre>
import re 
print(re.findall(r'\d+', '12 + ٦٧')) 
# -> ['12', '٦٧'] 
print(re.findall(r'\w+', 'Hello, мир!')) 
# -> ['Hello', 'мир'] 
print(re.findall(r'\d+', '12 + ٦٧', <b>flags=re.ASCII</b>)) 
# -> ['12'] 
print(re.findall(r'\w+', 'Hello, мир!', <b>flags=re.ASCII</b>)) 
# -> ['Hello'] 
print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя')) 
# -> ['ааааа', 'яяяя'] 
print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя', <b>flags=re.IGNORECASE</b>)) 
# -> ['ОООО', 'ааааа', 'ЫЫЫЫ', 'яяяя'] 

text = r""" 
Торт 
с вишней1 
вишней2 
""" 
print(re.findall(r'Торт.с', text)) 
# -> [] 
print(re.findall(r'Торт.с', text, flags=re.DOTALL)) 
# -> ['Торт\nс'] 
print(re.findall(r'виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней1', 'вишней2'] 
print(re.findall(r'^виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней2'] </pre>
<p>
8. Знак <b>|</b> - перечисления (операция «ИЛИ»)<br>
Чтобы проверить, удовлетворяет ли строка хотя бы одному из шаблонов, можно воспользоваться аналогом оператора or, который 
записывается с помощью символа |. Так, некоторая строка подходит к регулярному выражению A|B тогда и только тогда, когда она 
подходит хотя бы к одному из регулярных выражений A или B. Например, отдельные овощи в тексте можно искать при помощи шаблона 
морковк|св[её]кл|картошк|редиск.
<p>
<h4>Скобочные группы (?:){}</h4>
Зачастую шаблон состоит из нескольких повторяющихся групп. Так, MAC-адрес сетевого устройства обычно записывается как шесть 
групп из двух шестнадцатиричных цифр, разделённых символами - или :. Например, 01:23:45:67:89:ab. Каждый отдельный символ 
можно задать как [0-9a-fA-F], и можно весь шаблон записать так:<br>
[0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}
<p>
Ситуация становится гораздо сложнее, когда количество групп заранее не зафиксировано. Чтобы разрешить эту проблему в 
синтаксисе регулярных выражений есть группировка (?:...). Можно писать круглые скобки и без значков ?:, однако от этого у 
группировки значительно меняется смысл, регулярка начинает работать гораздо медленнее. Об этом будет написано ниже. Итак, если 
REGEXP — шаблон, то (?:REGEXP) — эквивалентный ему шаблон. Разница только в том, что теперь к (?:REGEXP) можно применять 
квантификаторы, указывая, сколько именно раз должна повториться группа. Например, шаблон для поиска MAC-адреса, можно записать 
так: [0-9a-fA-F]{2}(?:[:-][0-9a-fA-F]{2}){5}
<p>
<h4>Скобки плюс перечисления</h4>
Также скобки (?:...) позволяют локализовать часть шаблона, внутри которого происходит перечисление. Например, шаблон (?:он|
тот) (?:шёл|плыл) соответствует каждой из строк «он шёл», «он плыл», «тот шёл», «тот плыл», и является синонимом он шёл|он 
плыл|тот шёл|тот плыл.
<p>
Примеры:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>

<tr><td>Шаблон</td><td>Применяем к тексту</td></tr>

<tr><td>(?:\w\w\d\d)+</td><td>Есть м<font color=green>иг29</font>а, <font color=green>ту15</font>4б. Некоторые делают даже 
м<font color=green>иг29ту15</font>4<font color=green>ил86</font>.</td></tr>

<tr><td>(?:\w+\d+)+</td><td>Есть <font color=green>миг29</font>а, ту154б. Некоторые делают даже <font 
color=green>миг29ту154ил86</font>.</td></tr>

<tr><td>(?:\+7|8)(?:-\d{2,3}){4}</td><td><font color=green>+7-926-123-12-12, 8-926-123-12-12</font></td></tr>

<tr><td>(?:[Хх][аоеи]+)+</td><td>Му<font color=green>ха</font> — <font color=green>хахахехо</font>, ну <font 
color=green>хааахооохе</font>, да <font color=green>хахахехохииии</font>! <font color=green>Ха</font>м трамвайный.</td></tr>

<tr><td>\b(?:[Хх][аоеи]+)+\b</td><td>Муха — <font color=green>хахахехо</font>, ну <font color=green>хааахооохе</font>, да <font color=green>хахахехохииии</font>! Хам трамвайный.</td></tr>

</table>
<p>
Если функции re.search, re.fullmatch не находят соответствие шаблону в строке, то они возвращают None, функция re.finditer не 
выдаёт ничего. Однако если соответствие найдено, то возвращается match-объект. 
<p>
<h4>Группирующие скобки (...) без ?:</h4>
Если в шаблоне регулярного выражения встречаются скобки (...) без ?:, то они становятся группирующими. В match-объекте, 
который возвращают re.search, re.fullmatch и re.finditer, по каждой такой группе можно получить ту же информацию, что и по 
всему шаблону. А именно часть подстроки, которая соответствует (...), а также индексы начала и окончания в исходной строке. 
Достаточно часто это бывает полезно.
<p>
<h4>Группировка</h4>
<b>Обратная связь</b><br>
Одно из применений группировки — повторное использование ранее найденных групп символов (подстрок, блоков, отмеченных 
подвыражений, захватов). При обработке выражения подстро́ки, найденные по шаблону внутри группы, сохраняются в отдельной 
области памяти и получают номер, начиная с единицы. Каждой подстроке соответствует пара скобок в регулярном выражении.
<p>
Обычно поддерживается до 9 нумерованных подстрок с номерами от 1 до 9, но некоторые интерпретаторы позволяют работать с 
бо́льшим 
количеством. Впоследствии в пределах данного регулярного выражения можно использовать обозначения от \1 до \9 для проверки на 
совпадение с ранее найденной подстрокой. В некоторых реализациях вместо бэкслеша используется знак доллара.
<p>
Например, регулярное выражение (та|ту)-\1 найдёт строку та-та или ту-ту, но пропустит строку та-ту.
<p>
Квантификация группы трактуется как многократное сохранение подстроки под одним и тем же номером, то есть запоминается 
последнее вхождение: например, <font color=red>регулярное выражение (.)+\1 найдёт строку abcc, но пропустит abca</font>.
<p>
Также ранее найденные подстро́ки можно использовать при замене по регулярному выражению. В таком случае в замещающий текст 
вставляются те же обозначения, что и в пределах самого выражения.
<p>
<b>Группировка без обратной связи</b><br>
Если группа используется только для группировки и её результат в дальнейшем не потребуется, то можно использовать группировку 
вида (?:шаблон). Под результат такой группировки не выделяется отдельная область памяти и, соответственно, ей не назначается 
номер. Это положительно влияет на скорость выполнения выражения, но понижает удобочитаемость.
<p>
<b>Атомарная группировка</b><br>
Атомарная группировка вида (?>шаблон) так же, как и группировка без обратной связи, не создаёт обратных связей. В отличие от 
неё, такая группировка запрещает возвращаться назад по строке, если часть шаблона уже найдена.
<p>
<img src="./images/python_base10.png">
<p>
<i>Тут нужны группировки. Если туговато с их пониманием, как было у меня, читаем и стараемся понять логику:
<pre>
import re
line = 'abcdef'
pattern = r'(\w)(\w)(\w)(\w+)'
print(re.sub(pattern, r'\3\2\1\4', line))
>>> cbafed</pre>

В нашем шаблоне (pattern) есть (\w) повторённая три раза. Операция повторения () даёт нам возможность запомнить "индекс" 
элемента шаблона. Этот "индекс" в дальнейшем мы можем вызвать например через \1 что соответствует первому элементу группировки 
т.е. \1 == 'a' в данной строке; аналогично и дальше слева направо \2 =='b'    \3 == 'с'    ,а  (\w+) == 'def'  то есть остаток 
нашей строки.
<p>
Таким образом указывая в выводе \3\2\1\4 мы заменяем соответствующие элементы в обратном порядке:  \3\2\1 == 'cba'  то же 
самое 'abc' >>>'cba' и прибавляем к ним 'def' через \4.</i>









<pre>


=================================================================================================================



</pre>
<h3 align=center><a name="def">Функции</h3>
Ссылки: <a href="https://pyplanet.ru/article/def-return.html">Функции, директивы def, return</a><br>
<a href="https://pythonworld.ru/tipy-dannyx-v-python/vse-o-funkciyax-i-ix-argumentax.html">Функции и их аргументы</a>
<p>
<b>Отличие функции от метода:</b><br>
<i>Важно различать функции и методы в Python, поскольку они используются для разных целей. Функции предназначены для 
выполнения общих задач, которые могут быть вызваны из любой части кода, в то время как методы связаны с объектами и 
предназначены для выполнения задач, специфичных для конкретного типа объекта.</i>
<p>
<i>Метод в Python вызывается по имени, но связан с объектом (зависим). Определение метода всегда включает «self» в качестве 
первого параметра. Метод неявно передается объекту, для которого он вызывается. Он может возвращать или не возвращать какие-
либо данные.
<p>
Функция в Python — это блок кода, который вызывается по своему имени. Функция может иметь разные параметры или не иметь их 
вообще. Если передаются какие-либо данные (параметры), они передаются явно. Функция может возвращать или не возвращать какие-
либо данные. Она не имеет дела с классом и концепцией его экземпляра.</i>
<p>
<b>Для чего нужна функция?</b><br>
Часто некоторый код нужно выполнить несколько раз. Либо мы хотим как-то изолировать некоторый код, и вызывать его в 
необходимом месте.<br>
Этого можно достичь написанием функции.
<p>
<b>Определение функции:</b><br>Функция в python - объект, принимающий аргументы и возвращающий значение. Обычная функция 
определяется с помощью инструкции def. Второй способ с помощью lambda.
<p>
Синтаксис:
<pre>
def name_f(arg1, arg2,...):
    return command</pre>
После инструкции def идёт <b>имя функции</b>.
<h4>Аргументы функции</h4>
В скобках функции переменные, которые называются или аргументы или параметры.<br>
<b>Аргумент</b> – это фактическое значение, когда мы вызываем функцию, а <b>параметр</b> – это переменная внутри скобок функции, когда мы объявляем функцию, не путать с вызовом.
<p>
<ul>
<li> По способу передачи аргументов они бывают <b>позиционные (positional arguments) или именованные (иногда называют ключевыми)</b>:<br>
В fun(12, 123, a = 5, b = 10)<br>
a = 5 и b = 10 - аргументы именованные, 12 и 123 - аргументы позиционные
<p>
Однако именованные аргументы должны в скобках перечисляться в конце. То есть, можно вызвать add(1, y=2), add(1, 2), add(x=1, y=2), но нельзя add(2, x=1).
<p>
<li> <b>Аргументы по умолчанию</b> (positional_args_with_defaults)<br>
Так называются аргументы, если при объявлении функции параметры имеют уже определенное значение.<br>
def f(b, <b>a =10</b>)<br>
Здесь a = 10 является параметром по умолчанию.
<p>
Следовало бы упомянуть один важный момент: значение по умолчанию вычисляется только один раз - при первом вызове функции. 
При всех последующих вызовах будет повторно использован тот объект, который получили при первом вычислении значения по 
умолчанию.<br>
В случае с неизменяемыми значениями (числа, строки) это поведение ни на что не влияет, а если в значении по умолчанию 
используется изменяемый тип - то все изменения этого аргумента будут сохраняться между вызовами.
<br>В качестве примера используем новый список как значение по умолчанию для аргумента b:
<pre>
>>> def f(a, b=[]):
...     b.append(a)
...     print(b)
...
>>> f(1)
[1]
>>> f(2)
[1, 2]
>>> f(3,b=[])
[3]
>>> f(4)
[1, 2, 4]  # непонятно почему 4 добавилось в список, созданный при вызове f(2)
</pre>
<h4>Звездочки * внутри скобок функции</h4>
<b>*args</b> (*pos_args_name)<br>
args - это список позиционных аргументов.<br>
По соглашению между программистами в Python  в функции  c произвольным количеством принимающих параметров принято писать <b>*args</b> вместо *(с каким либо другим названием переменной).
<p>
<b>**kwargs</b> (**kw_args_name)<br>
Это словарь из именнованых аргументов.
<p>
Пример:
<pre>
def printab(a=50, b=100, *args, **kwargs):
    print('a =', a)
    print('b =', b)
    print('additional <b>positional arguments</b>:')
    for i in <b>args</b>:  # распечатка кортеджа
        print(i)
    print('additional <b>named arguments</b>:')
    for key in <b>kwargs</b>:  # распечатка словаря
        print(key, '=', kwargs[key])

printab(10, 20, 25, 35, 45, 50, 60, c=30, d=40, jimmi=12
</pre>
<pre>
результат:

a = 10
b = 20
additional positional arguments:
25
35
45
50
60
additional named arguments:
c = 30
d = 40
jimmi = 123
</pre>
<li> Общий синтаксис:
<pre>
def function_name([ positional_args,
                  [ positional_args_with_default,
                  [ *pos_args_name,
                  [ keyword_only_args,
                  [ **kw_args_name]]]]]):
</pre>
-позиционные аргументы: a, b, c<br>
-позиц. аргументы со значением по умолчанию: d=0, e=True<br>
-дополнительные позиционные аргументы (которые в инициализации не участвовали) отправляются в кортеж (*args)<br>
<font color=red>-блок аргументов, которые можно передать только по имени: f, g, h=10</font><br>
-именованные аргументы которые в инициализации не участвовали, отправляются в словарь: **kwarqs
<p>
<li>
Ошибка «SyntaxError: positional argument follows keyword argument» в Python возникает, когда один или несколько аргументов 
ключевого слова (например, age=35, name=John) размещаются перед позиционными аргументами (например, 35, John) в вызове функции.
<p>
Согласно синтаксису Python, аргументы ключевого слова должны следовать позиционным аргументам, а не наоборот.
<br>Чтобы исправить эту синтаксическую ошибку, можно воспользоваться одним из следующих подходов:
<p>
Передать аргументы ключевого слова после позиционных аргументов.
<p>
Передать все аргументы в качестве позиционных аргументов.
<p>
Передать все аргументы в качестве аргументов ключевого слова.

</ul>
<p>
<li> <b>Тело функции:</b><br>
В следующей строке с отступом идет <b>тело функции</b>.<br>
Инструкция return говорит, что нужно вернуть значение. В нашем случае функция возвращает сумму x и y.
<p>
Внутри функции может быть какой угодно код, но, если мы хотим вернуть значение, мы обязаны написать return ЧТО_ТО. Если этого не написать, то функция вернёт специальное значение None (некоторый аналог NULL из других языков программирования).
<p>
Код после достижения return внутри функции не выполняется.
<p>
Внутри программы функция может быть вызвана. Например:
<pre>
def add(x, y):
    return x + y

print(add(1, 2))  # Выведет 3</pre>

<b>Согласно PEP 8 после определения функции нужно отступать 2 пустые строчки.</b>


<h4>Локальные и глобальные переменные</h4>
Переменные, объявленные внутри функции, являются локальными. Если их использовать за пределами выполнения функции, то произойдет ошибка.
<p>
Глобальные переменные - это переменные объявленные вне функции.

<li> <b>Стек вызовов</b><br>
Ссылки: <a href="https://stepik.org/lesson/24459/step/6?unit=6764">Функции и стек вызовов</a><br>
Стек вызовов чаще всего служит для хранения функций.<br>
Если интерпретатор видит функцию, он ложит ее в стек, если функция завершает выполнение, он эту функцию снимает.<br>
В стеке всегда в самом низу находится module.
<p>
<li> Если return пустой или его вообще не будет, тогда функция будет возвращать объект None. Тип этого None есть NoneType.
<p>
<li> <b>Рекурсивная функция</b><br>
Это такая функция в теле которой присутствует сама функция.
<p>
<li> <a name="space"><h3 align=center>Пространство имён и область видимости</h3>
Ссылки: <a href="https://nuancesprog.ru/p/9211/">Пространства имен и области видимости в Python</a>
<p>
<i>Пространство имён - это совокупность ссылок от имён объектов (переменных, функций, классов и т. д.) к их значениям в оперативной памяти (объектам). То есть, в теории мы могли бы обращаться сразу к значениям в памяти. Но их неудобно понимать, поэтому и придумали пространство имён. Оно, по сути, является переводчиком между понятному человеку названием объекта и его непонятному человеку значению в памяти. Словарь, если угодно.</i></i>
<p>
Пространство имен - это все ссылки на объекты (переменные).
<p>
Пространств имён может быть несколько.
<p>
Интерпретатор Python ищет имена согласно правилу LEGB (Local, Enclosed, Global, Built-in).
<p>
<b>Встроенное пространство имен builtins</b> содержит имена всех встроенных объектов, которые всегда доступны при работе в Python. Вы можете перечислить объекты во встроенном пространстве с помощью следующей команды: 
<pre>
>>> dir(__builtins__)
</pre>
Первое пространство имен - builtins, создается когда запускаем интерпретатор.
<p>
<b>Глобальное пространство имен nain</b> содержит имена, определенные на уровне основной программы, и создаётся сразу при запуске тела этой программы. Сохраняется же оно до момента завершения работы интерпретатора. 
<br>Строго говоря, могут существовать и другие глобальные пространства имен. Интерпретатор также создает пространство данного типа для любого модуля, загружаемого программой при помощи выражения import.
<p>
nain, является глобальным, создается когда создаем функцию или что-то делаем с переменной.
<p>
Интерпретатор создает новое пространство имен при каждом выполнении функции. Это пространство является локальным для функции и 
сохраняется до момента завершения ее действия.<br>
Локальное пространство имен содержит аргументы функции и локальные переменные (объявленные внутри функции).
<p>
Наличие нескольких отличных пространств имен означает, что в процессе выполнения программы Python несколько разных экземпляров 
одного имени могут существовать одновременно. Пока каждый из них находится в собственном пространстве, все они обслуживаются 
по отдельности, и путаницы не происходит. 
<p>
Но тут возникает вопрос. Предположим, что вы ссылаетесь на имя x в коде, а оно существует в нескольких пространствах. Как 
Python узнает, какое именно вы имеете в виду? 
</ol>
<h4>Область видимости в Python</h4>
Ответ кроется в понятии области видимости имени, представляющей из себя часть программы, в которой данное имя обладает 
значением. Интерпретатор определяет эту область в среде выполнения, основываясь на том, где располагается определение имени и 
из какого места в коде на него ссылаются.
<p>
Интерпретатор Python ищет имена согласно правилу LEGB (Local, Enclosed, Global, Built-in). Например, если вы указываете какое-то имя, Python сначала будет искать его последовательно в локальной, вложенной, глобальной и встроенной области видимости. Это означает следующее: поиск имени осуществляется внутри функции (локальная область), далее внутри тех функций, в которых располагается наша функция (вложенная область), далее в скрипте (глобальная область) и в конце, если имя не было найдено ранее, в зарезервированных значениях Python (встроенная область).
<pre>
def a():
    print(x)
 
def b():
    x = 1
    a()
 
b()#NameError
</pre>
Функция b() вызывает функцию a(), зоны видимости функций не включены друг в друга. Т. е. интерпретатор не найдя имя 'x' в зоне видимости a() перейдёт в глобальную зону видимости, потом в зону видимости builtins - и не обнаружит 'x'. В результате: NameError
<pre>
def b():
    def a():
        print(x)
    x = 1
    a() 
b()#1</pre>
Функция b() также вызывает функцию a(), но теперь a() определена внутри b(). Т. е. интерпретатор не найдя имя 'x'  в зоне 
видимости a() перейдёт в зону видимости b() и найдет 'x' . Результат: 1
<p>
<pre>
def outer_func(who):
    def inner_func():
        print(f"Hello, {who}")
    inner_func()

>>> outer_func("World!")
Hello, World!</pre>
Теперь мы можем передать строку в качестве аргумента функции outer_func(), и inner_func() будет обращаться к этому аргументу 
через имя who. Это имя определяется в локальной области видимости outer_func(). Имена, которые мы определяем в локальной 
области внешней функции, определяются как nonlocal. Они нелокальны с точки зрения вложенной функции inner_func().
<p>
<h4>global и nonlocal</h4>
Оператор global задает пространство имен. 
<pre>
A = 10
def local_A():
    <b>global A</b>
    A = 20
    print("Local", A)

local_A()
print("Global: ", A)
local_A()

Вывод:
Local 20
Global:  20
Local 20
</pre>
<pre>

============================================================================================================


</pre>
<h3 align=center><a name="recurs">Рекурсивные функции</h3>
Рекурсивная функция — это функция, которая вызывает сама себя в процессе своего выполнения. Структурно она состоит из двух 
основных частей: базового случая и рекурсивного случая.
<p>
<b>Базовый случай</b> (Base Case): Это условие, которое останавливает рекурсию. Без этого условия рекурсивная функция будет вызывать 
саму себя бесконечно, что приведёт к переполнению стека вызовов. Базовый случай обычно представляет собой простое условие, при 
котором функция возвращает результат без дальнейших рекурсивных вызовов.
<p>
<b>Рекурсивный случай</b> (Recursive Case): Это часть, где функция вызывает сама себя. Здесь важно, чтобы каждый последующий вызов приближал функцию к базовому случаю, уменьшая проблему или изменяя данные таким образом, чтобы в конечном итоге достигнуть базового случая.
<p>
Для успешной работы рекурсивной функции, чёткое определение базового и рекурсивного случаев является ключевым. Базовый случай 
обеспечивает "точку остановки", предотвращая бесконечную рекурсию. Рекурсивный случай же обрабатывает часть задачи и делает 
рекурсивный вызов с "меньшей" или "измененной" версией исходной задачи.
<p>
В качестве простейшего примера рассмотрите следующий код:
<pre>
def factorial(n):
    if n == 1:  # Базовый случай
        return 1
    else:
        return n * factorial(n - 1)  # Рекурсивный случай</pre>
<p>
<b>Хвостовая рекурсия и её оптимизация</b><br>
Хвостовая рекурсия возникает, когда рекурсивный вызов является последним действием функции, то есть нет необходимости 
сохранять контекст текущего вызова. В хвостово-рекурсивной функции возвращаемое значение рекурсивного вызова сразу же 
возвращается из функции.
<p>
Оптимизация:<br>
Некоторые языки программирования и компиляторы способны оптимизировать хвостовую рекурсию, уменьшая нагрузку на стек вызовов и 
превращая рекурсию в итерацию во время компиляции.<br>
В языках, не поддерживающих оптимизацию хвостовой рекурсии (например, Python), можно переписать рекурсивную функцию в 
итеративный стиль для повышения эффективности.
<p>
<b>Мемоизация в рекурсивных функциях</b><br>
Мемоизация — это техника оптимизации, которая включает сохранение результатов выполнения функций для предотвращения повторных 
вычислений при последующих вызовах с теми же аргументами.
<p>
Применение в рекурсии:<br>
Мемоизация особенно полезна в рекурсивных функциях с большим количеством повторяющихся вызовов, например, при вычислении чисел 
Фибоначчи.<br>
Реализуется путём сохранения возвращаемых значений в структуру данных (например, в словарь) и проверки, был ли данный вызов 
функции уже выполнен ранее.
<p>
Множественная рекурсия<br>
Множественная рекурсия возникает, когда в теле функции происходит более одного рекурсивного вызова.<br>
Примеры:<br>
Примером множественной рекурсии может служить алгоритм быстрой сортировки, где рекурсивные вызовы происходят для двух половин 
массива.<br>
Другой пример — бинарное дерево поиска, где рекурсивные вызовы идут как для левой, так и для правой ветви дерева.
<p>
Разбор рекурсии на примере <a href="python_example.html#text">здесь</a>.
<pre>



</pre>
<h3 align=center><a name="lambda"">lambda - функции</a></h3>
Ссылки: <a href="https://webdevblog.ru/kak-ispolzovat-v-python-lyambda-funkcii/">Как использовать в Python лямбда-функции</a>
<p>
Синтаксис:
<pre>name = <b>lambda arguments: expression(arguments)</b></pre>
lambda-функциям эквивалентен следующий код:
<pre>
def name(*arguments):
    return expression(arguments)</pre>
<i>expression(arguments)</i> - это выражение. В объект name записывается результат выражения от argument.
<p>    
<b>Шаблоны выполнения анонимной функции:</b>
<p>
<table border=1><tr>
<td>
Через переменную:
<pre>
>>> a = lambda x, y: x + y
>>> a(1, 3)
4</pre>
</td><td>
Можно и без присваивания переменной выполнять лямбду-функцию, через нижнюю черточку:
<pre>
>>> lambda x, y: x + y
&lt;function &lt;lambda&gt; at 0x7f2de74533a0&gt;
>>> _(1, 2)
3
</pre></td><td>
Другой шаблон — это немедленное выполнение лямбда-функции. Это называется <b>выражением немедленного вызова функции</b> (IIFE 
—  Immediately Invoked Function Expression, произносится «iffy»).
<pre>
>>> (lambda x, y: x + y)(2, 3)
5</pre></td>
</tr></table>
<p>
<h4>Аргументы</h4>
Как и обычный объект функции, определенный с помощью def, лямбда поддерживают все различные способы передачи аргументов. Это 
включает:
<ul>
<li> Позиционные аргументы
<li> Именованные аргументы (иногда называемые ключевыми аргументами)
<li> Переменный список аргументов (часто называемый varargs)
<li> Переменный список аргументов ключевых слов
<li> Аргументы только для ключевых слов
</ul>
Следующие примеры иллюстрируют опции, доступные для передачи аргументов в лямбда-выражения:
<pre>
>>> (lambda x, y, z: x + y + z)(1, 2, 3)
6
>>> (lambda x, y, z=3: x + y + z)(1, 2)
6
>>> (lambda x, y, z=3: x + y + z)(1, y=2)
6
>>> (lambda *args: sum(args))(1,2,3)
6
>>> (lambda **kwargs: sum(kwargs.values()))(one=1, two=2, three=3)
6
>>> (lambda x, *, y=0, z=0: x + y + z)(1, y=2, z=3)
6</pre>
<p>
<h4>lambda-функции в качестве аргумента функции или наоборот</h4>
Лямбда-функции часто используются с функциями более высокого порядка, которые принимают одну или несколько функций в качестве 
аргументов или возвращают одну или несколько функций.
<p>
Лямбда-функция может быть функцией более высокого порядка, принимая функцию (нормальную или лямбда-функцию) в качестве 
аргумента, как в следующем надуманном примере:
<pre>
>>> high_ord_func = lambda x, func: x + func(x)
>>> high_ord_func(2, lambda x: x * x)
6
>>> high_ord_func(2, lambda x: x + 3)
7</pre>
Здесь вызывается лямбда-функция по шаблону через переменную с двумя аргументами, где второй аргумент сам является лямбда-
функцией.
<pre>

==========================================================================================================================


</pre>
<a name="zamik"><h3 align=center>Замыкание</h3>
<b>Замыкание</b> в Python - это функция, ссылающая на переменные из внешней функции внутри которой она находится.
<p>
Вот пример замыкания, построенное с помощью обычной функции Python:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def mult(num1):
    <b>def inner(num2):</b>  # функция-замыкание
        return num1 * num2
    return inner

mult_by_2 = mult(2) # ссылается на inner() и вроде как не вызывает (не выполняет) при инициализации функцию mult(2)
print(mult_by_2(2)) # => 4 
</pre></td></tr></table>
<p>
В данном примере функция inner() является замыканием.<br>
<font color=red>Непонятно почему num2 стала равна num1?</font> Это и есть следствие замыкания.<br>
Если закомментировать вроде как не нужную строчку: return inner<br>
то на print(mult_by_2(2)) получим ошибку: TypeError: 'NoneType' object is not callable
<p>
Необходимо понимать в какой момент происходит запоминание значения. Для этого рассмотрим пример:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def mult(num1):
    x = 1
    def inner(num2):
        return num1 * num2 + x
    <b>x = 10</b>
    return inner
mult_by_2 = mult(2)
print(mult_by_2(2)) 
</pre></td></tr></table>
<p>
На первый взгляд можно предположить, что результатом будет число 5, но нет, результат будет 14.
<p>
Рассмотрим следующий пример:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def mult(num1):
    a = 10
    def inner(num2):
        a += 1
        return num1 * num2 + a
    return inner

mult_by_2 = mult(2)
print(mult_by_2(2))
</pre></td></tr></table>
<p>
Получим:
<pre>
print(mult_by_2(2))
  File "test.py", line 4, in inner
    a += 1
UnboundLocalError: local variable 'a' referenced before assignment
</pre>
То есть переменной a ещё не присвоено значение.
<p>
Переменная a является свободной, поэтому чтобы ее менять с сохранением измененного значения между вызовами, следует использовать <b>оператор nonlocal</b>:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def mult(num1):
    a = 10
    def inner(num2):
        nonlocal a
        a += 1
        return num1 * num2 + a
    return inner
</pre></td></tr></table>
<p>
Для обыкновенного присваивания значения переменной a, оператор nonlocal использовать не нужно. Например, nonlocal можно использовать следующим способом:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def up(num1):
    a = num1
    def inner():
        nonlocal a
        a -= 1
        return a
    return inner

up_one = up(10)
print(up_one()) # => 9
print(up_one()) # => 8
print(up_one()) # => 7
print(up_one()) # => 6
</pre></td></tr></table>
<p>
Замыкания из-за умения запоминать значения свободных переменных чем-то напоминают классы (о них мы будем говорить позднее).
<p>
Другой пример:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def outer_func(x):
    y = 4
    def inner_func(z):
        print(f"x = {x}, y = {y}, z = {z}")
        return x + y + z
    return inner_func
  
for i in range(3):
    closure = outer_func(i)
    print(f"closure({i+5}) = {closure(i+5)}")
</pre></td></tr></table>
<p>
outer_func() возвращает inner_func(), вложенную функцию, которая вычисляет сумму трех аргументов:
<ul>
<li> x передается в качестве аргумента outer_func().
<li> y является локальной переменной для outer_func().
<li> z - аргумент, передаваемый в inner_func() из 10 строки: closure({<b>i+5</b>}).
</ul>
Чтобы продемонстрировать поведение outer_func() и inner_func(), outer_func() вызывается три раза в цикле for, который выводит 
следующее:
<pre>
x = 0, y = 4, z = 5
closure(5) = 9
x = 1, y = 4, z = 6
closure(6) = 11
x = 2, y = 4, z = 7
closure(7) = 13</pre>
В строке 9 кода inner_func(), возвращаемый вызовом outer_func(), привязывается к имени замыкания closure.<br>
В строке 5 inner_func() захватывает x и y, потому что он имеет доступ к своей области видимости, так что при вызове замыкания 
он может работать с двумя свободными переменными x и y.
<p>
Точно так же лямбда также может быть замыканием. Вот тот же пример с лямбда-функцией Python:
<pre>
def outer_func(x):
    y = 4
    return lambda z: x + y + z
for i in range(3):
    closure = outer_func(i)
    print(f"closure({i+5}) = {closure(i+5)}")
</pre>
Когда вы выполняете приведенный выше код, вы получаете следующий вывод:
<pre>
closure(5) = 9
closure(6) = 11
closure(7) = 13
</pre>
В строке 6 outer_func() возвращает лямбду и присваивает ее переменную замыкания. В строке 3 тело лямбда-функции ссылается на x 
и y. Переменная y доступна во время определения, тогда как x определяется во время выполнения, когда вызывается outer_func().
<p>
В этой ситуации и нормальная функция, и лямбда ведут себя одинаково. В следующем разделе вы увидите ситуацию, когда поведение 
лямбды может быть обманчивым из-за времени его оценки (время определения против времени выполнения).
<p>
<h4>Классические функциональные конструкции</h4>
Лямбда-функции регулярно используются со встроенными функциями map() и filter(), а также functools.reduce(), представленными в 
модуле functools. Следующие три примера являются соответствующими иллюстрациями использования этих функций с лямбда-
выражениями в качестве компаньонов:
<pre>
>>> list(map(lambda x: x.upper(), ['cat', 'dog', 'cow']))
['CAT', 'DOG', 'COW']
>>> list(filter(lambda x: 'o' in x, ['cat', 'dog', 'cow']))
['dog', 'cow']
>>> from functools import reduce
>>> reduce(lambda acc, x: f'{acc} | {x}', ['cat', 'dog', 'cow'])
'cat | dog | cow'</pre>
<p>
<h4>UI Фреймворки</h4>
UI фреймворки, такие как Tkinter, wxPython или .NET Windows Forms с IronPython, используют лямбда-функции для отображения 
действий в ответ на события пользовательского интерфейса.
<p>
Простая программа Tkinter, представленная ниже, демонстрирует использование лямбды, назначенной команде кнопки Reverse:
<pre>
import tkinter as tk
import sys
window = tk.Tk()
window.grid_columnconfigure(0, weight=1)
window.title("Lambda")
window.geometry("300x100")
label = tk.Label(window, text="Lambda Calculus")
label.grid(column=0, row=0)
button = tk.Button(
    window,
    text="Reverse",
    command=lambda: label.configure(text=label.cget("text")[::-1]),
)
button.grid(column=0, row=1)
window.mainloop()</pre>
Нажатие кнопки «Reverse» запускает событие, которое запускает лямбда-функцию, изменяя метку с Lambda Calculus на suluclaC 
adbmaL *:
<p>
<img src="./images/python_base9.png">
<p>
И wxPython, и IronPython используют одинаковый подход для обработки событий. Обратите внимание, что лямбда-это один из 
способов обработки событий, но функцию можно использовать для той же цели. В конечном итоге код становится автономным и менее 
многословным при использовании лямбды, когда объем необходимого кода очень мал.
<pre>




</pre>
<h3 align=center><a name="decorator">Декораторы</h3>
Ссылки: <a href="https://habr.com/ru/articles/141411/">Понимаем декораторы в Python'e, шаг за шагом. Шаг 1</a><br>
<a href="https://habr.com/ru/companies/otus/articles/727590/">Декораторы Python: пошаговое руководство</a>
<p>
<b>Декоратор</b> – это функция, которая принимает другую функцию в качестве аргумента и возвращает третью. Так и ведут себя декораторы.<br>
Декораторы в Python позволяют расширять и изменять поведение <b>вызываемых объектов</b> (функций, методов и классов) без постоянного изменения самого вызываемого объекта. Это значит мы выполняем (вызываем) функцию, но декоратор теперь изменил её выполнение.<br>
Это бывает полезным, более удобным, например нужно изменить поведение нескльких десятков функций и для этого достаточно написать один декоратор (обёртку) для этих нескольких десятков функций и не менять несколько десятков функций.
<p>
Есть декораторы функций и есть декораторы классов
<p>
Теперь объяснение декораторов:<br>
<b>Функции в Python'e являются объектами.</b><br>
Для того, чтобы понять, как работают декораторы, в первую очередь следует осознать, что в Python'е функции — это тоже объекты.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def shout(word="да"):
    return word.capitalize() + "!"
 
print shout()
# выведет: 'Да!'
 
# Так как функция - это объект, вы можете связать её с переменнной,
# как и любой другой объект
<b>scream = shout</b>
 
# Заметьте, что мы не используем скобок: мы НЕ вызываем функцию "shout",
# мы связываем её с переменной "scream". Это означает, что теперь мы
# можем вызывать "shout" через "scream":
 
<font color=red>print scream()</font>  <font color=brown>#статья старая, 2012 года, python 2  в нем print был без скобок</font>
# выведет: 'Да!'

# Более того, это значит, что мы можем удалить "shout", и функция всё ещё
# будет доступна через переменную "scream"
 
<font color=red>del</font> shout
try:
    print shout()
except NameError, e:
    print e
    #выведет: "name 'shout' is not defined"
 
print scream()
# выведет: 'Да!'
</pre>
</td></tr></table>
<p>
Запомним этот факт, скоро мы к нему вернёмся, но кроме того, стоит понимать, что функция в Python'e может быть определена… внутри другой функции!
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def talk():
    # Внутри определения функции "talk" мы можем определить другую...
    <b>def whisper(word="да"):</b>
        return word.lower() + "..."
 
    # ... и сразу же её использовать!
    print whisper()

# Теперь, КАЖДЫЙ РАЗ при вызове "talk", внутри неё определяется а затем
# и вызывается функция "whisper".
talk()
# выведет: "да..."
 
# Но вне функции "talk" НЕ существует никакой функции "whisper":
try:
    print whisper()
except NameError, e:
    print e
    #выведет : "name 'whisper' is not defined"
</pre>
</td></tr></table>
<p>
Теперь мы знаем, что функции являются полноправными объектами, а значит:
<ol>
<li> могут быть связаны с переменной;
<li> могут быть определены одна внутри другой.
</ol>
<p>
Что ж, а это значит, что одна функция может вернуть другую функцию!<br>
Давайте посмотрим:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def getTalk(type="shout"):
 
    # Мы определяем функции прямо здесь
    def shout(word="да"):
        return word.capitalize()+"!"
 
    def whisper(word="да") :
        return word.lower()+"...";
 
    # Затем возвращаем необходимую
    if type == "shout":
        # Заметьте, что мы НЕ используем "()", нам нужно не вызвать функцию,
        # а вернуть объект функции
        return shout
    else:
        return whisper
 
# Как использовать это непонятное нечто?
# Возьмём функцию и свяжем её с переменной
talk = getTalk()
 
# Как мы можем видеть, "talk" теперь - объект "function":
print(talk)
# выведет: &lt;function getTalk.&lt;locals>.shout at 0x7fe0acda9ca0>
 
# Который можно вызывать, как и функцию, определённую "обычным образом":
print(talk())  # выведет: Да!
 
# Если нам захочется - можно вызвать её напрямую из возвращаемого значения:
print(getTalk("whisper")<font color=red>()</font>)  # выведет: да...
# <font color=red> Если в конце убрать пару скобок,</font> то выведет &lt;function getTalk.&lt;locals>.whisper at 0x7fa02e0cc040>
</pre>
<font color=red>Подождите, раз мы можем возвращать функцию, значит, мы можем и передавать её другой функции, как параметр:</font>
<pre>
def doSomethingBefore(func):
    print "Я делаю что-то ещё, перед тем как вызвать функцию, которую ты мне передал"
    print func()
 
doSomethingBefore(scream)
#выведет:
# Я делаю что-то ещё, перед тем как вызвать функцию, которую ты мне передал
# Да!
</pre>
</td></tr></table>
<p>
Ну что, теперь у нас есть все необходимые знания для того, чтобы понять, как работают <b>декораторы</b>.<br>
Как вы могли догадаться, декораторы — это, по сути, просто своеобразные «обёртки», которые дают нам возможность делать что-либо до и после того, что сделает декорируемая функция, не изменяя её.
<pre>
Создадим свой декоратор «вручную»

# Декоратор - это функция, ожидающая ДРУГУЮ функцию в качестве параметра
def my_shiny_new_decorator(a_function_to_decorate):
    # Внутри себя декоратор определяет функцию-"обёртку".
    # Она будет (что бы вы думали?..) обёрнута вокруг декорируемой,
    # получая возможность исполнять произвольный код до и после неё.

    def the_wrapper_around_the_original_function():
        # Поместим здесь код, который мы хотим запускать ДО вызова
        # оригинальной функции
        print "Я - код, который отработает до вызова функции"
 
        # ВЫЗОВЕМ саму декорируемую функцию
        a_function_to_decorate()

        # А здесь поместим код, который мы хотим запускать ПОСЛЕ вызова
        # оригинальной функции
        print "А я - код, срабатывающий после"

    # На данный момент функция "a_function_to_decorate" НЕ ВЫЗЫВАЛАСЬ НИ РАЗУ

    # Теперь, вернём функцию-обёртку, которая содержит в себе
    # декорируемую функцию, и код, который необходимо выполнить до и после.
    # Всё просто!
    return the_wrapper_around_the_original_function

# Представим теперь, что у нас есть функция, которую мы не планируем больше трогать.
def a_stand_alone_function():
    print "Я – простая одинокая функция, ты ведь не посмеешь меня изменять?.."
 
a_stand_alone_function()
# выведет: Я – простая одинокая функция, ты ведь не посмеешь меня изменять?..
 
# Однако, чтобы изменить её поведение, мы можем декорировать её, то есть
# Просто передать декоратору, который обернет исходную функцию в любой код,
# который нам потребуется, и вернёт новую, готовую к использованию функцию:
 
a_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function_decorated()
#выведет:
# Я - код, который отработает до вызова функции
# Я простая одинокая функция, ты ведь не посмеешь меня изменять?..
# А я - код, срабатывающий после
</pre>
Наверное, теперь мы бы хотели, чтобы каждый раз, во время вызова a_stand_alone_function, вместо неё вызывалась a_stand_alone_function_decorated. Нет ничего проще, просто перезапишем a_stand_alone_function функцией, которую нам вернул my_shiny_new_decorator:
<pre>
a_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)
a_stand_alone_function()
#выведет:
# Я - код, который отработает до вызова функции
# Я простая одинокая функция, ты ведь не посмеешь меня изменять?..
# А я - код, срабатывающий после
</pre>
Вы ведь уже догадались, что это ровно тоже самое, что делают @декораторы.:)<br>
Разрушаем ореол таинственности вокруг декораторов
<p>
Вот так можно было записать предыдущий пример, используя синтаксис декораторов:
<pre>
@my_shiny_new_decorator
def another_stand_alone_function():
    print "Оставь меня в покое"
 
another_stand_alone_function()
#выведет:
# Я - код, который отработает до вызова функции
# Оставь меня в покое
# А я - код, срабатывающий после
</pre>
Да, всё действительно так просто! decorator — просто синтаксический сахар для конструкций вида:<br>
another_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)
<p>
Декораторы — это просто pythonic-реализация паттерна проектирования «Декоратор». В Python включены некоторые классические паттерны проектирования, такие как рассматриваемые в этой статье декораторы, или привычные любому пайтонисту итераторы.
<p>
Конечно, можно вкладывать декораторы друг в друга, например так:
<pre>
def bread(func):
    def wrapper():
        print "</------\>"
        func()
        print "<\______/>"
    return wrapper
 
def ingredients(func):
    def wrapper():
        print "#помидоры#"
        func()
        print "~салат~"
    return wrapper
 
def sandwich(food="--ветчина--"):
    print food
 
sandwich()
#выведет: --ветчина--
sandwich = bread(ingredients(sandwich))
sandwich()
#выведет:
# </------\>
# #помидоры#
# --ветчина--
# ~салат~
# <\______/>


И используя синтаксис декораторов:
@bread
@ingredients
def sandwich(food="--ветчина--"):
    print food
 
sandwich()
#выведет:
# </------\>
# #помидоры#
# --ветчина--
# ~салат~
# <\______/>


Следует помнить о том, что порядок декорирования ВАЖЕН:
@ingredients
@bread
def sandwich(food="--ветчина--"):
    print food
 
sandwich()
#выведет:
# #помидоры#
# </------\>
# --ветчина--
# <\______/>
# ~салат~
</pre>
<pre>




</pre>
<h4>Другое объяснение:</h4>
В Python декоратор — это реализация шаблона, который позволяет добавить поведение к функции или классу. Обычно это выражается 
синтаксисом @decorator с префиксом функции. Вот пример:
<pre>
def some_decorator(f):
    def wraps(*args):
        print(f"Calling function '{f.__name__}'")
        return f(args)
    return wraps
@some_decorator
def decorated_function(x):
    print(f"With argument '{x}'")</pre>
В приведенном выше примере some_decorator() — это функция, которая добавляет поведение к decorated_function(), так что при 
вызове decorated_function(2) получается следующий результат:
<pre>
>>> decorated_function(2)
Calling function 'decorated_function'
With argument '(2,)'
</pre>
decorated_function() печатает только With argument '(2,)', но декоратор добавляет дополнительное поведение, которое также 
печатает Calling function 'decorated_function'.
<p>
Декоратор может быть применен к лямбде. Хотя невозможно декорировать лямбду с помощью синтаксиса @decorator, декоратор — это 
просто функция, поэтому он может вызывать функцию лямбда:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
# <b>Определение декоратора</b>
def trace(f):
    def wrap(*args, **kwargs):
          print(f"[TRACE] func: {f.__name__}, args: {args}, kwargs: {kwargs}")
          return f(*args, **kwargs)
  
    return wrap
  
<b># Применение декоратора к функции:</b>
@trace
def add_two(x):
    return x + 2</pre>
</td></tr></table>
<pre>
# Calling the decorated function
>>> add_two(3)
[TRACE] func: add_two, args: (3,), kwargs: {}
5
# <b>Применение декоратора к lambda:</b>
>>> print((trace(lambda x: x ** 2))(3))
[TRACE] func: &lt;lambda&gt;, args: (3,), kwargs: {}
9
</pre>
add_two(), декорирована @trace в строке 11, вызывается с аргументом 3. В отличие от этого, в строке 18 сразу же 
включается лямбда-функция и встраивается в вызов метода trace(), декоратора.
<p>
Посмотрите, как, как вы уже видели, имя лямбда-функции выглядит как &lt;lambda&gt;, тогда как add_two четко идентифицировано 
как обычная функция.
<p>
Декорирование лямбды таким способом может быть полезно для целей отладки, возможно, для отладки поведения лямбды, используемой 
в контексте функции более высокого порядка или ключевой функции.
<p>
Давайте посмотрим пример с map():
<pre>list(map(trace(lambda x: x*2), range(3)))</pre>
Первый аргумент map() — это лямбда, которая умножает свой аргумент на 2. Эта лямбда декорирована trace(). При выполнении 
приведенный выше пример выводит следующее:
<pre>
[TRACE] Calling &lt;lambda&gt; with args (0,) and kwargs {}
[TRACE] Calling &lt;lambda&gt; with args (1,) and kwargs {}
[TRACE] Calling &lt;lambda&gt; with args (2,) and kwargs {}
[0, 2, 4]</pre>
<font color=red>Почему вывелся список [0, 2, 4], непонятно.</font>
<h4><font color=red>Разница между декоратором с wrapper и декоратором без wpapper</font></h4>
Во всех учебниках декораторы объявляются с вложенной функцией wpapper(). Я никак понять не могу для чего она. Выполню код с wrapper и без:<br>
Классический код декоратора, взятый <a href="https://habr.com/ru/articles/814217/">отсюда.</a>
<pre>
def simple_decorator(func):
    def wrapper():
        print("До вызова функции")
        func()
        print("После вызова функции")
    return wrapper

@simple_decorator
def hello():
    print("Привет, мир!")
hello()

Вывод:
#До вызова функции
#Привет, мир!
#После вызова функции
</pre>
и аналогичный по смыслу для меня декоратор без wrapper():
<pre>
def simple_decorator(func):
    
    '''
    def wrapper():
        print("До вызова функции")
        func()
        print("После вызова функции")
    return wrapper
    '''
    print("До вызова функции")
    func()
    print("После вызова функции")


@simple_decorator
def hello():
    print("Привет, мир!")

hello()
</pre>
Результат:
<pre>
До вызова функции
Привет, мир!
После вызова функции
Traceback (most recent call last):
  File "test.py", line 19, in &lt;module>
    hello()
TypeError: 'NoneType' object is not callable
</pre>
То есть ошибка, но почему, непонятно.
<pre>

===========================================================================================================================

</pre>
<h3 align=center><a name="file" href="https://pyplanet.ru/article/files.html">Работа с файлами: чтение, запись, 
редактирование</a></h3>
В Python, как и в других языках программирования, можно работать с файлами: читать из файла и писать в файл. Это позволяет 
легко манипулировать любыми файлами из Python.
<p>
Файловые объекты должны поддерживать основные методы: read(), write(), readline(), readlines(), seek(), tell(), close() и т.п.
<p>
Прежде, чем работать с файлом, его надо открыть. Открыть файл можно с помощью встроенной функции open:
<pre>
f = open('pyplanet.txt', 'r', encoding='utf-8')</pre>
У функции open много параметров, нам пока важны 3 аргумента.
<p>
Первый, это путь к файлу. Путь к файлу может быть относительным или абсолютным.
<p>
В случае относительного пути поиск файла будет производиться относительно директории, из которой была запущена программа на Python. Как правило, это та папка, в которой находится сама программа.
<p>
Поэтому, чтобы приведённый выше код выполнился, необходимо создать файл pyplanet.txt в той же папке, что и программа, которую вы пишете.
<p>
Однако можно задать и абсолютный путь, например,
<pre>
f = open(r'D:\files\pyplanet.txt', 'r', encoding='utf-8')</pre>
Второй аргумент, это режим, в котором мы будем открывать файл.
<p>
<img src="./images/python_base1.png">
<p>
Режимы могут (и должны) быть объединены, то есть, к примеру, 'rb' - чтение в двоичном режиме. По умолчанию режим равен 'rt'.
<p>
И последний аргумент, encoding, нужен только в текстовом режиме чтения файла. Этот аргумент задает кодировку.
<p>
Какая кодировка идёт по умолчанию? А неизвестно. Начиная с Python версии 3.15 (это примерно к 2026 году) кодировкой по умолчанию станет utf-8.
<p>
В какой же кодировке Ваш файл, зависит от редактора, в котором вы создавали / редактировали файл.
<p>
Как правило, это utf-8, или, в более редких случаях, windows-1251.
<p>
Функция open возвращает объект файла (или по-другому файлового дескриптора).
<h4>Чтение из файла</h4>
Файл мы открыли, а теперь хотим прочитать из него информацию. Для этого есть несколько способов.
<p>
<b>Метод read</b><br>
Метод read файла, читает весь файл целиком, если был вызван без аргументов, и n символов, если был вызван с аргументом (целым числом n).
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> f.read(1)
'H'
>>> f.read()
'ello world!\nThe end.\n\n'</pre>
Каждый последующий вызов read продолжит читать с того места, на котором остановилось чтение.
<h4>Цикл for для чтения файла</h4>
Ещё один прочитать файл - сделать это построчно, воспользовавшись циклом for. Файловый объект в Python - тоже итерируемый объект, и в цикле for он возвращает содержимое файла построчно.
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> for line in f:
...     line
...
'Hello world!\n'
'\n'
'The end.\n'
'\n'</pre>
<h4>readlines</h4>
Метод readlines файла, читает весь файл целиком, и возвращает список всех строк в нём. Этот способ более затратный по памяти, чем цикл for, однако иногда тоже может использоваться.
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> f.readlines()
['Hello world!\n', '\n', 'The end.\n', '\n']</pre>
<h4>Закрытие файла</h4>
После манипуляций с файлом, его необходимо закрыть, таким образом, освободив ресурсы файлового дескриптора.
<pre>f.close()</pre>
Все дескрипторы, конечно, будут освобождены автоматически при выходе из программы, но что, если программа работает долго? Или она открывает много файлов?
<p>
Количество одновременно открытых файлов в системе ограничено.
<p>
Здесь очень сильно может помочь конструкция try - finally, так как при возникновении и перехвате исключения можно забыть закрыть файл:
<pre>
f = open('pyplanet.txt', 'r', encoding='utf-8')
try:
    for line in f:
        do_something(line)
finally:
    f.close()</pre>
<h4>Запись в файл</h4>
Как что-либо записать в файл?
<p>
Во-первых, необходимо открыть файл в режиме "для записи", иначе ничего не получится:
<pre>f = open('pyplanet_output.txt', 'w', encoding='utf-8')</pre>
<ol>
<li> <b>Метод write</b><br>
Метод write, записывает строку в файл:
<pre>f.write("Hello pyplanet!\n")</pre>
Метод write возвращает количество записанных символов. Не пугайтесь, если в интерактивном режиме увидите цифры - это они и есть.<br>
Перенос строки не добавляется автоматически. Не забывайте добавлять его вручную, иначе строки "слипнутся".
<p>
<img src="./images/python_base6.png"><br>
На рисунке показаы 2 способа записи в файл. Число не записывается напрямую, сначало нужно с помощью функции str() преобразовать число в строку.
<p>
<li> <b>Аргумент file функции print</b><br>
Функция print может принимать в качестве аргумента файловый дескриптор для печати.
<p>
Из плюсов - символ переноса строки поставится за вас:
<pre>print("Hello pyplanet!", file=f)</pre>
<p>
<li> <b>Метод writelines</b><br>
Метод writelines, записывает список строк в файл:
<pre>f.writelines(["1\n", "2\n", "3\n"])</pre>
Перенос строки, как и в методе write, не добавляется автоматически. Не забывайте добавлять его вручную, иначе строки "слипнутся".<br>
Для записи более сложных структур в Python есть такие средства, как pickle, json, csv, и многие другие.
<p>
Примеры:<br>
Следующий пример показывает копирование файла:
<pre>
f1 = open("file1.txt", "r")
f2 = open("file2.txt", "w")
for line in f1.readlines():
  f2.write(line)
f2.close()
f1.close()
</pre>

<li> Стоит заметить, что кроме собственно файлов в Python используются и файлоподобные объекты. В очень многих функциях просто 
неважно, передан ли ей объект типа file или другого типа, если он имеет все те же методы (и в том же смысле). Например, 
копирование содержимого по ссылке (URL) в файл file2.txt можно достигнуть, если заменить первую строку из предыдущего примера 
на:
<pre>
import urllib
f1 = urllib.urlopen("http://python.onego.ru")</pre>

<li> <b>with open() as var</b><br>
Открыть файл, выполнить с ним нужные операции и автоматически закрыть его после можно с помощью конструкции:
<pre>
with open('name_file') as var
    s1 = var.readline()
    s2 = var.readline()</pre>
По выполнении блока, файловый дескриптор будет удален (файл закроется). Поэтому такая конструкция with open file as f является 
более рекомендованной по сравнению с f = open file
<li> <b>Полезные методы файлов</b>
<ol>
<li> strip()<br>
Удаляет служебные символы при чтении строк файла.

<li> os.path.join(arg1, arg2,...)<br>
Создает из склеивания аргументов полный путь к файлу.<br>
Для того чтобы выполнить этот метод, нужно импортировать модуль os (import as).
<p>
<img src="./images/python_base5.png">
</ol>
<li> <b>Пример построчного чтения файла</b>
<pre>with open('input.txt') as inf:
  for line in inf:
      line = line.strip()
      print()</pre>
</ol>
<h4>Как скачать сайт или вебстраницу</h4>
Код:
<pre>
from urlib.request import urlopen

# html = urlopen("https://dzen.ru/").read().decode('utf-8')
html = urlopen("https://ru.wikipedia.org/wiki/Python").read().decode('utf-8')
print(html)
</pre>
urlib.request - это расширенная библиотека для открытия url адресов.
<p>
html имеет тип str, который будет равен коду веб-страницы.<br>
Почему-то не на всех страницах работает, например на dzen.ru получаю пустой текст внутри тега body или вообще ошибку.
<pre>

============================================================================================================


</pre>

<h3 align=center><a name="except">Исключения: try except</h3>
Ошибки в питоне называются <b>исключениями.</b>
С помощью ключевых слов можно реализовать механизм обработки ошибок во время выполнения программы. Он позволяет программе 
продолжить работу после обнаружения ошибки, а не завершаться аварийно. В Python есть встроенные исключения, которые 
обрабатывают большинство типовых ошибок.
<p>
Обычные ошибки:
<ul>
<li> TypeError — операция или функция применяется к объекту несоответствующего типа.
<li> ValueError — операция или функция получает аргумент неподходящего значения. К примеру, исключение возникает, если 
попытаться преобразовать строку в число.
<li> IndexError — обращение к элементу по несуществующему индексу.
<li> ZeroDivisionError — деление числа на ноль.
<li> FileNotFoundError — Python не может найти файл, который мы хотим открыть.
</ul>
Полный список ошибок <a href="https://docs.python.org/3/library/exceptions.html">здесь.</a>
<p>
В Python есть всё необходимое для создания собственных обработчиков исключений. Это полезно, если надо реализовать нетипичное 
для Python поведение, которое не предусмотрели разработчики. Для этого используются блоки try, except, finally, else и raise:
<ul>
<li> В блоке try/except механизм работает таким образом:
<p>
сначала выполняются выражения, которые записаны в блоке try
<p>
если при выполнения блока try не возникло никаких исключений, блок except пропускается, и выполняется дальнейший код
<p>
если во время выполнения блока try в каком-то месте возникло исключение, оставшаяся часть блока try пропускается
<p>
если в блоке except указано исключение, которое возникло, выполняется код в блоке except
<p>
если исключение, которое возникло, не указано в блоке except, выполнение программы прерывается и выдается ошибка
<p>
<pre>
try:
    a = input("Введите первое число: ")
    b = input("Введите второе число: ")
    print("Результат: ", int(a)/int(b))
except (ValueError, ZeroDivisionError):
    print("Что-то пошло не так...")</pre>
Проверка:
<pre>
$ python divide_ver2.py
Введите первое число: wer
Введите второе число: 4
Что-то пошло не так...

$ python divide_ver2.py
Введите первое число: 5
Введите второе число: 0
Что-то пошло не так...</pre>
<p>
<li> <b>try/except/else</b><br>
В конструкции try/except есть опциональный блок else. Он выполняется в том случае, если не было исключения.
<pre>
try:
    a = input("Введите первое число: ")
    b = input("Введите второе число: ")
    result = int(a)/int(b)
except (ValueError, ZeroDivisionError):
    print("Что-то пошло не так...")
else:
    print("Результат в квадрате: ", result**2)</pre>
Пример выполнения:
<pre>
$ python divide_ver3.py
Введите первое число: 10
Введите второе число: 2
Результат в квадрате:  25

$ python divide_ver3.py
Введите первое число: werq
Введите второе число: 3
Что-то пошло не так...</pre>
<p>
<li> <b>try/except/finally</b><br>
Блок finally - это еще один опциональный блок в конструкции try. Он выполняется всегда, независимо от того, было ли исключение 
или нет.
<br>Сюда ставятся действия, которые надо выполнить в любом случае. Например, это может быть закрытие файла.
<p>
Файл divide_ver4.py с блоком finally:
<pre>
# -*- coding: utf-8 -*-

try:
    a = input("Введите первое число: ")
    b = input("Введите второе число: ")
    result = int(a)/int(b)
except (ValueError, ZeroDivisionError):
    print("Что-то пошло не так...")
else:
    print("Результат в квадрате: ", result**2)
finally:
    print("Вот и сказочке конец, а кто слушал - молодец.")</pre>
Проверка:
<pre>
$ python divide_ver4.py
Введите первое число: 10
Введите второе число: 2
Результат в квадрате:  25
Вот и сказочке конец, а кто слушал - молодец.
</pre>
<p>
<li> Ключевое слово <b>as</b> при обработке ошибок используется для присвоения исключению переменной. К примеру, напишем 
собственное исключение для обработки деления на ноль. Ошибку назовём ZeroDivisionError и присвоим переменной e. Теперь к ней 
можно получить доступ для печати названия ошибки в консоль.
<pre>
try:
    1/0
except ZeroDivisionError as e:
    print(f'Исключение: {str(e)}') # Исключение: division by zero</pre>
<p>
<li> Команда <b>raise</b> в Python используется для принудительного вызова исключения. Это может быть полезно, если мы 
столкнулись с условием, которое должно остановить выполнение программы или вызвать ошибку.
<pre>raise ValueError('Недопустимое значение')</pre>

<h4>Создание собственных исключений</h4>
Ссылки: <a href="https://habr.com/ru/companies/piter/articles/537642/">Как определять собственные классы исключений в Python</
a>
<p>
Иногда надо реализовать собственный обработчик ошибок с помощью исключений. Это делает код более безопасным и поддерживаемым. 
Для создания собственного исключения достаточно определить новый класс, который наследуется от базового класса Exception или 
от любого другого встроенного исключения:
<pre>
class ValidationError(Exception):
    pass</pre>

</ul>







<h3><a href="https://pyplanet.ru/article/with-as.html">Конструкция with - as: менеджер контекста</a></h3>
<h3><a href="https://pyplanet.ru/article/magic-methods.html">Магические методы</a></h3>
<h3><a href="https://pyplanet.ru/article/pip.html">Пакетный менеджер pip</a></h3>






<h3 align=center><a href="https://intuit.ru/studies/courses/49/49/lecture/27080">Лекция 12: Создание приложений с графическим интерфейсом</a></h3>


























<pre>











</pre>
</div></body></html>
