<html><head>
<style>
.menu {
       height: 100%;
       width: 140px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 10px;
           margin-left: 140px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Язык Cи++</title>
<div class="menu">
<a href="./index.html">Главная</a>
--------------------------
<a href="./c++_massiv.html">Массивы</a>
<a href="./c++file.html">Работа с файлами</a>
<a href="./c++funk.html">Функции</a>
<a href="./c++_example.html">Решения</a>
---------------------
Основы языка C++:
<a href="#stdout">Ввод-вывод с помощью объектов cin и cout</a>
<a href="#namespace">Пространства имен</a>
<a href="#using">Оператор using</a>
<a href="#type">Типы данных. Приведение типов указателей</a>
<a href="#const">const в С++</a>
<a href="#links">Ссылки</a>
<a href="#string">Объект-строка string</a>
<a href="#add_string">&nbsp;&nbsp; Добавление и объединение строк</a>
<a href="#write_string">&nbsp;&nbsp; getline - ввод строк из stdin</a>
</div>

<div class="content">

Ссылки на учебники: <a href="https://metanit.com/cpp/tutorial/">Руководство по языку программирования C++</a><br>
<a href="https://proproprogs.ru/c_base/cpp-pervaya-programma-na-s">Первая программа на С++</a><br>
<a href="https://cplusplus.com/doc/tutorial/">C++ Language</a>
<p>
С++ является компилируемым языком, а это значит, что компилятор транслирует исходный код на С++ в исполняемый файл, который содержит набор машинных инструкций. Но разные платформы имеют свои особенности, поэтому скомпилированные программы нельзя просто перенести с одной платформы на другую и там уже запустить. Однако на уровне исходного кода программы на С++ по большей степени обладают переносимостью, если не используются какие-то специфичные для текущей ос функции. А наличие компиляторов, библиотек и инструментов разработки почти под все распространенные платформы позволяет компилировать один и тот же исходный код на С++ в приложения под эти платформы.
<p>
В отличие от Си язык C++ позволяет писать приложения в объектно-ориентированном стиле, представляя программу как совокупность взаимодействующих между собой классов и объектов. Что упрощает создание крупных приложений.
<p>
В 1998 году была предпринята первая попытка по стандартизации языка организацией ISO (International Organiztion for Standartization). Первый стандарт получил название ISO/IEC 14882:1998 или сокращенно С++98. В дальнейшем в 2003 была издана новая версия стандарта C++03.
<p>
В 2011 году был издан новый стандарт C++11, который содержал множество добавлений и обогащал язык С++ большим числом новых функциональных возможностей. С тех пор было выпущено еще ряд стандартов. На момент написания данной статьи самый последний стандарт - C++20 был опубликован в декабре 2020 года. В 2023 году ожидается выход стандарта C++23
<pre>


</pre>
<h3 align=center>Как писать и запускать программы на С++</h3>
Для написания программ на языке С++ как минимум необходимы два компонента: текстовый редактор, с помощью которого можно набрать исходный код, и компилятор, который принимает файл с исходным кодом и компилирует его в исполняемый файл. В качестве текстового редактора можно выбрать любой понравившийся. Я бы посоветовал кросcплатформенный редактор Visual Studio Code, который поддерживает плагины для разных языков, в том числе для C++.
<p>
Если с текстовым редактором относительно просто - можно выбрать любой, то выбор компилятора может действительно стать проблемой. Поскольку в настоящий момент есть очень много различных компиляторов, которые могут отличаться по различным аспектам, в частности, по реализации стандартов. Базовый список компиляторов для С++ можно посмотреть в <a href="https://en.wikipedia.org/wiki/List_of_compilers#C.2B.2B_compilers">википедии</a>. А на странице https://en.cppreference.com/w/cpp/compiler_support можно ознакомиться с поддержкой компиляторами последних стандартов. В общем случае нередко рекомендуют хотя бы ознакомиться как минимум с тремя основными компиляторами:
<ul>
<li> g++ от проекта GNU (в составе набора компиляторов GCC)
<p>
<li> Clang (доступен в рамках проекта LLVM)
<p>
<li> компилятор C++ от компании Microsoft (используется в Visual Studio)
</ul>
<p>
<b>Чтобы убедиться, что компилятор установлен</b>, достаточно открыть командное окно и ввести команду:
<pre>
g++ --version
</pre>
Если отобразится версия, значит, все настроено и готово к работе. Иначе, необходимо установить компилятор.
<br>
У меня на ubuntu 20.04 уже установлен компилятор g++:<br>
<img src="./images/c++.png">
<pre>


</pre>
<b>Как установить компилятор на Windows, описано <a href="https://metanit.com/cpp/tutorial/1.2.php">здесь</a></b>.
<p>
<a href="https://metanit.com/cpp/tutorial/1.3.php">Первая программа на Linux. Компилятор g++</a>
<pre>



</pre>
В домашнем каталоге создал папку С++<br>
Далее:
<pre>
cd C++
touch course.cpp
</pre>
С помощью последней команды создал файл course.cpp<br>
<i>Программы на языке С++ принято сохранять с расширением cpp</i>
<p>
В нем записал программу:
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
// Первая программа на языке С++
#include &lt;iostream> // подключаем заголовочный файл
 
int main()
{
    std::cout &lt;&lt; "Hello World!" << std::endl; //вывод сообщения на терминал
    
    return 0;
}
</pre></td></tr></table>

<h4>Теперь скомпилируем эту программу</h4>
Переходим в папку файла:<br>
cd C++
<p>
Чтобы скомпилировать исходный код, необходимо компилятору gcc передать в качестве параметра файл hello.cpp:
<pre>
g++ hello.cpp -o hello
</pre>
Кроме имени файла с исходным кодом компилятору передается параметр -o hello. Он указывает, что мы хотим скомпилировать файл по имени hello. Если этот параметр не передать, то будет создан файл с именем по умолчанию - a.out.
<p>
В итоге после выполнения выше приведенной команды в папке с файлом hello.cpp появится скомпилированный файл, который будет называться hello. И мы сможем его запустить с помощью следующей команды:
<pre>
<b>./hello</b>
</pre>
Последняя команда верна на ubuntu, для windows достаточно набрать: hello
<p>
<i>Теперь мои действия:<br>
Выполнил команду: <b>g++ course.cpp -o course</b><br>
В папке файла кроме course.cpp появились файлы a.out и course без расширения.
<p>
Далее выполнил команду: course<br>
Сообщение: course: команда не найдена<br>
Почитал инструкцию, немного я не так сделал.
<p>
Выполнил:
<pre>./course
</pre></i>
<p>
<img src="./images/c++1.png">
<p>
Для того, чтобы автоматически запустить приложение после компиляции, можно использовать следующую команду:
<pre>
g++ source.cpp & ./a.out
</pre>
Можно налепить в одну команду различные опции:
<pre>
g++ -std=c++20 -Wall -pedantic app.cpp -o app & app
</pre>
<h4>Теперь разбор выше написанной программы:</h4>
Конструкция:
<pre>
std::cout << "Hello World!" << std::endl;
</pre>
отвечает за вывод информации в стандартный выходной поток. Здесь в глаза бросается фрагмент «std::…». Ключевое слово <b>std</b> – это предопределенное название пространства имен, так называемой, стандартной библиотеки языка С++. Как я отмечал во вступлении, в язык С++ на уровне стандарта включили библиотеку STL, которая заметно упрощает работу со сложными коллекциями и типами данных, таких как:
<ul>
<li> строки (std::string);
<li> массивы (std::array);
<li> динамический массив (std::vector);
<li> двухсвязный список (std::list);
<li> очередь (std::deque);
<li> упорядоченные множества (std::set);
<li> упорядоченные ассоциативные массивы (std::map)
</ul>
и многое другое. Так вот, чтобы обратиться к тому или иному определению в пространстве стандартной библиотеки, следует прописать название этого пространства std и через два двоеточия (четвероточие) указать нужный элемент. В частности, <b>cout</b> – это объект класса ostream, который отвечает за вывод информации в стандартный выходной поток. Затем, используя переопределенную операцию <<, указываются выводимые данные. В конце, после вывода строки «Hello World!» прописан <b>endl</b>. Он передает символ переноса строки и очищает буфер потока, к которому применен.
<pre>




</pre>
<a name="stdout"><h3 align=center>Ввод-вывод с помощью объектов cin и cout</h3>
Разберем работу двух объектов:
<ul>
<li> cin – объект класса istream для работы с потоком stdin;
<li> cout – объект класса ostream для работы с потоком stdout.
</ul>
По умолчанию язык C++ не содержит встроенных средств для ввода с консоли и вывода на консоль, эти средства предоставляются библиотекой <b>iostream</b>. В ней определены два типа: <b>istream</b> и <b>ostream</b>. istream представляет поток ввода, а ostream - поток вывода.
<p>
Вообще, сам термин "поток" в данном случае представляет последовательность символов, которая записывается на устройство ввода-вывода или считывается с него. И в данном случае под устройством ввода-вывода рассматривается консоль.
<p>
Для записи или вывода символов на консоль применяется объект <b>cout</b>, который представляет тип ostream. А для чтения с консоли используется объект <b>cin</b>
<p>
Для использования этих объектов в начало исходного файла необходимо подключить библиотеку iostream:
<pre>
#include &lt;iostream>
</pre>
<h4>Вывод на консоль</h4>
Начнем с более простого объекта cout. Чтобы им воспользоваться, в программе на С++ вначале необходимо подключить файл iostream. После этого в пространстве имен std будет доступен объект cout. Затем, объявим в программе несколько переменных разных типов и выведем их в стандартный поток с помощью cout. Сделать это можно следующим образом:
<pre>
#include &lt;iostream>
 
int main()
{
    char str[100] = "Hi, Sergey!";
    short old = 99;
    double weight = 82.54;
 
    <b>std::cout << str << "\n";
    std::cout << old << "\n";    //перевод строки можно по разному делать
    std::cout << weight << std::endl;</b>
}
</pre>
Первое, что бросается в глаза – это вывод значения переменной без дополнительного указания ее типа. Например, если бы мы эту же операцию захотели бы повторить с помощью функции printf(), то пришлось бы прописывать форматную строку со спецификаторами:<br>
printf("%s\n%d\n%.2f\n", str, old, weight);
<p>
Если кому интересно, как это все работает «под капотом», то скажу буквально пару слов. У каждого класса в С++ можно делать переопределение стандартных операций. В частности, операция << для класса ostream переопределена для каждого стандартного, базового типа и компилятор в соответствии с типом переменной (или, в общем случае, по данным в правом операнде), выбирает соответствующую реализацию операции <<. Сама же операция << выполняет передачу в выходной поток stdout соответствующих данных и возвращает объект cout. А раз так, то мы можем записать вывод трех переменных следующим образом:
<pre>
std::cout << str << '\n' << old << "\n" << weight << std::endl;
</pre>
Получим абсолютно тот же самый результат.
<p>
Второе, на что следует обратить внимание – это использование управляющих символов ‘\n’. Сначала я его прописал, как символ, а второй раз – как строку. Для объекта cout это не имеет большого значения, но, конечно, если нам нужно вывести отдельный символ, то лучше это делать через одинарные кавычки.
<p>
В самом конце вывода прописана функция endl. Она выполняет два действия: переводит курсор на новую строку и очищает выходной буфер, указывая конечному устройству, связанному с выходным потоком, что все данные переданы и их можно обрабатывать. В случае с выводом на монитор очистка мало что дает, т.к. информация сразу отображается на экране. Но, вполне могут быть и другие ситуации, когда вместо монитора подключено другое устройство и вывод осуществляется только в момент очистки выходного буфера.
<h4>Ввод с консоли</h4>
Следующий объект <b>cin</b> работает похожим образом, но осуществляет уже считывание информации из стандартного входного потока stdin и запись прочитанных данных в указанную переменную или, в общем случае, lvalue выражение.
<p>
Давайте, для примера выполним считывание данных в переменные old и weight с помощью cin следующим образом:
<pre>
#include &lt;iostream>
 
int main()
{
    char str[100] = "Hi, Sergey!";
    short old = 99;
    double weight = 82.54;
 
    std::cin >> old;
    std::cin >> weight;
    
    std::cout << str << '\n' << old << '\n' << weight << std::endl;
}
</pre>
Если данные введены верно (целочисленное значение и вещественное), то переменные old и weight будут содержать корректные введенные значения. Причем ввести их можно каждый с новой строки или через пробел. Если во входном потоке stdin встречаются данные, не соответствующие типу переменной, то значение переменной обнуляется с неверной интерпретацией последующих операций считывания. Поэтому формат входных данных в stdin должен совпадать с типами читаемых данных.
<p>
Операция >> после чтения порции данных возвращает объект cin, поэтому два последовательных вызова cin можно объединить в один:
<pre>
std::cin >> old >> weight;
</pre>
Результат будет тем же самым.
<p>
Последний важный момент, связанный с использованием объекта cin, это чтение строк из входного потока. Допустим, мы в переменную str читаем строковые данные следующим образом:
<pre>
std::cin >> str;
</pre>
и вводим строку «hello world». В результате в массив str будет помещен только первый фрагмент до пробела, то есть, «hello», а второй останется во входном потоке. То есть, cin со строками работает так же, как и функция scanf() языка Си. Если вам нужно читать строку целиком (до символа перевода строки или до конца данных), то следует использовать новую функцию getline() языка С++. Она работает с объектом std::string и речь о ней еще впереди.
<pre>


</pre>
<a name="namespace"><h3 align=center>Пространства имен (namespace)</h3>
В языке С++ все объявления переменных вне функции main() попадают в так называемое <b>глобальное пространство имен</b>.<br>
Внутри функции main() мы можем обращаться к этим определениям следующим образом:
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
<pre>
void foo()
{
    std::cout << "function: foo()" << std::endl;
}
 
int global_a = 5;
 
struct point {
    double x, y;
};

int main()
{
    point pt {};
 
    foo();
    std::cout << global_a << std::endl;
 
    return 0;
}

или так:

int main()
{
    <b>::</b>point pt {};
 
    <b>::</b>foo();
    std::cout << ::global_a << std::endl;
 
    return 0;
}
</pre>
</td></tr></table>
Два двоеточия (программисты еще иногда их называют «четвероточием») - это <b>символ раскрытия области видимости</b>.<br>
<font color=green>Если перед ним (слева) не указана какая-либо область видимости, то подразумевается глобальная область (глобальное пространство имен).</font>
<p>
Что нам дает этот символ? Смотрите, если, к примеру, внутри функции main() объявить еще одну переменную с именем global_a:<br>
int global_a = 10;<br>
то мы можем их различать с помощью «четвероточия»:
<pre>
std::cout << ::global_a << " " << global_a << std::endl;
</pre>
С двумя двоеточиями global_a - это глобальная переменная, без - локальная. Поэтому увидим значения 5 и 10. Поэтому, если мы хотим быть уверены, что обращаемся к глобальной переменной, то перед ее именем достаточно прописать два двоеточия. В ряде случаев это бывает очень полезно.
<h4>namespace</h4>
Может быть так, что внутри файла могут быть определены две функции с одинаковыми именами или могут быть другие конфликты имен, для решения подобных конфликтов в С++ существует возможность создавать свои пространства имен, которые позволяют разделять один набор определений от другого набора. Для этого используется ключевое слово <b>namespace</b>, после которого указывается название нового или существующего пространства. Например, так:
<pre>
namespace firstSpace {   //foo внутри пространства имен firstSpace
    void foo()
    {
        std::cout << "function from firstSpace: foo()" << std::endl;
    }
}
 
void foo()               //foo внутри глобального пространства имен::
{
    std::cout << "function: foo()" << std::endl;
}
</pre>
Здесь название firstSpace мы придумываем сами подобно именам переменных и функций, а, затем, в фигурных скобках следует содержимое этого пространства. В нашем примере там располагается функция с именем foo. Теперь программа будет компилироваться без проблем, так как функции foo() находятся в разных пространствах имен.
<p>
Как следует вызывать эти функции внутри main()? Делается это следующим образом:
<pre>
firstSpace::foo();
</pre>
То есть, <b>сначала указывается название пространства имен, а затем, через два двоеточия элемент этого пространства</b>. В данном случае вызывается функция foo().
<p>
Несколько важных деталей. Во-первых, определение одного и того же пространства имен можно определять в разных местах программы (проекта), например, следующим образом:
<pre>
namespace firstSpace {
    void foo()
    {
        std::cout << "function from firstSpace: foo()" << std::endl;
    }
}
 
namespace firstSpace {
    struct point {
        double x, y;
    };
}
</pre>
В результате будет создано пространство firstSpace с функцией foo и структурой point. Это эквивалентно тому, если бы мы их прописали в одном определении firstSpace:
<pre>
namespace firstSpace {
    void foo()
    {
        std::cout << "function from firstSpace: foo()" << std::endl;
    }
 
    struct point {
        double x, y;
    };
}
</pre>
Данный прием бывает полезен, когда программист разбивает свой проект на несколько файлов и в каждом нужно прописывать свою реализацию одного и того же пространства имен. Тогда в каждом файле достаточно прописать одно и то же имя после ключевого слова namespace.
<p>
Второй момент, касается вложенных пространств имен. Например, так:
<pre>
<b>namespace secondSpace {
    namespace functions</b> {
        void foo()
        {
            std::cout << "function from secondSpace: foo()" << std::endl;
        }
    }
 
    namespace params {
        int global_a = 5;
    }
}
</pre>
Соответственно, обращение к элементам такого пространства будет выглядеть следующим образом:
<pre>
secondSpace::functions::foo(); //foo находится в secondSpace::functions

std::cout << secondSpace::params::global_a << std::endl; //global_a находится в secondSpace::params
</pre>
<h4>inline</h4>
И последний штрих. Если перед именем <i>вложенного пространства</i> прописать ключевое слово <b>inline</b>, например, так:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
<pre>
namespace secondSpace {
    <b>inline</b> namespace functions {
        void foo()
        {
            std::cout << "function from secondSpace: foo()" << std::endl;
        }
    }
    ...
}
</pre>
</td></tr></table>
<p>
то доступ к функции foo() можно делать следующим образом:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
<pre>
secondSpace::functions::foo();

secondSpace::foo(); //ns functions указывать не обязательно
</pre>
</td></tr></table>
<p>
То есть, имя inline-пространства указывать не обязательно.
<pre>



</pre>
<a name="using"><h3 align=center>Оператор using</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-operator-using">Оператор using</a><br>
<a href="https://metanit.com/cpp/tutorial/2.11.php">using. Подключение пространств имен и определение псевдонимов</a>
<p>
При чтении и записи в предыдущих темах использовались объекты std::cout и std::cin соответственно. Причем они использовались с префиксом std::. Этот префикс указывает, что объекты cout, cin, endl определены в пространстве имен std. А само двойное двоеточие :: представляет оператор области видимости (scope operator), который позволяет указать, в каком пространстве имен определен объект. И без префикса эти объекты по умолчанию мы использовать не можем.
<p>
Однако подобная запись может показаться несколько громоздкой. И в этом случае можно использовать оператор using, который позволяет ввести в программу объекты из различных пространств имен. Использовать его можно в соответствии со следующим синтаксисом:
<pre>
using пространство имен::элемент;
</pre>
Например, чтобы импортировать объекты cin/cout и функцию endl в текущий модуль <font color=red>в глобальное пространство имен</font>, достаточно прописать:
<pre>
#include &lt;iostream>
 
using std::cout;
using std::cin;
using std::endl;
 
int main()
{
    char str[50];
 
    cin >> str;                              //вместо std::cin пишем только cin
    cout << "Hello, " << str << "!" << endl; //вместо std::cout пишем только cout
 
    return 0;
}
</pre>
Если же этот оператор прописать в каком-либо блоке, например, в теле функции main(), то импорт будет сделан в пределах этого блока:
<pre>
#include &lt;iostream>
 
int main()
{
    using std::cout;
    using std::cin;
    using std::endl;
 
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
</pre>
Соответственно, определения cout, cin и endl доступны теперь только внутри тела функции main() и не доступны за его пределами.
<p>
Обычно, на практике, отдельные элементы импортируются в глобальную область или в пространство имен, где их активно предполагается использовать. А вот делать импорт всех определений того или иного пространства имен следует исключительно в локальные области.
<p>
Давайте посмотрим, как синтаксически выполняется импорт всего пространства. Для этого также прописывается ключевое слово using, за которым следует еще одно ключевое слово namespace с указанием имени импортируемого пространства. Например:
<pre>
int main()
{
    using namespace std;
    // using std::cout;
    // using std::cin;
    // using std::endl;
 
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
</pre>
В результате, все определения из std становятся доступными напрямую в теле функции main(). И, еще раз, обратите внимание. Писать подобный импорт в глобальной области – крайне плохая практика. Часто, далеко не все, что прописано в std, используется в текущем модуле. И программист вполне может случайно объявить переменную или функцию или что-либо еще с тем же именем, что и импортированный элемент. Возникнет конфликт имен и компиляция программы завершится с ошибкой. Как раз чтобы этого избежать, лучше явно указывать импортируемые элементы:
<pre>
using std::cout;
using std::cin;
using std::endl;
</pre>
Или, в крайнем случае, делать полный импорт в локальную область видимости.
<pre>


</pre>
<h4 align=center>Определение псевдонимов типов</h4>
это еще не все, что умеет делать оператор using. С его помощью можно создавать псевдонимы (алиасы) существующих в программе типов данных. Делается это по следующему синтаксису:
<pre>
using &lt;alias> = &lt;тип данных>;
</pre>
Например, в самом простом варианте, можно прописать что-то вроде:
<p>
using byte_8 = unsigned char;<br>
В программе появляется новое имя byte_8 базового типа unsigned char, которое полноценно можно использовать следующим образом:
<pre>
byte_8 byte;
byte_8* byte_ptr;
</pre>
Или, такой пример. Пусть у нас в программе объявлено пространство имен с определением функции и структуры:
<pre>
namespace firstSpace {
    void foo()
    {
        cout << "function from firstSpace: foo()" << endl;
    }
 
    struct point {
        double x, y;
    };
}
</pre>
Тогда для типа firstSpace::point можно создать псевдоним следующим образом:
<p>
using point2D = firstSpace::point;<br>
и использовать его для объявления соответствующей переменной на структуру:
<p>
point2D pt;<br>
При этом прежний тип firstSpace::point, конечно же продолжает существовать. Мы лишь создаем еще одно имя этого типа не более того. И using создает псевдонимы именно для типов данных. Например, запись вида:
<p>
using func = firstSpace::foo;<br>
приведет к ошибке, т.к. foo – это имя функции, а не тип данных.
<h4>Разница между typedef и using NAME = type</h4>
Вообще конструкция
<pre>
using &lt;alias> = &lt;тип данных>;
</pre>
очень напоминает оператор typedef языка Си. Например, с его помощью мы также можем записать:
<pre>
typedef unsigned char byte_8;
typedef firstSpace::point point2D;
</pre>
<h4>Указатель на функцию через using</h4>
На первый взгляд никаких отличий. Но они все же имеются. Оператор using полностью покрывает функциональность оператора typedef и привносит некоторые дополнительные возможности и улучшения. Например, объявление типа указателя на функцию через typedef выглядит так:
<pre>
typedef float (*func_ptr)(int);
</pre>
а с использованием using несколько понятнее и красивее:
<pre>
using func_ptr = float (*)(int);
</pre>
Но, конечно, главное преимущество using перед typedef проявляются при работе с шаблонами (templates). Но это уже выходит за пределы нашего базового курса по С++. Отмечу лишь, что в современных программах на С++ нет смысла использовать typedef и от него лучше отказываться в пользу оператора using. Хотя это не строгое правило и применение typedef все же допустимо.
<pre>


============================================================================================================================

</pre>
<a name="type"><h3 align=center>Новые типы данных. Приведение типов указателей</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-novye-tipy-dannyh-privedenie-tipov-ukazateley">Новые типы данных. Приведение типов указателей</a><br>
<a href="https://metanit.com/cpp/tutorial/2.3.php">Типы данных</a>
<p>
В С++ присутствуют все стандартные (базовые) типы языка Си, но дополнительно введено еще несколько:
<ul>
<li> bool – булевый тип (1 байт), принимающий два состояния true/false;
<li> wchar_t – расширенный символьный тип (2 байта в ОС Windows; 4 байта в ОС Linux);
<li> char8_t – символьный тип (1 байт) для символов кодировки Unicode (UTF-8) (добавлен в стандарте С++20);
<li> char16_t – символьный тип (2 байта) для символов кодировки Unicode (UTF-16);
<li> char32_t – символьный тип (4 байта) для символов кодировки Unicode (UTF-32).
</ul>
<h4>bool</h4>
Логический тип bool может хранить одно из двух значений: true (истинно, верно) и false (неверно, ложно).<br>
При выводе значения типа bool преобразуются в 1 (если true) и 0 (если false).<br>
Значение по умолчанию для переменных этого типа - false.<br>
Переменные типа bool обычно используют в условных выражениях. В частности, мы можем записать такую конструкцию:
<pre>
bool fl_print = false;
fl_print = true; //изменили
if (fl_print) {
        std::cout << "Hi!" << std::endl;
}
</pre>
Вообще, значение false соответствует целому числу 0, а true – единице. Поэтому, запись вида:
<p>
fl_print = 1;
будет эквивалентна предыдущей. Тип bool и ключевые слова true/false введены для удобства написания и понимания программы. Принципиально нового на уровне машинных кодов ничего не появляется.
<pre>


</pre>
<h3 align=center>Целочисленные типы</h3>
Целые числа в языке C++ представлены следующими типами:
<ul>
<li> <b>signed char</b>: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от -128 до 127
<p>
<li> <b>unsigned char</b>: представляет один символ. Занимает в памяти 1 байт (8 бит). Может хранить любой значение из диапазона от 0 до 255
<p>
<li> <b>char</b>: представляет один символ в кодировке ASCII. Занимает в памяти 1 байт (8 бит). Может хранить любое значение из диапазона от -128 до 127, либо от 0 до 255<br>
Несмотря на то, что данный тип представляет тот же диапазон значений, что и вышеописанный тип signed char, но они не эквивалентны. Тип char предназначен для хранения числового кода символа и в реальности может представлять как signed char, так и unsigned char в зависимости от конкретного компилятора.
<p>
<li> <b>short</b>: представляет целое число в диапазоне от –32768 до 32767. Занимает в памяти 2 байта (16 бит).<br>
Данный тип также имеет псевдонимы <b>short int, signed short int, signed short</b>.
<p>
<li> <b>unsigned short</b>: представляет целое число в диапазоне от 0 до 65535. Занимает в памяти 2 байта (16 бит).<br>
Данный тип также имеет синоним <b>unsigned short int</b>.
<p>
<li> <b>int</b>: представляет целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита). Диапазон предельных значений соответственно также может варьироваться от –32768 до 32767 (при 2 байтах) или от −2 147 483 648 до 2 147 483 647 (при 4 байтах). Но в любом случае размер должен быть больше или равен размеру типа short и меньше или равен размеру типа long<br>
Данный тип имеет псевдонимы <b>signed int</b> и <b>signed</b>.
<p>
<li> <b>unsigned int</b>: представляет положительное целое число. В зависимости от архитектуры процессора может занимать 2 байта (16 бит) или 4 байта (32 бита), и из-за этого диапазон предельных значений может меняться: от 0 до 65535 (для 2 байт), либо от 0 до 4 294 967 295 (для 4 байт).<br>
Имеет псевдоним <b>unsigned</b>
<p>
<li> <b>long</b>: в зависимости от архитектуры может занимать 4 или 8 байт и представляет целое число в диапазоне от −2 147 483 648 до 2 147 483 647 (при 4 байтах) или от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807 (при 8 байтах). Занимает в памяти 4 байта (32 бита) или.<br>
Имеет псевдонимы <b>long int, signed long int и signed long</b>
<p>
<li> <b>unsigned long</b>: представляет целое число в диапазоне от 0 до 4 294 967 295. Занимает в памяти 4 байта (32 бита).<br>
Имеет синоним <b>unsigned long int</b>.
<p>
<li> <b>long long</b>: представляет целое число в диапазоне от −9 223 372 036 854 775 808 до +9 223 372 036 854 775 807. Занимает в памяти 8 байт (64 бита).<br>
Имеет псевдонимы <b>long long int, signed long long int и signed long long</b>.
<p>
<li> <b>unsigned long long</b>: представляет целое число в диапазоне от 0 до 18 446 744 073 709 551 615. Занимает в памяти, как правило, 8 байт (64 бита).<br>
Имеет псевдоним <b>unsigned long long int</b>.
</ul>
Для представления чисел в С++ применятся целочисленные литералы со знаком или без, типа -10 или 10. Например, определим ряд переменных целочисленных типов и выведем их значения на консоль:
<pre>
#include &lt;iostream>
 
int main()
{
    signed char num1{ -64 };
    unsigned char num2{ 64 };
    short num3{ -88 };
    unsigned short num4{ 88 };
    int num5{ -1024 };
    unsigned int num6{ 1024 };
    long num7{ -2048 };
    unsigned long num8{ 2048 };
    long long num9{ -4096 };
    unsigned long long num10{ 4096 };
    std::cout << "num1 = " << num1 << std::endl;
    std::cout << "num2 = " << num2 << std::endl;
    std::cout << "num3 = " << num3 << std::endl;
    std::cout << "num4 = " << num4 << std::endl;
    std::cout << "num5 = " << num5 << std::endl;
    std::cout << "num6 = " << num6 << std::endl;
    std::cout << "num7 = " << num7 << std::endl;
    std::cout << "num8 = " << num8 << std::endl;
    std::cout << "num9 = " << num9 << std::endl;
    std::cout << "num10 = " << num10 << std::endl;
}
</pre>
Но стоит отметить, что все целочисленные литералы по умолчанию представляют тип int. Так, выше переменным разных типов присваивались различные числа - 64, -64, 88, -88, 1024 и т.д. Но все эти целочисленные литералы представляют тип int.
<p>
Однако мы можем использовать целочисленные литералы и других типов. Целочисленные литералы без знака (которые представляют unsigned-типы) имеют суффикс u или U. Литералы типов long и long long имеют суффиксы L/l и LL/ll соответственно:
<pre>
#include &lt;iostream>
 
int main()
{
    unsigned int num6{ 1024U };         // U - unsigned int
    long num7{ -2048L };                // L - long
    unsigned long num8{ 2048UL };       // UL - unsigned long
    long long num9{ -4096LL };          // LL - long long
    unsigned long long num10{ 4096ULL };// ULL - unsigned long long
    std::cout << "num6 = " << num6 << std::endl;
    std::cout << "num7 = " << num7 << std::endl;
    std::cout << "num8 = " << num8 << std::endl;
    std::cout << "num9 = " << num9 << std::endl;
    std::cout << "num10 = " << num10 << std::endl;
}
</pre>
Тем не менее использовать суффиксы необязательно, поскольку, как правило, компилятор может успешно преобразовать целочисленный литерал типа (который технически представляет тип int) к нужному типу без потери информации.
<p>
Если число большое, то при вводе мы можем где-то ошибиться. Чтобы упростить читабельность чисел, начиная со стандарта C++14 в язык была добавлена возможность разделения разрядов числа с помощью одинарной кавычки '
<pre>
#include &lt;iostream>
 
int main()
{
    int num{ <b>1'234'567'890</b> };
    std::cout << "num = " << num << "\n";   // num = 1234567890
}
</pre>
<pre>


</pre>
<h3 align=center>Символьные типы</h3>
<h4>wchar_t</h4>
тип wchar_t используется для представления символов, коды которых выходят за пределы одного байта (типа char). На Windows занимает в памяти 2 байта (16 бит), на Linux - 4 байта (32 бита). Может хранить любой значение из диапазона от 0 до 65 535 (при 2 байтах), либо от 0 до 4 294 967 295 (для 4 байт)
<p>
Значения wchar_t определяются также как и символы char за тем исключением, что они предваряются символов "L":
<pre>
wchar_t a1 {L'A'};
</pre>
Также можно передать код символа
<pre>
wchar_t a1 {L'\x41'};
</pre>
Значение, заключенное в одинарные кавычки, представляет собой шестнадцатеричный код символа. Обратная косая черта указывает на начало управляющей последовательности, а x после обратной косой черты означает, что код шестнадцатеричный.
<p>
Стоит учитывать, что для вывода на консоль символов wchar_t следует использовать не std::cout, а поток std::wcout:
<pre>
#include &lt;iostream>
 
int main()
{
    char h = 'H';
    wchar_t i {L'i'};
    std::wcout << h << i <<'\n';
}
</pre>
При этом поток std::wcout может работать как с char, так и с wchar_t. А поток std::cout для переменной wchar_t вместо символа будет выводить его числовой код.
<p>
Пример с символом кодировки Unicode. Если записать:
<pre>
wchar_t wch;
wch = L'Я';
</pre>
и вывести значение кода буквы ‘Я’:
<p>
std::cout << wch << std::endl;<br>
то увидим число 1071. Это значение символа ‘Я’ в кодировке UTF8, т. к. текст программы сохранен в файле в этой кодировки. Причем, смотрите, если мы попытаемся этот же символ присвоить переменной типа char:
<p>
char ch = 'Я';<br>
то компилятор выдаст предупреждение, что код символа выходит за диапазон типа char. А вот с латинскими символами таких проблем уже не возникает:
<p>
char ch = 'd';<br>
так как их коды не превышают 127.
<p>
Еще одно важное отличие языка С++ от Си состоит в том, что символьные литералы, записанные в программе, приводятся компилятором к типу char, а не int, как это было в языке Си. Во всем остальном, работа с отдельными символами или их последовательностями остается прежней. Например, можно объявить строковый литерал следующим образом:
<p?
char str[] = "Привет мир!";<br>
и вывести это сообщение в консоль:
<pre>
std::cout << str << std::endl;
std::cout << sizeof(str) << std::endl;
</pre>
Увидим строку «Привет мир!» и число 21. Почему размер массива равен 21, а не 11 по числу символов? Очевидно, что под русские символы здесь отводится два байта (кодировка UTF8), поэтому и размер становится больше.
<p>
Если мы далее запишем:
<pre>
char ch = str[0];
printf("ch = %c\n", ch);
</pre>
то увидим вывод не символа буквы ‘П’, а кракозябру. Но, если прописать:
<pre>
wchar_t str[] = L"Привет мир!";
wchar_t ch = str[0];
 
std::cout << ch << std::endl;
</pre>
то переменная ch будет содержать корректный код первого символа строки.
<p>
Обратите внимание, все эти изменения актуальны для кодировок, отличающихся от кодировки ASCII, где символы латинского и русского алфавитов умещались в диапазон [0; 255], то есть, в один байт. Если, например, используется кодовая страница Windows-1251, то символы можно по-прежнему обрабатывать переменными типа char.
<pre>

=========================================================================================================================

</pre>
<a name="ptr"><h3 align=center>Приведение типов указателей</h3>
Следующее важное отличие языка С++ от Си проявляется в приведении разных типов указателей друг к другу. Пусть, например, объявлены два следующих указателя:
<pre>
int* ptr_i = 0L;
char* ptr_ch = 0L;
</pre>
В языке Си, далее, мы могли бы записать команду:
<p>
ptr_ch = ptr_i;<br>
и она бы скомпилировалась с предупреждением, что типы указателей не совпадают. Язык С++ работает строже. Если типы указателей не совпадают, то компиляция останавливается с сообщением об ошибке. Поэтому здесь нам нужно явно прописывать операцию приведения типов:
<pre>
ptr_ch = (char *)ptr_i;
</pre>
сообщая компилятору, что мы знаем, что делаем и адрес указателя ptr_i нужно присвоить указателю ptr_ch.
<p>
Та же самая ситуация возникает и с обобщенным указателем *void языка Си:
<pre>
void* ptr_void = 0L;
</pre>
Чтобы присвоить адрес, который хранится в ptr_void, нужно также явно прописывать операцию приведения типов:
<pre>
ptr_i = (int *)ptr_void;
</pre>
Напомню, что в языке Си использование указателей *void с другими типами даже не приводило к предупреждениям. В С++ ситуация изменилась кардинально. В частности, из-за этого при выделении памяти с помощью функции malloc() нужно дополнительно записывать приведение типов:
<p>
ptr_i = (int *)malloc(sizeof(int) * 5);<br>
Далее, в С++ не принято использовать константу NULL для указания нулевого адреса. Пишется просто числовой литерал 0L. Начиная со стандарта С++11 был введен специальный «нулевой» указатель с ключевым словом nullptr:
<pre>
char* ptr_ch = nullptr;
printf("%p\n", ptr_ch);
</pre>
В данном случае видим все то же значение 0.
<p>
Если версия компилятора языка С++ позволяет использовать nullptr, то рекомендуется его применять для обозначения «нулевого» указателя.
<h4 align=center>Новая форма for</h4>
В заключение этого занятия отмечу еще одно популярное нововведение в языке С++ - новую форму записи цикла for для перебора коллекций. Давайте я покажу его на конкретном примере. Пусть у нас имеется строка:
<p>
char msg[] = "I like C++ language";<br>
С точки зрения языка С++ - это коллекция (последовательность), которую можно перебирать. Воспользуемся для этого новой формой цикла for:
<pre>
<b>for (char x : msg)</b>
    std::cout << x << " ";
</pre>
После запуска увидим:
<pre>
I   l i k e   C + +   l a n g u a g e
</pre>
То есть, массив msg был последовательно (от начала до конца) перебран и на каждой итерации в переменную x помещался текущий символ. В теле цикла символы выводились через пробел. Видите, как удобно можно проходить по коллекциям целиком, используя новую форму записи цикла for. Причем, цикл проходит именно по массиву, а не по строке. Например, если указать больший размер массива:
<p>
char msg[30] = "I like C++ language";<br>
то при выводе дополнительно увидим значение NUL в консоли, которые присутствуют в массиве msg. Это же касается и всех других коллекций, например, динамических массивов (std::vector) или связных списков (std::list) и многих других последовательностей библиотеки STL.
<pre>


===========================================================================================================================



</pre>
<a name=""><h3 align=center>Способы инициализации переменных в С++.</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-inicializaciya-peremennyh-klyuchevye-slova-auto-i-decltype">Инициализация переменных. Ключевые слова auto и decltype</a><br>
<a href="https://metanit.com/cpp/tutorial/2.2.php">Переменные</a>
<p>
Присвоение переменной начального значения называется <b>инициализацией</b>.<br>
В языке Си инициализация происходит с помощью знака '=' и ничем внешне не отличатся от операции присваивания.<br>
В отличии от Си в C++ есть три вида инициализации:
<ul>
<li> Нотация присваивания (assignment notation)<br>
Суть нотациия присваивания - с помощью оператора присваивания (знак "равно" или =) переменной передаем некоторое значение:
<pre>
int age;
age = 20;
</pre>
Здесь в качестве значения переменной присваивается число 20. Постоянные значения любого типа, наподобие чисел, символов, строк, такие как 20, 123.456 (дробное число), "A" или "hello", называются <b>литералами</b>. То есть в данном случае переменной присваивается целочисленный литерал 20.
<p>
<li> Функциональная нотация (functional notation)<br>
При функциональной нотации после названия переменной в круглых скобках указывается ее значение:
<pre>
int age (38);   // functional notation
</pre>
В данном случае переменная будет иметь значение 38.
<p>
<li> Инициализация в фигурных скобках (braced initialization)<br>
При инициализации braced initialization после названия переменной в фигурных скобках указывается ее значение:
<pre>
int age {38};   // braced initialization
</pre>
В данном случае переменная будет иметь значение 38.
</ul>
Примеры:
<pre>
    <b>short sh(10);   // functional notation
    double d(-4.37);
 
    char ch{'b'};   // braced initialization
    long lv{};</b>
</pre>
Если в <b>скобках ничего не прописано, то переменная инициализируется нулем</b>.
<p>
Вообще, в языках Си и С++ начальная инициализация переменных – это рекомендуемая практика. Напомню, что все локальные переменные, размещаемые в стековом фрейме (их еще называют автоматическими), могут принимать неопределенное начальное значение. Конкретное поведение зависит от компилятора С++. Поэтому, чтобы не возникало непредвиденных ошибок из-за неопределенного начального значения переменной, ее следует сразу инициализировать. Именно для этого введены операторы круглых и фигурных скобок.
<h4>Разница между иницилизациями с помощью круглых и фигурных скобок</h4>
Но здесь возникает вопрос, чем отличаются эти два способа инициализации? На самом деле, почти ничем, но при использовании фигурных скобок дополнительно происходит проверка типа инициализируемых данных. Например, если у переменной lv в фигурных скобках прописать вещественное число:<br>
long lv{5.43};<br>
то компилятор выдаст ошибку из-за несовпадения типов переменной lv (long) и числа 5.43 (double). Причем, тип double нельзя без потерь привести к типу long. Но, если фигурные скобки заменить на круглые:<br>
long lv(5.43);<br>
то ошибки не будет и переменная lv примет значение 5, то есть, будет выполнено неявное приведение типа double к типу long.
<p>
Ещё примеры инициализации:
<pre>
int sum {2 + 3 + 4 + 5};
double p (1 * 2.3 * 4.5 - 1);
bool n_fl(false), t_fl(true);
</pre>
<pre>

</pre>
<h4 align=center>Инициализация по умолчанию</h4>
Если переменную не инициализировать, то происходит ее инициализация по умолчанию. И переменная получает некоторое значение по умолчанию, которое зависит от места, где эта переменная определена.
<p>
Если переменная, которая представляет встроенный тип (например, тип int), определена внутри функции, то она получает неопределенное значение. Если переменная встроенного типа определена вне функции, то она получает то значение по умолчанию, которое соответствует ее типу. Для числовых типов это число 0. Например:
<pre>
#include &lt;iostream>
 
int x;
int main()
{
    int y;
    std::cout <<"X = " << x << "\n";
    std::cout <<"Y = " << y;
}
</pre>
Переменная x определена вне функции, и поэтому она получит значение по умолчанию - число 0.
<p>
Гораздо сложнее дело обстоит с переменной y, которая определена внутри функции main - ее значение будет неопределенным, и многое будет зависеть от используемого компилятора. В частности, вывод программы, скомпилированной с помощью компилятора G++, может выглядеть следующим образом:
<pre>
X = 0
Y = 0
</pre>
А в Visual Studio отсутствие значения переменной y вызовет ошибку компиляции.<br>
Но в любом случае перед использованием переменной лучше явным образом назначать ей определенное значение, а не полагаться на значение по умолчанию.
<pre>

</pre>
<a name="const"><h3 align=center>Особенность модификатора const в С++</h3>
В Си с помощью ключевого слова const можно определять неизменяемые переменные, то есть, константы. Например, так:
<pre>
const double pi {3.1415};
</pre>
В С++ этот модификатор используется с теми же целями, но есть одно небольшое отличие при его использовании. Константная переменная должна быть инициализирована в момент ее объявления. То есть, запись, которая была допустима в языке Си:<br>
const double pi;<br>
в С++ приведет к ошибке при компиляции программы. Во всем остальном он работает так же, как и в языке Си. И это не удивительно, так как ключевое слово const перешло в Си из языка С++.
<p>
Примеры:
<pre>
const short sh = 100; //верно

<font color=red>//const int var;

//char const cnst_ch; cnst_ch = 12;</font> //почему неверно? 

<font color=red>//const char ch_cnst;</font> ch_cnst = 12;

long const lg = 10; //верно

const int a = 5; int b = a; //верно
</pre>
<pre>


</pre>
<h3 align=center>Вычисляемый тип (auto и decltype)</h3>
В языке С++, начиная со стандарта С++11, ключевое слово auto радикально изменило свое назначение. Если раньше в язык Си оно вводилось для явного обозначения автоматических переменных, то есть, тех, что располагаются в стековом фрейме, то в С++ имеет совсем другой смысл..
<p>
Иногда бывает трудно определить тип выражения. В этом случае можно предоставить компилятору самому определять тип объекта. И для этого применяется спецификатор auto. При этом если мы определяем переменную со спецификатором auto, эта переменная должна быть обязательно инициализирована каким-либо значением:
<pre>
auto number = 5;        //тип int

auto sum {1234.56};     //тип double

auto distance {267UL};  //тип unsigned long

auto i = 1 + 2 - 10;      //тип int

auto d = 1 + i + 3.0;     //тип double

auto g = 55u;          // тип unsigned int

auto h = (short)10 + 100000UL;  // тип unsigned long

auto var_4 (486L);	//long

auto var_5 {4.86L};    //long double
</pre>
На основании присвоенного значения компилятор определит тип переменной. Неинициализированные переменные со спецификатором auto не допускаются.
<p>
Есть ряд важных нюансов. Давайте объявим следующие три переменных:
<pre>
    int *ptr = nullptr;
    int k;
    int& lk = k;
</pre>
и посмотрим, какой тип будет вычисляться компилятором с их использованием:
<pre>
    auto t1 = k;        // int
    auto t2 = *ptr;     // int
    auto t3 = ptr;      // int *
    auto t4 = &ptr;     // int **
    auto t5 = lk;       // int
</pre>
Пока использовались обычные переменные и указатели, все ожидаемо, но для ссылки получили обычный тип int, а не ссылку.
<p>
Далее, если перед типами прописать ключевое слово const:
<pre>
    const int *ptr = nullptr;
    const int k = 0;
    const int& lk = k;
то  результат будет следующим:

    auto t1 = k;        // int
    auto t2 = *ptr;     // int
    auto t3 = ptr;      // const int *
    auto t4 = &ptr;     // const int **
    auto t5 = lk;       // int
</pre>
В целом, ожидаемо. Компилятор старается найти наиболее общий тип при учете ссылок и модификаторов. Поэтому везде, где это допустимо, ключевое слово const отбрасывается при вычислении типа переменной. Очевидно, его нельзя отбросить для переменных t3 и t4, т. к. здесь объявляются указатели через константный указатель ptr. Во всех остальных случаях его можно не учитывать.
<p>
Еще раз примеры:
<pre>
const char symbol_f = 'f';
const short* ptr_sh;
int count = 0;
const int& lnk = count;


auto var_1 = symbol_f;	  //char

auto var_2 = &symbol_f  //char*

auto var_3 = ptr_sh;	//const short*

auto var_4 = &count;	//int*

auto var_5 = lnk;	//int

auto var_6 = *ptr_sh;  //short
</pre>
<pre>

</pre>
<h4 align=center>Ключевое слово decltype</h4>
Однако если для нас важно сохранить полную идентичность типа переменной, например, ссылку оставить ссылкой, или не отбрасывать модификатор const, то при объявлении переменных можно воспользоваться еще одним новым ключевым словом <b>decltype</b> следующим образом:
<pre>
    decltype(k) var1 = 1;   // const int
    decltype(ptr) var2;     // const int *
    decltype(lk) var3 = k;  // const int &
</pre>
Конечно, здесь возникает вопрос, зачем это нужно? Разве не проще явно объявлять типы переменных, как это делалось до сих пор? На самом деле, есть ряд ситуаций, когда использование auto несколько облегчает написание программного кода. Часто это касается использования STL-коллекций со сложными шаблонными типами данных. Например, в программе можно объявить двусвязный список, содержащий числа, инициализировать его и перебрать обычным циклом for:
<pre>
#include &lt;iostream>
#include &lt;list>
 
int main()
{
    std::list&lt;short> dg = {-3, -2, 0, 2, 3};
 
    for(std::list&lt;short>::iterator i = dg.begin(); i != dg.end(); ++i)
                   std::cout << *i << " ";
 
    return 0;
}
</pre>
Смотрите, какой тип (std::list&lt;short>::iterator) приходится прописывать у переменной i. Это не очень удобно. Как раз в подобных случаях проще прописать ключевое слово auto и компилятор сам автоматически подставит нужный тип переменной:
<pre>
    for(<b>auto</b> i = dg.begin(); i != dg.end(); ++i)
                   std::cout << *i << " ";
</pre>
И результат будет абсолютно такой же.
<p>
Конечно, злоупотреблять этим не стоит. Все же, явное обозначение чаще лучше неявного. И ключевое слово auto имеет ряд ограничений. Например, его нельзя (в ряде компиляторов) использовать при определении параметров функции:
<pre>
void func(auto x)
{ }
</pre>
Компилятор GCC выдает предупреждение, но другие могут приводить к ошибке. Поэтому вместо auto следует использовать или перегрузку функций, или определять шаблон функции.
<p>
Примеры:
<pre>
const char symbol_f = 'f';
const short* ptr_sh;
int count = 0;
const int& lnk = count;
</pre>
<img src="./images/c++2.png">
<pre>

==========================================================================================================================


</pre>
<a name="links"><h3 align=center>Ссылки</h3>
Ссылки объявляются так же, как и обычные переменные, только после типа следует поставить символ амперсанда. Например:
<pre>
int d = 10;
<b>int& lnk_d = d;  // ссылка с именем lnk_d на переменную d</b>

или, что то же самое:

<b>int& lnk_d2 {d};
int& lnk_d3 (d);</b>
</pre>
В итоге, с ячейками памяти, где хранится значение переменной d, связано теперь два имени: d и lnk_d. Ссылку можно воспринимать, как неявный указатель, который хранит адрес переменной, записанной при инициализации. В результате, мы через ссылку lnk_d можем выполнять все те же самые действия, что и с переменной d.
<p>
Объявить ссылку без инициализации в С++ нельзя, то есть без указания на переменную. Следующая строчка приведет к ошибке:
<p>
<font color=red>double& alias_d;</font> //ошибка
<p>
При этом в инициализаторе можно прописывать любое допустимое <font color=red>lvalue</font> выражение. Например:
<pre>
int a = 10;
int *ptr = &a;
int ar[] = {1, 2, 3};
 
int& lnk_1 = a;        / / ok
int& lnk_2 = *ptr;    // ok //непонятно, тут вроде ссылка на число или на переменную?
int& lnk_3 = ar[1];   // ok //тот же вопрос
int& lnk_4 = 10;  // ошибка
int& lnk_5 = ptr;  // ошибка //а тут почему ошибка? указатель не лежит в памяти?
</pre>
То есть, ссылка должна быть связана <b>с областью памяти</b>, где хранятся данные того же типа, который указан при объявлении ссылки.
<p>
Ещё примеры:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<pre>
int main()
{
int var {-54};
int *ptr_v {&var};
short marks[] = {4, 3, 5, 2, 5};

//<font color=red>int& lnk_8 = &ptr_v;</font> //error: invalid conversion from ‘int**’ to ‘int’

short& lnk_6 {*marks};

//<font color=red>int& lnk_2 {&var};</font> //error: invalid conversion from ‘int*’ to ‘int’

//<font color=red>int& lnk_3 (ptr_v);</font> //invalid conversion from ‘int*’ to ‘int’

int& lnk_1 = var;

short& lnk_7 {marks[3]};

//<font color=red>short& lnk_5 = marks;</font> //error: invalid conversion from ‘short int*’ to ‘short int’

int& lnk_4 = *ptr_v;

return 0;
}
</pre></td></tr></table>
<p>
Некоторые из вас, возможно, задаются вопросом, <b>зачем вообще нужны ссылки, когда с переменной (данными) можно работать напрямую через их имена</b>? На самом деле, польза ссылок проявляется там же, где и польза указателей. Например, в классической задаче обмена значениями двух переменных. Без использования ссылок мы могли бы для этой цели объявить следующую функцию:
<pre>
void swap_d(double* x, double* y)
{
    double t = *x;
    *x = *y;
    *y = t;
}
</pre>
И, затем, в функции main() вызвать ее для переменных типа double:
<pre>
double a{1.2}, b{-3.4};
swap_d(&a, &b);
std::cout << a << " " << b << std::endl;
</pre>
Как видите, при вызове в аргументах функции swap_d() дополнительно приходится указывать операцию взятия адреса переменных a и b. Это не очень удобно и красиво. Куда лучше было бы записать эту же функцию с использованием ссылок:
<pre>
void swap_d(double& x, double& y)
{
    double t = x;
    x = y;
    y = t;
}
</pre>
И ее последующий вызов:
<p>
swap_d(a, b);<br>
Так все выглядит куда более естественно. Кроме того, ссылки куда более безопаснее указателей, так как мы уже знаем, что они могут быть инициализированы только корректными lvalue выражениями, а значит, работают с ячейками памяти, в которых хранятся данные соответствующего типа. Все это делает ссылки более удобным и безопасным инструментом, чем указатели. Поэтому часто, где это возможно, они заменяют указатели.
<p>
Также обратите внимание, что при объявлении параметров функции в виде ссылок <font color=red>их не нужно инициализировать</font>. Компилятор поставит им в соответствие те переменные, которые мы укажем при вызове этой функции. Причем, сами переменные при этом не копируются, а лишь формируется связь между параметрами-ссылками и переменными, указанными при вызове функции. В частности, это означает, что если нужно передать в функцию какие-либо объемные данные, например, большие структуры, то часто целесообразно это сделать через ссылки.
<p>
Другое назначение ссылок – это возможность изменения данных, где другие инструменты не очень удобны в использовании. Например, дан массив:<br>
short p[] = {1, 2, 3, 4};<br>
и нам нужно значения всех его элементов увеличить в два раза. Логично было бы воспользоваться новой формой записи цикла for следующим образом:
<pre>
for (short& x : p)
    x *= 2;
</pre>
И выведем полученный массив p в консоль:
<pre>
for (int i = 0; i < sizeof(p)/sizeof(*p); ++i)
    std::cout << p[i] << " ";
</pre>
Увидим:<br>
2 4 6 8
<p>
Почему здесь в первом цикле for нужно прописывать переменную x в виде ссылки? Думаю, вы уже догадались, что в противном случае:
<pre>
for (short x : p)
    x *= 2;
</pre>
мы получим копирование текущего значения массива p в переменную x и изменение (увеличение в 2 раза) коснется этой новой переменной, а не элемента массива. Ссылка же решает нашу задачу.
<h3 align=center>Константные ссылки</h3>
В языке С++ допустимо объявлять константные ссылки, то есть, ссылки, с помощью которых можно только читать значение переменной, но не менять. Например:
<pre>
int s = 0;
const int& ls = s;
 
int x = ls;  // чтение данных разрешено
ls = 5; // ошибка, запись нового значения невозможна
</pre>
Соответственно, константные ссылки могут быть инициализированы, как обычными переменными, так и константными:
<pre>
int s = 0;
<b>const int d = -2;</b>
 
const int& ls = s;
<b>const int& ld = d;</b>
</pre>
А вот обычная ссылка может вести только на такую же обычную переменную:
<pre>
int s = 0;
const int d = -2;
 
int& ls = s;    // ok
int& ld = d;    // ошибка
</pre>
Это вполне очевидное ограничение, т.к. иначе бы мы смогли изменить константную переменную d через ссылку ld.
<p>
<b>Также есть одно исключение: константную ссылку можно проиницилизировать числом:</b>
<pre>
const short &lnk_6 = 100;
</pre>
<pre>

</pre>
<h4>Когда нам могут понадобиться константные ссылки?</h4>
Самое очевидное – это описание неизменяемых параметров функции. Давайте представим, что у нас имеется структура, которая описывает точки в двумерном пространстве следующим образом:
<pre>
struct point {
    char name[50];      // название точки
    double x, y;        // координаты точки
};
</pre>
Затем, объявим функцию, которая вычисляет длину такого радиус-вектора:
<pre>
double length(const point& p)
{
    return sqrt(p.x * p.x + p.y * p.y);
}
</pre>
И вызовем ее в функции main():
<pre>
int main()
{
    point p2 {"first", 10.0, 20.0};
    double len = <b>length(p2);</b>
    std::cout << len << std::endl;
 
    return 0;
}
</pre>
Смотрите, в момент вызова функции length(p2), структура p2 не копируется в параметр p, копируется только ее адрес. В результате ссылка p связывается со структурой p2. А дополнительное ключевое слово const гарантирует, что структура p2 никак не будет менять свое состояние внутри функции length(). Соответственно, программист, который использует эту функцию, понимает, что если какой-либо ее параметр помечен как const, то он может быть уверенным в неизменности передаваемого аргумента.
<p>
И еще раз отмечу, что если бы в функции length() передача аргумента происходила бы не по ссылке, а по значению:
<p>
double length(const point p) ...<br>
то выполнялось бы полное побайтовое копирование структуры p2 в переменную p, в результате программа работала бы дольше, но результат был бы тем же. Поэтому везде, где происходит передача объемных данных в параметры функции, целесообразно подумать об использовании ссылок или указателей.
<pre>

</pre>
<pre>



</pre>



========================================================================================================

</pre>
<a name="string"><h3 align=center>Объект-строка string</h3>
Cсылка: <a href="https://proproprogs.ru/c_base/cpp-obekt-stroka-string-operacii-s-obektami-klassa-string">Объект-строка string. Операции с объектами класса string</a><br>
<a href="https://habr.com/ru/articles/318962/">О строковом форматировании в современном C++</a>
<p>
В языке Си строки описывались одномерным массивом типа char и содержали набор символов той или иной строки. Например, фразу «Hello, World!»:<br>
char msg[] = "Hello, World!";<br>
В конце каждой корректной Си-строки должен присутствовать символ ‘\0’, то есть, просто число 0.
<p>
В языке С++ появилась дополнительная возможность применять объект string, который значительно упрощает строковые операции на уровне написания программы программистом. Для этого первым делом необходимо подключить заголовок string в нашей программе следующим образом:
<pre>
#include &lt;string>
</pre>
После этого в пространстве имен std будет доступен <b>класс string</b> с возможностью объявления строковых объектов. В самом простом варианте можно записать:
<pre>
std::string msg;
</pre>
Так как мы не проходили классы и ООП, то воспринимайте string, как специальный тип данных для объявления строк. В результате, msg будет представлять собой пустую строку, то есть, строку, содержащую только одно значение 0 – маркер конца строки.
<p>
В действительности, класс string базируется на динамическом массиве символов, в котором хранится текущая строка. Поэтому, нам не обязательно прописывать максимальную длину строки, это значение будет меняться в соответствии с длиной хранимой строки. Например, для объекта msg можно вывести число символов в строке и физический размер динамического массива:
<pre>
cout << msg.size() << " " << msg.capacity() << endl;
</pre>
Получим: 0 15<br>
То есть, размер строки 0, а зарезервировано под строку 15 символов. Если же инициализировать объект-строку какой-либо строкой:
<pre>
std::string msg {"Hello, Sergey Balakirev!"};
cout << msg.size() << " " << msg.capacity() << endl;
</pre>
то увидим числа: 24 24
<p>
<i>Метод msg.<b>size()</b> показывает количество элементов объекта msg<br>
Метод msg.<b>capacity()</b> - длину массива</i>
<p>
Саму же строку можно вывести как обычную переменную с помощью объекта cout следующим образом:
<pre>
cout << msg << endl;
</pre>
Или же, получить константный указатель на строковый массив символов:
<pre>
const char* data = msg.data();
</pre>
и, например, вывести данные с помощью функции printf():<br>
printf("%s\n", data);<br>
Все это еще раз показывает, что внутри объекта msg мы имеем все ту же Си-строку в виде массива символов.
<p>
Далее, для доступа к отдельным символам строки можно по-прежнему использовать оператор []. Например:
<pre>
std::string fio {"Sergey Balakirev!"};
std::string fio_new {fio};
 
<b>fio_new[5]</b> = 'i';
cout << fio_new << endl;
</pre>
<pre>

</pre>
Примеры правильной и неправильной объявления иницилизации строки
<pre>
//<font color=red>std::string s_7 {"Sergey" + "Balakirev"}</font>; //error: conflicting declaration ‘std::string s_7’

Ниже все верные

std::string s_3 {"Hello, C++"};

std::string str; const std::string s_7 = str;

const std::string s_4 ("Hello, C++");

std::string s1 {"A"}, s2 {"B"}; std::string s_9 = s1 + s2;

std::string str; std::string s_5 = str;

std::string s_8 {"Sergey" "Balakirev"};

std::string s_1;

std::string s_10 {'A'};

<font color-gray>const std::string str; std::string s_6 = str</font>; //верный, но мой компилятор: error: conflicting declaration ‘const string str’

const std::string s_2;
</pre>
<p>
<b>Перебор строки по символам</b><br>
Объект-строку можно перебрать по символам с помощью цикла for. В самом простом варианте это можно сделать так:
<pre>
    for(const char& ch : fio)
        cout << ch << " ";
</pre>
В более сложном, использовать итератор для перебора любых последовательностей, определенных в стандартной библиотеки шаблонов (STL):
<pre>
    for(auto it = msg.cbegin(); it != msg.cend(); ++it)
        cout << *it << " ";
</pre>
Я не буду сейчас углубляться в эту тему. Привел этот пример для демонстрации многообразия возможностей языка С++ и библиотеки STL.
<p>
Наконец, можно воспользоваться уже известным вам способом перебора Си-строки:
<pre>
    const char* ptr_str = <font color=red>fio.data()</font>; //data() - это метод, причем тут Си, непонятно?
    for(int i = 0; ptr_str[i] != '\0'; ++i)
        cout << ptr_str[i] << " ";
</pre>
Конечно, удобнее всего использовать первый способ, поэтому чаще всего он и встречается в программах.
<pre>


</pre>
<a name="add_string"><h3 align=center>Добавление и объединение строк</h3>
Приятной возможностью объекта-строк является возможность неограниченно (пока хватает памяти устройства) добавлять новые символы в конец строки. Например, пусть имеется строка:<br>
std::string msg {"Hello"};<br>
И мы хотим ее преобразовать в строку «Hello, Sergey!», то есть в конец дописать недостающий фрагмент. Это легко сделать с помощью <b>метода append()</b> следующим образом:
<pre>
msg.<b>append</b>(", Sergey!");
cout << msg << endl;
</pre>
Также мы можем объединять строки между собой. Например:
<pre>
std::string msg {"Hello"};
std::string name {"Sergey"};
msg.append(", ");
<b>msg = msg + name</b>;
cout << msg << endl;
</pre>
Или, короче:<br>
msg += name;<br>
Или, еще короче:<br>
msg = msg.append(", ") + name;
<p>
Все эти варианты вполне допустимы.

<a name="write_string"><h3 align=center>Функция getline() или ввод строк из стандартного входного потока</h3>
Наверное, последний важный момент связан с возможностью ввода строковых данных из стандартного входного потока stdin. Чаще всего – это ввод строк с клавиатуры. Так как в программе у нас имеется объект cin, давайте воспользуемся им и посмотрим, как это будет работать с объектами-строками:
<pre>
#include &lt;iostream>
#include &lt;string>
 
using std::cout;
using std::cin;
using std::endl;
 
int main()
{
    std::string msg;
    cin >> msg;
    cout << msg << endl;
    return 0;
}
</pre>
<font size=5>Если ввести строку «hello world», то в объекте msg будет только первый фрагмент «hello» <b>(до пробела)</b></font>. Чтобы прочитать строку целиком (до символа перевода строки) удобно воспользоваться <b>функцией getline()</b> языка С++. Например, так:
<pre>
<b>getline(cin, msg);</b>
</pre>
Теперь, при вводе «hello world», вся строка целиком помещается в объект msg.
<p>
Третьим аргументом в этой функции можно указать разделитель, до которого будет читаться введенный фрагмент. Например, если прописать:
<pre>
getline(cin, msg, ';');
</pre>
то при вводе:<br>
1, 2; 3, 4<br>
в объект msg будет помещена строка:<br>
1, 2
<h4>Запись в char array[] через getline():</h4>
<font size=4>Похоже синтаксис getline(cin, var) работает только с var типа string в параметре функции, а для char массивов правилен другой синтаксис:
<pre>
<b>cin.getline(arr, count)</b>
</pre></font>
<pre>





</pre>
</div></body></html>
