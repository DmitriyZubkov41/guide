<html><head></head><body>
<title>PX4 Autopilot User Guide (перевод)</title>
<h2 align="center">перевод документации <a href="https://docs.px4.io/main/en/">PX4 Autopilot User Guide</a></h2>
Существует простой способ изучить азы программирования полётов дрона – виртуальная среда симуляции. Для прокачки базовых навыков программирования дрона не нужно ничего покупать – достаточно использовать симулятор дрона jMAVSim проекта PX4. PX4 – мощный набор ПО с открытым исходным кодом, предназначенный для использования на различных беспилотных транспортных средствах, как летающих, так и ездящих по земле. Исходные коды ПО проекта лежат на <a href="https://github.com/PX4/Firmware">Гитхабе</a> и <a href="https://github.com/PX4/PX4-Autopilot.git">другом гитхабе</a>.

<h3 align="center"><a href="https://docs.px4.io/main/en/getting_started/px4_basic_concepts.html">Основные понятия</a></h3>
Типы дронов:
<ul>
<li> Multicopters 
<li> Helicopters 
<li> Planes (Fixed-wing) - Летательные аппараты с неподвижным крылом обеспечивают более длительный и быстрый полет, чем мультикоптеры, и, следовательно, лучший охват для наземных исследований и т.д. Однако ими сложнее управлять и приземляться, чем мультикоптерами, и они не подходят, если вам нужно зависать или лететь очень медленно (например, при съемке вертикальных сооружений).
<li> VTOL (Vertical Takeoff and Landing - Вертикальный взлет и посадка) - Гибридные летательные аппараты с неподвижным крылом и мультикоптером предлагают лучшее из обоих миров: взлетать в вертикальном режиме и зависать в воздухе, как мультикоптер, но переходить к прямолинейному полету, как самолет, чтобы покрыть большую площадь. VTOL часто стоят дороже, чем мультикоптеры и самолеты с неподвижным крылом, и их сложнее создавать и настраивать. Они бывают разных типов: конвертопланы, хвостовые оперения, квадропланы и т.д.
<li> Airships/Balloons — Транспортные средства легче воздуха, которые, как правило, позволяют совершать длительные полеты на большой высоте, часто за счет ограниченного контроля скорости и направления полета (или его отсутствия).
<li> Rovers — Наземные транспортные средства, похожие на автомобили. Ими просто управлять, и ими часто интересно пользоваться. Они не могут передвигаться так быстро, как большинство самолетов, но могут перевозить более тяжелую полезную нагрузку и не потребляют много энергии в неподвижном состоянии.
<li> Boats 
<li> Submersibles -подводные дроны
</ul>
<h4>Autopilot</h4>
Autopilot минимально состоит из ПО flight stack, работающего в операционной системе реального времени ("RTOS") на лётном контроллере (FC). Flight stack обеспечивает необходимые функции стабилизации и безопасности, а также, как правило, некоторую помощь пилоту при выполнении полетов в ручном режиме и автоматизации обычных задач, таких как взлет, посадка и выполнение заранее определенных заданий.
<p>
Некоторые автопилоты также включают в себя вычислительную систему общего назначения, которая может обеспечить управление на "более высоком уровне" и может поддерживать более продвинутые сетевые технологии, компьютерное зрение и другие функции. Это может быть реализовано в виде отдельного сопутствующего компьютера, но в будущем, скорее всего, это будет полностью интегрированный компонент.
<h3>PX4 Flight Stack</h3>
PX4 - это мощный flight stack автопилота с открытым исходным кодом, работающий на NuttX RTOS.
<p>
Особенности PX4:
<ul>
<li> Поддерживает множество различных типов транспортных средств
<li> Большой выбор компонентов дрона для управления полетом, датчиков, полезной нагрузки и других периферийных устройств.
<li> Гибкие и мощные режимы полета и функции безопасности
<li> Надежная и глубокая интеграция с сопутствующими компьютерами и робототехническими API, такими как ROS 2 и MAVSDK).
</ul>
PX4 является основной частью более широкой платформы беспилотных летательных аппаратов, которая включает в себя наземную станцию QGroundControl, аппаратное обеспечение Pixhawk и MAVSDK для интеграции с сопутствующими компьютерами, камерами и другим оборудованием, использующим протокол MAVLink. PX4 поддерживается проектом Dronecode.
<h3>Ground Control Stations</h3>
Ground Control Stations (Наземные станции управления GCS) - это наземные системы, которые позволяют операторам UV контролировать беспилотный летательный аппарат и его полезную нагрузку. Ниже перечислены некоторые продукты, которые, как известно, работают с PX4.
<h3>QGroundControl</h3>
Программное обеспечение Dronecode GCS называется QGroundControl ("QGC"). Оно работает на оборудовании Windows, Android, macOS или Linux и поддерживает широкий спектр форм-факторов экрана. Вы можете скачать его (бесплатно) <a href="http://qgroundcontrol.com/downloads/">здесь</a>.
<p>
<img src="./images/px42.png">
<p>
QGroundControl взаимодействует с дроном с помощью телеметрической радиостанции (двунаправленный канал передачи данных), которая позволяет получать информацию о полете и безопасности в режиме реального времени, а также управлять транспортным средством, камерой и другими полезными устройствами с помощью интерфейса "наведи и щелкни". На оборудовании, которое их поддерживает, вы также можете управлять транспортным средством вручную с помощью джойстиков. QGC также можно использовать для визуального планирования, выполнения и мониторинга автономных миссий, установки геозон и многого другого.
<p>
Настольные версии QGroundControl также используются для установки (прошивки (firmware)) встроенного ПО PX4 и настройки PX4 на аппаратном обеспечении автопилота/контроллера полета дрона.
<h3>Полётный контроллер (FC)</h3>
Контроллер полета (FC) - это аппаратное обеспечение (плата, железо), на которое загружается и запускается микропрограмма (firmware) flight stack для PX4. Подключается к датчикам, с помощью которых PX4 определяет свое состояние, и к приводам/двигателям, которые используются для стабилизации и перемещения транспортного средства.
<p>
PX4 может работать на множестве различных типов полётного контроллера, начиная от контроллеров серии Pixhawk и заканчивая компьютерами Linux. К ним относятся стандартные платы Pixhawk и платы, поддерживаемые производителем. Вам следует выбрать доску, которая соответствует физическим возможностям вашего автомобиля, видам деятельности, которые вы хотите выполнять, и стоимости.


<h2 align="center"><a href="https://docs.px4.io/main/en/dev_setup/dev_env.html">ПО для работы с PX4</a></h2>
Поддерживаемые ОС для PX4:
<ul>
<li> Ubuntu Linux (22.04/20.04/18.04) — рекомендовано
<li> Windows (10/11) — внутри WSL2
<li> Mac OS
</ul>
Поддерживаемые связи с PX4:
<p>
<img src="./images/px43.png">
<p>
Пользователи Docker также могут создавать с помощью контейнеров, используемых нашей системой непрерывной интеграции: <a href="https://docs.px4.io/main/en/test_and_ci/docker.html">Docker Containers</a>.
<p>
После того как закончили установку указанных выше программ (ros, gazebo) далее следующие шаги:
<ol>
<li> Установка <a href="https://docs.px4.io/main/en/dev_setup/vscode.html">VSCode</a> Необязательно, это если хотим использовать IDE вместо командной линии терминала.
<li> Установить <a href="https://docs.px4.io/main/en/dev_setup/qgc_daily_build.html">QGroundControl Daily Build</a>
<li> <a href="https://docs.px4.io/main/en/dev_setup/building_px4.html">Собрать и запустить симулятор PX4 (Building PX4 Software.).</a> 
</ol>

<h3><a href="https://docs.px4.io/main/en/dev_setup/dev_env_linux_ubuntu.html">ПО для работы с PX4 в Ubuntu:</a></h3>
 В следующих инструкциях используется скрипт bash для настройки среды разработки PX4 в Ubuntu Linux LTS версиях, поддерживаемых PX4: Ubuntu 22.04 (Jammy Jellyfish), 20.04 (Focal Fossa) и 18.04 (Bionic Beaver).
<p>
ПО включает в себя:
<ul>
<li> <a href="https://docs.px4.io/main/en/sim_gazebo_gz/">Симулятор Gazebo в Ubuntu 22.04 и Ubuntu 20.04</a>
<li> или <a href="https://docs.px4.io/main/en/sim_gazebo_classic/">классический симулятор Gazebo для Ubuntu 20.04 и Ubuntu 18.04</a>
<li> <a href="https://docs.px4.io/main/en/dev_setup/building_px4.html#nuttx-pixhawk-based-boards">Набор инструментов для Pixhawk (и другого оборудования на базе NuttX)</a>.
</ul>

<h3><a href="https://docs.px4.io/main/en/dev_setup/dev_env_linux_ubuntu.html#simulation-and-nuttx-pixhawk-targets">Установка среды разработки (development toolchain) для Pixhawk/NuttX</a>:</h3>
Установка среды разработки (development toolchain) для Pixhawk/NuttX, включая симулятор jmavsim, осуществляется автоматически с помощью скрипта ubuntu.sh.
<p>
Установка набора инструментов:
<ol>
<li> Сначала скачать исходный код PX4 с репозитория:
<p>
<b>git clone https://github.com/PX4/PX4-Autopilot.git --recursive</b>
<li> Запустите ubuntu.sh без аргументов (в оболочке bash), чтобы установить все:
<p>
<b>bash ./PX4-Autopilot/Tools/setup/ubuntu.sh</b>
<p>
Можете использовать опции --no-nuttx и --no-sim-tools, чтобы не использовать NuttX и/или инструменты моделирования.
<li> Перезагрузить компьютер.
</ol>

<h3><a href="https://docs.px4.io/main/en/ros/mavros_installation.html">ROS1</a> и <a href="https://docs.px4.io/main/en/ros2/user_guide.html#installation-setup">ROS2</a></h3>
<p>
Как только вы закончите настройку набора инструментов командной строки:
<ol>
<li> Установите VSCode (если вы предпочитаете использовать IDE вместо командной строки).<br>
<a href="https://docs.px4.io/main/en/dev_setup/vscode.html">Настройка VSCode</a>
<li> Установите <a href="https://docs.px4.io/main/en/dev_setup/qgc_daily_build.html">QGroundControl Daily Build</a>
</ol>


<h3><a href="https://docs.px4.io/main/en/dev_setup/qgc_daily_build.html">QGroundControl Daily Build</a></h3>
Ежедневная сборка QGroundControl включает в себя инструменты разработки, которые скрыты в релизных сборках, и предоставляет доступ к новым функциям PX4, которые еще не поддерживаются в релизных сборках.<br>
<a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/releases/daily_builds.html">Ссылка на закачку</a>

<h3>QGroundControl</h3>
Ссылки: <a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/">Руководство пользователя QGroundControl</a><br>
<a href="https://docs.qgroundcontrol.com/master/en/qgc-dev-guide/">Руководство по разработке QGroundControl</a>
<p>
Программное обеспечение Dronecode GCS называется QGroundControl ("QGC"). Оно работает на оборудовании Windows, Android, macOS или Linux и поддерживает широкий спектр форм-факторов экрана. Вы можете скачать его (бесплатно) <a href="http://qgroundcontrol.com/downloads/">здесь</a>.
<p>
QGroundControl взаимодействует с дроном с помощью телеметрической радиостанции (двунаправленный канал передачи данных), которая позволяет получать информацию о полете и безопасности в режиме реального времени, а также управлять транспортным средством, камерой и другими полезными устройствами с помощью интерфейса "наведи и щелкни". На оборудовании, которое их поддерживает, вы также можете управлять транспортным средством вручную с помощью джойстиков. QGC также можно использовать для визуального планирования, выполнения и мониторинга автономных миссий, установки геозон и многого другого.
<p>
Настольные версии QGroundControl также используются для установки (прошивки) встроенного ПО PX4 и настройки PX4 на аппаратном обеспечении автопилота/контроллера полета дрона.

<h3><a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/getting_started/download_and_install.html">Загрузка и установка QGroundControl</a></h3>
<h4>Системные требования:</h4>
QGC должна хорошо работать на любом современном компьютере или мобильном устройстве. Производительность будет зависеть от системного окружения, приложений сторонних производителей и доступных системных ресурсов. Более мощное оборудование обеспечит лучшую работу. Для большинства приложений подойдет компьютер с объемом оперативной памяти не менее 8 ГБ, твердотельным накопителем, графикой Nvidia или AMD и процессором i5 или выше.
<h3><a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/getting_started/download_and_install.html">Установка для Ubuntu Linux</a></h3>
QGroundControl можно установить / запустить в Ubuntu LTS 20.04 (и более поздних версиях).
<p>
Ubuntu поставляется с менеджером последовательного модема, который препятствует любому использованию последовательного порта (или USB serial), связанному с робототехникой. Перед установкой QGroundControl вам следует удалить диспетчер модемов и предоставить себе разрешения на доступ к последовательному порту. Вам также необходимо установить GStreamer для поддержки потоковой передачи видео.
<p>
Перед первой установкой QGroundControl:<br>
В командной строке введите:
<pre>
sudo usermod -a -G dialout $USER
sudo apt-get remove modemmanager -y
sudo apt install gstreamer1.0-plugins-bad gstreamer1.0-libav gstreamer1.0-gl -y
sudo apt install libfuse2 -y
sudo apt install libxcb-xinerama0 libxkbcommon-x11-0 libxcb-cursor-dev -y
</pre>
Выйдите из системы и войдите снова, чтобы разрешить изменение прав пользователя.
<p>
Как установить QGroundControl:
<ol>
<li> Загрузите QGroundControl <a href="https://d176tv9ibo4jno.cloudfront.net/latest/QGroundControl.AppImage">отсюда</a>.
<li> Установите (и запустите) с помощью команд терминала:
<pre>
chmod +x ./QGroundControl.AppImage
./QGroundControl.AppImage</pre>  (или двойной клик)
</ol>

<h3><a href="https://docs.px4.io/main/en/dev_setup/qgc_daily_build.html">QGroundControl Daily Build</a></h3>
Ежедневная сборка QGroundControl включает в себя инструменты разработки, которые скрыты в релизных сборках (QGroundControl), и предоставляет доступ к новым функциям PX4, которые еще не поддерживаются в релизных сборках.
<p>
Его следует использовать вместо стабильной версии при работе с новым кодом, разветвленным из основной ветки main PX4.
<p>
<a href="https://d176tv9ibo4jno.cloudfront.net/builds/master/QGroundControl-x86_64.AppImage">Ссылка на закачку QGroundControl Daily Build для linux</a>
<p>
<font color=red>Скачал файл в Загрузку, а что дальше делать, не сказано.</font>
<p>
<img src="./images/dron1.png">


<h3 align="center"><a href="https://docs.px4.io/main/en/dev_setup/building_px4.html">Сборка программ PX4</a></h3>
Прошивка PX4 может быть собрана из исходного кода на консоли или в среде IDE как для имитируемых, так и для аппаратных целей.
<p>
Вам необходимо создать PX4, чтобы использовать симуляторы, или если вы хотите модифицировать PX4 и создать пользовательскую сборку. Если вы просто хотите опробовать PX4 на реальном оборудовании, то загрузите готовые двоичные файлы с помощью QGroundControl (нет необходимости следовать этим инструкциям).
<p>
Прежде чем следовать этим инструкциям, вы должны сначала установить набор инструментов разработчика для вашей основной операционной системы и целевого оборудования (IDE и QGC). 
<ol>
<li> <b>Загрузить исходный код PX4:</b><br>
Исходный код PX4 хранится на Github в репозитории PX4/PX4-Autopilot. Чтобы загрузить самую последнюю версию (основную ветвь) на свой компьютер, введите в терминал следующую команду:
<p>
<b>git clone https://github.com/PX4/PX4-Autopilot.git --recursive</b>
<p>
Возможно уже скачали репозиторий, когда устанавливали Developer Toolchain.
<li> <b>Первая сборка (с использованием симулятора)</b><br>
Сначала мы создадим имитируемую цель, используя консольную среду. Это позволит нам проверить настройки системы, прежде чем переходить к реальному оборудованию и IDE.
<p>
Перейдите в каталог PX4-Autopilot. В зависимости от вашей операционной системы у вас будет установлена либо Gazebo SITL, либо Gazebo Classic SITL (если вы не знаете, какая из них лучше, вы можете попробовать обе).
</ol>
<p>
Запустите Gazebo SITL, используя следующую команду:
<p>
<b>make px4_sitl gz_x500</b>
<p>
После этого откроется консоль PX4.
<p>
Возможно, вам потребуется запустить QGroundControl, прежде чем продолжить, поскольку конфигурация PX4 по умолчанию требует подключения к наземному управлению перед взлетом. Загрузка и установка <a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/getting_started/download_and_install.html">здесь (Загрузка и установка)</a>.
<p>
Дроном можно управлять, набрав следующую команду (как показано в консоли выше).:
<p>
<b>pxh&gt; commander takeoff</b>
<p>
Дрон взлетит, и вы увидите это в пользовательском интерфейсе симулятора.
<p>
Беспилотник можно посадить, набрав команду commander land, а всю имитацию можно остановить, нажав CTRL+C (или введя команду shutdown).
<p>
Управление симулятором с помощью наземной станции управления приближено к реальному управлению транспортным средством. Нажмите на местоположение на карте во время полета транспортного средства (режим взлета) и включите ползунок. Это изменит положение транспортного средства.

<h3>Платы на основе NuttX / Pixhawk</h3>
<h4>Сборка для NuttX</h4>
Чтобы выполнить сборку для плат на базе NuttX или Pixhawk, перейдите в каталог PX4-Autopilot и затем вызовите make, указав цель сборки для вашей платы.
<p>
Например, для сборки для аппаратного обеспечения Pixhawk 4 можно использовать следующую команду:
<pre>
cd PX4-Autopilot
make px4_fmu-v5_default
</pre>
Успешный запуск завершится с результатом, аналогичным следующему:
<pre>
-- Build files have been written to: /home/youruser/src/PX4-Autopilot/build/px4_fmu-v4_default
[954/954] Creating /home/youruser/src/PX4-Autopilot/build/px4_fmu-v4_default/px4_fmu-v4_default.px4
</pre>
Первая часть параметра build target px4_fmu-v4 указывает на аппаратное обеспечение целевого контроллера полета для встроенного ПО. Суффикс, в данном случае _default, указывает на конфигурацию встроенного ПО, например, на поддержку или отсутствие определенных функций.
<p>
<i>Вы должны использовать поддерживаемую версию GCC для сборки этой платы (например, ту же, что используется CI/docker) или удалить модули из сборки. Сборка с использованием неподдерживаемого GCC может завершиться неудачей, так как PX4 близок к пределу флэш-памяти платы в 1 МБ.</i>

<h3>Полный синтаксис команды make</h3>
В предыдущих разделах было показано, как можно вызвать make для создания нескольких различных целевых объектов, запуска симуляторов, использования IDE и т.д. В этом разделе показано, как создаются параметры make и как найти доступные варианты.
<p>
Полный синтаксис для вызова make с определенным файлом конфигурации и инициализации приведен ниже.:
<pre>
make [VENDOR_][MODEL][_VARIANT] [VIEWER_MODEL_DEBUGGER_WORLD]
</pre>
VENDOR_MODEL_VARIANT: (также известный как CONFIGURATION_TARGET)
<ul>
<li> Vendor (поставщик): Производитель платы: px4, aerotenna, airmind, atlflight, auav, beaglebone, intel, nxp и т.д. Производитель плат серии Pixhawk - px4.
<li> Model: модель платы "model": sitl, fmu-v2, fmu-v3, fmu-v4, fmu-v5, navio2 и т.д.
<li> Variant: Указывает на конкретные конфигурации: например, bootloader, cyphal, которые содержат компоненты, отсутствующие в конфигурации по умолчанию. Чаще всего это default - значение используется по умолчанию и может быть опущено.
</ul>
Вы можете получить список всех доступных параметров CONFIGURATION_TARGET, используя приведенную ниже команду:
<p>
<b>make list_config_targets</b>
</p>
<b>VIEWER_MODEL_DEBUGGER_WORLD:</b>
<ul>
<li> Viewer<br>
Это симулятор ("просмотрщик") для запуска и подключения: gz, gazebo, jmavsim, none.<br>
<b>none</b> может использоваться, если вы хотите запустить PX4 и дождаться запуска симулятора (jmavsim, Gazebo, Gazebo Classic или какого-либо другого симулятора). Например: <b>px4_sitl none_iris</b> запускает PX4 без симулятора (но с планером iris).
<li> <b>MODEL</b><br>
Используемая модель транспортного средства (например, iris (по умолчанию), rover, tailsitter и т.д.), которая будет загружена симулятором. Переменной среды PX4_SIM_MODEL будет присвоено значение выбранной модели, которое затем используется в сценарии запуска для выбора соответствующих параметров.
<li> <b>DEBUGGER</b><br>
Используемый отладчик: none (по умолчанию), ide, gdb, lldb, ddd, valgrind, callgrind. Дополнительные сведения смотреть в разделе <a href="https://docs.px4.io/main/en/debug/simulation_debugging.html">Имитационная отладка</a>.
<li><b>WORLD</b><br>
Только для Gazebo Classic. Укажите загружаемый мир (<a href="https://github.com/PX4/PX4-SITL_gazebo-classic/tree/main/worlds">PX4-Автопилот/Инструменты/моделирование/gazebo-classic/sitl_gazebo-classic/worlds</a>). Значение по умолчанию - <a href="https://github.com/PX4/PX4-SITL_gazebo-classic/blob/main/worlds/empty.world">empty.world</a>. Для получения дополнительной информации смотреть раздел <a href="https://docs.px4.io/main/en/sim_gazebo_classic/#loading-a-specific-world">Gazebo Classic &gt; Loading a Specific World</a>.
</ul>
<p>
Вы можете получить список всех доступных параметров VIEWER_MODEL_DEBUGGER_WORLD, используя приведенную ниже команду:
<p>
<b>make px4_sitl list_vmd_make_targets</b>
<p>
Дополнителеная информация:
<ul>
<li> Большинство значений в CONFIGURATION_TARGET и VIEWER_MODEL_DEBUGGER имеют значения по умолчанию и, следовательно, являются необязательными. Например, gazebo-classic эквивалентно gazebo-classic_iris или gazebo-classic_iris_none.
<li> Вы можете использовать три символа подчеркивания, если хотите указать значение по умолчанию между двумя другими параметрами. Например, gazebo-classic___gdb эквивалентно gazebo-classic_iris_gdb.
<li> Вы можете использовать значение none для VIEWER_MODEL_DEBUGGER, чтобы запустить PX4 и дождаться запуска симулятора. Например, запустите PX4 с помощью make px4_sitl_default none и jMAVSim с помощью ./Tools/simulation/jmavsim/jmavsim_run.sh -l.
</ul>
<p>
Параметры VENDOR_MODEL_VARIANT сопоставляются с конкретными файлами конфигурации px4board в дереве исходных текстов PX4 в каталоге /boards. В частности, VENDOR_MODEL_VARIANT сопоставляется с файлом конфигурации boards/VENDOR/MODEL/VARIANT.px4board (например, px4_fmu-v5_default соответствует boards/px4/fmu-v5/default.px4board).
<h3>Firmware Version & Git Tags (Версия прошивки и Git-теги)</h3>
Firmware Version PX4 и Custom Firmware Version публикуются с помощью сообщения MAVLink AUTOPILOT_VERSION и отображаются на панели QGroundControl Setup &gt; Summary.

<h3 align="center"><a href="https://docs.px4.io/main/en/concept/px4_systems_architecture.html">Архитектура системы PX4</a></h3>
В приведенных ниже разделах представлен общий обзор аппаратного и программного обеспечения PX4 для двух "типичных" систем PX4: одна из них имеет только контроллер полета, а другая - контроллер полета и вспомогательный компьютер (также известный как "компьютер миссии").
<h3>Только полётный контроллер (Flight Controller)</h3>
На приведенной ниже диаграмме представлен общий обзор типичной "простой" системы PX4, основанной на контроллере полета.
<p>
<img src="./images/dron2.png">
<p>
Аппаратное обеспечение состоит из:
<ul>
<li> Контроллера полета (работающего на PX4 flight stack). Часто это включает в себя встроенные IMU, компас и барометр.
<li> ESC двигателя подключены к PWM-выходам (ШИМ-выходы), DroneCAN (DroneCAN обеспечивает двустороннюю связь, а не одностороннюю, как показано на рисунке) или какой-либо другой шине.
<li> Сенсоры (датчики) (GPS, компас, датчики расстояния, барометры, оптический поток, барометры-передатчики ADSB и т.д.), подключаются через I2C, SPI, CAN, UART и т.д.
<li> Камера или другая полезная нагрузка. Камеры могут быть подключены к ШИМ-выходам или через MAVLink.
<li> Телеметрические радиостанции для подключения к компьютеру/программному обеспечению наземной станции.
<li> Радиоуправляемая система управления для ручного управления
</ul>
В левой части диаграммы показан программный пакет, который (приблизительно) выровнен по горизонтали с аппаратными частями диаграммы.
<p>
Компьютер наземной станции обычно запускает QGroundControl (или какое-либо другое программное обеспечение наземной станции). На нем также может работать программное обеспечение для робототехники, такое как MAVSDK или ROS.<br>
PX4 flight stack (пакет управления полетом PX4), работающий на контроллере полета, включает драйверы, модули связи, контроллеры, оценщики и другое промежуточное программное обеспечение и системные модули.

<h3>Полётный контроллер и сопутствующий компьютер</h3>
На приведенной ниже схеме показана система PX4, которая включает в себя как контроллер полета, так и вспомогательный компьютер (здесь называемый "компьютером миссии").
<p>
<img src="./images/dron3.png">
<p>
Контроллер полета управляет обычным полетным стеком PX4, в то время как компьютер-компаньон предоставляет расширенные функции, использующие компьютерное зрение. Обе системы подключены по быстрому последовательному каналу или IP-каналу и, как правило, взаимодействуют по протоколу MAVLink. Связь с наземными станциями и облаком обычно осуществляется через сопутствующий компьютер (например, с помощью маршрутизатора MAVLink (от Intel)).
<p>
Системы PX4 обычно работают под управлением операционной системы Linux на сопутствующем компьютере. Linux - гораздо лучшая платформа для разработки "общего" программного обеспечения, чем NuttX; разработчиков Linux гораздо больше, и уже написано много полезного программного обеспечения (например, для компьютерного зрения, коммуникаций, облачной интеграции, драйверов оборудования). Компьютеры-компаньоны иногда работают под управлением Android по той же причине.
<p>
<b>Flight stack</b> - это набор алгоритмов наведения, навигации и управления автономными беспилотными летательными аппаратами. Он включает в себя контроллеры для самолетов с неподвижным крылом, мультироторных и СВВП, а также средства оценки ориентации и положения.
<p>
<b>middleware </b> (промежуточное программное обеспечение) состоит в основном из драйверов устройств для встроенных датчиков, средств связи с внешним миром (сопутствующий компьютер, GCS и т.д.) и шины сообщений uORB для публикации и подписки.<br>
Кроме того, промежуточное программное обеспечение включает в себя уровень моделирования, который позволяет запускать пилотажный код PX4 в настольной операционной системе и управлять смоделированным на компьютере транспортным средством в имитируемом "мире".
<p>
<b>NuttX</b> - это основная RTOS для запуска PX4 на пульте управления полетом. Она с открытым исходным кодом (лицензия BSD), легкая, эффективная и очень стабильная.<br>
Модули выполняются как задачи: у них есть свои собственные списки файловых дескрипторов, но они используют одно адресное пространство. Задача все равно может запускать один или несколько потоков, которые используют общий список файловых дескрипторов.<br>
Каждая задача / поток имеет стек фиксированного размера, и существует периодическая задача, которая проверяет, осталось ли во всех стеках достаточно свободного места (в зависимости от цвета стека).



<h2 align="center"><a href="https://docs.px4.io/main/en/simulation/">Симуляция</a></h2>
Симуляторы позволяют PX4 flight code управлять дроном, смоделированным на компьютере, в имитируемом "мире". Вы можете взаимодействовать с этим дроном так же, как с реальным, используя QGroundControl, автономный API или радиоконтроллер / геймпад.
<p>
Моделирование - это быстрый, простой и, самое главное, безопасный способ протестировать изменения в коде PX4 перед началом полетов в реальных условиях. Это также хороший способ начать летать с PX4, если у вас еще нет машины для экспериментов.
<p>
PX4 поддерживает как программную симуляцию в цикле (SITL), при которой стек управления полетом выполняется на компьютере (либо на том же компьютере, либо на другом компьютере в той же сети), так и аппаратную симуляцию в цикле (HITL) с использованием встроенного программного обеспечения для моделирования на реальной плате контроллера полета.
<h3>Поддерживаемые тренажеры (симуляторы)</h3>
<ul>
<li> Gazebo<br>
Gazebo заменяет Gazebo Classic, предлагая более продвинутые модели рендеринга, физики и сенсоров. Это единственная версия Gazebo, доступная в Ubuntu Linux 22.04<br>
Мощная среда 3D-моделирования, которая особенно подходит для тестирования способности избегать объектов и компьютерного зрения. Он также может использоваться для моделирования нескольких транспортных средств и обычно используется с ROS, набором инструментов для автоматизации управления транспортными средствами.<br>
Поддерживаемые транспортные средства: Quad, Standard VTOL, Plane (квадроцикл, стандартный СВВП, самолет.
<li> Gazebo Classic<br>
Мощная среда 3D-моделирования, которая особенно подходит для тестирования способности избегать столкновения с объектами и компьютерного зрения. Она также может использоваться для моделирования нескольких транспортных средств и обычно используется с ROS, набором инструментов для автоматизации управления транспортными средствами.<br>
Поддерживаемые транспортные средства: Квадроцикл (Iris), шестигранник (Typhoon H480), Универсальный стандартный СВВП (QuadPlane), Рулевой, Самолет, вездеход, подводная лодка
</ul>
<h3>Симулятор MAVLink API</h3>
Все симуляторы, за исключением Gazebo, взаимодействуют с PX4 с помощью API Simulator MAVLink. Этот API определяет набор сообщений MAVLink, которые передают данные датчиков из моделируемого мира в PX4 и возвращают значения двигателя и привода из кода полета, который будет применен к моделируемому транспортному средству. На рисунке ниже показан поток сообщений.
<img src="./images/dron4.png">
<p>
<i>В сборке SITL для PX4 для обработки этих сообщений используется SimulatorMavlink.cpp, в то время как в аппаратной сборке в режиме HIL используется mavlink_receiver.cpp. Данные датчиков из симулятора записываются в разделы PX4 uORB. Все двигатели / исполнительные механизмы заблокированы, но внутреннее программное обеспечение полностью работоспособно.</i>
<p>
PX4 напрямую использует Gazebo API для взаимодействия с Gazebo, и MAVLink не требуется.
<h3>UDP-порты MAVLink PX4 по умолчанию</h3>
По умолчанию PX4 использует общепринятые UDP-порты для связи MAVLink с наземными станциями управления (например, QGroundControl), внешними API (например, MAVSDK, MAVROS) и интерфейсами симулятора (например, Gazebo). Это следующие порты::
<ul>
<li> Удаленный UDP-порт PX4 14550 используется для связи с наземными станциями управления. Ожидается, что GCS будут прослушивать соединения по этому порту. QGroundControl по умолчанию прослушивает этот порт.
<li>Удаленный UDP-порт PX4 14540 используется для связи с внешними API. Ожидается, что внешние API будут прослушивать соединения через этот порт.
<i>При моделировании нескольких транспортных средств для каждого экземпляра используется отдельный удаленный порт, последовательно выделяемый от 14540 до 14549 (все дополнительные экземпляры используют порт 14549).</i>
<li> Локальный TCP-порт симулятора, 4560, используется для связи с PX4. Симулятор прослушивает этот порт, и PX4 инициирует TCP-соединение с ним.
</ul>
<h3>Среда моделирования SITL</h3>
На диаграмме ниже показана типичная среда моделирования SITL для любого из поддерживаемых симуляторов, использующих MAVLink (т.е. для всех, кроме Gazebo).
<p>
<img src="./images/dron5.png">
<ul>
<li> PX4 использует специальный модуль для моделирования для подключения к локальному TCP-порту симулятора 4560. Затем симуляторы обмениваются информацией с PX4, используя API MAVLink для симулятора, описанный выше. PX4 на SITL и симулятор могут работать как на одном компьютере, так и на разных компьютерах в одной сети.
<li> PX4 использует обычный модуль MAVLink для подключения к наземным станциям и внешним API-интерфейсам разработчиков, таким как MAVSDK или ROS:
<ul>
<li> Наземные станции прослушивают удаленный UDP-порт PX4: 14550
<li> Внешние API-интерфейсы разработчика прослушивают удаленный UDP-порт PX4: 14540. Для моделирования нескольких транспортных средств PX4 последовательно выделяет отдельный удаленный порт для каждого экземпляра с 14540 по 14549 (все дополнительные экземпляры используют порт 14549).
</ul>
<li> PX4 определяет ряд локальных UDP-портов (14580,18570), которые иногда используются при подключении к сети с помощью PX4, запущенного в контейнере или виртуальной машине. Они не рекомендуются для "общего" использования и могут измениться в будущем.
<li> Последовательное соединение может использоваться для подключения аппаратного обеспечения джойстика/геймпада через QGroundControl.
</ul>
<p>
Если вы используете обычную систему сборки SITL make configuration targets (см. следующий раздел), то и SITL, и симулятор будут запущены на одном компьютере, и указанные выше порты будут автоматически настроены. Вы можете настроить дополнительные UDP-соединения MAVLink и иным образом изменить среду моделирования в файлах конфигурации сборки и инициализации.
<h3>Моделирование запуска/построения SITL</h3>
Система сборки позволяет очень просто собрать и запустить PX4 на SITL, запустить симулятор и подключить их. Синтаксис (упрощенный) выглядит следующим образом:
<p>
<b>make px4_sitl simulator[_vehicle-model]</b>
<p>
где simulator - это gz (для Gazebo), gazebo-classic, jmavsim или какой-либо другой симулятор, а модель транспортного средства - это конкретный тип транспортного средства, поддерживаемый этим симулятором (на момент написания статьи Gazebo и jMAVSim поддерживают только мультикоптеры, в то время как Gazebo Classic поддерживает множество различных типов).
<p>
Ниже приведен ряд примеров, и их гораздо больше на отдельных страницах для каждого из симуляторов:
<p>
<pre>
 # Start Gazebo with the x500 multicopter
make px4_sitl gz_x500

# Start Gazebo Classic with plane
make px4_sitl gazebo-classic_plane

# Start Gazebo Classic with iris and optical flow
make px4_sitl gazebo-classic_iris_opt_flow

# Start JMavSim with iris (default vehicle model)
make px4_sitl jmavsim

# Start PX4 with no simulator (i.e. to use your own "custom" simulator)
make px4_sitl none_iris
</pre>
<p>
Моделирование может быть дополнительно настроено с помощью переменных среды:
<p>
PX4_ESTIMATOR: Эта переменная определяет, какой оценщик использовать. Возможные варианты: ekf2 (по умолчанию), lpe (не рекомендуется). Его можно задать с помощью export PX4_ESTIMATOR=lpe перед запуском моделирования.
<p>
Описанный здесь синтаксис упрощен, и есть много других параметров, которые вы можете настроить с помощью make - например, указать, что вы хотите подключиться к IDE или отладчику. Дополнительные сведения см. в разделе: <a href="https://docs.px4.io/main/en/dev_setup/building_px4.html#px4-make-build-targets">Создание кода > PX4 Make Build Targets</a>.

<h3>Запуск моделирования быстрее, чем в реальном времени</h3>
SITL может выполняться быстрее или медленнее, чем в реальном времени, при использовании jMAVSim или Gazebo Classic.
<p>
Коэффициент скорости устанавливается с помощью переменной среды PX4_SIM_SPEED_FACTOR. Например, чтобы запустить симуляцию jMAVSim со скоростью, в 2 раза превышающей скорость реального времени:
<p>
<b>PX4_SIM_SPEED_FACTOR=2 make px4_sitl jmavsim</b>
<p>
Для запуска в два раза меньшей скорости реального времени:
<p>
<b>PX4_SIM_SPEED_FACTOR=0.5 make px4_sitl jmavsim</b>
<p>
Вы можете применить этот коэффициент ко всем запускам SITL в текущем сеансе, используя EXPORT:
<pre>
export PX4_SIM_SPEED_FACTOR=2
make px4_sitl jmavsim
</pre>

<h3>Имитация последовательного шага​</h3>
PX4 SITL и симуляторы (jMAVSim или Gazebo Classic) настроены на совместную работу. Это означает, что PX4 и симулятор ожидают друг от друга сообщений от датчиков и исполнительных механизмов, а не работают на своих собственных скоростях.
<p>
Последовательность шагов для lockstep такова:
<ol>
<li> Моделирование отправляет сообщение датчика HIL_SENSOR, включающее временную метку time_usec, для обновления состояния датчика и времени PX4.
<li> PX4 получает это и выполняет одну итерацию оценки состояния, управления и т.д. И в конечном итоге отправляет сообщение привода HIL_ACTUATOR_CONTROLS.
<li> Симуляция ожидает получения сообщения о приводе/двигателе, затем моделирует физические параметры и вычисляет следующее сообщение датчика для повторной отправки на PX4.
</ol>
Система запускается с периода "свободного хода", когда моделирование отправляет сообщения датчиков, включая время, и, следовательно, запускает PX4 до тех пор, пока оно не инициализируется и не ответит сообщением привода.

<h3>SSH Tunneling</h3>
SSH-туннелирование является гибким вариантом, поскольку компьютер для моделирования и система, использующая его, не обязательно должны находиться в одной сети.
<p>
<i>Аналогичным образом вы можете использовать VPN для создания туннеля к внешнему интерфейсу (в той же или другой сети).</i>
<p>
Один из способов создания туннеля - использовать параметры SSH-туннелирования. Сам туннель можно создать, выполнив следующую команду на localhost, где remote.local - это имя удаленного компьютера:
<p>
<b>ssh -C -fR 14551:localhost:14551 remote.local</b>
<p>
UDP-пакеты необходимо преобразовать в TCP-пакеты, чтобы их можно было передавать по SSH. Утилиту netcat можно использовать на обеих сторонах туннеля - сначала для преобразования пакетов из UDP в TCP, а затем обратно в UDP на другом конце.<br>
<i>QGC должен быть запущен перед запуском netcat.</i>
<p>
На компьютере QGroundControl преобразование пакетов UDP может быть реализовано путем выполнения следующих команд:
<p>
<pre>
mkfifo /tmp/tcp2udp
netcat -lvp 14551 < /tmp/tcp2udp | netcat -u localhost 14550 > /tmp/tcp2udp
</pre>
<p>
На стороне симулятора SSH-туннеля команда выглядит следующим образом:
<p>
<pre>
mkfifo /tmp/udp2tcp
netcat -lvup 14550 < /tmp/udp2tcp | netcat localhost 14551 > /tmp/udp2tcp
</pre>
<p>
Номер порта 14550 действителен для подключения к QGroundControl или другому GCS, но его следует настроить для других конечных точек (например, API разработчика и т.д.).
<p>
Теоретически туннель может работать бесконечно, но в случае возникновения проблемы может потребоваться перезапуск подключений netcat.
<p>
На компьютере QGC можно запустить скрипт QGC_remote_connect.bash для автоматической настройки/выполнения приведенных выше инструкций. Моделирование уже должно быть запущено на удаленном сервере, и у вас должна быть возможность подключиться к этому серверу по SSH.

<h3 align="center"><a href="https://docs.px4.io/main/en/sim_gazebo_gz/">Gazebo Simulation</a></h3>
<i><font color="red">Gazebo ранее был известен как "Gazebo Ignition" (в то время как Gazebo Classic ранее был известен как Gazebo). Дополнительную информацию смотрите в <a href="https://www.openrobotics.org/blog/2022/4/6/a-new-era-for-gazebo">официальном блоге</a>.</font></i>
<p>
Gazebo - это симулятор робототехники с открытым исходным кодом. Он заменяет старый классический симулятор Gazebo и является единственной поддерживаемой версией Gazebo для Ubuntu 22.04 и более поздних версий.<br>
Поддерживаемые транспортные средства: Квадротор, самолет, СВВП, ровер
<h3>Установка на ubuntu</h3>
Gazebo устанавливается по умолчанию в Ubuntu 22.04 в рамках обычной настройки среды разработки.
<p>
Если вы хотите использовать Gazebo в Ubuntu 20.04, вы можете установить его вручную, предварительно выполнив обычный процесс установки (установка gz-garden приведет к удалению Gazebo-Classic!).:
<p><pre>
sudo wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/pkgs-osrf-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/pkgs-osrf-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/gazebo-stable.list &gt; /dev/null
sudo apt-get update
sudo apt-get install gz-garden
</pre>
<h3>Запуск моделирования</h3>
Моделирование Gazebo SITL можно удобно запустить с помощью команды make, как показано ниже:
<p>
<pre>
cd /path/to/PX4-Autopilot
make px4_sitl gz_x500
</pre>
</p>
При этом запускаются как экземпляр PX4 SITL, так и клиент Gazebo.
<p>
Ниже перечислены поддерживаемые средства и команды make. Обратите внимание, что все целевые объекты gazebo make имеют префикс gz_.
<p>
<img src="./images/dron6.png">
<p>
Все модели транспортных средств (и миры) включены в качестве подмодуля из репозитория <a href="https://docs.px4.io/main/en/sim_gazebo_gz/gazebo_models.html">Gazebo Models Repository</a>.
<p>
Приведенные выше команды запускают одно транспортное средство с полным пользовательским интерфейсом. QGroundControl должен иметь возможность автоматического подключения к моделируемому транспортному средству.
<h3>Автономный режим</h3>
Другой способ подключения Gazebo SITL - это автономный режим. В этом режиме PX4 SITL и Gazebo запускаются отдельно на своих собственных терминалах. По умолчанию эти терминалы находятся на одном хосте, но вы также можете подключить экземпляры SITL и Gazebo, работающие на любых двух устройствах в сети (или даже в разных сетях, если вы используете для их подключения VPN).
<p>
Вы запускаете PX4 в автономном режиме, добавив к команде make префикс PX4_GZ_STANDALONE=1:
<p>
<pre>
cd /path/to/PX4-Autopilot
PX4_GZ_STANDALONE=1 make px4_sitl gz_x500
</pre>
Затем PX4 SITL будет ждать, пока не обнаружит экземпляр gz-сервера, а затем подключится к нему.<br>
Если вы еще не запустили gz-сервер при запуске команды make, вы будете видеть следующее предупреждение до тех пор, пока gazebo не будет запущен и экземпляр gz-сервера не будет обнаружен PX4:
<pre>
WARN [gz bridge] Service call timed out as Gazebo has not been detected
</pre>
Самый простой способ запустить симуляцию - использовать скрипт Python simulation-gazebo, который можно найти в репозитории Gazebo Models Repository. Его можно использовать для запуска экземпляра gz-сервера с любым поддерживаемым миром и транспортным средством.
<p>
Скрипт можно использовать без установки каких-либо дополнительных зависимостей, и он будет извлекать поддерживаемые модели и миры PX4 при первом использовании (по умолчанию) и сохранять их в ~/.simulation-gazebo. При повторном вызове скрипт будет использовать этот каталог для получения моделей и миров. Поэтому, если вы хотите использовать свою собственную модель и запускать ее в автономном режиме, вам нужно будет поместить ее исходный код в ~/.simulation-gazebo.
<p>
Вы можете скачать скрипт локально, используя любой метод, который вам нравится, например, wget:
<pre>
wget https://raw.githubusercontent.com/PX4/PX4-gazebo-models/main/simulation-gazebo
</pre>
Скрипт можно запустить с помощью:
<pre>
cd /path/to/script/
python3 simulation-gazebo
</pre>
Дополнительные сведения и аргументы приведены в разделе <a href="https://docs.px4.io/main/en/sim_gazebo_gz/gazebo_models.html">Gazebo models</a>.
<p>
<i>Если команда make px4_sitl gz_x500 выдает ошибку: <b>ninja: error: unknown target 'gz_x500'</b>, запустите команду make distclean, чтобы начать с чистого листа, и попробуйте снова запустить команду make px4_sitl gz_x500</i>

<h3 align="center"><a href="https://docs.px4.io/main/en/sim_gazebo_classic/">Gazebo Classic</a></h3>
Gazebo Classic поддерживается с помощью PX4 вплоть до Ubuntu Linux 20.04. В Ubuntu 22.04 и более поздних версиях вы должны использовать Gazebo (который ранее был известен как "Gazebo Ignition").
<p>
Gazebo Classic - это мощная среда 3D-моделирования для автономных роботов, которая особенно подходит для тестирования способности обходить объекты и компьютерного зрения. На этой странице описано ее использование с SITL и одним транспортным средством. Gazebo Classic также можно использовать с HITL и для моделирования нескольких транспортных средств.
<p>
Поддерживаемые роботы: Quad (Iris, Hex (Typhoon H480), Generic Standard VTOL (QuadPlane), Tailsitter, Plane, Rover, Submarine/UUV.
<p>
<img src="./images/dron7.png">
<p>
Если вы планируете использовать PX4 с ROS, вам следует следовать <a href="https://docs.px4.io/main/en/simulation/ros_interface.html">инструкциям ROS</a>, чтобы установить как ROS, так и Gazebo Classic (и тем самым избежать конфликтов при установке).
<h3>Установка PX4 с Gazebo Classic для ubuntu 20.04:</h3>
Сначало установить <a href="https://docs.px4.io/main/en/dev_setup/dev_env.html">стандартный набор инструментов</a>:
<ol>
<li> Установить <a href="https://docs.px4.io/main/en/dev_setup/vscode.html">VSCode</a>
<li> Установить <a href="https://docs.px4.io/main/en/dev_setup/qgc_daily_build.html">QGroundControl Daily Build</a>
</ol>
<font color=brown>В Ubuntu 22.04 LTS и более поздних версиях установочный скрипт (/Tools/setup/ubuntu.sh) вместо этого устанавливает Gazebo simulator</font>.<br>
Далее <a href="https://docs.px4.io/main/en/dev_setup/building_px4.html">собрать PX4</a>.
<h3>Сборка и запуск PX4</h3>
Сначала скачать репозиторий:
<p>
<b>git clone https://github.com/PX4/PX4-Autopilot.git --recursive</b>
<p>
Здесь загрузка через hhtps, для меня удобнее через ssh.
<p>
Теперь создадим имитируемую цель, используя консольную среду. Это позволит нам проверить настройки системы, прежде чем переходить к реальному оборудованию и IDE.
<p>
Перейдите в каталог PX4-Autopilot. В зависимости от вашей операционной системы у вас будет установлена либо Gazebo SITL, либо Gazebo Classic SITL (если вы не знаете, какая из них лучше, вы можете попробовать обе).
<p>
Запустите Gazebo Classic, используя следующую команду:
<p>
<b>make px4_sitl gazebo-classic</b>
<p>
или Gazebo:
<p>
<b>make px4_sitl gz_x500</b>
<p>
После этого откроется консоль PX4.
<p>
Возможно, вам потребуется запустить QGroundControl, прежде чем продолжить, поскольку конфигурация PX4 по умолчанию требует подключения к наземному управлению перед взлетом. Его можно загрузить <a href="https://docs.qgroundcontrol.com/master/en/qgc-user-guide/getting_started/download_and_install.html">отсюда</a>.
<p>
Дроном можно управлять, набрав следующую команду (как показано в консоли выше).:
<p>
pxh&gt; <b>commander takeoff</b>
<p>
Робот взлетит, и вы увидите это в окне симулятора Gazebo (classic).
<p>
Если вы хотите использовать Gazebo Classic в Ubuntu 22.04, вы можете использовать следующие команды, чтобы удалить Gazebo (garden), а затем переустановить Gazebo-Classic 11:
<pre>
sudo apt remove gz-garden
sudo apt install aptitude
sudo aptitude install gazebo libgazebo11 libgazebo-dev
</pre>
<i>Обратите внимание, что aptitude необходим, поскольку он может разрешать конфликты зависимостей (путем удаления определенных пакетов), с которыми apt не может справиться.</i><br>
Дополнительные инструкции по установке можно найти на странице <a href="https://gazebosim.org/docs/latest/getstarted/">gazebosim.org</a>.
<h3>Запуск симулятора gazebo</h3>
Запустите симуляцию, запустив PX4 SITL и Gazebo Classic с конфигурацией планера для загрузки (поддерживаются мультикоптеры, самолеты, СВВП, моделирование оптического потока и нескольких транспортных средств).<br>
Самый простой способ сделать это - открыть терминал в корневом каталоге репозитория PX4 PX4-Autopilot и вызвать make для нужной цели. Например, для запуска моделирования квадрокоптера (по умолчанию).:
<pre>
cd /path/to/PX4-Autopilot
make px4_sitl gazebo-classic
</pre>
Ниже перечислены поддерживаемые транспортные средства и команды make:
<p>
<img src="./images/dron8.png">
<h3>Запуск дрона в Headless режиме или раздельно:</h3>
Приведенные выше команды запускают одно транспортное средство с полным пользовательским интерфейсом. Другие опции включают:
<ul>
<li> Запуск PX4 и Gazebo раздельно, чтобы вы могли поддерживать работу Gazebo Classic и повторно запускать PX4 только при необходимости (это быстрее, чем перезапускать оба).
<ol>
<li> Запустите сервер gazebo classic (или любой другой симулятор) и клиентские программы просмотра через терминал, указав вариант _ide:
<p>
<b>make px4_sitl gazebo-classic___ide</b>
<p>
или:
<p>
<b>make px4_sitl gazebo-classic_iris_ide</b>
<li> В вашей IDE выберите цель px4_&lt;mode&gt;, которую вы хотите отладить (например, px4_iris).
<li> Запустите сеанс отладки непосредственно из IDE
</ol>
Такой подход значительно сокращает время цикла отладки, поскольку симулятор всегда работает в фоновом режиме, и вы только повторно запускаете процесс px4, который очень прост.
<li> Запустите симуляцию в Headless режиме, который не запускает классический пользовательский интерфейс Gazebo (это требует меньше ресурсов и выполняется намного быстрее).<br>
<b>HEADLESS=1 make px4_sitl gazebo-classic_plane</b>
</ul>
<p>
Приведенные выше команды make сначала создают PX4, а затем запускают его вместе с симулятором Gazebo Classic.

<h3><a href="https://docs.px4.io/main/en/sim_gazebo_classic/vehicles.html">Команды запуска робота в gazebo_classic</a></h3>
<h3><a href="https://docs.px4.io/main/en/sim_gazebo_classic/worlds.html">Миры робота в gazebo_classic</a></h3>
<h3><a href="https://docs.px4.io/main/en/sim_gazebo_classic/multi_vehicle_simulation.html">Симуляция нескольких роботов в gazebo_classic</a></h3>


<h3 align=center><a href="https://docs.px4.io/main/en/sim_jmavsim/">Глава: симулятор jMAVSim с помощью SITL</a></h3>
jMAVSim - это простой мультироторный / квадроцикловый симулятор, который позволяет вам летать на транспортных средствах типа вертолетов под управлением PX4 по моделируемому миру. Он прост в настройке и может быть использован для проверки того, что ваш автомобиль может взлетать, летать, садиться и надлежащим образом реагировать на различные сбои (например, сбой GPS).
<h3>Установка</h3>
Установка jMAVSim включена в наши <a href="https://docs.px4.io/main/en/dev_setup/dev_env.html">стандартные инструкции по сборке для Ubuntu Linux</a>.
<h3>Схема работы</h3>
<img src="./images/px4.png">
<h3>Выполнение SITL</h3>
Убедившись, что в системе установлены необходимые компоненты для моделирования, просто запустите, программа convenience make target скомпилирует сборку узла POSIX и запустит моделирование:
<p>
<b>make px4_sitl_default jmavsim</b>
<p>
Откроется оболочка PX4 (в терминале командная строка изменится на <b>pxh&gt;</b>.  Также появится окно, показывающее 3D-изображение симулятора jMAVSim:
<p>
<img src="./images/px41.png">
<p>
Команда для подъёма робота:
<p>
<b>pxh> commander takeoff</b> 
<p>
Вы можете использовать QGroundControl для выполнения задания или для подключения к джойстику.
<h3>Установите пользовательское местоположение взлета</h3>
Местоположение взлета по умолчанию в может быть переопределено с помощью переменных среды: <b>PX4_HOME_LAT, PX4_HOME_LON, and PX4_HOME_ALT</b>
<p>
Например, чтобы задать широту, долготу и высоту над уровнем моря:
<pre>
export PX4_HOME_LAT=28.452386
export PX4_HOME_LON=-13.867138
export PX4_HOME_ALT=28.5
make px4_sitl_default jmavsim
</pre>
<h3>Имитация беспилотника с Wi-Fi</h3>
Существует специальная мишень для имитации дрона, подключенного через Wi-Fi к локальной сети:
<p>
<b>make broadcast jmavsim</b>
<p>
Симулятор транслирует свой адрес по локальной сети, как это сделал бы настоящий беспилотник.
<h3>Запуск JMAVSim и PX4 отдельно</h3>
<pre>
./Tools/simulation/jmavsim/jmavsim_run.sh -l
make px4_sitl none
</pre>
Это позволяет ускорить цикл тестирования (перезапуск jMAVSim занимает значительно больше времени).
<h3>Headless режим</h3>
Чтобы запустить jMAVSim без графического интерфейса, установите переменную env HEADLESS=1:
<p>
<b>HEADLESS=1 make px4_sitl jmavsim</b>
<h3><a href="https://docs.px4.io/main/en/sim_jmavsim/multi_vehicle.html">Запуск нескольких беспилотников одновременно</a></h3>
<h3><a href="https://docs.px4.io/main/en/simulation/ros_interface.html">Сопряжение с ROS</a></h3>
<h3>Ошибки</h3>
<ul>
<li> java.long.NoClassDefFoundError
<li> An illegal reflective access operation has occurred
<li> java.awt.AWTError: Assistive Technology not found: org.GNOME.Accessibility.AtkWrapper
</ul>
Если вы видите эту ошибку, попробуйте обойти ее следующим образом:<br>
Отредактируйте accessibility.properties:
<p>
<b>sudo gedit /etc/java-8-openjdk/accessibility.properties</b><br>
и закомментируйте строку, указанную ниже:
<p>
<b>#assistive_technologies=org.GNOME.Acessibility.AtkWrapper</b>
<h3><a href="https://docs.px4.io/main/en/test_and_ci/integration_testing.html">Интеграционное тестирование с использованием ROS</a></h3>

<h3 align="center"><a href="">Контейнеры Docker PX4</a></h3>
Контейнеры Docker предоставляют полный набор инструментов для разработки на PX4, включая аппаратные средства на базе NuttX и Linux, классическое моделирование Gazebo и ROS.<br>
В этом разделе показано, как использовать доступные контейнеры docker для доступа к среде сборки на локальном компьютере с Linux.
<p>
Готовые образы можно найти на <a href="https://github.com/PX4/PX4-containers/tree/master?tab=readme-ov-file#container-hierarchy">Github здесь</a>. Они автоматически создаются в <a href="https://hub.docker.com/u/px4io/">Docker Hub</a>.<br>
Dockerfiles смотреть <a href="https://github.com/PX4/PX4-containers/tree/master/docker">здесь</a><br>
По моей теме изучения самый интересный <a href="https://github.com/PX4/PX4-containers/blob/master/docker/Dockerfile_ros-noetic">Dockerfile_ros-noetic</a>
<h3>Иеархия контейнеров</h3>
Они позволяют тестировать различные целевые объекты сборки и конфигурации (о включенных инструментах можно судить по их названиям). Контейнеры являются иерархическими, так что они обладают функциональностью своих родительских элементов. Например, приведенная ниже частичная иерархия показывает, что контейнер docker с инструментами сборки nuttx (px4-dev-nuttx-focal) не включает ROS 2, в то время как контейнеры для моделирования включают:
<pre>
- px4io/px4-dev-base-focal
  - px4io/px4-dev-nuttx-focal
  - px4io/px4-dev-simulation-focal
    - px4io/px4-dev-ros-noetic
      - px4io/px4-dev-ros2-foxy
  - px4io/px4-dev-ros2-rolling
- px4io/px4-dev-base-jammy
  - px4io/px4-dev-nuttx-jammy
</pre>
Доступ к самой последней версии можно получить, используя тег latest: px4io/px4-dev-nuttx-focus:latest
<h3>Использование Dockerконтейнеров</h3>
В следующих инструкциях показано, как создать исходный код PX4 на главном компьютере с помощью набора инструментов, работающего в контейнере docker. Предполагается, что вы уже загрузили исходный код PX4 в src/PX4-Autopilot, как показано на рисунке:
<pre>
mkdir src
cd src
git clone https://github.com/PX4/PX4-Autopilot.git
cd PX4-Autopilot
</pre>
<h3>Скрипт docker_run.sh</h3>
Проще всего использовать контейнеры с помощью docker_run.sh вспомогательного скрипта. Этот скрипт принимает команду сборки PX4 в качестве аргумента (например, выполняет тесты). Он запускает docker с последней версией (жестко запрограммированной) соответствующего контейнера и разумными настройками среды.<br>
Например, для создания SITL вы должны вызвать (из каталога /PX4-Autopilot):
<p>
<b>./Tools/docker_run.sh 'make px4_sitl_default'</b>
<p>
Или запустить сеанс bash с помощью набора инструментов NuttX:
<p>
<b>./Tools/docker_run.sh 'bash'</b>
<p>
Скрипт прост, потому что вам не нужно много знать о Docker или думать о том, какой контейнер использовать. Однако он не особенно надежен! Ручной подход, описанный в разделе ниже, более гибкий, и его следует использовать, если у вас возникнут какие-либо проблемы со скриптом.
<h3>Вызов Docker вручную</h3>
Ниже показан синтаксис типичной команды. При этом запускается контейнер Docker, который поддерживает X-переадресацию (делает графический интерфейс моделирования доступным изнутри контейнера). Он сопоставляет каталог &lt;host_src&gt; с вашего компьютера с &lt;container_src&gt; внутри контейнера и перенаправляет UDP-порт, необходимый для подключения QGroundControl. С помощью опции --privileged он автоматически получит доступ к устройствам на вашем хосте (например, к джойстику и графическому процессору). Если вы подключаете/отключаете устройство, вам необходимо перезапустить контейнер.
<pre>
# enable access to xhost from the container
xhost +

# Run docker
docker run -it --privileged \
    --env=LOCAL_USER_ID="$(id -u)" \
    -v &lt;host_src&gt;:&lt;container_src&gt;:rw \
    -v /tmp/.X11-unix:/tmp/.X11-unix:ro \
    -e DISPLAY=:0 \
    -p 14570:14570/udp \
    --name=&lt;local_container_name&gt; &lt;container&gt;:&lt;tag&gt; &lt;build_command&gt;
</pre>
Где,
<ul>
<li> &lt;host_src&gt;: каталог главного компьютера, который должен быть сопоставлен с <container_src> в контейнере. Обычно это должен быть каталог PX4-Autopilot.
<li> &lt;container_src&gt;: Местоположение общего (исходного) каталога внутри контейнера.
<li> &lt;имя_локального_контейнера&gt;: Имя для создаваемого контейнера docker. Это может быть использовано позже, если нам понадобится снова обратиться к контейнеру.
<li> &lt;контейнер&gt;:&lt;тег&gt;: контейнер с тегом версии для запуска - например: px4io/px4-dev-ros:2017-10-23.
<li> &lt;build_command&gt;: команда для вызова в новом контейнере. Например, bash используется для открытия оболочки bash в контейнере.
</ul>
В приведенном ниже конкретном примере показано, как открыть оболочку bash и предоставить общий доступ к каталогу ~/src/PX4-Autopilot на главном компьютере:
<pre>
# enable access to xhost from the container
xhost +

# Run docker and open bash shell
docker run -it --privileged \
--env=LOCAL_USER_ID="$(id -u)" \
-v ~/src/PX4-Autopilot:/src/PX4-Autopilot/:rw \
-v /tmp/.X11-unix:/tmp/.X11-unix:ro \
-e DISPLAY=:0 \
--network host \
--name=px4-ros px4io/px4-dev-ros2-foxy:2022-07-31 bash
</pre>
Мы используем режим <b>host network</b>, чтобы избежать конфликтов между управлением доступом к порту UDP при использовании QGroundControl в той же системе, что и контейнер docker.
<p>
Если вы столкнулись с ошибкой "<font color=red>Can't open display: :0</font>", возможно, для DISPLAY необходимо установить другое значение. На хосте Linux (XWindow) вы можете изменить -e DISPLAY=:0 на -e DISPLAY=$DISPLAY. На других хостах вы можете iterate 0 в -e DISPLAY=:0 до тех пор, пока ошибка "Can't open display: :0" не исчезнет.
<p>
Если все прошло хорошо, вы уже должны быть в новой оболочке bash. Проверьте, все ли работает, запустив, например, SITL:
<pre>
cd src/PX4-Autopilot    #This is <container_src>
make px4_sitl_default gazebo-classic
</pre>
<h3>Перехаход  в контейнер</h3>
Команду docker run можно использовать только для создания нового контейнера. Чтобы вернуться в этот контейнер (который сохранит внесенные вами изменения), просто выполните:
<pre>
# start the container
docker start container_name
# open a new bash shell in this container
docker exec -it container_name bash
</pre>
Если вам нужно подключить к контейнеру несколько оболочек, просто откройте новую оболочку и снова выполните эту последнюю команду.
<h3>Очистка контейнера</h3>
Иногда вам может потребоваться полностью удалить контейнер. Вы можете сделать это, используя его имя:<br>
<b>docker rm mycontainer</b>
<p>
Если вы не можете вспомнить название, вы можете перечислить идентификаторы неактивных контейнеров, а затем удалить их, как показано ниже:
<pre>
docker ps -a -q
45eeb98f1dd9
docker rm 45eeb98f1dd9
</pre>
<h3>QGroundControl</h3>
При запуске экземпляра симулятора, например, SITL, внутри контейнера docker и управлении им с помощью QGroundControl с хоста необходимо вручную настроить канал связи. Функция автоматического подключения QGroundControl здесь не работает.<br>
В QGroundControl перейдите к настройкам и выберите Comm Links. Создайте новую ссылку, использующую протокол UDP. Порт зависит от используемой конфигурации, например, порт 14570 для конфигурации SITL. Это IP-адрес вашего контейнера docker, обычно 172.17.0.1/16 при использовании сети по умолчанию. IP-адрес контейнера docker можно найти с помощью следующей команды (при условии, что имя контейнера - mycontainer).:
<p>
<b>$ docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' mycontainer</b>
<h3>Проблемы:</h3>
<b>Permission Errors</b><br>
Контейнер создает файлы по мере необходимости с использованием имени пользователя по умолчанию - обычно "root". Это может привести к ошибкам с правами доступа, когда пользователь на главном компьютере не сможет получить доступ к файлам, созданным контейнером.<br>
В приведенном выше примере используется строка --env=LOCAL_USER_ID="$(id -u)" для создания пользователя в контейнере с тем же UID, что и у пользователя на хосте. Это гарантирует, что все файлы, созданные в контейнере, будут доступны на хосте.
<p>
<b>Graphics Driver Issues</b><br>
Вполне возможно, что запуск Gazebo Classic приведет к появлению аналогичного сообщения об ошибке, подобного приведенному ниже:<br>
<b>libGL error: failed to load driver: swrast</b>
<p>
В этом случае необходимо установить собственный графический драйвер для вашей хост-системы. Загрузите нужный драйвер и установите его внутри контейнера. Для драйверов Nvidia следует использовать следующую команду (в противном случае программа установки увидит загруженные модули с хоста и откажется выполнять дальнейшую работу).:<br>
<b>./NVIDIA-DRIVER.run -a -N --ui=none --no-kernel-module</b>
<p>
Более подробную информацию об этом можно найти <a href="http://gernotklingler.com/blog/howto-get-hardware-accelerated-opengl-support-docker/">здесь</a>.


<h3 align="center"><a href="https://docs.px4.io/main/en/robotics/">Приложения и API для беспилотных летательных аппаратов</a></h3>
API-интерфейсы дронов позволяют вам писать код для управления транспортными средствами на базе PX4 и их интеграции с ними, не вникая в мельчайшие детали транспортного средства и системы управления полетом, а также не задумываясь о поведении, критически важном для безопасности.
<p>
Например, вы можете захотеть создать новые "умные" режимы полета или пользовательские режимы геозоны, или интегрировать новое оборудование. API-интерфейсы беспилотных летательных аппаратов позволяют вам делать это, используя высокоуровневые инструкции на выбранном вами языке программирования, а затем код может быть запущен в автомобиле на вспомогательном компьютере или с наземной станции. По сути, API-интерфейсы взаимодействуют с PX4 с помощью MAVLink или uXRCE-DDS.
<p>
PX4 поддерживает следующие SDK/инструменты для робототехники:
<ul>
<li> MAVSDK
<li> ROS 2
<li> ROS 1
</ul>
<h3>Какой API я должен использовать?</h3>
Мы рекомендуем использовать MAVSDK там, где это возможно, в первую очередь потому, что он более интуитивно понятен и прост в освоении, а также может работать на большем количестве операционных систем и менее производительном оборудовании.<br>
Вы можете предпочесть ROS, если уже знаете, как им пользоваться, или если хотите использовать уже существующие интеграции (например, задачи компьютерного зрения). В целом, ROS, вероятно, будет лучшим выбором для задач, требующих очень низкой задержки или более глубокой интеграции с PX4, чем это обеспечивает MAVLink.
<p>
Основными отличиями являются:<br>
MAVSDK:
<ul>
<li> Интуитивно понятный и оптимизированный для беспилотных летательных аппаратов, с небольшим временем обучения и простой настройкой.
<li> Вы можете писать приложения на C++, Python, Swift, Java, Go и других языках.
<li> Работает на оборудовании с ограниченными ресурсами
<li> Работает на широком спектре операционных систем, включая Android, Linux, Windows.
<li> Взаимодействие осуществляется через MAVLink.
<li> Стабильно и широко поддерживается.
<li> Доступ ограничен службами MAVLink - необходимая информация может быть недоступна.
<li> В некоторых случаях задержка может быть слишком высокой.
</ul>
<b>ROS 2</b>
<ul>
<li> Универсальный робототехнический API, расширенный для поддержки интеграции с беспилотными летательными аппаратами:
<li> Концептуально не так хорошо оптимизирован для беспилотных летательных аппаратов, как MAVSDK
<li> Значительный уровень обучения
<li> Многие уже существующие библиотеки полезны для повторного использования кода.
<li> Поддерживает библиотеки C++ и Python
<li> Работает на Linux
<li> ROS 2 - это последняя версия, которая подключается через XRCE-DDS
<li> Интерфейсный уровень DDS обеспечивает глубокую интеграцию с любым аспектом PX4, который представлен в разделе UORB (почти со всем).
<li> Может обеспечить значительно меньшую задержку.
<li> Все еще находится в стадии разработки:<br>
На момент написания статьи требуется более глубокое понимание PX4, чем ROS 1.<br>
Интерфейс сообщения с PX4 не стабилен/не поддерживается в версиях ROS и PX4.
</ul>
<h3>Устаревшие API-интерфейсы: ROS1 и DroneKit</h3>
<b>ROS 1​</b><br>
Хотя и не является строго устаревшей, ROS 1 находится в финальной версии для LTS "Noetic Ninjemys", срок действия которой истекает в мае 2025 года. Это означает, что никаких новых функций или исправлений ошибок предоставляться не будет, и даже обновления для системы безопасности прекратятся в 2025 году.
<p>
ROS 1 по-прежнему "работает" на PX4, поскольку использует MAVROS, абстракцию MAVLINK-ROS, в качестве интеграционного уровня. Это означает, что ROS 1 обладает всеми недостатками MAVLink, такими как более высокая задержка и небольшая площадь API (а также преимуществами, такими как стабильный интерфейс).
<p>
Все инвестиции PX4 в ROS направлены на глубокую интеграцию с ROS 2. По сути, это позволит сделать приложения ROS 2 практически неотличимыми от кода, выполняемого в самом PX4.
<p>
Используйте ROS 2 для новых проектов. Как можно скорее перейдите на ROS 2 для существующих проектов
<p>
<b>DroneKit​</b><br>
DroneKit-Python - это API MAVLink, написанный на Python. Он не оптимизирован для использования с PX4 и не поддерживался в течение нескольких лет. Устаревшие документы по использованию PX4 и DroneKit можно найти здесь: <a href="https://docs.px4.io/v1.12/en/robotics/dronekit.html">PX4 v1.12 &gt; DroneKit</a>.
<h3><a href="https://docs.px4.io/main/en/ros2/user_guide.html">ROS 2 User Guide</a></h3>
<h3 align="center"><a href="https://docs.px4.io/main/en/ros/ros1.html">ROS1</a></h3>
ROS 1 теперь "не рекомендуется", поскольку срок службы последней версии LTS подходит к концу. ROS 2 имеет гораздо более глубокую интеграцию с PX4, обеспечивая связь с меньшей задержкой и доступ к внутренним сообщениям PX4.
<p>
ROS (1) - это библиотека робототехники общего назначения, которую можно использовать с PX4 для разработки приложений для беспилотных летательных аппаратов.
<p>
В этой версии ROS используется пакет MAVROS для взаимодействия с PX4 через MAVLink (MAVROS связывает темы ROS с соглашениями MAVLink и PX4).
<h3><a href="https://docs.px4.io/main/en/ros/mavros_installation.html">ROS1 с руководством по установке MAVROS</a></h3>
В этой документации объясняется, как настроить связь между автопилотом PX4 и вспомогательным компьютером с поддержкой ROS 1 с помощью MAVROS.
<p>
<b>MAVROS</b> - это пакет ROS 1, который обеспечивает расширяемую связь MAVLink между компьютерами, работающими под управлением ROS 1, для любого автопилота, наземной станции или периферийного устройства с поддержкой MAVLink. MAVROS - это "официальный" поддерживаемый мост между ROS 1 и протоколом MAVLink.
<p>
Сначала мы устанавливаем PX4 и ROS, а затем MAVROS.
<h3>Установка ROS и PX4</h3>
В этом разделе объясняется, как установить ROS 1 с помощью PX4. Полные настольные сборки ROS 1 поставляются с Gazebo Classic, поэтому, как правило, вы не будете устанавливать зависимости симулятора самостоятельно!
<p>
<i>Эти инструкции представляют собой упрощенную версию официального руководства по установке. Они охватывают релизы ROS Melodic и Noetic.</i>
<p>
Если вы работаете с ROS Noetic в Ubuntu 20.04:
<ol>
<li> Установите PX4 без набора инструментов симулятора:
<ol>
<li> <a href="https://docs.px4.io/main/en/dev_setup/building_px4.html">Скачать исходный код PX4</a>:
<p>
<b>git clone https://github.com/PX4/PX4-Autopilot.git --recursive</b>
<li> Запустите ubuntu.используйте --no-sim-tools (и, необязательно, --no-nuttx).:
<p>
<b>bash ./PX4-Autopilot/Tools/setup/ubuntu.sh --no-sim-tools --no-nuttx</b><br>
Отвечайте на все запросы по мере выполнения сценария.
<li> По завершении перезагрузите компьютер.
</ol>
<li> Возможно, вам потребуется установить следующие дополнительные зависимости:
<p>
<b>sudo apt-get install protobuf-compiler libeigen3-dev libopencv-dev -y</b>
<li> Следуйте <a href="http://wiki.ros.org/noetic/Installation/Ubuntu#Installation">инструкциям по установке Noetic</a> (рекомендуется использовать ros-noetic-desktop-full).
</ol>
<h3>Установка MAVROS</h3>
Затем MAVROS может быть установлен как из исходного кода, так и из двоичного файла. Мы рекомендуем разработчикам использовать установку из исходного кода.
<p>
<b>Бинарная установка (Debian / Ubuntu)</b><br>
В репозитории ROS есть бинарные пакеты для Ubuntu x86, amd64 (x86_64) и armhf (ARMv7). Kinetic также поддерживает Debian Jessie amd64 и arm64 (ARMv8).
<p>
Используйте apt-get для установки, где ${ROS_DISTRO}, указанный ниже, должен преобразоваться в kinetic или noetic, в зависимости от вашей версии ROS:
<p>
<b>sudo apt-get install ros-${ROS_DISTRO}-mavros ros-${ROS_DISTRO}-mavros-extras ros-${ROS_DISTRO}-mavros-msgs</b>
<p>
Затем установите данные GeographicLib, запустив скрипт install_geographiclib_datasets.sh :
<pre>
wget https://raw.githubusercontent.com/mavlink/mavros/master/mavros/scripts/install_geographiclib_datasets.sh
sudo bash ./install_geographiclib_datasets.sh
</pre>
<p>
<b>Установка с помощью исходного кода:</b><br>
При такой установке предполагается, что у вас есть рабочее пространство catkin, расположенное по адресу ~/catkin_ws, если вы не создадите его с помощью:
<pre>
mkdir -p ~/catkin_ws/src
cd ~/catkin_ws
catkin init
wstool init src
</pre>
Для этой установки вы будете использовать инструменты ROS Python: wstool (для извлечения исходных текстов), rosinstall и catkin_tools (для сборки). Хотя они могли быть установлены во время установки ROS, вы также можете установить их с помощью:
<p>
<b>sudo apt-get install python-catkin-tools python-rosinstall-generator -y</b>
<p>
<i>Хотя пакет может быть собран с помощью catkin_make, предпочтительным методом является использование catkin_tools, поскольку это более универсальный и "дружественный" инструмент сборки.</i>
<p>
Если вы впервые используете wstool, вам нужно будет инициализировать исходное пространство с помощью:<br>
<b>wstool init ~/catkin_ws/src</b>
<p>
Теперь вы готовы приступить к сборке:
<ol>
<li> Установка MAVLink
<pre>
# We use the Kinetic reference for all ROS distros as it's not distro-specific and up to date
rosinstall_generator --rosdistro kinetic mavlink | tee /tmp/mavros.rosinstall
</pre>
<li> Установите MAVROS из исходного кода, используя либо выпущенную, либо последнюю версию:
<ul>
<li> Released/stable:
<p>
<b>rosinstall_generator --upstream mavros | tee -a /tmp/mavros.rosinstall</b>
<li> latest версия:
<p>
<b>rosinstall_generator --upstream-development mavros | tee -a /tmp/mavros.rosinstall</b>
<pre>
# For fetching all the dependencies into your catkin_ws,
# just add '--deps' to the above scripts, E.g.:
#   rosinstall_generator --upstream mavros --deps | tee -a /tmp/mavros.rosinstall
</pre>
</ul>
<li> Создание рабочего пространства и отделений
<pre>
wstool merge -t src /tmp/mavros.rosinstall
wstool update -t src -j4
rosdep install --from-paths src --ignore-src -y
</pre>
<li> Установка наборов данных GeographicLib:
<p>
<b>./src/mavros/mavros/scripts/install_geographiclib_datasets.sh</b>
<li> Сборка исходника:<br>
<b>catkin build</b>+
<li> Убедитесь, что вы используете setup.bash или setup.zsh из рабочей области.
<pre>
#Needed or rosrun can't find nodes from this workspace.
source devel/setup.bash
</pre>
</ol>
В случае возникновения ошибки в репозитории mavros есть <a href="https://github.com/mavlink/mavros/tree/master/mavros#installation">дополнительные указания по установке и устранению неполадок</a>.

<h3><a href="https://docs.px4.io/main/en/ros/mavros_offboard_cpp.html">Пример автономного управления MAVROS (C++)</a></h3>

<h3><a href="https://docs.px4.io/main/en/ros/mavros_offboard_python.html">Пример автономного управления MAVROS (Python)</a></h3>

<h3><a href="https://docs.px4.io/main/en/ros/mavros_custom_messages.html">Отправка пользовательского сообщения из MAVROS на PX4</a></h3>

<h3><a href="https://docs.px4.io/main/en/simulation/ros_interface.html">ROS with Gazebo Classic Simulation</a></h3>

<h3><a href="https://docs.px4.io/main/en/sim_gazebo_classic/octomap.html">OctoMap 3D Models with ROS/Gazebo Classic</a></h3>

<h3><a href="https://docs.px4.io/main/en/ros/raspberrypi_installation.html">Raspberry Pi - ROS installation</a></h3>

<h3><a href="https://docs.px4.io/main/en/ros/external_position_estimation.html">Использование систем видеонаблюдения или захвата движения для оценки местоположения</a></h3>





<br><br><br><br><br><br></body></html>
