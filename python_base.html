<html><head>
<style>
.menu {
       height: 100%;
       width: 140px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 155px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Основы Python</title>
<div class="menu">
<a href="#top">Начало</a><br>
<a href="#sintaks">Синтаксис</a><br>
<a href="#var">Переменные</a>
<ul>
<li><a href="#number">Числа</a>
<li><a href="#string">Строки</a>
<li><a href="#list">Список</a>
<li><a href="#set">Множества (set и frozenset)</a>
<li><a href="#typle">Кортеж</a>
<li><a href="#diction">Словарь</a>
</ul>
<a href="#range">Функция range</a><br>
<a href="#srez">Срез массивов</a><br>
<a href="#if">Условие if</a><br>
<a href="#while">Циклы while</a><br>
<a href="#for">и for</a><br>
<a href="#def">Функции</a><br>
<a href="#file">Работа с файлами</a><br>
<a href="#modul">Импорт и создание модулей</a><br>
<a href="#lib">Стандартная библиотека модулей</a><br>
<a href="#obiekt">Классы, объекты</a><br>
</div>
<div class="content">
<h2 align=center><a name="top">Введение в Python</h2>
Ссылки на учебники: <a href="https://pythonworld.ru/samouchitel-python">Самоучитель Python</a>
<p>
Языки программирования делятся на два типа:
<ul>
<li> Компилируемые<br>
Специальная программа, компилятор, преобразует исходный код в машинный.<br>
Полученный в результате файл готов к исполнению без дополнительных инструментов.<br>
Примеры: C++, Colang, Rust
<li> Интерпретируемые<br>
Код исполняется строчка за строчкой специальной программой - интерпретатором.<br>
Исполнение возможно только при наличии этой программы.<br>
Примеры: Python, Lua, JavaScript.
</ul>

<h3 align=center><a href="https://pyplanet.ru/article/install.html">Установка Python на linux системы (Ubuntu, Debian и другие)</a></h3>
Откройте консоль (обычно ctrl+alt+t). Введите в консоли:
<pre>python3</pre>
Скорее всего, вас любезно поприветствует python:
<pre>
dmitriy@945G-M3:~$ python3
Python 3.8.10 (default, Sep 11 2024, 16:02:53) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 
</pre></pre>
или узнать версию  python:
<pre>
dmitriy@945G-M3:~$ python3 --version
Python 3.8.10</pre>
Если это так, то можно вас поздравить: у вас уже стоит python. В противном случае нужно установить пакет *python3*:
<pre>sudo apt install python3</pre>


<h3 align=center>На чем писать код и как выпонять?</h3>
<ol>
<li> VS code и Pycharm<br>
для моего компьютера очень тяжелые.
<li> В python для linux нет предустановленной среды IDLE. Если хотите, её можно установить отдельно. Пакет называется idle3 (в более ранних версиях он может называться python3-idle).<br>
Однако, её установка не является обязательной. Вы можете писать в своём любимом текстовом редакторе (gedit, vim, emacs...) и запускать программы через консоль:<br>
python3 path_to_file.py
<p>
Как писать на <a href="https://pyplanet.ru/article/hello-world.html">IDLE</a>
<li> https://repl.it/<br>
Начал на нем.
<li> Jupyter Notebook<br>
Чтобы начать на нем работать, команда:
<pre>jupyter notebook</pre>

<li> <b>Shebang</b> — это специальное выражение, которое указывается в начале файла исполняемого скрипта. Оно сообщает системе, какой интерпретатор использовать для запуска скрипта.
<p>
В случае с Python это может быть один из двух вариантов:
<p>
/usr/bin/env python. Более переносимый вариант, который позволяет системе самой найти нужный интерпретатор Python.
<p>
/usr/local/bin/python. Требует, чтобы интерпретатор Python был установлен именно в этом месте.
<p>
Использование shebang не является обязательным для Python-скриптов. Оно полезно, если скрипт предназначен для запуска из командной строки Unix как самостоятельная программа. Если же скрипт запускается из другого Python-скрипта с помощью функции exec() или подобных, то shebang не требуется.
<p>
Написал простой код 1.py:
<pre>
#!/usr/bin/env python 
print("aggggggg")</pre>
Если выполнить скрипт, просто: <b>1.py</b><br>
<font color=red>то команда не найдена.</font><br>
если: <b>source 1.py</b><br>
<font color=red>то синтаксическая ошибка</font>
<p>
Прочитал, что требуется указывать полный путь к скрипту для его выполнения. Выполнил: 
<pre>/usr/bin/python3 ~/Python/1.py</pre>
Выполнился без ошибок. После этого:
<pre>~/Python/1.py
     /usr/bin/env: «python»: Нет такого файла или каталога</pre>
Очевидно неправильный шебанг.<br>
Исправил:
<pre>
#!/usr/bin/env <font color=green>python3</font> 
print("aggggggg")</pre>
Снова: ~/Python/1.py<br>
Теперь выполнился и без ошибок.
<p>
Если все же выполнить:
<pre>
1.py
1.py: команда не найдена</pre>
То есть все равно нужно указывать явный путь к файлу.py
<p>
<li> <b>Интерактивный режим:</b><br>
Выполняем команду: <b>python3</b> и далее можно выполнять команды сразу после каждой строки.<br>
Выход из интерактивного режима: нажатие Ctrl+z
</ol>





<h3 align=center><a name="sintaks">Синтаксис</h3>
Синтаксис языка Python очень прост.
<ul>
<li> Конец строки является концом инструкции (точка с запятой не требуется).

<li> Вложенные инструкции объединяются в блоки по величине отступов. Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков. Однако хорошим тоном считается отступ каждого блока в 4 пробела
<li> Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, как правило, с отступом под строкой основной инструкции.
<pre>
Основная инструкция:
    Вложенный блок инструкций</pre>
<h4><a href="https://intuit.ru/studies/courses/49/49/lecture/27058?page=7">Имена</a></h4>    
Имя может начинаться с латинской буквы (любого регистра) или подчеркивания, а дальше допустимо использование цифр. В качестве идентификаторов нельзя применять ключевые слова языка и нежелательно переопределять встроенные имена.<br>
<p>Имена, начинающиеся с подчеркивания или двух подчеркиваний, имеют особый смысл. Одиночное подчеркивание говорит программисту о том, что имя имеет местное применение, и не должно использоваться за пределами модуля. Двойным подчеркиванием в начале и в конце обычно наделяются специальные имена атрибутов - об этом будет говориться в лекции по объектно-ориентированному программированию.
<p>    
В каждой точке программы интерпретатор "видит" три пространства имен: локальное, глобальное и встроенное. Пространство имен - отображение из имен в объекты.
<p>
Для понимания того, как Python находит значение некоторой переменной, необходимо ввести понятие блока кода. В Python блоком кода является то, что исполняется как единое целое, например, тело определения функции, класса или модуля.
<p>
Локальные имена - имена, которым присвоено значение в данном блоке кода. Глобальные имена - имена, определяемые на уровне блока кода определения модуля или те, которые явно заданы в операторе global. Встроенные имена - имена из специального словаря __ builtins __.
<p>
Области видимости имен могут быть вложенными друг в друга, например, внутри вызванной функции видны имена, определенные в вызывающем коде. Переменные, которые используются в блоке кода, но связаны со значением вне кода, называются свободными переменными.
<p>
Так как переменную можно связать с объектом в любом месте блока, важно, чтобы это произошло до ее использования, иначе будет возбуждено исключение NameError. Связывание имен со значениями происходит в операторах присваивания, from, import, в формальных аргументах функций, при определении функции или класса, во втором параметре части except оператора try-except.
<p>
С областями видимости и связыванием имен есть много нюансов, которые хорошо описаны в документации. Желательно, чтобы программы не зависели от таких нюансов, а для этого достаточно придерживаться следующих правил:
<ul>
<li> Всегда следует связывать переменную со значением (текстуально) до ее использования.
<li> Необходимо избегать глобальных переменных и передавать все в качестве параметров. Глобальными на уровне модуля должны остаться только имена-константы, имена классов и функций.
<li> Никогда не следует использовать from модуль import * - это может привести к затенению имен из других модулей, а внутри определения функции просто запрещено.
</ul>
Предпочтительнее переделать код, нежели использовать глобальную переменную. Конечно, для программ, состоящих из одного модуля, это не так важно: ведь все определенные на уровне модуля переменные глобальны.
<p>
Убрать связь имени с объектом можно с помощью оператора del. В этом случае, если объект не имеет других ссылок на него, он будет удален.     
    
    
<h4><a href="https://intuit.ru/studies/courses/49/49/lecture/27058?page=8">Стиль программирования</a></h4>
Наиболее существенные положения этого стиля перечислены ниже. В случае сомнений хорошим образцом стиля являются модули стандартной библиотеки.
<ul>
<li> Рекомендуется использовать отступы в 4 пробела.
<li> Длина физической строки не должна превышать 79 символов.
<li> Длинные логические строки лучше разбивать неявно (внутри скобок), но и явные методы вполне уместны. Отступы строк продолжения рекомендуется выравнивать по скобкам или по первому операнду в предыдущей строке. Текстовый редактор Emacs в режиме python-mode и некоторые интегрированные оболочки (IDE) автоматически делают необходимые отступы в Python-программах:
<pre>
def draw(figure, color="White", border_color="Black",
         size=5):
    if color == border_color or \
       size == 0:
        raise "Bad figure"
    else:
        _draw(size, size, (color,
                           border_color))</pre>
<li> Не рекомендуется ставить пробелы сразу после открывающей скобки или перед закрывающей, перед запятой, точкой с запятой, перед открывающей скобкой при записи вызова функции или индексного выражения. Также не рекомендуется ставить более одного пробела вокруг знака равенства в присваиваниях. Пробелы вокруг знака равенства не ставятся в случае, когда он применяется для указания значения по умолчанию в определении параметров функции или при задании именованных аргументов.
<li> Также рекомендуется применение одиночных пробелов вокруг низкоприоритетных операций сравнения и оператора присваивания. Пробелы вокруг более приоритетных операций ставятся в равном количестве слева и справа от знака операции.
</ul>
Несколько рекомендаций касаются написания комментариев.
<ul>
<li> Комментарии должны точно отражать актуальное состояние кода. (Поддержание актуальных комментариев должно быть приоритетной задачей!) После коротких комментариев можно не ставить точку, тогда как длинные лучше писать по правилам написания текста. Автор Python обращается к неанглоязычным программистам с просьбой писать комментарии на английском, если есть хотя бы небольшая вероятность того, что код будут читать специалисты, говорящие на других языках.

<li> Комментарии к фрагменту кода следует писать с тем же отступом, что и комментируемый код. После " # " должен идти одиночный пробел. Абзацы можно отделять строкой с " # " на том же уровне. Блочный комментарий можно отделить пустыми строками от окружающего кода.

<li> Комментарии, относящиеся к конкретной строке, не следует использовать часто. Символ " # " должен отстоять от комментируемого оператора как минимум на два пробела.

<li> Хороший комментарий не перефразирует программу, а содержит дополнительную информацию о действии программы в терминах предметной области.
</ul>

Все модули, классы, функции и методы, предназначенные для использования за пределами модуля, должны иметь строки документации, описывающие способ их применения, входные и выходные параметры.
<ul>
<li> Строка документации для отдельной программы должна объяснять используемые ею ключи, назначение аргументов и переменных среды и другую подобную информацию.
<li> Для строк документации рекомендуется везде использовать утроенные кавычки ( """ ).
<li> Однострочная документация пишется в императиве, как команда: "делай это", "возвращай то".
<li> Многострочная документация содержит расширенное описание модуля, функции, класса. Она будет смотреться лучше, если текст будет написан с тем же отступом, что и начало строки документации.
<li> Документация для модуля должна перечислять экспортируемые функции, классы, исключения и другие объекты, по одной строке на объект.
<li> Строка документации для функции или метода должна кратко описывать действия функции, ее входные параметры и возвращаемое значение, побочные эффекты и возможные исключения (если таковые есть). Должны быть обозначены необязательные аргументы и аргументы, не являющиеся частью интерфейса.
<li> Документация для класса должна перечислять общедоступные методы и атрибуты, содержать рекомендации по применению класса в качестве базового для других классов. Если класс является подклассом, необходимо указать, какие методы полностью заменяют, перегружают, а какие используют, но расширяют соответствующие методы надкласса. Необходимо указать и другие изменения по сравнению с надклассом.
<li> Контроль версий повышает качество процесса создания программного обеспечения. Для этих целей часто используются RCS или CVS. "Python Style Guide" рекомендует записывать $Revision: 1.31 $ в переменную с именем __version__, а другие данные заключать в комментарии " # ".
</ul>
<ul>
<li> Имена модулей лучше давать строчными буквами, например, shelve, string, либо делать первые буквы слов заглавными, StringIO, UserDict. Имена написанных на C модулей расширения обычно начинаются с подчеркивания " _ ", а соответствующие им высокоуровневые обертки - с прописных букв: _tkinter и Tkinter.
<li> Классы обычно называют, выделяя первые буквы слов прописными, как в Tag или HTTPServer.
<li> Имена глобальных переменных (если таковые используются) лучше начинать с подчеркивания, чтобы они не импортировались из модуля оператором from-import со звездочкой.
<li> Имена констант (имен, которые не должны переопределяться) лучше записывать прописными буквами, например: RED, GREEN, BLUE.
</ul>
</ul>




<h2 align=center><a name="var">Переменные</h2>
Для имени переменной используется любой набор допустимых символов: буквы английского алфавита, цифры, знак _. При этом цифру нельзя ставить в начале.
<p>
<i>В Python переменные являются лишь именованиями объектов. Ссылками на объекты, если так проще.
<p>
Присвоив, скажем, переменной b значение 5 (b = 5) - стоит помнить, что переменная b лишь ссылается на целочисленное значение 5.
<p>
При желании можно объявить переменную b хоть стоковым значением (b = str(b)) и это будет всё та же "5", но уже не целочисленная. И арифметических действий с ней уже не получится. Просто старое значение (ссылка) переменной будет стёрта и теперь она уже будет ссылаться на 5 - объект типа strint (str).
<p>
Точно также и с преобразованием во float - это будет ссылка уже на третий объект, 5.0 типа float.
<p>
Все три объекта в ходе этих операций не менялись, они неизменны. Просто переменная ссылалась то на один, то на другой. 
<p>
По сути, когда вы присваиваете переменной значение - в памяти "создаётся объект". Если дальше значение в этой переменной изменилось, и на старый объект она больше не ссылается - то (при условии, что на старый объект не ссылается какая-нибудь другая переменная) так называемый "Сборщик мусора" (встроенная, автоматическая штука в компиляторе Python, которая облегчает нам всем жизнь) уничтожает этот самый объект (когда на него больше никакая переменная не ссылается, значит - он в памяти больше не нужен). 
<p>
Так что да, технически - объекты этих типов не изменяемы. Надеюсь, не слишком сумбурно изложил.</i>
<p>
Ещё:<br>
<i>В Python есть изменяемые и неизменяемые типы. Изменяемые отличаются тем, что их содержимое можно сменить, не изменив ссылку на них. Неизменяемые объекты приходится пересоздавать, чтобы отразить изменения состояния. При этом все старые ссылки не видят это обновление, потому что указывают на старый объект.
<p>
Поясню на практике. Списки, словари, множества - это изменяемые объекты:
<pre>
l1 = [1, 2, 3]
l2 = l1
print(l1, l2, id(l1), id(l2))  
# [1, 2, 3] [1, 2, 3] 139917408901064 139917408901064

l1[1] = 10
print(l1, l2, id(l1), id(l2))  
# [1, 10, 3] [1, 10, 3] 139917408901064 139917408901064</pre>
Числа, строки, кортежи - это неизменяемые объекты:
<pre>
v1 = 1024
v2 = v1
print(v1, v2, id(v1), id(v2))
# 1024 1024 ...7040 ...7040

v1 = 2048
print(v1, v2, id(v1), id(v2))
# 2048 1024 ...5312 ...7040

t1 = (1, 2, 3)
t2 = t1
print(t1, t2, id(t1), id(t2))
# (1, 2, 3) (1, 2, 3) ...6232 ...6232

# t1[1] = 10  # не сработает, так как кортежи неизменяемые
t1 = (1, 10, 3)
print(t1, t2, id(t1), id(t2))
# (1, 10, 3) (1, 2, 3) ...7240 ...6232</pre></i>


<h3><a name="number">Числа:</h3>
Типы int и float
<p>
Все объекты в Python принадлежат какому-то классу или, другими словами, у всех данных есть свой определенный тип. Чтобы узнать тип данных, можно воспользоваться следующим кодом:
<pre>
print(type(5))
print(type(5.8))</pre>
В первом случае будет выведен результат &lt;class 'int'&gt;, а во втором - &lt;class 'float'&gt;. Целые числа принадлежат классу int, дробные - классу float.
<p>
Тип можно менять:
Функция int(x) - преобразует число x типа float (вещественное) в число типа int (целое)
<pre>
>>> x=2.7666
>>> print(int(x))
2</pre>
float(x) наоборот выводит число int типа в типе float
<pre>
>>> x=7
>>> type(x)
&lt;class 'int'&gt;
>>> print(float(x))
7.0
>>> type(x)
&lt;class 'int'&gt;
>>> print(x)
7</pre>
Нужно иметь в виду, что объекты: числа строки являются неизменяемыми, потому x=7 в примере выше не изменилось, только вывод функции в другом формате.
<p>
<ul>
<li> <b>Операции с числами</b><br>
Над объектами из классов int и float можно производить стандартные арифметические операции:
<pre>
print(5+7)
print(10-4)
print(64/8)
print(9*8+25/5)</pre>

В Python есть 3 типа делений:
<pre>
print(17/2) #обычное деление - результат - число с плавающей точкой (вещественное) 8.5
print(17//2) #целочисленное деление, результат - целая часть при делении
print(17%2) #деление с остатком - результат 1, остаток при делении</pre>
Обратите внимание на текст после знака #. Так в Python обозначаются комментарии. Эта часть кода не обрабатывается интерпретатором, она нужна для вас и других разработчиков, которые будут работать с кодом.
<p>
Многострочные комментарии делаются с помощью тройных кавычек:
<pre>
'''Различные варианты деления в Python
обычное деление
целочисленное деление
деление с остатком'''</pre>
<li> <b>Возведение в степень:</b>
<pre>
print(3**6)
print(10**(-1))
print(25**(1/2))</pre>
Результат выполнения этой программы:
<pre>
729 
0.1
5.0
</pre>
<li> <b>Приоритет арифметических операций</b><br>
Это хоть и кажется иногда очевидным, или несущественным, но на самом деле крайне важно.<br>
Сначала идут выражения в скобках<br>
Затем операция возведения в степень<br>
Затем умножение и деление (обычное, целочисленное)<br>
Сложение и вычитание<br>
При равном приоритете операции выполняются слева направо<br>
Любые арифметические операции выше по приоритету операций сравнения и логических операторов.
<p>
<li> <b>Приоритет логических операций</b><br>
Операция and имеет более высокий приоритет чем or:
<pre>
>>> print(7>5 or 6<10 and 10>11)
True</pre>
Здесь сначала будет выполняться правый логический оператор (and), а потом только левый (or).
<p>

<li> Вещественные числа можно записывать в таком формате: 5e-1 - это число 0,5. Здесь e - это экспонента, равная 10. -1 - это степень.<br>
1234e-2 - это 12,34<br>
<pre>
>>> 23e3
23000.0</pre>

<li> <b>Операторы приращения</b><br>
Сумму x = x + 3 можно записать по-другому: x += 3<br>
Другие операторы приращения:
x -=i это x = x - i<br>
x *=i это x = x*i<br>
x /=i это x = x / i<br>
x //=i это x = x // i<br>
x %=i это x = x % i<br>
x **=i будет означать команду x = x ** i
</ul>



<h3><a name="string">Строки</h3>
<ul>
<li> Строки относятся к классу <font color=red>str</font>
<p>
<li> Строчные переменные можно задать 3 способами:<br>
<ol>
<li> s1="stroka"
<li> s2='stroka'
<li> s3="""stroka""""
</ol>
Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, не используя экранированные последовательности.
<pre>
>>> string = '"sp"am"'
>>> print(string)
"sp"am"
>>> string = "'sp'am'"
>>> print(string)
'sp'am'</pre>
Тройные кавычки позволяют создавать многостроковые комментарии:
<pre>
""" stroka1
    stroka2
    stroka3 """</pre>
    
<li> Строки имеют индесацию<p>

<li> Если хотим вызвать все символы по отдельности с строки, то можно использовать цикл:
<pre>
s = 'stroka'
for i in s:
    print(i)</pre>
    
<li> <b>Экранированные последовательности</b><br>
Экранированные последовательности позволяют вставить символы, которые сложно, или невозможно ввести с клавиатуры.
<ul>
<li> \n - перевод строки
<li> \f - перевод страницы
<li> \t - горизонтальная табуляция
<li> \v - вертикальная табуляция
</ul>

<li> "Сырые" строки - подавляют экранирование<br>
Если перед открывающей кавычкой стоит символ 'r' (в любом регистре), то механизм экранирования отключается.
<pre>S = r'C:\newt.txt'</pre>
"Сырая" строка не может заканчиваться символом обратного слэша. Его придётся добавлять (или убирать) вручную. Также неочевидно работает экранирование кавычек. Оно происходит, но символ обратного слэша также добавляется в строку. А не экранировать кавычку того же типа, что и в литерале, нельзя.

<li> Операции над строками<br>
Строка в Python ведёт себя как массив символов, а значит, можно применять индексы и срезы:
<pre>
>>> string = "Привет, pyplanet"
>>> string[0]
'П'
>>> string[-1]
't'
>>> string[8:]
'pyplanet'
>>> string[::-1]
'tenalpyp ,тевирП'
>>> string[::2]
'Пие,ppae'</pre>
Полный список строковых методов есть в <a href="https://pyplanet.ru/article/string-methods.html">нашем справочнике</a>.
<p>
Несколько примеров:
<pre>
>>> string = "Привет, pyplanet"
>>> string.upper()
'ПРИВЕТ, PYPLANET'
>>> string.replace("и", "е")
'Превет, pyplanet'
>>> string.split()
['Привет,', 'pyplanet']</pre>

<li> Строки можно складывать. При сложении они склеиваются.
<pre>
str1 = 'Hello, '
str2 = 'world!'
print(str1+str2)</pre>
Результат: “Hello, world!”
<p>
<li> Строку можно умножить на число:
<pre>print(str1*5)</pre>
Результат - это повторение строки str1 5 раз.
<p>
<li> Часто нам будет полезно уметь определять длину строки. Для этого существует функция len( ):
<pre>
print(len('строка'))</pre>
<li> Обратите внимание, что когда мы считываем данные с помощью функции input( ), мы считываем именно строковый тип. Если мы в дальнейшем хотим работать с введенными данными как с числами, то можно воспользоваться приведением типов:
<pre>
a = int(input())
b = float(input())
</pre>

<li> <b>Строки являются неизменяемыми:</b>
<pre>
>>> s='asdf'
>>> s[0]='a'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment</pre>
объект 'str' не поддерживает назначение элемента

<li> <b>Методы объекта строка</b>
<ul>
<li> count(arg) - считает сколько раз в строке встречается символ(ы) arg
<pre>
s = input()
n = s.count('g') + s.count('G') + s.count('c') + s.count('C')
print(n * 100 / len(s))</pre>
<li> upper() - переводит строку в верхний регистр
<li> lower() - наоборот в нижний регистр
<li> find(arg) - выдает индекс arg в строке. Если arg не будет в строке, то результат будет -1<br>
более рекомендуется конструкция: <b>if 'arg' in s:</b>
<li> replace(arg1,arg2) - меняет все arg1 в строке на arg2
</ul>
Нужно иметь в виду, что метод создает новый объект, как результат выполнения метода, но оригинальный объект не меняется.

<li> <b>Срез (диапазон строки)</b><br>
Общий шаблон:
<pre>
s = 'stroka'
print(s[x1:x2:x3]</pre>
Здесь напечатается строка из символов, где x1 - это индекс первого нужного символа в строке. Если не указан, то по умолчанию равен 0 Может иметь отрицательное значение, тогда индекс считается с првой стороны, <b>но все равно далее символы смотрятся в првую сторону.</b><br>
x2 -  индекс последнего нужного символа. Может иметь отрицательное значение, то есть отсчет с правой стороны.<br>
x3 - шаг приращения индекса, если не указан, то по умолчанию 1. Может иметь отрицательное значение. s[::-1] просто перевернёт строку.
</ul>

<h4>Логический тип данных</h4>
В Python существует логический тип данных - класс bool. Переменные этого типа могут принимать только 2 значения: True и False. Подробнее с этим типом данных мы столкнемся, когда будем рассматривать логические выражения и условные конструкции.


<h3>Тип данных None</h3>
В Python существует зарезервированное слово None, которое обозначает отсутствие типа.
<pre>
a = None
print(type(a))</pre>

<h3>Параметры функции print</h3>
<ul>
<li> Без параметров print() будет выводить в цикле результат на новой строке.
<li> print('stroka', end='')<br>
Здесь результаты будут выводиться на одной строке через пробел.
<li> Функция print(arg1, arg2, ..., argN) выводит аргументы через пробел. Если указать флаг sep="\n", то каждый аргумент выведется на новой строке, пример print(arg1, arg2 , sep="\n")
<li> print(*list[])<br>
это "распаковка" списка (да и не только). позволяет вывести не список (с [] и запятыми между  элементами), а только элементы.
</ul>

<h3>input()</h3>
<ul>
<li>
<pre>a, b = (int(i) for i in input().split())</pre>
<font color=red>В этой команде вводим число из нескольких цифр, функция split расщепляет это число на отдельные цифры и они присваиваются переменным a и b</font>
<br>Проверил, у меня если одно число ввести, то вызывает ошибку, что дескать нужно ввести два числа. Ввел 2 числа через пробел, теперь все верно, переменным присвоились эти значения.<p>
<li> <font color=brpwn>Команда input() выдает объект типа строка, даже если напечатаем число</font>. Поэтому с числа надо input приводить к типу int или float.
</ul>





<h3 align=center><a name="list" href="https://pyplanet.ru/article/array-list.html">Список</a></h3>
<b>Список</b> - переменная, содержащая список данных (элементов), внутри квадратных скобок идущих через запятую. Элементы строки можно в отличии от строки изменять.
<pre>
list = [] # пустой список
array = [1, 2, 3, 4, 5, 6, 7] # список из целых чисел int
print(type(array)) # класс list
ar = [2, 4.6, 'str', [1, 2, 3]] # список, состоящий из целого числа,
# из числа с плавающей точкой, из строки и из списка
</pre>
<ul>
<li> <b>Индексация списков:</b><br>
Индексация элементов списка имеет 2 способа, традиционная с 0 и с конца списка с -1.
Например есть список a = [1, 2, 3, 4]<br>
Тогда по обычной индексации элемент 1 имеет индекс 0 (a[0] = 1, a[1] = 2, a[2] = 3, a[3] = 4)<br>
По индексации с конца последний элемент имеет индекс -1 и далее левее на -1 индекс растет: a[-1] = 4, a[-2] = 3, a[-3] = 2, a[-4] = 1
<br>Индекс, в общем случае, не обязан быть числом. К элементам хеш-таблиц (которые мы рассмотрим позже) можно обращаться по строковому индексу.<br>
Также, поскольку списки - изменяемый тип данных, то по индексу возможно присвоение:
<pre>
>>> array = [1, 2, 3, 0, 1.4, -2]
>>> array[1] = 42
>>> array
[1, 42, 3, 0, 1.4, -2]</pre>
    
<li> <b>Методы объекта список:</b>
<p>
<img src="./images/python_base.png">
<p>
<b>append()</b><br>
<pre>array.append(8)</pre>
В список array добавили элемент 8 с помощью метода append.
<p>
Другой способ добавления в конец списка нового элемента - оператор приращения:
<pre>array +=[8]</pre>
Интересный пример по этому случаю:
<pre>
>>> students = ['Ivan', 'Masha', 'Sasha']
>>> students += ['Olga']
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga']
>>> students += 'Olga'
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a']</pre>
Видна разница между добавлением элемента с помощью модуля append и оператором +=.<br>
И списки, и строки - это последовательности (см. https://docs.python.org/3/library/stdtypes.html?highlight=mutable%20sequence#) . 
<br>+= складывает список с элементами последовательности ﻿по отдельности.
<br>А append прибавляет к списку новый элемент списка, сколько бы вложенных элементов в этом элементе ни было .
<br>Продолжение:
<pre>
>>> students += ['Dmitriy', 'Alexei']
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei']
>>> students.append(['Anna', 'Elena'])
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei', ['Anna', 'Elena']]</pre>

<b>remove() - удаление элемента из списка</b><br>
Удалить элемент можно с помощью модуля remove(element). Параметров может быть только один, то есть можно удалить за раз только один элемент:
<pre>
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei', ['Anna', 'Elena']]
>>> students.remove('o', 'l', 'g', 'a', ['Anna', 'Elena'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: remove() takes exactly one argument (5 given)
>>> students.remove(['Anna', 'Elena'])
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei']</pre>
Можно также удалять элемент с помощью <b>команды del</b> с указанием индекса:
<pre>
>>> del students[4]
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'l', 'g', 'a', 'Dmitriy', 'Alexei']</pre>

<b>sort()</b> - сортировка элементов по возрастанию
<pre>
>>> students.sort()
>>> students
['Alexei', 'Dmitriy', 'Ivan', 'Masha', 'Olga', 'Sasha', 'a', 'g', 'l']</pre>
Здесь строки отсортировались по алфавитному порядку, буквы также по алфавиту, но после строк.
<p>
Второй способ, использовать функцию sorted():
<pre>
>>> number = [1, 1000, 6, 9, 4, 0]
>>> sorted(number)
[0, 1, 4, 6, 9, 1000]
>>> number
[1, 1000, 6, 9, 4, 0]</pre>
В отличии от метода sort() функция sorted() не меняет порядок списка

<p>
<b>insert(par1, par2)</b> - вставка элемента par2 по индексу par1
<pre>
>>> list = [0, 2, 3, 4]
>>> list.insert(1, 1)
>>> list
[0, 1, 2, 3, 4]
</pre>

<b>Метод  reverse()</b><br>
Этот метод перевернет список в обратном порядке.
<p>
Функция reversed() делает тоже самое.

<p>
<b>Функции max() и min()</b><br>
Эти функции возвращают максимальное и минимальное значение из списка.
<p>
<li>
Можно определить длину списка new_array:
           <pre>
           len(new_array)
           </pre>
Найти сумму элементов списка:
           <pre>
           sum(new_array)
           </pre>

<li> Списки можно складывать (склеивать):
           <pre>array2 = [9, 10]
                new_array = array + array2
                new_array = [0, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                </pre>

<li> <b>Списки можно умножать</b>:
<pre>
>>> list=['f',4,5,'r']
>>> list
['f', 4, 5, 'r']
>>> list*5
['f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r']
>>></pre>

<li> <b>Как узнать входит ли 'stroka' в список list</b>
<pre>
if 'stroka' in list:
    # true, входит
else:
    # false, не входит</pre>
Можно для этой цели использовать модуль index(var):
<pre>
>>> students.index('Sasha')
2</pre>
Здесь если строка Sasha входит в список, то вернется индекс этого элемента, иначе вернет ошибку.
<p>
<li> <b>Присвоение списков</b><br>
В питоне:
<pre>
>>> a = [1, 2, 3, 4]
>>> b = a
>>> b
[1, 2, 3, 4]
>>> a[3] = 10
>>> a
[1, 2, 3, 10]
>>> b
[1, 2, 3, 10]</pre>
Видно, что если изменили значение элемента в списке a, то изменится и список b, хотя обычно в других языках так не должно быть.<br>
<i>Когда вы пишите  a = [1, 2, 3], то а лишь указывает на список  [1, 2, 3], это как ярлык, который вы прикрепили к данному списку.
Затем, делая b=a, вы не копируете список, вы просто создаете новый ярлык к списку, на который указывает а.
Изменяя a, вы меняете также b. Потому﻿ что они указывают на один и тот же список.</i><br>
Чтобы a и b открепить друг от друга, нужно одному из них присвоить новый список (или любой объект другого типа).
<p>
<li> <b>Генерация списков</b><br>
Список можно создавать с помощью List Comprehension:
<pre>num = [int(i) for i in input().split()]</pre>
Если на вход подавать числа, то на выходе будет список из чисел.<br>
Если же для получения списка использовать попроще конструкцию:
<pre>num = input().split()</pre>
то здесь даже если подавать на вход числа, на выходе будет список из односимвольных строк.
<pre>
>>> numbers = [int(i) for i in input().split()]
1 3 5 6 10
>>> numbers
[1, 3, 5, 6, 10]
>>> num = input().split()
1 3 5 6 10
>>> num
['1', '3', '5', '6', '10']</pre>


<li> <b>Прямоугольная матрица</b><br>
Иногда нам приходится использовать таблицы с данными для решения своих задач. Такие таблицы называются матрицами или двумерными массивами.
<p>
В Python подобные таблицы можно представить в виде списка, элементы которого являются другими списками.
<p>
Создать такой массив в Python можно разными способами. Первый способ:
<pre>
# Создание таблицы с размером 3x3, заполненной нулями
a = 3           
mas = [0] * a 
for i in range(a): 
    mas[i] = [0] * a 
print(mas) # Выведет [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</pre>

Второй способ предполагает создание пустого списка с добавлением в него новых списков. Рассмотрим на примере:
<pre>
# Создание таблицы с размером 2x2, заполненной единицами
a = 3
mas = [] 
for i in range(a): 
    mas.append([1] * a)
print(mas) # Выведет [[1, 1, 1], [1, 1, 1], [1, 1, 1]]</pre>
                                 
Третьим и самым простым способом является генератор списков с x строками, которые будут состоять из y элементов. Пример: 
<pre>
# Создание таблицы с размером 3x3, заполненной двойками
a = 3
mas = [[2] * a for i in range(a)]
print(mas) # Выведет [[2, 2, 2], [2, 2, 2], [2, 2, 2]]</pre>
4 способ:  
<pre>a = [[0 for j in range(m)] for i in range(n)]</pre>
Здесь получаем матрицу из n строк и m  столбцов, заполненную нулями.
<p>
Для обработки и <b>вывода двухмерных списков</b> используются два вложенных цикла. Первый цикл – по порядковому номеру строки, второй – по ее элементам. Например, вывести массив можно так:
<pre>
mas = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
for i in range(0, len(mas)):
    for i2 in range(0, len(mas[i])):
        print(mas[i][i2], end=' ')
    print()
# Выведет
1 1 1
1 1 1
1 1 1</pre>
То же самое можно сделать не по индексам, а по значениям массива:
<pre>
mas = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
for i in mas: 
    for i2 in i: 
        print(i2, end=' ') 
    print()
# Выведет
1 1 1
1 1 1
1 1 1
</pre>
</ul>        
        
        

        
<h3 align=center><a name="set" href="https://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html">Множества (set и frozenset)</a></h3>
Множество - объект, который содержит неповторяющие элементы. Оформляется с помощью фигурных скобок.<br>
some_set = {1, 2, 3...}<br>
Но если попробуем так:<br>
test = {}<br>
то создадим не множество, а словарь.
<p>
Пустое множество создается с помощью функции set():<br>
some_set = set()
<pre>
1  numbers = set()
2
3  user_input = input()
4  while user_input:
5      number = int(user_input)
6      numbers.add(number)
7      user_input = input()
8 
9  print(numbers)</pre>
numbers.add(number) - с помощью метода add множества мы добавляем элемент (почти как методом append в статье про списки). 
Отличие в том, что при попытке добавить элемент, который уже находится в множестве, ничего со множеством не произойдёт. В 
список же добавился бы ещё один такой же элемент.

<h4>Особенности set</h4>
Может содержать только неизменяемые элементы (числа, строки, кортежи - может; списки, другие множества - не может)<br>
Порядок элементов не определён<br>
Особенности связаны с тем, что внутри множества в Python реализованы хеш-таблицей. Если кратко, то от каждого элемента мы вычисляем хеш-функцию, и её значение - это индекс в каком-то большом заранее выделенном массиве.
<p>
Отсюда также следует, что для поиска элемента в большом массиве выгоднее (по скорости) использовать множества, а не списки.
<p>
Перебрать элементы множества можно обычным способом с помощью цикла:<br>
<b>for element in some_set:</b>


<h4>Frozenset</h4>
frozenset - это неизменяемое множество. Создано по аналогии с парой список - кортеж, имеет те же самые особенности по сравнению с множеством, что и кортежи по сравнению со списками. Создаётся только с помощью функции frozenset(), своего литерала (как кортеж) не имеет.
<p>
frozenset может использоваться в качестве элементов set.
<br>А больше сказать про него особо нечего.

<h4>Методы множества</h4>
<ol>
<li> name_set.add(element)<br>
Добавляем element в name_set. Если element уже есть, то не добавится.
<li> name_set.remove(element)<br>
Удаляет element из множества. Если этого элемента нет в множестве, то возникнет ошибка.
<li> name_set.discard(element)<br>
Аналогично методу remove, только при удалении несуществующего элемента, ошибки не возникнет. 
<li> name_set.clear(element)<br>
Удалит все элементы множества.
</ol>






<h3 align=center><a name="typle" href="https://pyplanet.ru/article/tuple.html">Кортежи</a></h3>
Кортежи - почти как изученные нами ранее списки, за исключением того, что они неизменяемы.
<p>
Как создаётся кортеж?<br>
Кортеж создаётся способом, походим на то, каким создаются списки, только вместо квадратных скобок - круглые.
<pre>a = (1, 2, 3, 0, -1, 2)</pre>
Скобок может вообще не быть:
<pre>a = 1, 2, 3, 0, -1, 2</pre>
Пустой кортеж:
<pre>a = ()</pre>
А вот кортеж из одного элемента выглядит иначе:
<pre>a = (1, )</pre>
Здесь обязательна запятая, иначе Python не сможет отличить одноэлементный кортеж от просто числа.
<p>
Зачем нужен кортеж, если есть списки?
<ul>
<li> Кортежи занимают немного меньше памяти и работают чуть быстрее до тех пор, пока вы не собираетесь изменять его содержимое
<li> Кортежи лучше защищены от ненамеренного изменения данных
<li> Кортежи могут быть использованы в местах, требующих неизменяемый тип данных
<li> Некоторые функции работают только с кортежами
</ul>
С кортежами можно работать так же, как и со списками, кроме методов, изменяющих список (таких, как append, extend, pop, sort и 
др.). Также есть доступ по индексу, есть срезы (только срез кортежа вернёт кортеж, а не список). 






<h3 align=center><a name="diction" href="https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html">Словарь</a></h3>
<b>Словарь</b> (хэш, ассоциативный массив) - это изменчивая структура данных для хранения пар key-value, где value однозначно определяется ключом.<br>
В качестве ключа может выступать неизменчивый тип данных (число, строка, кортеж и т.п.).<br>
Порядок пар ключ-значение произволен (словарь не имеет индекса, вместо индекса ключ).<br>
value может быть строкой, числом, списком.<br>
Задается с помощью фигурных скобок (как множество):
<pre>
       var_dictionary={
                       key1:value1,
                       key2:value2,
                       key3:value3
                      }</pre>
Пример:
<pre>dictionary = {'dog' : 'собака', 'table' : 'стол', 'computer': 'компьютер'}</pre>
Мы можем обращаться к значениям словаря по ключу.
<pre>
print(dictionary['dog'])  # печатаем строку 'собака'
dictionary['dog'] = 'пес' # изменяем значение 'собака' на 'пес'
dictionary['laptop'] = 'ноутбук' # добавляем новый элемент с ключом 'laptop' и значением 'ноутбук' в словарь
del dictionary[dog]       # удаляется пара ключ-значение с данным ключом
</pre>
Словарь:
<pre>
dictionary = {
            'dog': 'собака', 'table': 'стол', 'computer': 'компьютер', 'apple': 'яблоко', 1: 'yyy', 0: ['qq', 'ww']}
</pre>
Цикл по всему словарю:
<pre>
<b>for key, val in dictionary.items():</b>   
    print(key, val)
</pre>
Выполнит:
<pre>
dog собака
table стол
computer компьютер
apple яблоко
1 yyy
0 ['qq', 'ww']
</pre>
<b>Цикл по ключам словаря:</b><pre>
for key in dictionary.keys():
   print(key, dictionary[key])
</pre>
Выполнит:
<pre>
dog собака
table стол
computer компьютер
apple яблоко
1 yyy
0 ['qq', 'ww']
</pre>
Можно и так: <b>for key in some_dict:</b>
<p>
<b>Цикл по значениям словаря:</b><pre>
for val in dictionary.values():
    print(val)<br>
собака
стол
компьютер
яблоко
yyy
['qq', 'ww']</pre>
<b>Пополняется словарь dictionary из другого diction2:</b><pre>
diction2={'orange':'мандарин'}
dictionary.update(diction2)
print(dictionary)</pre>
{'dog': 'собака', 'table': 'стол', 'computer': 'компьютер', 'apple': 'яблоко', 1: 'yyy', 0: ['qq', 'ww'], 'orange': 'мандарин'}<p>
<b>Получить одновременно и ключ и значение:</b><br>
for key, value in some_d.items():
<p>
<b>Количество пар в словаре:</b><br>
print(len(dictionary))
<p>
Если попытаемся получить значение в словаре по несуществующему ключу (dict[key]), то получим ошибку. Чтобы не возникало ошибки, используем метод get(key), который вернет объект None, если такого ключа нет.

        
        
        
<h3 align=center><a name="srez" href="https://pyplanet.ru/article/slice.html">Срезы массивов</a></h3>
Иногда необходимо выбрать подмножество массива: убрать первые или последние элементы, выбрать только чётные или нечётные элементы.
<p>
Конечно, можно проходить по списку с помощью цикла for, в этом цикле писать условия, и записывать нужный диапазон значений в новый массив. Однако в Python есть инструмент, с помощью которого это делать проще.
<p>
Этот инструмент называется срезы (slice).
<p>
<b>Синтаксис срезов:</b></br>
<pre>array[start:stop:step]</pre>
Похоже на взятие по индексу, но здесь у нас вместо одного - 3 целых числа. Начать с индекса start (включая его), закончить на индексе stop (не включая его), с шагом step.
<p>
Например, возьмём срез со второго по третий элемент с шагом 1:
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[1:3:1]
[4, 3]</pre>
Каждый из аргументов может быть опущен. Если опущен start, то он полагается равным нулю; stop - длине массива, step - единице. Срез совсем без аргументов вернёт просто копию массива:
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[:]
[1, 4, 3, 3, -2]</pre>
<b>Выбрать чётные и нечётные элементы:</b>
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[::2]
[1, 3, -2]
>>> array[1::2]
[4, 3]</pre>
Аргументы могут быть отрицательными: в случае со start и stop это будет означать нумерацию с конца массива; В случае со step элементы среза будут идти в обратном порядке:
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[::-1]
[-2, 3, 3, 4, 1]</pre>
И, поскольку срез списка возвращает список, его можно использовать: присваивать переменной, итерировать в цикле for или while, или любым другим необходимым программисту способом.





<h3 align=center><a href="">Форматирование строк</a></h3>
Иногда нужно напечатать строку, в которой присутствует пользовательский ввод. Например, напечатать "Привет, name", где name - это введённое пользователем имя.
<p>
Можно это сделать с помощью конкатенации строк, например:
<pre>
name = input("Как вас зовут?")
print("Привет, " + name)</pre>
Однако, если строки станут сложнее, и подстановок станет больше, то выражение, получающееся при применении всех сложений, будет слишком громоздким.<br>
Для облегчения подобных распространённых задач в Python существуют инструменты форматирования строк, аж целых 3.
<h4>Форматирование при помощи оператора %</h4>
Этот оператор форматирования - наследник форматирования строк из языка C, где были строковые подстановки. Если у нас один аргумент для подстановки, то через процент (так же, как и остаток от деления) пишется переменная для подстановки:
<pre>
name = input("Как вас зовут?")
print("Привет, %s" % name)</pre>
Если несколько переменных - то подставлять нужно кортеж (список не подойдёт!) значений.
<pre>
>>> print("Привет, %s, %d лет" % ("Вася", 35))
Привет, Вася, 35 лет</pre>
Спецификаторы преобразования (это те, что %s, %d и т.д.) записываются в следующем порядке:
<ol>
<li> %
<li> Ключ отображения (необязательно), состоящий из последовательности символов в круглых скобках (например, (somename))
<li> Флаги преобразования
<li> Минимальная ширина поля
<li> Точность, начинается с '.', затем - желаемая точность
<li> Модификатор длины (опционально)
<li> Тип преобразования
</ol>
Поясню каждый пункт подробнее.
<p>
2. Есть возможность подставить словарь значений
<pre>
>>> print("Привет, %(name)s, %(age)d лет" % {"name": "Вася", "age": 35})
Привет, Вася, 35 лет</pre>
3. Это флаги, отвечающие за особое отображение чисел. В примере ниже мы отображаем знак числа
<pre>
>>> print("Привет, %s, %+d лет" % ("Вася", 35))
Привет, Вася, +35 лет</pre>
4. Минимальная ширина поля полезна для выравнивания
<pre>
>>> print("Привет, %s, %3d лет" % ("Вася", 35))
Привет, Вася,  35 лет
>>> print("Привет, %s, %3d лет" % ("Вася", 100))
Привет, Вася, 100 лет</pre>
5. Позволяет более точно управлять дробными значениями
<pre>
>>> print("Привет, %s, %.2f лет" % ("Вася", 35 + 1/12))
Привет, Вася, 35.08 лет
>>> print("Привет, %s, %.4f лет" % ("Вася", 35 + 1/12))
Привет, Вася, 35.0833 лет</pre>
6. Это про числа. Наследие C, где можно писать %ld для чисел типа long int; в Python игнорируется
<p>
7. %s, %d - это так называемый тип преобразования (%s - строка, %d - целое число, %f - число с плавающей точкой)
<h4>Форматирование при помощи метода format</h4>
Вместо фигурных скобок в строку, к которой был применён метод format, подставляются значения аргументов
<pre>
>>> print("Привет, {}, {} лет".format("Вася", 35))
Привет, Вася, 35 лет</pre>
Можно внутри фигурных скобок указывать номер аргумента:
<pre>
>>> print("Привет, {1} лет, {0}".format("Вася", 35))
Привет, 35 лет, Вася</pre>
Можно указывать именованные аргументы:
<pre>
>>> print("Привет, {name}, {age} лет".format(name="Вася", age=35))
Привет, Вася, 35 лет</pre>
Можно комбинировать номера и имена:
<pre>
>>> print("Привет, {}, {age} лет".format("Вася", age=35))
Привет, Вася, 35 лет</pre>
Полную спецификацию метода format можно посмотреть <a href="https://docs.python.org/3/library/string.html#formatstrings">здесь (англ.)</a>, но в целом там не очень много различий с оператором %, только все флаги записываются после двоеточия:
<pre>
>>> print("Привет, {:10}, {age:.2f} лет".format("Вася", age=35.0833))
Привет, Вася      , 35.08 лет</pre>
И можно внутри выражения обращаться по индексу
<pre>
>>> print("Привет, {}, {age[0]} лет, {age[1]} месяц(ев)".format("Вася", age=(35, 1)))
Привет, Вася, 35 лет, 1 месяц(ев)</pre>
<h4>f-строки</h4>
В Python версии 3.6 появился новый способ форматирования строк, а именно f-строки.
<p>
Почему f? Из-за способа задания. Как "сырые" строки задаются буквой r в начале, так f-строки задаются буквой f.
<pre>s = f"Это f-строка"</pre>
Значения в f-строку подставляются прямо в строке, в фигурных скобках. В качестве подстановки выступает выражение, внутри можно выполнить некоторый код.
<p>
Также после двоеточия можно записать флаги-модификаторы, как и в format:
<pre>
name = "вася"
age = 35
months = 1
print(f"Привет, {name.title()}, {age} лет, {months} месяц(ев), всего {age + months / 12:.2f} лет")
# Привет, Вася, 35 лет, 1 месяц(ев), всего 35.08 лет</pre>







<h3 align=center><a href="https://pyplanet.ru/article/unpacking.html">Распаковка элементов</a></h3>
Допустим, есть задача: обменять значения двух переменных. Например, a = 5, b = 10. Нам нужно, чтобы стало a = 10, b = 5.
<p>
Можно это сделать через введение временной переменной:
<pre>
a = 5
b = 10

tmp = a
a = b
b = tmp</pre>
А можно воспользоваться инструментом распаковки элементов кортежа / списка. Но для начала о том, что это вообще такое. А это, по сути, операция, обратная созданию кортежа / списка. Мы "распаковываем" кортеж в переменные:
<pre>
a = (1, 2, 3)
(variable_1, variable_2, variable_3) = a</pre>
Так кортеж из трёх элементов теперь "записан" в 3 переменные, с каждой из которых можно работать отдельно.
<p>
Как и при создании кортежа, скобки необязательны:
<pre>
a = (1, 2, 3)
variable_1, variable_2, variable_3 = a</pre>
Так как же можно решить задачу из начала статьи? Очень просто: создадим кортеж со значениями (a, b), и распакуем его в обратном порядке:
<pre>
a = 5
b = 10
(a, b) = (b, a)</pre>
Или, можно без скобок:
<pre>
a = 5
b = 10
a, b = b, a</pre>
<h4>Расширенная распаковка</h4>
Иногда из всего кортежа нам нужен 1-2 элемента; или наоборот, 1-2 элемента нам как раз не нужны.
<p>
В Python для подобных случаев имеется расширенная распаковка: Если поставить перед одной из переменных звёздочку, то ей присвоятся все оставшиеся значения:
<pre>
>>> a = 1, 2, 3, 4
>>> first, *rest = a
>>> print(first)
1
>>> print(rest)
[2, 3, 4]</pre>
<h4>Распаковка в цикле</h4>
Рассмотрим более сложный случай: у нас есть список людей, с полями (фамилия, имя, возраст, рост, вес). И нам нужно вывести только фамилию и возраст.
<pre>
people = [
    ("Иванов", "Иван", 35, 180, 85),
    ("Петров", "Петр", 27, 190, 74),
    ("Сидоров", "Петр", 19, 175, 68),
    ("Иванова", "Анастасия", 42, 172, 75),
]
for surname, name, age, height, weight in people:
    print(surname, age)</pre>
Что происходит во время выполнения кода? В цикле for мы проходимся по элементам списка people. А каждый элемент - это кортеж. Можно его присвоить переменной и распаковать уже внутри блока цикла, однако можно это сделать прямо на месте; и получить, таким образом, 5 переменных на каждой итерации цикла.
<p>
Поскольку после возраста остальные поля нам не нужны, можно также воспользоваться расширенной распаковкой:
<pre>
for surname, name, age, *rest in people:
    print(surname, age)</pre>





<h3 align=center><a name="if" href="https://pyplanet.ru/article/if.html">Инструкция if-elif-else</a></h3>
<h4>Синтаксис инструкции if</h4>
Сначала записывается часть if с условным выражением, далее могут следовать одна или более необязательных частей elif, и, наконец, необязательная часть else. Общая форма записи условной инструкции if выглядит следующим образом:
<pre>
if test1:
    state1
elif test2:
    state2
else:
    state3</pre>
Пример:
<pre>
a = int(input())
if a < -5:
    print('Low')
elif -5 <= a <= 5:
    print('Mid')
else:
    print('High')</pre>
    
<h4>Проверка истинности в Python</h4>
<ul>
<li> Любое число, не равное 0, или непустой объект - истина.
<li> Числа, равные 0, пустые объекты и значение None - ложь
<li> Операции сравнения применяются к структурам данных рекурсивно
<li> Операции сравнения возвращают True или False
<li> Логические операторы and и or возвращают истинный или ложный объект-операнд
</ul>   
<h4>Проверки на равенство</h4>
После слова if идёт условие. И только если оно истинное, выполняется блок с отступом от if. Условия могут проверяться самые разные; многие из них задаются операторами.
<ul>
<li> == - проверка на равенство (условие верно, если выражение слева равно выражению справа)
<li> != - проверка на неравенство (условие верно, если выражение слева не равно выражению справа)
<li> > - условие верно, если выражение слева больше выражения справа
<li> >= - условие верно, если выражение слева больше, либо равно выражению справа
<li> < - условие верно, если выражение слева меньше выражения справа
<li> <= - условие верно, если выражение слева меньше, либо равно выражению справа
</ul>
Вообще, условие может быть любым, необязательно сравнение. Например,
<pre>
say = input()
if say:
    print("Ох, вы что-то сказали? Жалко, я не смогу это понять")
else:
    print("Не хотите разговаривать? Ну и ладно")</pre>
Здесь условием выступает просто переменная say. Условие истинно, если строка непустая, и ложно, если она пустая. Истинно также любое отличное от нуля число, и любой непустой объект (например, непустая строка).

<h4>Логические операторы</h4>
Иногда есть необходимость в сложных условиях. Например, если число больше нуля, но не равно 42. Такие условия помогают задавать логические операторы:
<ul>
<li> and - логическое И
<li> or - логическое ИЛИ
<li> not - логическое НЕ
</ul>
Задача выше имеет такое решение:
<pre>
a = 33
if a > 0 and a != 42:
    print("YES")</pre>
Частая ошибка с логическими операторами: допустим, нам надо проверить, что переменная либо 0, либо 42. Некоторые пишут ошибочное решение
<pre>
a = 33
if a == 0 or 42: # Это ОШИБКА, так условие составлять НЕЛЬЗЯ!
    print("YES")</pre>
Здесь условие эквивалентно (a == 0) or (42), и, если первое условие иногда истинно, то второе условие (42) истинно всегда, потому что это отличное от нуля число. Правильно писать так:
<pre>
a = 33
if a == 0 or a == 42:
    print("YES")</pre>
Выражения слева и справа логических операторов выполняются "лениво". Это значит, что, например, если есть условие A or B, и A истинно, то B вычислено не будет. Это может быть важно, если выражение B имеет внешние эффекты (например, там функция input, ожидающая ввода, и она иногда не будет вызвана как раз из-за такого эффекта).
<h4>Приоритет логических операторов</h4>
<ul>
<li> Все арифметические
<li> Все операторы сравнения
<li> not
<li> and
<li> or
</ul>
<pre>
a = 33
if not a == 0 or a == 42:
    # a не 0, или a равно 42; часть с 42 можно убрать
    print("YES")

if not (a == 0 or a == 42):
    # a не 0, и не 42
    print("YES")</pre>
Отличие этих двух if в том, что, если a равно 42, то первый выведет YES, а второй - не выведет. Приоритет операции можно поднять скобками там, где нужно.


<h3 align=center><a href="https://pyplanet.ru/article/switch-case.html">Множественный условный оператор Switch - case</a></h3>
Допустим, мы хотим написать простейшую систему вопрос - ответ. У нас есть заранее известный список потенциальных вопросов и ответов на них.
<p>
Безусловно, можно решить эту задачу, используя конструкцию if-elif-else, но появилась несколько более удобная конструкция для решения подобных задач.<br>
Решение с помощью if-elif-else:
<pre>
question = input()
if question == "Привет?":
    print("Привет!")
elif question == "Что ты знаешь?":
    print("Что-то, да знаю")
elif question == "Как дела?":
    print("Хорошо!")
elif question == "Что делаешь?":
    print("Отвечаю на вопросы кожаных мешков")
elif question == "Кто ты?":
    print("Я - компьютерная программа, написанная на Python")
elif question == "В чем смысл жизни?":
    print("42")
else:
    print("Вопрос непонятен")</pre>
Это достаточно элегантный способ решения, однако эту же задачу можно решить с помощью сравнительно недавно появившегося в Python выражении match - case (на данном этапе обучения считайте его аналогом switch - case из других языков программирования).
<pre>
question = input()
match question:
    case "Привет?":
        print("Привет!")
    case "Что ты знаешь?":
        print("Что-то, да знаю")
    case "Как дела?":
        print("Хорошо!")
    case "Что делаешь?":
        print("Отвечаю на вопросы кожаных мешков")
    case "Кто ты?":
        print("Я - компьютерная программа, написанная на Python")
    case "В чем смысл жизни?":
        print("42")
    case _:
        print("Вопрос непонятен")</pre>
Данный синтаксис появился только в Python 3.10, если у вас более ранняя версия - пример работать не будет, и вы можете смело переходить к следующей лекции.<br>
Здесь match (аналог switch в других языках) - принимает выражение, которое затем сопоставляется с шаблонами в блоках case.
<p>
case _ здесь - аналог слова default в других языках программирования
<p>
Почему match, а не switch<br>
Потому что это не обычный switch-case, это конструкция сопоставления шаблонов.
<p>
В простейшем случае, как в примере выше - оператор имеет поведение такое же, как и switch - case в других языках.
<p>
На самом деле, выражение match - case гораздо мощнее, но с остальными его фишками мы познакомимся позже.
<p>
И case _ тоже не совсем аналог слова default, об этом тоже позже.



<h3 align=center><a name="while" href="https://pyplanet.ru/article/while.html">Цикл while</a></h3>
Синтаксис while:
<pre>
while УСЛОВИЕ:
    ТЕЛО_ЦИКЛА</pre>
Выполняет тело цикла до тех пор, пока условие цикла истинно. Что означает УСЛОВИЕ? Да ровно то же самое, что и у оператора if, без каких-либо дополнительных ограничений.
<p>
ТЕЛО_ЦИКЛА - это блок кода (одна, или несколько, или много строк кода, другие, вложенные блоки, и т.д.)
<p>
Пример: Напишите программу, которая считывает целые числа с консоли по одному числу в строке.
<br>Для каждого введённого числа проверить:
<br>если число меньше 10, то пропускаем это число;
<br>если число больше 100, то прекращаем считывать числа;
<br>в остальных случаях вывести это число обратно на консоль в отдельной строке.
<pre>
while <b>True</b>:
    number = int(input())
    if number >100:
        break
    if number <10:
        continue
    print(number)</pre>
Второе решение:
<pre>
a = 0
while a <= 100:
    a = int(input())
    if 10 <= a <= 100:
        print(a)</pre>
        
Напишите программу, которая считывает с клавиатуры два числа a и b, считает и выводит на консоль среднее арифметическое всех чисел из отрезка [a;b], которые кратны числу 3. 
<pre>
<b>a, b = int(input()), int(input())</b>

sm = 0;
n = 0;

for i in range(a, b + 1):
    if i % 3 == 0:
        sm += i
        n += 1

print(sm / n)</pre>


        

<h3 align=center><a href="https://pyplanet.ru/article/break-continue.html">Операторы break и continue, слово else в циклах</a></h3>
<h4>Оператор break</h4>
Оператор break досрочно прерывает цикл.
<br>Пример:
<pre>
>>> for i in 'hello world':
...     if i == 'o':
...         break
...     print(i * 2, end='')
...
hheellll</pre>

<h4>Оператор continue</h4>
Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)<br>
Пример:
<pre>
>>> for i in 'hello world':
...     if i == 'o':
...         continue
...     print(i * 2, end='')
...
hheellll  wwrrlldd</pre>

<h4>While - else</h4>
Слово else, примененное в цикле for или while, проверяет, был ли произведен выход из цикла инструкцией break, или же "естественным" образом. Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.
<br>Пример:
<pre>
>>> for i in 'hello world':
...     if i == 'a':
...         break
... else:
...     print('Буквы a в строке нет')
...
Буквы a в строке нет</pre>
<p>
Слово else под циклом не имеет ничего общего с выражением if - else! То, к какому блоку относится else, указывается уровнем отступа.


<h3 align=center><a name="for" href="https://pyplanet.ru/article/for.html">Цикл for</a></h3>
Синтаксис цикла for:
<pre>for element in array:
    тело цикла</pre>
array - это объект, поддерживающий протокол итерирования.
<br>in - ключевое слово, которое в данном контексте обозначает примерно "все элементы из array".
<br>element - переменная, куда будет помещено значение элемента массива на каждой итерации. И да, каждую итерацию это будет следующий элемент последовательности, не нужно увеличивать никакой счётчик, как в цикле while (или как в языке Pascal).
<p>
Не следует изменять array внутри самого цикла! Это может привести к непредсказуемым результатам работы программы.
Внутри цикла for, как и внутри цикла while, можно использовать break, continue. Также есть возможность использовать блок else.
<p>
Например, дана задача: вывести первое положительные число в массиве, или написать, что положительных чисел нет.
<pre>
array = [0, -3, -5, 4, -2, -3, 5, 6, 1]
for element in array:
    if element > 0:
        print(element)
        break
else:
    print("Положительных чисел нет")
</pre>
Другой пример.<br>
Напишите программу, на вход которой даются четыре числа a, b, c и d, каждое в своей строке. Программа должна вывести фрагмент 
таблицы умножения для всех чисел отрезка. Мое решение:
<pre>
a = int(input())
b = int(input())+1
c = int(input())
d = int(input()) + 1
for y in range(c,d):
    # формируем шапку
    print('\t',y,end='')
for i in range(a,b):
    print()    
    print(i,end='')
    for y in range(c,d):
        print('\t',i*y,end='')
print()</pre>
<img src="./images/python_base3.png">
<p>
Другое решение:
<pre>
a, b, c, d = int(input()), int(input()), int(input()), int(input())

for i in range(c, d + 1):
    print("\t" + str(i), end="")

print()

for i in range(a, b + 1):
    print(i, end="\t")
    for n in range(c, d + 1):
        print(i * n, end="\t")
    print()
</pre>

<font color=red>Разбор моих ошибок с for:</font>
<pre>
#!/usr/bin/env python3 
num = input().split()
s = 0
i = 0
for i in len(num):
    s = s + int(i)
print(s)
<font color=red>for i in len(num):
TypeError: 'int' object is not iterable</font></pre>
<i>Оператором in можно перебрать элементы в какой-нибудь последовательности, которую можно перебирать - итерировать.
Например - список, кортеж. А Вы пытаетесь применить его к единственному числу - len(s). Вот оно и пишет, что целое число неперебираемо.</i>





<h3 align=center><a name="def">Функции, директивы def, return</h3>
Ссылки: <a href="https://pyplanet.ru/article/def-return.html">Функции, директивы def, return</a><br>
<a href="https://pythonworld.ru/tipy-dannyx-v-python/vse-o-funkciyax-i-ix-argumentax.html">Функции и их аргументы</a>
<p>
Часто некоторый код нужно выполнить несколько раз. Либо мы хотим как-то изолировать некоторый код, и вызывать его в необходимом месте.<br>
Этого можно достичь написанием функции.
<p>
Функция в python - объект, принимающий аргументы и возвращающий значение. Обычная функция определяется с помощью инструкции def. Второй способ с помощью lambda.
<p>
Синтаксис:
<pre>
def name_f(arg1, arg2,...):
    return command</pre>
После инструкции def идёт <b>имя функции</b>. Можно воспринимать это как присвоение переменной.<br>
Затем, в скобках, пишутся <b>аргументы</b> (или иногда говорят параметры) функции.<br>
Эти аргументы не имеют никакого отношения к переменным, которые будут в главной программе. То есть, можно вызывать функцию, 
называя извне аргументы не x и y, а по-другому:
<pre>
a = 1
b = 2
add(a, b)</pre>
Аргументов у Вашей функции может быть сколько угодно (или не быть вовсе).
<br>Если перед аргументом стоит <b>звездочка (*)</b>, то это значит что функция может принимать произвольное количество аргументов. <i>По соглашению между программистами в Python  в функции  c произвольным количеством принимающих параметров принято писать *args вместо *(с каким либо другим названием переменной).</i>
<br>
В следующей строке с отступом идет <b>тело функции</b>.<br>
Инструкция return говорит, что нужно вернуть значение. В нашем случае функция возвращает сумму x и y.
<p>
Внутри функции может быть какой угодно код, но, если мы хотим вернуть значение, мы обязаны написать return ЧТО_ТО. Если этого не написать, то функция вернёт специальное значение None (некоторый аналог NULL из других языков программирования).
<p>
Код после достижения return внутри функции не выполняется.
<p>
Внутри программы функция может быть вызвана. Например:
<pre>
def add(x, y):
    return x + y

print(add(1, 2))  # Выведет 3</pre>
<h4>Значения по умолчанию</h4>
Аргументы можно инициализировать значениями по умолчанию:
<pre>
def add(x, y=0):
    return x + y</pre>
Тогда, если мы вызовем функцию add(1), то выведется 1, так как внутри функции x = 1, y = 0
<h4>Именованные аргументы</h4>
Функцию можно также вызвать с аргументами по их имени, а не позиции, например:
<pre>
def add(x, y):
    return x + y

print(add(x=1, y=2))  # Выведет 3
print(add(y=1, x=2))  # Выведет 3</pre>
Однако по имени можно передавать только последние аргументы. То есть, можно вызвать add(1, y=2), add(1, 2), add(x=1, y=2), но нельзя add(2, x=1).

<h4>Локальные и глобальные переменные</h4>
Переменные, объявленные внутри функции, являются локальными. Если их использовать за пределами выполнения функции, то произойдет шибка.
<p>
Глобальные переменные - это переменные объявленные вне функции.






<h3 align=center><a href="https://intuit.ru/studies/courses/49/49/lecture/27060?page=2">Встроенные функции</a></h3>
В среде Python без дополнительных операций импорта доступно более сотни встроенных объектов, в основном, функций и исключений. Для удобства функции условно разделены по категориям:<p>
<ul>

<li> <a href="https://pythonworld.ru/osnovy/vstroennye-funkcii.html">Функции преобразования типов и классы</a>: coerce, str, repr, int, list, tuple, long, float, complex, dict, super, file, bool, object<p>
<li> Числовые и строковые функции: abs, divmod, ord, pow, len, chr, unichr, hex, oct, cmp, round, unicode
<p>
abs(x)	Модуль числа x. Результат: |x|.
<p>
divmod(x, y)	Частное и остаток от деления. Результат: (частное, остаток).
<p>
pow(x, y[, m])	Возведение x в степень y по модулю m. Результат: x**y % m.
<p>
round(n[, z])	Округление чисел до заданного знака после (или до) точки.
<p>
ord(s)	Функция возвращает код (или Unicode) заданного ей символа в односимвольной строке.
<p>
chr(n)	Возвращает строку с символом с заданным кодом.
<p>
len(s)	Возвращает число элементов последовательности или отображения.
<p>
oct(n), hex(n)	Функции возвращают строку с восьмеричным или шестнадцатеричным представлением целого числа n.
<p>
cmp(x, y)	Сравнение двух значений. Результат: отрицательный, ноль или положительный, в зависимости от результата сравнения.
<p>
unichr(n)	Возвращает односимвольную Unicode-строку с символом с кодом n.
<p>

<li> <a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=4">Функции обработки данных: apply, map, filter, reduce, zip, range, xrange, max, min, iter, enumerate, sum</a><br>
<a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=5">Списковые включения</a><br>
<a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=6">Итераторы</a>



<h3 align=center><a name="range">Функция range</a></h3>
Функция range обычно применяется в цикле и позволяет перебрать какой-нибудь объект типа список по его индексу.
<pre>
for index range(len(spisok):
    print spisok(index)</pre>
функция range принимает от одного до трех аргументов. Если аргумент всего один, она генерирует список чисел от 0 (включительно) до заданного числа (исключительно).<br>
Если аргументов два, то список начинается с числа, указанного первым аргументом.<br>
Если аргументов три - третий аргумент задает шаг
<pre>
>>> print range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10, 3)
[1, 4, 7]</pre>
Третий аргумент может быть и отрицательным:
<pre>
>>> for i in range(10, 5, -1):
...     print(i)</pre>
Получим 10, 9, 8, 7, 6

<p>
Функция <b>xrange()</b> - аналог range(), более предпочтительный для использования при последовательном доступе, например, в цикле for или с итераторами. Она возвращает специальный xrange -объект, который ведет себя почти как список, порождаемый range(), но не хранит в памяти все выдаваемые элементы.
<p>
<li> Функции определения свойств: hash, id, callable, issubclass, isinstance, type
<p>
<li> Функции для доступа к внутренним структурам: locals, globals, vars, intern, dir
<p>
<li> Функции компиляции и исполнения: eval, execfile, reload, __import__, compile
<p>
<li> Функции ввода-вывода: input, raw_input, open<p>
<li> Функции для работы с атрибутами: getattr, setattr, delattr, hasattr
<p>
<li> Функции-"украшатели" методов классов: staticmethod, classmethod, property
<p>
<li> Прочие функции: buffer, slice
</ul>

<h4>Функции как параметры и результат</h4>
функции являются такими же объектами Python как числа, строки или списки. Это означает, что их можно передавать в качестве параметров функций или возвращать из функций.
<p>
Функции, принимающие в качестве аргументов или возвращающие другие функции в результате, называют функциями высшего порядка. В Python функции высшего порядка применяются программистами достаточно часто. В большинстве случаев таким образом строится механизм обратных вызовов (callbacks), но встречаются и другие варианты. Например, алгоритм поиска может вызывать переданную ему функцию для каждого найденного объекта.





<h3><a href="https://pyplanet.ru/article/lambda.html">Анонимные lambda-функции</a></h3>
<h3><a href="https://pyplanet.ru/article/args-kwargs.html">Функции с переменным числом аргументов; args, kwargs</a></h3>
<h3><a href="https://pyplanet.ru/article/scopes-global-nonlocal.html">Области видимости; инструкции global, nonlocal</a></h3>
<h3><a href="https://pyplanet.ru/article/try-except.html">Конструкция try - except для обработки исключений</a></h3>





<h3 align=center><a name="file" href="https://pyplanet.ru/article/files.html">Работа с файлами: чтение, запись, редактирование</a></h3>
В Python, как и в других языках программирования, можно работать с файлами: читать из файла и писать в файл. Это позволяет легко манипулировать любыми файлами из Python.
<p>
Файловые объекты должны поддерживать основные методы: read(), write(), readline(), readlines(), seek(), tell(), close() и т.п.
<p>
Прежде, чем работать с файлом, его надо открыть. Открыть файл можно с помощью встроенной функции open:
<pre>
f = open('pyplanet.txt', 'r', encoding='utf-8')</pre>
У функции open много параметров, нам пока важны 3 аргумента.
<p>
Первый, это путь к файлу. Путь к файлу может быть относительным или абсолютным.
<p>
В случае относительного пути поиск файла будет производиться относительно директории, из которой была запущена программа на Python. Как правило, это та папка, в которой находится сама программа.
<p>
Поэтому, чтобы приведённый выше код выполнился, необходимо создать файл pyplanet.txt в той же папке, что и программа, которую вы пишете.
<p>
Однако можно задать и абсолютный путь, например,
<pre>
f = open(r'D:\files\pyplanet.txt', 'r', encoding='utf-8')</pre>
Второй аргумент, это режим, в котором мы будем открывать файл.
<p>
<img src="./images/python_base1.png">
<p>
Режимы могут (и должны) быть объединены, то есть, к примеру, 'rb' - чтение в двоичном режиме. По умолчанию режим равен 'rt'.
<p>
И последний аргумент, encoding, нужен только в текстовом режиме чтения файла. Этот аргумент задает кодировку.
<p>
Какая кодировка идёт по умолчанию? А неизвестно. Начиная с Python версии 3.15 (это примерно к 2026 году) кодировкой по умолчанию станет utf-8.
<p>
В какой же кодировке Ваш файл, зависит от редактора, в котором вы создавали / редактировали файл.
<p>
Как правило, это utf-8, или, в более редких случаях, windows-1251.
<p>
Функция open возвращает объект файла (или по-другому файлового дескриптора).
<h4>Чтение из файла</h4>
Файл мы открыли, а теперь хотим прочитать из него информацию. Для этого есть несколько способов.
<p>
<b>Метод read</b><br>
Метод read файла, читает весь файл целиком, если был вызван без аргументов, и n символов, если был вызван с аргументом (целым числом n).
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> f.read(1)
'H'
>>> f.read()
'ello world!\nThe end.\n\n'</pre>
Каждый последующий вызов read продолжит читать с того места, на котором остановилось чтение.
<h4>Цикл for для чтения файла</h4>
Ещё один прочитать файл - сделать это построчно, воспользовавшись циклом for. Файловый объект в Python - тоже итерируемый объект, и в цикле for он возвращает содержимое файла построчно.
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> for line in f:
...     line
...
'Hello world!\n'
'\n'
'The end.\n'
'\n'</pre>
<h4>readlines</h4>
Метод readlines файла, читает весь файл целиком, и возвращает список всех строк в нём. Этот способ более затратный по памяти, чем цикл for, однако иногда тоже может использоваться.
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> f.readlines()
['Hello world!\n', '\n', 'The end.\n', '\n']</pre>
<h4>Закрытие файла</h4>
После манипуляций с файлом, его необходимо закрыть, таким образом, освободив ресурсы файлового дескриптора.
<pre>f.close()</pre>
Все дескрипторы, конечно, будут освобождены автоматически при выходе из программы, но что, если программа работает долго? Или она открывает много файлов?
<p>
Количество одновременно открытых файлов в системе ограничено.
<p>
Здесь очень сильно может помочь конструкция try - finally, так как при возникновении и перехвате исключения можно забыть закрыть файл:
<pre>
f = open('pyplanet.txt', 'r', encoding='utf-8')
try:
    for line in f:
        do_something(line)
finally:
    f.close()</pre>
<h4>Запись в файл</h4>
Как что-либо записать в файл?
<p>
Во-первых, необходимо открыть файл в режиме "для записи", иначе ничего не получится:
<pre>f = open('pyplanet_output.txt', 'w', encoding='utf-8')</pre>
<ol>
<li> <b>Метод write</b><br>
Метод write, записывает строку в файл:
<pre>f.write("Hello pyplanet!\n")</pre>
Метод write возвращает количество записанных символов. Не пугайтесь, если в интерактивном режиме увидите цифры - это они и есть.<br>
Перенос строки не добавляется автоматически. Не забывайте добавлять его вручную, иначе строки "слипнутся".
<p>
<img src="./images/python_base6.png"><br>
На рисунке показаы 2 способа записи в файл. Число не записывается напрямую, сначало нужно с помощью функции str() преобразовать число в строку.
<p>
<li> <b>Аргумент file функции print</b><br>
Функция print может принимать в качестве аргумента файловый дескриптор для печати.
<p>
Из плюсов - символ переноса строки поставится за вас:
<pre>print("Hello pyplanet!", file=f)</pre>
<p>
<li> <b>Метод writelines</b><br>
Метод writelines, записывает список строк в файл:
<pre>f.writelines(["1\n", "2\n", "3\n"])</pre>
Перенос строки, как и в методе write, не добавляется автоматически. Не забывайте добавлять его вручную, иначе строки "слипнутся".<br>
Для записи более сложных структур в Python есть такие средства, как pickle, json, csv, и многие другие.
<p>
Примеры:<br>
Следующий пример показывает копирование файла:
<pre>
f1 = open("file1.txt", "r")
f2 = open("file2.txt", "w")
for line in f1.readlines():
  f2.write(line)
f2.close()
f1.close()
</pre>

<li> Стоит заметить, что кроме собственно файлов в Python используются и файлоподобные объекты. В очень многих функциях просто 
неважно, передан ли ей объект типа file или другого типа, если он имеет все те же методы (и в том же смысле). Например, 
копирование содержимого по ссылке (URL) в файл file2.txt можно достигнуть, если заменить первую строку из предыдущего примера 
на:
<pre>
import urllib
f1 = urllib.urlopen("http://python.onego.ru")</pre>

<li> <b>with open() as var</b><br>
Открыть файл, выполнить с ним нужные операции и автоматически закрыть его после можно с помощью конструкции:
<pre>
with open('name_file') as var
    s1 = var.readline()
    s2 = var.readline()</pre>
По выполнении блока, файловый дескриптор будет удален (файл закроется).
<li> <b>Полезные методы файлов</b>
<ol>
<li> strip()<br>
Удаляет служебные символы при чтении строк файла.
<li> os.path.join(arg1, arg2,...)<br>
Создает из склеивания аргументов полный путь к файлу.<br>
Для того чтобы выполнить этот метод, нужно импортировать модуль os (import as).
<p>
<img src="./images/python_base5.png">
</ol>
<li> <b>Пример построчного чтения файла</b>
<pre>with open('input.txt') as inf:
  for line in inf:
      line = line.strip()
      print()</pre>
</ol>


<h3 align=center><a name="modul" href="https://pyplanet.ru/article/import.html">Импорт и создание модулей</a></h3>
<b>Модулем</b> в Python называется любой файл с программой.
<p>
Каждая программа может подключить модуль и получить доступ к его классам, функциям и объектам.
<p>
Модуль может быть написан не только на Python, но и, например, на C или C++.
<p>
К примеру, модуль math написан как раз на C и имеет интерфейс для вызова из Python.
<p>
В языке Python набор модулей, посвященных одной проблеме, можно поместить в <b>пакет</b>. Хорошим примером такого пакета является пакет xml, в котором собраны модули для различных аспектов обработки XML.
<p>
В программе на Python модуль представлен объектом-модулем, атрибутами которого являются имена, определенные в модуле:
<pre>
>>> import datetime
>>> d1 = datetime.date(2004, 11, 20)</pre>
В данном примере импортируется модуль datetime. В результате работы оператора import в текущем пространстве имен появляется объект с именем datetime.
<p>
Модули для использования в программах на языке Python по своему происхождению делятся на обычные (написанные на Python) и модули расширения, написанные на другом языке программирования (как правило, на C). С точки зрения пользователя они могут отличаться разве что быстродействием. Бывает, что в стандартной библиотеке есть два варианта модуля: на Python и на C. Таковы, например, модули pickle и cPickle. Обычно модули на Python в чем-то гибче, чем модули расширения.
<p>
Модуль оформляется в виде отдельного файла с исходным кодом. Стандартные модули находятся в каталоге, где их может найти соответствующий интерпретатор языка.<br>
При импорте модуля интерпретатор Python пытается найти модуль в следующих местах:
<ul>
<li> Директория, где находится файл, в котором вызывается команда импорта.

<li> Директория, определённая в консольной переменной PYTHONPATH (если модуль не найден с первого раза).

<li> Путь, заданный по умолчанию (если модуль не найден в предыдущих двух случаях).
</ul>
Путь поиска сохраняется в переменной path в системном модуле sys. Переменная sys.path включает в себя все три вышеописанных места поиска.<br>
<img src="./images/python_base2.png">
<p>
Чтобы получить полный список модулей, установленных на ПК, используют команду help("modules") или по конкретному модулю атрибуты: help("name_modul")


<p>
Чтобы получить доступ к функциям из модуля, его необходимо импортировать. Сделать это можно несколькими способами:
<h4>Инструкция import</h4>
После ключевого слова import указывается название модуля.<br>
Название модуля - это имя файла без расширения.
<p>
Одной инструкцией можно подключить несколько модулей (для этого они указываются через запятую), хотя это не рекомендуется делать, так как снижает читаемость кода. Импортируем модуль math:
<pre>import math</pre>
После импортирования модуля его название становится переменной, через которую можно получить доступ к атрибутам (функциям) 
модуля. Например чтобы вычислить синус числа импортируем сначало модуль (математическую библиотеку) math и после этого можем использовать его функцию sin:
<pre>
>>> import math
>>> math.sin(1)
0.8414709848078965</pre>
Стоит отметить, что если указанный атрибут модуля не будет найден, возникнет исключение AttributeError. А если не удастся найти модуль для импортирования, то ModuleNotFoundError.

<h4>Использование псевдонимов</h4>
Если название модуля слишком длинное, или оно вам не нравится по каким-то другим причинам, то для него можно создать псевдоним, с помощью ключевого слова as.
<pre>
>>> import math as m
>>> m.sin(1)
0.8414709848078965</pre>
Теперь доступ ко всем атрибутам модуля math осуществляется только с помощью переменной m, а переменной math в этой программе уже не будет (если, конечно, вы после этого не напишете import math, тогда модуль будет доступен как под именем m, так и под именем math).
<h4>Инструкция from ... import ...</h4>
Подключить только определенные атрибуты (функции) модуля, а не полностью весь модуль можно с помощью инструкции from:
<pre><b>from &lt;Название модуля&gt; import &lt;Атрибут 1&gt; [ as &lt;Псевдоним 1&gt; ], [&lt;Атрибут 2&gt; [ as &lt;Псевдоним 2&gt; ] ...]</b></pre>
Эта инструкция позволяет подключить из модуля только указанные вами атрибуты. При этом сам модуль не записывается в переменную, а в глобальную область видимости добавляются те функции и объекты, которые вы импортировали. Для длинных имён также можно назначить псевдоним, указав его после ключевого слова as.
<pre>
>>> from math import sin, ceil as c
>>> sin(1)
0.8414709848078965
>>> c(4.6)
5</pre>
Импортируемые атрибуты можно разместить на нескольких строках, если их много, для лучшей читаемости кода:
<pre>
from math import (
    sin, cos,
    tan, atan
)</pre></pre>
<h4>Инструкция from ... import *</h4>
Второй формат инструкции from позволяет подключить все (точнее, почти все) переменные из модуля.
<p>
Данным способом импортируются только атрибуты, определённые в переменной __all__ у модуля (если создатель модуля об этом побеспокоился). Или только те атрибуты, которые не начинаются с _ (это соглашение о "скрытых" переменных, его мы рассмотрим в дальнейших лекциях).
<pre>from math import *</pre>
С данным способом нужно быть крайне аккуратным. Имена в модуле, совпадающие с именами в главной программе, во время импорта инструкцией from будут перезаписаны (и наоборот, переменные в главной программе будут перезаписывать функции с такими же названиями из импортированного модуля). И в целом, забивать пространство имён - не самая удачная идея.
<h4>Создание своего модуля на Python</h4>
Теперь пришло время создать свой модуль. Это можно сделать, просто создав файл с программой, например, назовём его mymodule.py, в котором определим какую-нибудь функцию:
<pre>
def hello():
    print('Hello, world!')</pre>
Теперь в этой же папке создадим другой файл, например, main.py:
<pre>
import mymodule

mymodule.hello()</pre>
Выведет Hello, world!.
<p>
Иии... это всё! Вы сделали свой модуль! В конце отвечу на несколько вопросов, связанных с созданием модулей.
<p>
Можно ли использовать модуль как самостоятельную программу?<br>
Можно. Однако следует помнить, что при импортировании модуля его код выполняется полностью, то есть, если программа что-то печатает, то при её импортировании это будет напечатано.
<p>
Подобного эффекта можно избежать, если проверять, запущен ли скрипт как программа, или импортирован. Это можно сделать с помощью магической переменной __name__, которая определена в любой программе, и равна "__main__", если скрипт запущен в качестве главной программы, и имя модуля, если он импортирован. Например, mymodule.py может выглядеть вот так:
<pre>
def hello():
    print('Hello, world!')

if __name__ == "__main__":
    hello()</pre>
<b>Как назвать модуль?</b><br>
Помните, что вы (или другие люди) будут его импортировать и использовать в качестве переменной.
<p>
Модуль нельзя именовать так же, как и ключевое слово:
<pre>
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield</pre>
Имена модулей нельзя начинать с цифры
<p>
Не нужно называть модуль также, как какую-либо из встроенных функций. Технически так сделать, конечно, можно, но это создаст большие неудобства при его последующем использовании
<p>
<b>Куда поместить модуль?</b><br>
Туда, где его потом можно будет найти.
<p>
Пути поиска модулей указаны в переменной sys.path. В него включены текущая директория (то есть модуль можно оставить в папке с основной программой), а также директории, в которых установлен python.
<p>
Кроме того, переменную sys.path можно изменять вручную, что позволяет положить модуль в любое удобное для вас место (главное, не забыть в главной программе модифицировать sys.path).

<h3 align=center><a name="lib">Обзор стандартной библиотеки</h3>
Ссылки: <a href="https://intuit.ru/studies/courses/49/49/lecture/27060?page=4">Обзор стандартной библиотеки</a><br>
<a href="https://docs.python.org/3/library/">Список модулей стандартной библиотеки</a>
<p>
Помимо создания собственных модулей python содержит большое количество собственных модулей, называемых библиотекой стандартных  модулей.<br>
Модули стандартной библиотеки можно условно разбить на группы по тематике.
<ol>
<li> Сервисы периода выполнения. Модули: sys, atexit, copy, traceback, math, cmath, random, time, calendar, datetime, sets, array, struct, itertools, locale, gettext.


<h4>Модуль sys</h4>
Ссылки: <a href="https://python-scripts.com/module-sys">Разбираем модуль sys</a>
<p>
 Модуль sys предоставляет системе особые параметры и функции.
<ol>
<li> <b>sys.argv</b><br>
Значение sys.argv – это список аргументов командной строки, которые причастны к скрипту Python. Первый аргумент, argv[0], 
имеет аналогичное скрипту Python наименование. В зависимости от платформы, на которой вы работаете, первый аргумент может 
содержать полный путь к скрипту или к названию файла. Для дополнительных деталей обратитесь к документации. А тем временем, 
попробуем поработать с парочкой примеров, чтобы познакомиться с этим инструментом:<br>
В интерпретаторе выполним:
<pre>
>>> import sys
>>> print(sys.argv)
['']</pre>
Получили пустой список, потому что никакую программу не запускали.
<p>
Если создадим скрипт 1.py с кодом:
<pre>
import sys
print(sys.argv)</pre>
и запустим его с командной строки:
<br><img src="./images/python_base7.png">
<p>
<li> sys.executable
<li> sys.exit
<li> sys.modules
<li> sys.path
<li> sys.platform
<li> sys.stdin/stdout/stderr
</ol>

<h4>Модуль subprocess</h4>
Ссылки: <a href="https://python-scripts.com/subprocess">Модуль subprocess — Работаем с процессам</a>
<p>
Модуль subprocess дает разработчику возможность запускать процессы программ из Python. Другим словами, вы можете запускать 
приложения и передавать им аргументы при помощи модуля subprocess. Модуль subprocess был внедрен в Python 2.4 для замены 
настроек вызовов модуля os, таких как os.popen, os.spawn и os.system, а также для замены popen2 и старых командных модулей.
<p>
<b>Функция вызова call</b><br>
Модуль subprocess содержит функцию под названием call. Эта функция позволяет вам вызывать другую программу, дожидаться 
завершения команды и вернуть код возврата. Она принимает один или несколько аргументов, а также следует ключевым аргументам (с 
их значениями): stdin=None, stdout=None, stderr=None, shell=False.<br>
Взглянем на простой пример:
<pre>
import subprocess
 
# Для Windows
subprocess.call("notepad.exe")
 
# Для linux
subprocess.call("gedit")</pre>
Если вы запустите этот код на машине, которая работает на Windows Python, вы увидите открывшийся блокнот. Обратите внимание на 
то, что IDLE (<font color=red>наверное это имя интерпретатора</font>) ожидает, пока вы закроете блокнот, после чего вернет 
нулевой код (0).
<br>Это значит, что код был выполнен успешно. Если вы получите что-либо, что не является ноль, то вы столкнулись с какой-то 
ошибкой.
<p>
Метод call также принимает аргументы, для передачи программе, которую вы выполняете. Давайте взглянем на то, как это работает:
<pre>
import subprocess
code = subprocess.call(["ping", "www.yahoo.com"])</pre>
В ответе получим результат пингования сайта.<br>
Обратите внимание на то, что в данном примере мы передали список аргументов. Первый объект в списке это программа, которую мы 
хотим вызвать. Все остальное в списке – это аргументы, которые мы хотим передать программе. Так что в данном примере мы 
выполняем пинг на сайте Yahoo. Также обратите внимание на то, что код возврата нулевой, так что все прошло успешно. 

<p>
Модуль copy содержит функции для копирования объектов.<p>
В модулях math cmath собраны математические функции для действительных и комплексных аргументов.<p>
Модуль random генерирует псевдослучайные числа для нескольких различных распределений.<p>
модуль time дает функции для получения текущего времени и преобразования форматов времени.<p>
Модуль sets реализует тип данных для множеств.<p>
Модули array и struct реализуют низкоуровневый массив и структуру данных. Основное их назначение - разбор двоичных форматов данных.<p>
Модуль itertools содержит набор функций для работы с итераторами. Итераторы позволяют работать с данными последовательно, как если бы они получались в цикле. Альтернативный подход - использование списков для хранения промежуточных результатов - требует подчас большого количества памяти, тогда как использование итераторов позволяет получать значения на момент, когда они действительно требуются для дальнейших вычислений.<p>
Модуль locale применяется для работы с культурной средой. В конкретной культурной среде могут использоваться свои правила для написания чисел, валют, времени и даты и т.п.<p>
Модуль gettext При интернационализации программы важно не только предусмотреть возможность использования нескольких культурных сред, но и перевод сообщений и меню программы на соответствующий язык.   <p>

<li> Поддержка цикла разработки. Модули: pdb, hotshot, profile, unittest, pydoc. Пакеты docutils, distutils.<br>
Модули этого раздела помогают поддерживать документацию, производить регрессионное тестирование, отлаживать и профилировать программы на Python, а также обслуживают распространение готовых программ, создавая среду для конфигурирования и установки пакетов.<p>

<li> Взаимодействие с ОС (файлы, процессы). Модули: os, os.path, getopt, glob, popen2, shutil, select, signal, stat, tempfile.
<p>
<li> Обработка текстов. Модули: string, re, StringIO, codecs, difflib, mmap, sgmllib, htmllib, htmlentitydefs. Пакет xml.
<p>
<li> Многопоточные вычисления. Модули: threading, thread, Queue.
<p>
<li> Хранение данных. Архивация. Модули: pickle, shelve, anydbm, gdbm, gzip, zlib, zipfile, bz2, csv, tarfile.<br>
К этой категории отнесены модули, которые работают с внешними хранилищами данных.
<p>
<li> Платформо-зависимые модули. Для UNIX: commands, pwd, grp, fcntl, resource, termios, readline, rlcompleter. Для Windows: msvcrt, _winreg, winsound.
<p>
<li> Поддержка сети. Протоколы Интернет. Модули: cgi, Cookie, urllib, urlparse, httplib, smtplib, poplib, telnetlib, socket, asyncore. Примеры серверов: SocketServer, BaseHTTPServer, xmlrpclib, asynchat.<br>
Почти все модули из этой категории, обслуживающие клиентскую часть протокола, построены по одному и тому же принципу: из модуля необходим только класс, объект которого содержит информацию о соединении с сервером, а методы реализуют взаимодействие с сервером по соответствующему протоколу. Таким образом, чем сложнее протокол, тем больше методов и других деталей требуется для реализации клиента.<br>
Примеры серверов используются по другому принципу. В модуле с реализацией сервера описан базовый класс, из которого пользователь модуля должен наследовать свой класс, реализующий требуемую функциональность. Правда, иногда замещать нужно всего один или два метода.
<p>
<li> Поддержка Internet. Форматы данных. Модули: quopri, uu, base64, binhex, binascii, rfc822, mimetools, MimeWriter, multifile, mailbox. Пакет email.<br>
В стандартной библиотеке Python имеются разноуровневые модули для работы с различными форматами, применяющимися для кодирования данных в сети Интернет и тому подобных приложениях.<br>
Сегодня наиболее мощным инструментом для обработки сообщений в формате является пакет email. С его помощью можно как разбирать сообщения в удобном для программной обработки виде, так и формировать сообщение на основе данных о полях и основном содержимом (включая вложения).
<p>
<li> Python о себе. Модули: parser, symbol, token, keyword, inspect, tokenize, pyclbr, py_compile, compileall, dis, compiler.
<p>
<li> Графический интерфейс. Модуль Tkinter.<br>
Почти все современные приложения имеют графический интерфейс пользователя. Такие приложения можно создавать и на языке Python. 
В стандартной поставке имеется модуль Tkinter, который есть не что иное, как интерфейс к языку Tcl/Tk, на котором можно 
описывать графический интерфейс.

Следует отметить, что существуют и другие пакеты для программирования графического интерфейса: wxPython (основан на 
wxWidgets), PyGTK и т.д. Среди этих пакетов в основном такие, которые работают на одной платформе (реже - на двух).
</ol>
Примечание:<br>
Очень часто модули содержат один или несколько классов, с помощью которых создается объект нужного типа, а затем речь идет уже 
не об именах из модуля, а об атрибутах этого объекта. И наоборот, некоторые модули содержат лишь функции, достаточно общие для 
того, чтобы работать над произвольными объектами (либо достаточно большой категорией объектов).






<h3 align=center>Дополнительные модули</h3>
Python  может работать с дополнительными библиотеками, которые в состав python не входят и их нужно устанавливать в систему.
<ol>
<li> <b>Библиотека requests</b><br>
Служит для отправки запросов на сервер и получения от него ответа.
<p>
Для установки служит команда: <b>pip3 install requests</b><br>
У меня установлен уже в python.
<p>
Пример простого запроса в программе:
<pre>
import requests
r = requests.get('htpp://example.com')  # простой get-запрос
print(r.text) # вывод ответа от сервера</pre>
<img src="./images/python_base8.png">
</ol>












<h3 align=center><a name="obiekt">Объектно-ориентированное программирование. Классы, объекты</h3>
Ссылки: <a href="https://intuit.ru/studies/courses/49/49/lecture/27064">Лекция 4: Объектно-ориентированное программирование</a><br>
<a href="https://pyplanet.ru/article/classes.html">Объектно-ориентированное программирование. Классы, объекты</a>
<p>
В объектно-ориентированном программировании (ООП) основными концепциями являются понятия объектов и классов.
<p>
<b>Объект</b><br>
В Python всё является объектами - строки, списки, словари, файлы, всё остальное.
<p>
<b>Метод</b><br>
Взаимодействие объектов заключается в вызове методов одних объектов другими. Иногда говорят, что объекты посылают друг другу сообщения. Сообщения - это запросы к объекту выполнить некоторые действия.<br>
<b>Сообщения, методы, операции, функции-члены</b> являются синонимами.
<p>
<b>Атрибут</b><br>
Каждый объект хранит свое состояние (для этого у него есть атрибуты ) и имеет определенный набор методов.<br>
Синонимы: <b>атрибут, поле, слот, объект-член, переменная экземпляра</b>.
<p>
<b>Класс</b><br>
Объекты описываются не индивидуально, а с помощью классов. Класс - объект, являющийся шаблоном чертежём объекта.<br>
Объект, созданный на основе некоторого класса, называется <b>экземпляром класса</b>. Все объекты определенных пользователем классов являются экземплярами класса. Тем не менее, объекты даже с одним и тем же состоянием могут быть разными объектами. Говорят, что они имеют разную <b>индивидуальность</b>.
<p>
В языке Python для определения класса используется оператор class:
<pre>
class имя_класса(класс1, класс2, ...):
  # определения методов</pre>
Класс определяет тип объекта, то есть его возможные состояния и набор операций.
<p>
Пример собственного класса:
<pre>
class A:
    pass</pre>
Здесь pass - это инструкция, которая "ничего не делает". Что-то написать в теле блока class мы должны, но не хотим. Тогда мы можем написать pass.
Теперь мы можем создать несколько экземпляров этого класса:
<pre>
>>> class A:
...     pass
...
>>> a = A()
>>> b = A()
>>> a.arg = 1  # у экземпляра a появился атрибут arg, равный 1
>>> b.arg = 2  # а у экземпляра b - атрибут arg, равный 2
>>> print(a.arg)
1
>>> print(b.arg)
2
>>> c = A()
>>> print(c.arg)  # а у этого экземпляра нет arg
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'A' object has no attribute 'arg'</pre>
Классу возможно задать собственные методы:
<pre>
>>> class A:
...     def say_hello(self):
...         return "Hello Pyplanet"
...
>>> a = A()
>>> a.say_hello()
'Hello Pyplanet'</pre>
Методы и атрибуты доступны через точку: экземпляр.метод(аргументы).
<p>
Это так же, как и доступ к атрибутам модуля (например math.sin(1)). Более того, модуль - это такой же объект; а его методами и атрибутами является то, что записано в файле модуля.
<p>
При вызове метода у экземпляра класса всегда происходит вызов классового метода с автоматической передачей экземпляра класса в качестве первого аргумента.
<p>
Так исторически сложилось, что в теле метода этот первый аргумент называют self.
<p>
Из любого метода можно создавать и изменять атрибуты экземпляра:
<pre>
class A:
    def set_hello(self):
        self.hello = "Hello Pyplanet"

a = A()
a.set_hello()
print(a.hello)</pre>
Выведет Hello Pyplanet.
<p>
Другой пример:<br>
Пусть в ходе анализа данной предметной области необходимо определить класс Граф. Граф - это множество вершин и набор ребер, попарно соединяющий эти вершины. Над графом можно проделывать операции, такие как добавление вершины, ребра, проверка наличия ребра в графе и т.п. На языке Python определение класса может выглядеть так:
<pre>
from sets import Set as set  # тип для множества

class G:
  def __init__(self, V, E):
    self.vertices = set(V)
    self.edges = set(E)

  def add_vertex(self, v):
    self.vertices.add(v)

  def add_edge(self, (v1, v2)):
    self.vertices.add(v1)
    self.vertices.add(v2)
    self.edges.add((v1, v2))

  def has_edge(self, (v1, v2)):
    return (v1, v2) in self.edges

  def __str__(self):
    return "%s; %s" % (self.vertices, self.edges)</pre>
Использовать класс можно следующим образом:
<pre>
g = G([1, 2, 3, 4], [(1, 2), (2, 3), (2, 4)])

print g
g.add_vertex(5)
g.add_edge((5,6))
print g.has_edge((1,6))
print g</pre>
что даст в результате:
<pre>
Set([1, 2, 3, 4]); Set([(2, 4), (1, 2), (2, 3)])
False
Set([1, 2, 3, 4, 5, 6]); Set([(2, 4), (1, 2), (5, 6), (2, 3)])</pre>
Как видно из предыдущего примера, определить класс не так уж сложно. Конструктор класса имеет специальное имя __init__. (Деструктор здесь не нужен, но он бы имел имя __del__.)<br>
Методы класса определяются в пространстве имен класса.<br>
В качестве первого формального аргумента метода принято использовать self.<br>
Кроме методов в объекте класса имеются два атрибута: vertices (вершины) и edges (ребра).<br>
Для представления объекта G в виде строки используется специальный метод __str__().
<p>
Принадлежность классу можно выяснить с помощью встроенной функции isinstance():
<pre>print isinstance(g, G)</pre>







<h3><a href="https://pyplanet.ru/article/with-as.html">Конструкция with - as: менеджер контекста</a></h3>
<h3><a href="https://pyplanet.ru/article/magic-methods.html">Магические методы</a></h3>
<h3><a href="https://pyplanet.ru/article/pip.html">Пакетный менеджер pip</a></h3>

<b>Инкапсуля́ция</b> — размещение в оболочке, изоляция, закрытие чего-либо инородного с целью исключения влияния на окружающее. Например, поместить радиоактивные отходы в капсулу, закрыть кожухом механизм, убрать мешающее в ящик или шкаф.
<p>
Обычно считается, что без инкапсуляции невозможно представить себе ООП, что это ключевое понятие. История развития методологий программирования движима борьбой со сложностью разработки программного обеспечения. Сложность больших программных систем, в создании которых участвует сразу большое количество разработчиков, уменьшается, если на верхнем уровне не видно деталей реализации нижних уровней. Собственно, процедурный подход был первым шагом на этом пути. Под инкапсуляцией (encapsulation, что можно перевести по-разному, но на нужные ассоциации хорошо наводит слово "обволакивание") понимается сокрытие информации о внутреннем устройстве объекта, при котором работа с объектом может вестись только через его общедоступный (public) интерфейс. Таким образом, другие объекты не должны вмешиваться в "дела" объекта, кроме как используя вызовы методов.
<p>
В языке Python инкапсуляции не придается принципиального значения: ее соблюдение зависит от дисциплинированности программиста. В других языках программирования имеются определенные градации доступности методов объекта.
<p>
<b>Итератор</b> — интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера) и навигацию по ним. В различных системах итераторы могут иметь разные общепринятые названия. В терминах систем управления базами данных итераторы называются курсорами. В простейшем случае итератором в низкоуровневых языках является указатель.
<p>
Итераторы в Python являются неотъемлемой частью языка и во многих случаях неявно используются в выражении for (цикл просмотра), в работе со списками и в выражениях генератора. Все стандартные типы циклов, являющиеся частью языка Python, поддерживают итерацию, так же как и множество классов, являющихся частью стандартной библиотеки. Следующий пример демонстрирует типичную неявную итерацию при помощи цикла:
<pre>
 for value in sequence:
     print(value)</pre>
Словари языка Python (вид ассоциативного массива) также могут быть перебраны напрямую с возвратом словарных ключей. Или метод items словаря может быть перебран, когда он дополняет связанный ключ, а значение этой пары является кортежем:
<pre>
for key in dictionary:
    value = dictionary[key]
    print(key, value)
for key, value in dictionary.items():
    print(key, value)</pre>
Тем не менее, итераторы могут использоваться и задаваться явным образом. Для любого перечисляемого типа цикла или класса встроенная функция iter() создает итератор. Итератор реализует метод next(), который возвращает следующий элемент в контейнере. Когда элементов больше не остается вызывается ошибка StopIteration. Следующий пример демонстрирует соответствующую циклическую итерацию при помощи явных итераторов:
<pre>
it = iter(sequence)
while True:
    try:
        value = it.next()
    except StopIteration:
        break
    print(value)</pre>




<h3 align=center><a href="https://intuit.ru/studies/courses/49/49/lecture/27080">Лекция 12: Создание приложений с графическим интерфейсом</a></h3>














</div>
<br><br><br><br><br></body></html>
