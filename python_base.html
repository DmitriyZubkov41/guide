<html><head>
<style>
.menu {
       height: 100%;
       width: 140px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 150px; /* То же, что и ширина боковой панели */
           padding: 0px 0px 0px 16px;
         }
</style>
</head><body>
<title>Основы Python</title>
<div class="menu">
<a href="#sintaks">Синтаксис</a>
<a href="#string">Строки</a>
<a href="#list">Список</a>
<a href="#diction">Словарь</a>
<a href="#gener">Генератор коллекций</a>
<a href="#table">Прямоугольная матрица</a>
<a href="#srez">Срез массивов</a>
<a href="#unpack">Распаковка</a>
<a href="#metod">Методы</a>
<a href="#join">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;join()</a>
<a href="#split">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;split()</a>
<a href="#loop">Циклы</a>
<a href="#potok">Вызов методов цепочкой</a>
<a href="#regul">Регулярные выражения</a>
<a href="#def">Функции</a>
<a href="#recurs"><b>Рекурсивные функции:</b></a>
<a href="#builtins"><b>Встроенные функции:</b></a>
<a href="#range">&nbsp;&nbsp;&nbsp; Функция range</a>
<a href="#filter">&nbsp;&nbsp;&nbsp; Функция filter()</a>
<a href="#map">&nbsp;&nbsp;&nbsp; Функция map()</a>
<a href="#lambda">lambda - функции:</a>
<a href="#decorator">&nbsp;&nbsp;&nbsp; Декораторы</a>
<a href="#zamik">&nbsp;&nbsp;&nbsp; Замыкания</a>
<a href="#file">Работа с файлами</a>
<a href="#except">Исключения: try except</a>
</div>
<div class="content">
<h2 align=center><a name="top">Введение в Python</h2>
Ссылки на учебники: <a href="https://pythonworld.ru/samouchitel-python">Самоучитель Python</a><br>
<a href="https://stepik.org/course/67">Программирование на Python (07.10.2024 - 20.10.2024)</a><br>
<a href="https://stepik.org/course/512">Python: основы и применение (20.10.2024 - )</a>
<p>
Языки программирования делятся на два типа:
<ul>
<li> Компилируемые<br>
Специальная программа, компилятор, преобразует исходный код в машинный.<br>
Полученный в результате файл готов к исполнению без дополнительных инструментов.<br>
Примеры: C++, Colang, Rust
<li> Интерпретируемые<br>
Код исполняется строчка за строчкой специальной программой - интерпретатором.<br>
Исполнение возможно только при наличии этой программы.<br>
Примеры: Python, Lua, JavaScript.
</ul>

<h3 align=center><a href="https://pyplanet.ru/article/install.html">Установка Python на linux системы (Ubuntu, Debian и другие)</a></h3>
Откройте консоль (обычно ctrl+alt+t). Введите в консоли:
<pre>python3</pre>
Скорее всего, вас любезно поприветствует python:
<pre>
dmitriy@945G-M3:~$ python3
Python 3.8.10 (default, Sep 11 2024, 16:02:53) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 
</pre></pre>
или узнать версию  python:
<pre>
dmitriy@945G-M3:~$ python3 --version
Python 3.8.10</pre>
Если это так, то можно вас поздравить: у вас уже стоит python. В противном случае нужно установить пакет *python3*:
<pre>sudo apt install python3</pre>
Чтобы загрузить установщики для операционных систем Windows и Mac OS, достаточно перейти по ссылке https://www.python.org/downloads/release/python-351/ ﻿и в самом низу страницы ﻿выбрать ﻿нужный для вашей архитектуры установщик интерпретатора: для windows 64bit - "﻿Windows x86-64 executable installer", для windows 32bit - "Windows x86 executable installer﻿", для Mac OS ﻿64 bit ﻿- ﻿"Mac OS X 64-bit/32-bit installer", ﻿ для Mac OS 32bit/PPC - ﻿﻿"Mac OS X 32-bit i386/PPC installer".


<h3 align=center>На чем писать код и как выпонять?</h3>
<ol>
<li> VS code и Pycharm<br>
для моего компьютера очень тяжелые.
<li> В python для linux нет предустановленной среды IDLE. Если хотите, её можно установить отдельно. Пакет называется idle3 (в более ранних версиях он может называться python3-idle).<br>
Однако, её установка не является обязательной. Вы можете писать в своём любимом текстовом редакторе (gedit, vim, emacs...) и запускать программы через консоль:<br>
python3 path_to_file.py
<p>
Как писать на <a href="https://pyplanet.ru/article/hello-world.html">IDLE</a>
<li> https://repl.it/<br>
Начал на нем.
<li> Jupyter Notebook<br>
Чтобы начать на нем работать, команда:
<pre>jupyter notebook</pre>

<li> <b>Shebang</b> — это специальное выражение, которое указывается в начале файла исполняемого скрипта. Оно сообщает системе, какой интерпретатор использовать для запуска скрипта.
<p>
В случае с Python это может быть один из двух вариантов:
<p>
/usr/bin/env python. Более переносимый вариант, который позволяет системе самой найти нужный интерпретатор Python.
<p>
/usr/local/bin/python. Требует, чтобы интерпретатор Python был установлен именно в этом месте.
<p>
Использование shebang не является обязательным для Python-скриптов. Оно полезно, если скрипт предназначен для запуска из командной строки Unix как самостоятельная программа. Если же скрипт запускается из другого Python-скрипта с помощью функции exec() или подобных, то shebang не требуется.
<p>
Написал простой код 1.py:
<pre>
#!/usr/bin/env python 
print("aggggggg")</pre>
Если выполнить скрипт, просто: <b>1.py</b><br>
<font color=red>то команда не найдена.</font><br>
если: <b>source 1.py</b><br>
<font color=red>то синтаксическая ошибка</font>
<p>
Прочитал, что требуется указывать полный путь к скрипту для его выполнения. Выполнил: 
<pre>/usr/bin/python3 ~/Python/1.py</pre>
Выполнился без ошибок. После этого:
<pre>~/Python/1.py
     /usr/bin/env: «python»: Нет такого файла или каталога</pre>
Очевидно неправильный шебанг.<br>
Исправил:
<pre>
#!/usr/bin/env <font color=green>python3</font> 
print("aggggggg")</pre>
Снова: ~/Python/1.py<br>
Теперь выполнился и без ошибок.
<p>
Если все же выполнить:
<pre>
1.py
1.py: команда не найдена</pre>
То есть все равно нужно указывать явный путь к файлу.py
<p>
<li> <b>Интерактивный режим:</b><br>
Выполняем команду: <b>python3</b> и далее можно выполнять команды сразу после каждой строки.<br>
Выход из интерактивного режима: нажатие Ctrl+z
<p>
Чтобы выполнить скрипт в интерактивном режиме, команда:
<pre><b>python3 -i ~/Python//mypython/1.py</b></pre>
</ol>





<h3 align=center><a name="sintaks">Синтаксис</h3>
Синтаксис языка Python очень прост.
<ul>
<li> Конец строки является концом инструкции (точка с запятой не требуется).

<li> Вложенные инструкции объединяются в блоки по величине отступов. Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков. Однако хорошим тоном считается отступ каждого блока в 4 пробела
<li> Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, как правило, с отступом под строкой основной инструкции.
</ul>
<pre>
Основная инструкция:
    Вложенный блок инструкций</pre>
<h4><a href="https://intuit.ru/studies/courses/49/49/lecture/27058?page=7">Имена</a></h4>    
Имя может начинаться с латинской буквы (любого регистра) или подчеркивания, а дальше допустимо использование цифр. В качестве 
идентификаторов нельзя применять ключевые слова языка и нежелательно переопределять встроенные имена.<br>
<p>Имена, начинающиеся с подчеркивания или двух подчеркиваний, имеют особый смысл. Одиночное подчеркивание говорит 
программисту о том, что имя имеет местное применение, и не должно использоваться за пределами модуля. Двойным подчеркиванием в 
начале и в конце обычно наделяются специальные имена атрибутов - об этом будет говориться в лекции по объектно-
ориентированному программированию.
<p>    
В каждой точке программы интерпретатор "видит" три пространства имен: локальное, глобальное и встроенное. Пространство имен - 
отображение из имен в объекты.
<p>
Для понимания того, как Python находит значение некоторой переменной, необходимо ввести понятие блока кода. В Python блоком 
кода является то, что исполняется как единое целое, например, тело определения функции, класса или модуля.
<p>
Локальные имена - имена, которым присвоено значение в данном блоке кода. Глобальные имена - имена, определяемые на уровне 
блока кода определения модуля или те, которые явно заданы в операторе global. Встроенные имена - имена из специального словаря 
__ builtins __.
<p>
Области видимости имен могут быть вложенными друг в друга, например, внутри вызванной функции видны имена, определенные в 
вызывающем коде. Переменные, которые используются в блоке кода, но связаны со значением вне кода, называются свободными 
переменными.
<p>
Так как переменную можно связать с объектом в любом месте блока, важно, чтобы это произошло до ее использования, иначе будет 
возбуждено исключение NameError. Связывание имен со значениями происходит в операторах присваивания, from, import, в 
формальных аргументах функций, при определении функции или класса, во втором параметре части except оператора try-except.
<p>
С областями видимости и связыванием имен есть много нюансов, которые хорошо описаны в документации. Желательно, чтобы 
программы не зависели от таких нюансов, а для этого достаточно придерживаться следующих правил:
<ul>
<li> Всегда следует связывать переменную со значением (текстуально) до ее использования.
<li> Необходимо избегать глобальных переменных и передавать все в качестве параметров. Глобальными на уровне модуля должны 
остаться только имена-константы, имена классов и функций.
<li> Никогда не следует использовать from модуль import * - это может привести к затенению имен из других модулей, а внутри 
определения функции просто запрещено.
</ul>
Предпочтительнее переделать код, нежели использовать глобальную переменную. Конечно, для программ, состоящих из одного модуля, 
это не так важно: ведь все определенные на уровне модуля переменные глобальны.
<p>
Убрать связь имени с объектом можно с помощью оператора del. В этом случае, если объект не имеет других ссылок на него, он 
будет удален.     
    
    
<h4><a href="https://intuit.ru/studies/courses/49/49/lecture/27058?page=8">Стиль программирования</a></h4>
Ссылки: <a href="https://intuit.ru/studies/courses/49/49/lecture/27058?page=8">Стиль программирования</a><br>
<a href="https://egorovegor.ru/python-pep8/">PEP8: руководство по написанию чистого и читаемого кода на Python</a><br>
<a href="https://peps.python.org/pep-0008/">PEP 8 – Style Guide for Python Code</a><br>
<a href="https://pyplanet.ru/article/pep-0008.html">PEP 8 - руководство по написанию кода</a>

<p>
Наиболее существенные положения этого стиля перечислены ниже. В случае сомнений хорошим образцом стиля являются модули 
стандартной библиотеки.
<ul>
<li> Рекомендуется использовать отступы в 4 пробела.
<li> <b>Максимальная длина строки</b><br>
Ограничьте длину строки не более чем 79 символами. Если строка длиннее, разбейте ее на несколько строк. Длинные строки могут быть трудны для чтения, особенно когда они выходят за границы окна редактора. Разбиение длинных строк на несколько строк с помощью продолжения строки с помощью символа обратной косой черты \является хорошей практикой.

<li> Длинные логические строки лучше разбивать неявно (внутри скобок), но и явные методы вполне уместны. Отступы строк продолжения рекомендуется выравнивать по скобкам или по первому операнду в предыдущей строке. Текстовый редактор Emacs в режиме python-mode и некоторые интегрированные оболочки (IDE) автоматически делают необходимые отступы в Python-программах:
<pre>
def draw(figure, color="White", border_color="Black",
         size=5):
    if color == border_color or \
       size == 0:
        raise "Bad figure"
    else:
        _draw(size, size, (color,
                           border_color))</pre>
<li> <b>Пробелы</b><br>
Используйте один пробел между операторами и операндами. Не используйте пробелы для выделения скобок вокруг аргументов функций. Это правило помогает упростить код и сделать его более читабельным.
<br>Например:
<pre>
# Правильно:
x = 2 + 3
y = (1 + 2) * 3
​
# Неправильно:
x=2+3
y = ( 1 + 2 ) * 3</pre>
Не рекомендуется ставить пробелы сразу после открывающей скобки или перед закрывающей, перед запятой, точкой с запятой, перед открывающей скобкой при записи вызова функции или индексного выражения.<br>
Также не рекомендуется ставить более одного пробела вокруг знака равенства в присваиваниях. Пробелы вокруг знака равенства не ставятся в случае, когда он применяется для указания значения по умолчанию в определении параметров функции или при задании именованных аргументов.<br>
Также рекомендуется применение одиночных пробелов вокруг низкоприоритетных операций сравнения и оператора присваивания. Пробелы вокруг более приоритетных операций ставятся в равном количестве слева и справа от знака операции.
<p>
<b>Пробелы вокруг операторов</b><br>
Используйте пустые строки для разделения логически связанных частей кода. Не используйте несколько операторов на одной строке.
<p>
Используйте пробелы вокруг операторов (=, +, -, *, /, //, %, и т. д.), но не используйте пробелы вокруг <b>символа индексирования или среза.</b>
<pre>
# Правильно:
x = 2 + 3
y = x * 4
z = list[0]

# Неправильно:
x=2+3
y = x*4
z = <font color=red>list [0]</font>
</pre>
<p>
<li> <b>Именование</b><br>
Используйте понятные и описательные имена переменных, функций и методов. Для имени переменных используйте строчные буквы, а для имен функций и методов — заглавные буквы. Это правило помогает делать ваш код более читаемым и понятным для других программистов.
<p>
Например:
<pre>
# Правильно:
age = 25
name = "John"

def calculate_sum(numbers):
    return sum(numbers)

# Неправильно:
a = 25
b = "John"

def calc_sum(nums):
    return sum(nums)
</pre>
<p>
<b>Названия функций и методов</b>
Используйте глаголы в названиях функций и методов, используйте нижнее подчеркивание для разделения слов. Это правило помогает делать код более понятным и легче читаемым.
<pre>
# Правильно:
def calculate_sum(numbers):
    return sum(numbers)

def get_user_name(user):
    return user.name

# Неправильно:
def numbersSum(nums):
    return sum(nums)
</pre>
<p>
<b>Название переменных</b><br>
Используйте понятные и описательные названия для переменных, избегайте использования одиночных символов в качестве названий 
переменных, используйте нижнее подчеркивание для разделения слов.
<pre>
# Правильно:
total_sum = 0
list_of_numbers = [1, 2, 3, 4]
user_name = "John"

# Неправильно:
t = 0
n = [1, 2, 3, 4]
un = "John"
</pre>
<b>Имена, которых следует избегать</b><br>
Никогда не используйте символы l (маленькая латинская буква «эль»), O (заглавная латинская буква «о») или I (заглавная 
латинская буква «ай») как однобуквенные идентификаторы.
<p>
В некоторых шрифтах эти символы неотличимы от цифры один и нуля. Если очень нужно l, пишите вместо неё заглавную L.
<p>
Имена модулей лучше давать строчными буквами, например, shelve, string, либо делать первые буквы слов заглавными, StringIO, 
UserDict. Имена написанных на C модулей расширения обычно начинаются с подчеркивания " _ ", а соответствующие им 
высокоуровневые обертки - с прописных букв: _tkinter и Tkinter.
<p>
Классы обычно называют, выделяя первые буквы слов прописными, как в Tag или HTTPServer.
<p>
Имена глобальных переменных (если таковые используются) лучше начинать с подчеркивания, чтобы они не импортировались из модуля 
оператором from-import со звездочкой.
<p>
Имена констант (имен, которые не должны переопределяться) лучше записывать прописными буквами, например: RED, GREEN, BLUE.
<p>
<li> <b>Комментарии</b><br>
Комментарии должны быть короткими, лаконичными и описательными, они должны помогать другим программистам понимать ваш код. Не 
используйте комментарии для описания очевидных вещей, таких как присваивание переменной значения, и избегайте комментариев в 
конце строки. После коротких комментариев можно не ставить точку, тогда как длинные лучше писать по правилам написания текста. 
<p>
Комментарии к фрагменту кода следует писать с тем же отступом, что и комментируемый код. После " # " должен идти <b>одиночный 
пробел</b>. Абзацы можно отделять строкой с " # " на том же уровне.<br>
Блочный комментарий можно отделить пустыми строками от окружающего кода.
<p>
Комментарии, относящиеся к конкретной строке, не следует использовать часто. <b>Символ " # " должен отстоять от 
комментируемого оператора как минимум на два пробела.</b>
<p>
Хороший комментарий не перефразирует программу, а содержит дополнительную информацию о действии программы в терминах 
предметной области.
<p>
Комментарий своего класса, а также описание модудя, функции модуля можно увидеть через атрибут __doc__:
<pre><font color=green><b>print(My_objekt.__doc__)</b></font></pre>
<p>
<li> <b>Импорты</b>
Импортируйте модули в алфавитном порядке, разделяйте группы импортов пустой строкой и избегайте использования символа *. Это 
правило помогает упростить импорты и улучшить читабельность кода.
<pre>
# Правильно:
import datetime
import os

from math import sqrt

import requests

# Неправильно:
import requests, os, datetime

from math import *

import my_module
</pre>
<p>
<li> 
Все модули, классы, функции и методы, предназначенные для использования за пределами модуля, должны иметь строки документации, 
описывающие способ их применения, входные и выходные параметры.

<li> <b>Документация:</b><br>
Для строк документации рекомендуется везде использовать утроенные кавычки ( """ ).
<p>
Строка документации для отдельной программы должна объяснять используемые ею ключи, назначение аргументов и переменных среды и 
другую подобную информацию.
<p>
Однострочная документация пишется в императиве, как команда: "делай это", "возвращай то".
<p>
Многострочная документация содержит расширенное описание модуля, функции, класса. Она будет смотреться лучше, если текст будет 
написан с тем же отступом, что и начало строки документации.
<p>
Документация для модуля должна перечислять экспортируемые функции, классы, исключения и другие объекты, по одной строке на 
объект.
<p>
Строка документации для функции или метода должна кратко описывать действия функции, ее входные параметры и возвращаемое 
значение, побочные эффекты и возможные исключения (если таковые есть). Должны быть обозначены необязательные аргументы и 
аргументы, не являющиеся частью интерфейса.
<p>
Документация для класса должна перечислять общедоступные методы и атрибуты, содержать рекомендации по применению класса в 
качестве базового для других классов. Если класс является подклассом, необходимо указать, какие методы полностью заменяют, 
перегружают, а какие используют, но расширяют соответствующие методы надкласса. Необходимо указать и другие изменения по 
сравнению с надклассом.
<p>
<li> Контроль версий повышает качество процесса создания программного обеспечения. Для этих целей часто используются RCS или 
CVS. "Python Style Guide" рекомендует записывать $Revision: 1.31 $ в переменную с именем __version__, а другие данные 
заключать в комментарии " # ".
<p>
<li> <b>Срезы:</b><br>
В срезе двоеточие действует как бинарный оператор и должно иметь равное количество пробелов с обеих сторон (рассматривая его 
как оператор с наименьшим приоритетом). В расширенном срезе оба двоеточия должны иметь одинаковое количество интервалов. 
Исключение: если параметр среза опущен, пробел не ставится.

Правильно:
<pre>
ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:] # без пробела
ham[lower:upper], ham[lower:upper:], <b>ham[lower::step]</b>
# Плюс в двух ниже примерах можно с пробелом так и без пробела
ham[lower+offset : upper+offset]
ham[lower + offset : upper + offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]

Неправильно:

ham[lower + offset:upper + offset] # видимо двоеточие между выражениями должно быть с пробелом
ham[1: 9], ham[1 :9], ham[1:9 :3]  # пробела не должно быть в обычных срезах
ham[lower : : step]                # еще раз, правильно без пробелов
ham[ : upper]</pre>
<p>
Не используйте пробелы вокруг знака =, если он используется для обозначения именованного аргумента или значения параметров по 
умолчанию.
<p>
Правильно:
<pre>
def complex(real, imag=0.0):
    return magic(r=real, i=imag)
Неправильно:

def complex(real, imag = 0.0):
    return magic(r = real, i = imag)</pre>
Однако при объединении аннотации аргумента со значением по умолчанию используйте пробелы вокруг знака =.
<p>
Правильно:
<pre>
def munge(sep: AnyStr = None): ...
def munge(input: AnyStr, sep: AnyStr = None, limit=1000): ...
Неправильно:

def munge(input: AnyStr=None): ...
def munge(input: AnyStr, limit = 1000): ...</pre>

</ul>




<h2 align=center><a name="var">Переменные</h2>
Для имени переменной используется любой набор допустимых символов: буквы английского алфавита, цифры, знак _. При этом цифру нельзя ставить в начале.
<p>
<i>В Python переменные являются лишь именованиями объектов. Ссылками на объекты, если так проще.
<p>
Присвоив, скажем, переменной b значение 5 (b = 5) - стоит помнить, что переменная b лишь ссылается на целочисленное значение 5.
<p>
При желании можно объявить переменную b хоть стоковым значением (b = str(b)) и это будет всё та же "5", но уже не целочисленная. И арифметических действий с ней уже не получится. Просто старое значение (ссылка) переменной будет стёрта и теперь она уже будет ссылаться на 5 - объект типа strint (str).
<p>
Точно также и с преобразованием во float - это будет ссылка уже на третий объект, 5.0 типа float.
<p>
Все три объекта в ходе этих операций не менялись, они неизменны. Просто переменная ссылалась то на один, то на другой. 
<p>
По сути, когда вы присваиваете переменной значение - в памяти "создаётся объект". Если дальше значение в этой переменной изменилось, и на старый объект она больше не ссылается - то (при условии, что на старый объект не ссылается какая-нибудь другая переменная) так называемый "Сборщик мусора" (встроенная, автоматическая штука в компиляторе Python, которая облегчает нам всем жизнь) уничтожает этот самый объект (когда на него больше никакая переменная не ссылается, значит - он в памяти больше не нужен). 
<p>
Так что да, технически - объекты этих типов не изменяемы. Надеюсь, не слишком сумбурно изложил.</i>
<p>
Ещё:<br>
<i>В Python есть изменяемые и неизменяемые типы. Изменяемые отличаются тем, что их содержимое можно сменить, не изменив ссылку на них. Неизменяемые объекты приходится пересоздавать, чтобы отразить изменения состояния. При этом все старые ссылки не видят это обновление, потому что указывают на старый объект.
<p>
Поясню на практике. Списки, словари, множества - это изменяемые объекты:
<pre>
l1 = [1, 2, 3]
l2 = l1
print(l1, l2, id(l1), id(l2))  
# [1, 2, 3] [1, 2, 3] 139917408901064 139917408901064

l1[1] = 10
print(l1, l2, id(l1), id(l2))  
# [1, 10, 3] [1, 10, 3] 139917408901064 139917408901064</pre>
Числа, строки, кортежи - это неизменяемые объекты:
<pre>
v1 = 1024
v2 = v1
print(v1, v2, id(v1), id(v2))
# 1024 1024 ...7040 ...7040

v1 = 2048
print(v1, v2, id(v1), id(v2))
# 2048 1024 ...5312 ...7040

t1 = (1, 2, 3)
t2 = t1
print(t1, t2, id(t1), id(t2))
# (1, 2, 3) (1, 2, 3) ...6232 ...6232

# t1[1] = 10  # не сработает, так как кортежи неизменяемые
t1 = (1, 10, 3)
print(t1, t2, id(t1), id(t2))
# (1, 10, 3) (1, 2, 3) ...7240 ...6232</pre></i>


<h3><a name="number">Числа:</h3>
Типы int и float
<p>
Все объекты в Python принадлежат какому-то классу или, другими словами, у всех данных есть свой определенный тип. Чтобы узнать тип данных, можно воспользоваться следующим кодом:
<pre>
print(type(5))
print(type(5.8))</pre>
В первом случае будет выведен результат &lt;class 'int'&gt;, а во втором - &lt;class 'float'&gt;. Целые числа принадлежат классу int, дробные - классу float.
<p>
Тип можно менять:
Функция int(x) - преобразует число x типа float (вещественное) в число типа int (целое)
<pre>
>>> x=2.7666
>>> print(int(x))
2</pre>
float(x) наоборот выводит число int типа в типе float
<pre>
>>> x=7
>>> type(x)
&lt;class 'int'&gt;
>>> print(float(x))
7.0
>>> type(x)
&lt;class 'int'&gt;
>>> print(x)
7</pre>
Нужно иметь в виду, что объекты: числа строки являются неизменяемыми, потому x=7 в примере выше не изменилось, только вывод функции в другом формате.
<p>
<ul>
<li> <b>Операции с числами</b><br>
Над объектами из классов int и float можно производить стандартные арифметические операции:
<pre>
print(5+7)
print(10-4)
print(64/8)
print(9*8+25/5)</pre>

В Python есть 3 типа делений:
<pre>
print(17/2) #обычное деление - результат - число с плавающей точкой (вещественное) 8.5
print(17//2) #целочисленное деление, результат - целая часть при делении
print(17%2) #деление с остатком - результат 1, остаток при делении</pre>
Обратите внимание на текст после знака #. Так в Python обозначаются комментарии. Эта часть кода не обрабатывается интерпретатором, она нужна для вас и других разработчиков, которые будут работать с кодом.
<p>
Многострочные комментарии делаются с помощью тройных кавычек:
<pre>
'''Различные варианты деления в Python
обычное деление
целочисленное деление
деление с остатком'''</pre>
<li> <b>Возведение в степень:</b>
<pre>
print(3**6)
print(10**(-1))
print(25**(1/2))</pre>
Результат выполнения этой программы:
<pre>
729 
0.1
5.0
</pre>
<li> <b>Приоритет арифметических операций</b><br>
Это хоть и кажется иногда очевидным, или несущественным, но на самом деле крайне важно.<br>
Сначала идут выражения в скобках<br>
Затем операция возведения в степень<br>
Затем умножение и деление (обычное, целочисленное)<br>
Сложение и вычитание<br>
При равном приоритете операции выполняются слева направо<br>
Любые арифметические операции выше по приоритету операций сравнения и логических операторов.
<p>
<li> <b>Приоритет логических операций</b><br>
Операция and имеет более высокий приоритет чем or:
<pre>
>>> print(7>5 or 6<10 and 10>11)
True</pre>
Здесь сначала будет выполняться правый логический оператор (and), а потом только левый (or).
<p>

<li> Вещественные числа можно записывать в таком формате: 5e-1 - это число 0,5. Здесь e - это экспонента, равная 10. -1 - это степень.<br>
1234e-2 - это 12,34<br>
<pre>
>>> 23e3
23000.0</pre>

<li> <b>Операторы приращения</b><br>
Сумму x = x + 3 можно записать по-другому: x += 3<br>
Другие операторы приращения:
x -=i это x = x - i<br>
x *=i это x = x*i<br>
x /=i это x = x / i<br>
x //=i это x = x // i<br>
x %=i это x = x % i<br>
x **=i будет означать команду x = x ** i
</ul>



<h3><a name="string">Строки</h3>
<ul>
<li> Строки относятся к классу <font color=red>str</font>
<p>
<li> Строчные переменные можно задать 3 способами:<br>
<ol>
<li> s1="stroka"
<li> s2='stroka'
<li> s3="""stroka""""
</ol>
Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, не используя экранированные последовательности.
<pre>
>>> string = '"sp"am"'
>>> print(string)
"sp"am"
>>> string = "'sp'am'"
>>> print(string)
'sp'am'</pre>
Тройные кавычки позволяют создавать многостроковые комментарии:
<pre>
""" stroka1
    stroka2
    stroka3 """</pre>
    
<li> Строки имеют индесацию<p>

<li> Если хотим вызвать все символы по отдельности с строки, то можно использовать цикл:
<pre>
s = 'stroka'
for i in s:
    print(i)</pre>
    
<li> <b>Экранированные последовательности</b><br>
Экранированные последовательности позволяют вставить символы, которые сложно, или невозможно ввести с клавиатуры.
<ul>
<li> \n - перевод строки
<li> \f - перевод страницы
<li> \t - горизонтальная табуляция
<li> \v - вертикальная табуляция
</ul>

<li> "Сырые" строки - подавляют экранирование<br>
Если перед открывающей кавычкой стоит символ 'r' (в любом регистре), то механизм экранирования отключается.
<pre>S = r'C:\newt.txt'</pre>
"Сырая" строка не может заканчиваться символом обратного слэша. Его придётся добавлять (или убирать) вручную. Также неочевидно работает экранирование кавычек. Оно происходит, но символ обратного слэша также добавляется в строку. А не экранировать кавычку того же типа, что и в литерале, нельзя.

<li> Операции над строками<br>
Строка в Python ведёт себя как массив символов, а значит, можно применять индексы и срезы:
<pre>
>>> string = "Привет, pyplanet"
>>> string[0]
'П'
>>> string[-1]
't'
>>> string[8:]
'pyplanet'
>>> string[::-1]
'tenalpyp ,тевирП'
>>> string[::2]
'Пие,ppae'</pre>

<li> Строки можно складывать. При сложении они склеиваются.
<pre>
str1 = 'Hello, '
str2 = 'world!'
print(str1+str2)</pre>
Результат: “Hello, world!”
<p>
<li> Строку можно умножить на число:
<pre>print(str1*5)</pre>
Результат - это повторение строки str1 5 раз.
<p>
<li> Часто нам будет полезно уметь определять длину строки. Для этого существует функция len( ):
<pre>
print(len('строка'))</pre>
<li> Обратите внимание, что когда мы считываем данные с помощью функции input( ), мы считываем именно строковый тип. Если мы в 
дальнейшем хотим работать с введенными данными как с числами, то можно воспользоваться приведением типов:
<pre>
a = int(input())
b = float(input())
</pre>

<li> <b>Строки являются неизменяемыми:</b>
<pre>
>>> s='asdf'
>>> s[0]='a'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment</pre>
объект 'str' не поддерживает назначение элемента
</ul>

<h4>Методы объекта строка</h4>
Полный список строковых методов есть в <a href="https://pyplanet.ru/article/string-methods.html">нашем справочнике</a>.
<p>
<ul>

<li> <b>replace()</b><br>
Метод replace() в Python используется для замены всех вхождений указанной подстроки в строке, на другую подстроку. Возвращает 
другую измененную строку.
<p>
Синтаксис
<br><b>str.replace(old, new[, count])</b>
<p>
где:
<br>str — строка, в которой нужно выполнить замену;<br>
old — подстрока, которую нужно заменить;<br>
new — новая подстрока, которой нужно заменить все вхождения old;<br>
count — необязательный параметр, который указывает, сколько раз нужно выполнить замену. По умолчанию заменятся все вхождения 
old.
<p>
Примеры использования метода replace()
<br>Допустим, у вас есть строка, в которой нужно заменить все вхождения одного символа на другой. В этом примере мы заменяем все запятые в строке на точки с помощью метода replace():
<pre>
s = '3,14'
new_s = s.replace(',', '.')
print(new_s) # '3.14'</pre>
<p>
<li> <b>count(arg)</b><br>
считает сколько раз в строке встречается символ(ы) arg
<pre>
s = input()
n = s.count('g') + s.count('G') + s.count('c') + s.count('C')
print(n * 100 / len(s))</pre>
<p>
<li> <b>upper()</b><br>
переводит строку в верхний регистр
<p>
<li> <b>lower()</b><br>
наоборот в нижний регистр
<p>
<li> <b>find(arg)</b><br>
выдает индекс arg в строке. Если arg не будет в строке, то результат будет -1<br>
более рекомендуется конструкция: <b>if 'arg' in s:</b><br>
Нужно иметь в виду, что метод создает новый объект, как результат выполнения метода, но оригинальный объект не меняется.
<p>
Синтаксис:
<pre>S.find(sub[, start[, end]]) -> int</pre>
Возвращает наименьший индекс в S, где находится подстрока sub, так что sub содержится в S[start:end].  Необязательные
аргументы start и end интерпретируются как в нотации slice.<br>
Возвращает значение -1 в случае сбоя.
<p>
<li> <b>strip()</b><br>
Функция strip() – это предопределенная библиотечная функция Python. Она используется для возврата копии исходной строки путем 
удаления начальных и конечных пробелов, символов, переданных в функцию strip().
<br>Другими словами, это функция строки, которая удаляет символы как с левого, так и с правого конца строки, указывая набор 
символов для функции strip() в качестве аргумента. По умолчанию она удаляет пробелы из начальной и конечной строки, если в 
функцию strip() в Python не передается аргумент.
<p>
Синтаксис<br>
<b>объект строки.strip('parametr')</b>
<p> 
Параметр strip() является необязательным. Если программист не передает какой-либо параметр функции strip(), она удаляет 
начальные и конечные пробелы из строк.<br>
Если набор заданного параметра передается в функцию strip(), она удаляет символы из исходной строки.<br>
Возвращаемое значение: возвращает другой объект строки, равной исходной минус удаленный набор символов (параметр) или пробелов 
в конце и начале исходной строки.
<pre>
>>> a = ' abcd e '
>>> b = a.strip()
>>> b
'abcd e'
>>> b = b.strip('e')
>>> b
'abcd '</pre>
</ul>


<li> <b>Срез (диапазон строки)</b><br>
Общий шаблон:
<pre>
s = 'stroka'
print(s[x1:x2:x3]</pre>
Здесь напечатается строка из символов, где x1 - это индекс первого нужного символа в строке. Если не указан, то по умолчанию 
равен 0 Может иметь отрицательное значение, тогда индекс считается с првой стороны, <b>но все равно далее символы смотрятся в 
правую сторону.</b><br>
x2 -  индекс последнего нужного символа. Может иметь отрицательное значение, то есть отсчет с правой стороны.<br>
x3 - шаг приращения индекса, если не указан, то по умолчанию 1. Может иметь отрицательное значение. s[::-1] просто перевернёт 
строку.
</ul>

<h4>Логический тип данных</h4>
В Python существует логический тип данных - класс bool. Переменные этого типа могут принимать только 2 значения: True и False. 
<p>


<h3>Тип данных None</h3>
В Python существует зарезервированное слово None, которое обозначает отсутствие типа.
<pre>
a = None
print(type(a))</pre>

<h3>Параметры функции print</h3>
<a href="https://shultais.education/blog/python-f-strings">5 способов форматирования строк</a>:
<ol>
<li> Конкатенация. Грубый способ форматирования, в котором мы просто склеиваем несколько строк с помощью операции сложения:
<pre>
>>> name = "Дмитрий"
>>> age = 25
>>> print("Меня зовут " + name + ". Мне " + str(age) + " лет.")
>>> Меня зовут Дмитрий. Мне 25 лет.</pre>
<p>
<li> %-форматирование. Самый популярный способ, который перешел в Python из языка С. Передавать значения в строку можно через 
списки и кортежи , а также и с помощью словаря. Во втором случае значения помещаются не по позиции, а в соответствии с именами.
<pre>
>>> name = "Дмитрий"
>>> age = 25
>>> print("Меня зовут %s. Мне %d лет." % (name, age))
>>> Меня зовут Дмитрий. Мне 25 лет.
>>> print("Меня зовут %(name)s. Мне %(age)d лет." % {"name": name, "age": age})
>>> Меня зовут Дмитрий. Мне 25 лет.</pre>
<p>
<li> Template-строки. Этот способ появился в Python 2.4, как замена %-форматированию (PEP 292), но популярным так и не стал. 
Поддерживает передачу значений по имени и использует $-синтаксис как в PHP.
<pre>
>>> from string import Template
>>> name = "Дмитрий"
>>> age = 25
>>> s = Template('Меня зовут $name. Мне $age лет.')
>>> print(s.substitute(name=name, age=age))
>>> Меня зовут Дмитрий. Мне 25 лет.</pre>
<p>
<li> Форматирование с помощью метода format(). Этот способ появился в Python 3 в качестве замены %-форматированию. Он также 
поддерживает передачу значений по позиции и по имени.
<pre>
>>> name = "Дмитрий"
>>> age = 25
>>> print("Меня зовут {}. Мне {} лет.".format(name, age)
>>> Меня зовут Дмитрий. Мне 25 лет.
>>> print("Меня зовут {name} Мне {age} лет.".format(age=age, name=name)
>>> Меня зовут Дмитрий. Мне 25 лет.</pre>
<p>
<li> f-строки. Форматирование, которое появилось в Python 3.6 (PEP 498). Этот способ похож на форматирование с помощью метода 
format(), но гибче, читабельней и быстрей.
<pre>
>>> name = "Дмитрий"
>>> age = 25
>>> print(f"Меня зовут {name} Мне {age} лет.")
>>> Меня зовут Дмитрий. Мне 25 лет.</pre>
f-строки делают очень простую вещь — они берут значения переменных, которые есть в текущей области видимости, и подставляют их 
в строку. В самой строке вам лишь нужно указать имя этой переменной в фигурных скобках.
<p>
С помощью f-строк можно форматировать дату без вызова метода strftime():
<pre>
>>> from datetime import datetime as dt
>>> now = dt.now()
>>> print(f"Текущее время {now:%d.%m.%Y %H:%M}")
>>> Текущее время 24.02.2017 15:51</pre>
<p>
</ol>
<p>Без параметров print() будет выводить в цикле результат на новой строке.
<p>
print('stroka', end='')<br>
Здесь результаты будут выводиться на одной строке через пробел.
<p>
Функция print(arg1, arg2, ..., argN) выводит аргументы через пробел. Если указать флаг sep="\n", то каждый аргумент 
выведется на новой строке, пример print(arg1, arg2 , sep="\n")
<p>
print(*list[])<br>
это "распаковка" списка (да и не только). позволяет вывести не список (с [] и запятыми между  элементами), а только элементы.
<p>


<h3>input()</h3>
<ul>
<li>
<pre>a, b = (int(i) for i in input().split())</pre>
<font color=red>В этой команде вводим число из нескольких цифр, функция split расщепляет это число на отдельные цифры и они 
присваиваются переменным a и b</font>
<br>Проверил, у меня если одно число ввести, то вызывает ошибку, что дескать нужно ввести два числа. Ввел 2 числа через пробел, теперь все верно, переменным присвоились эти значения.<p>
<li> <font color=brpwn>Команда input() выдает объект типа строка, даже если напечатаем число</font>. Поэтому с числа надо input приводить к типу int или float.
</ul>





<h3 align=center><a name="list" href="https://pyplanet.ru/article/array-list.html">Список</a></h3>
<b>Список</b> - переменная, содержащая список данных (элементов), внутри квадратных скобок идущих через запятую. Элементы строки можно в отличии от строки изменять.
<pre>
list = [] # пустой список
array = [1, 2, 3, 4, 5, 6, 7] # список из целых чисел int
print(type(array)) # класс list
ar = [2, 4.6, 'str', [1, 2, 3]] # список, состоящий из целого числа,
# из числа с плавающей точкой, из строки и из списка
</pre>

<h4>Индексация списков:</h4>
Индексация элементов списка имеет 2 способа, традиционная с 0 и с конца списка с -1.
Например есть список a = [1, 2, 3, 4]<br>
Тогда по обычной индексации элемент 1 имеет индекс 0 (a[0] = 1, a[1] = 2, a[2] = 3, a[3] = 4)<br>
По индексации с конца последний элемент имеет индекс -1 и далее левее на -1 индекс растет: a[-1] = 4, a[-2] = 3, a[-3] = 2, a[-4] = 1
<br>Индекс, в общем случае, не обязан быть числом. К элементам хеш-таблиц (которые мы рассмотрим позже) можно обращаться по строковому индексу.<br>
Также, поскольку списки - изменяемый тип данных, то по индексу возможно присвоение:
<pre>
>>> array = [1, 2, 3, 0, 1.4, -2]
>>> array[1] = 42
>>> array
[1, 42, 3, 0, 1.4, -2]</pre>
    
<h3>Методы списка</h3>
<p>
<img src="./images/python_base.png">
<p>
<ul>
<li> <b>append()</b><br>
<pre>array.append(8)</pre>
В список array добавили элемент 8 с помощью метода append.
<p>
Другой способ добавления в конец списка нового элемента - оператор приращения:
<pre>array +=[8]</pre>
Интересный пример по этому случаю:
<pre>
>>> students = ['Ivan', 'Masha', 'Sasha']
>>> students += ['Olga']
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga']
>>> students += 'Olga'
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a']</pre>
Видна разница между добавлением элемента с помощью модуля append и оператором +=.<br>
И списки, и строки - это последовательности (см. https://docs.python.org/3/library/stdtypes.html?highlight=mutable%20sequence#) . 
<br>+= складывает список с элементами последовательности ﻿по отдельности.
<br>А append прибавляет к списку новый элемент списка, сколько бы вложенных элементов в этом элементе ни было .
<br>Продолжение:
<pre>
>>> students += ['Dmitriy', 'Alexei']
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei']
>>> students.append(['Anna', 'Elena'])
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei', ['Anna', 'Elena']]</pre>
<p>

<li> <b><a href="https://skillbox.ru/media/code/kak-udalit-element-iz-spiska-v-python/">Способы удаления элементов из списка:
</a></b>
<p>
<ol>
<li> <b>remove() - удаление <b>одного</b> элемента из списка по имени</b><br>
Параметров может быть только один, то есть можно удалить за раз только один элемент:
<pre>
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei', ['Anna', 'Elena']]
>>> students.remove('o', 'l', 'g', 'a', ['Anna', 'Elena'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: remove() takes exactly one argument (5 given)
>>> students.remove(['Anna', 'Elena'])
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei']</pre>
<p>
<li> <b>Метод pop(): удаление по индексу</b><br>
pop() подойдёт, когда известно точное местоположение удаляемого элемента. В качестве аргумента pop() получает индекс, а 
возвращает удалённое значение:
<pre>
>>> lst = [1, 2, 3, 5]
>>> lst.pop(3)
5
>>> print(lst)
[1, 2, 3]</pre>
Если передать отрицательное значение, то pop() будет считать индексы не с нуля, а с -1
<p>
Если оставить pop() без аргумента, то удалится последний элемент — потому что -1 является аргументом по умолчанию.
<p>
При попытке обратиться в методе pop() к несуществующему индексу, интерпретатор выбросит исключение IndexError.

<p>
<li> <b>Метод clear(): очищение списка</b>
clear() удаляет из списка всё, то есть буквально очищает его. Он не принимает аргументов и не возвращает никаких значений:
<pre>
print(lst)
[1, 2, 3]
>>> lst.clear()
>>> print(lst)
[]</pre>
<p>
<li> <b>Ключевое слово del: удаление срезов</b><br>
del, как и метод pop(), удаляет элементы списка по индексу. При этом с его помощью можно избавиться как от единичного объекта, 
так и от целого среза:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[2]
print(new_list)

>>> ['ноль', 1, 3, 'IV']</pre>
Если передать срез, то элемент с правым индексом не удалится. В примере ниже это строка 'IV':
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[1:4]
print(new_list)

>>> ['ноль', 'IV']</pre>
Чтобы очистить список, достаточно передать полный срез [:]:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[:]
print(new_list)

>>> []</pre>
Также del можно использовать с отрицательными индексами:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[-4]
print(new_list)

>>> ['ноль', [2.1, 'два и два'], 3, 'IV']</pre>
Со срезами это тоже работает:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[-3:-1]
print(new_list)

>>> ['ноль', 1, 'IV']</pre>
Если при удалении единичного элемента указать несуществующий индекс, то Python выдаст ошибку IndexError.

</ol>
<p>
<li> <b>sort()</b> - сортировка элементов по возрастанию
<pre>
>>> students.sort()
>>> students
['Alexei', 'Dmitriy', 'Ivan', 'Masha', 'Olga', 'Sasha', 'a', 'g', 'l']</pre>
Здесь строки отсортировались по алфавитному порядку, буквы также по алфавиту, но после строк.
<p>
Второй способ, использовать функцию sorted():
<pre>
>>> number = [1, 1000, 6, 9, 4, 0]
>>> sorted(number)
[0, 1, 4, 6, 9, 1000]
>>> number
[1, 1000, 6, 9, 4, 0]</pre>
В отличии от метода sort() функция sorted() не меняет порядок списка
<p>
x = ['abc', 'a', 'ab', 'abcd']<br>
Сортировка элементов списка по возрастанию:
<pre>
# 1
x.sort(key=len) # по длине
print(x)
['a', 'ab', 'abc', 'abcd']

# 2
new_x = sorted(x, key=len)
print(new_x)
['a', 'ab', 'abc', 'abcd']
В обратном порядке:

# 1
x.sort(key=len, reverse=True)
print(x)
['abcd', 'abc', 'ab', 'a']

# 2
new_x = sorted(x, key=len, reverse=True)
print(new_x)
['abcd', 'abc', 'ab', 'a']</pre>
Разница между sort() и sorted() в том, что первый - сортирует список на месте, возвращая None (нет нового списка, а 
пероначальный меняется). Второй - возвращает новый отсортированный список.
<p>
Так же, можно сортировать словари.
<pre>
x = {1: 'a', 3: 'ab', 2: 'abc'}
 По ключам:

x = dict(sorted(x.items()))
print(x)
{1: 'a', 2: 'abc', 3: 'ab'}
По значениям:

x = dict(sorted(x.items(), key=lambda e:e[1]))
print(x)
{1: 'a', 3: 'ab', 2: 'abc'}</pre>
<p>

<li> <b>insert(par1, par2)</b><br>
Вставка элемента par2 по индексу par1
<pre>
>>> list = [0, 2, 3, 4]
>>> list.insert(1, 1)
>>> list
[0, 1, 2, 3, 4]
</pre>

<li> <b>Метод  reverse()</b><br>
Этот метод перевернет список в обратном порядке.
<p>
Функция reversed() делает тоже самое.
</ul>
<h4>Функции</h4>
<font color=red>Чем вообще функции отличаются от методов?</font>
<p>
<ul>
<li> <b>Функция reversed()</b><br>
В Python 3 встроена специальная функция reversed(), в качестве аргумента она принимает список или строку, а возвращает 
итератор последовательности значений, состоящей из всех элементов аргумента в обратном порядке.
<p>
<li> <b>Функция sum()</b><br>
Для суммирования элементов списка.<br>
Она принимает два аргумента:
<p>
iterable — итерируемый объект (например, список), элементы которого нужно суммировать.
<p>
start (необязательный) — начальное значение суммы. По умолчанию равно 0.
<p>
Пример использования:
<pre>
numbers = [1, 2, 3, 4, 5]
total = sum(numbers)
print(total)</pre>
В этом примере sum(numbers) возвращает сумму всех элементов списка numbers.
<p>
<li> <b>Функции max() и min()</b><br>
Эти функции возвращают максимальное и минимальное значение из списка.
<p>
<li>
Можно определить длину списка new_array:
           <pre>
           len(new_array)
           </pre>
Найти сумму элементов списка:
           <pre>
           sum(new_array)
           </pre>

<li> Списки можно складывать (склеивать):
           <pre>array2 = [9, 10]
                new_array = array + array2
                new_array = [0, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                </pre>

<li> <b>Списки можно умножать</b>:
<pre>
>>> list=['f',4,5,'r']
>>> list
['f', 4, 5, 'r']
>>> list*5
['f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r']
>>></pre>

<li> <b>Как узнать входит ли 'stroka' в список list</b>
<pre>
if 'stroka' in list:
    # true, входит
else:
    # false, не входит</pre>
Можно для этой цели использовать модуль index(var):
<pre>
>>> students.index('Sasha')
2</pre>
Здесь если строка Sasha входит в список, то вернется индекс этого элемента, иначе вернет ошибку.
<p>
<li> <b>Присвоение списков</b><br>
В питоне:
<pre>
>>> a = [1, 2, 3, 4]
>>> b = a
>>> b
[1, 2, 3, 4]
>>> a[3] = 10
>>> a
[1, 2, 3, 10]
>>> b
[1, 2, 3, 10]</pre>
Видно, что если изменили значение элемента в списке a, то изменится и список b, хотя обычно в других языках так не должно 
быть.<br>
<i>Когда вы пишите  a = [1, 2, 3], то а лишь указывает на список  [1, 2, 3], это как ярлык, который вы прикрепили к данному 
списку.
Затем, делая b=a, вы не копируете список, вы просто создаете новый ярлык к списку, на который указывает а.
Изменяя a, вы меняете также b. Потому﻿ что они указывают на один и тот же список.</i><br>
Чтобы a и b открепить друг от друга, нужно одному из них присвоить новый список (или любой объект другого типа).
</ul>




<h3 align=center><a name="gener">Генератор коллекций</h3>
<i>не стоит путать «генераторы коллекций» (comprehensions, они же «включения») и «генераторы-итераторы». Первые — мощный 
синтаксический сахар для генерации коллекций «на лету», вторые — способ получения значений по запросу. </i>

<h4>Генерация списков:</h4>
Список можно создавать с помощью так называемых генераторных выражений, шаблон:
<pre>(выражение for j in итерируемый объект if условие)</pre>
Где for, in, if — ключевые слова, j — переменная.
<p>
Пример: <pre>a = (i**2 for i in range(1,5))</pre>
<pre>num = [int(i) for i in input().split()]</pre>
Если на вход подавать числа, то на выходе будет список из чисел.<br>
Если же для получения списка использовать попроще конструкцию:
<pre>num = input().split()</pre>
то здесь даже если подавать на вход числа, на выходе будет список из односимвольных строк.
<pre>
>>> numbers = [int(i) for i in input().split()]
1 3 5 6 10
>>> numbers
[1, 3, 5, 6, 10]
>>> num = input().split()
1 3 5 6 10
>>> num
['1', '3', '5', '6', '10']</pre>

<h4>Генерация словарей:</h4>
Общий шаблон генераторов словарей в Python:
<pre>
dict_variable = {key:value for (key,value) in dictonary.items()}</pre>
Это самый простой вариант генератора. При добавлении условий код усложнится.
<p>
Генератор словарей — мощная концепция, которую можно использовать для замены циклов и лямбда-функций. При этом не все циклы for могут быть записаны как генератор словаря, но любой генератор можно переписать с использованием цикла for.
<p>
Рассмотрим следующую задачу. Вы хотите создать новый словарь, где ключами будут четные числа в диапазоне от 0 до 10, а значениями — квадраты этих чисел.
<p>
Давайте посмотрим, как можно решить эту проблему, используя цикл for и генератор словарей:
<pre>
numbers = range(10)
new_dict_for = {}
# Добавляем значения в `new_dict` с помощью цикла for 
for n in numbers:
    if n%2==0:
        new_dict_for[n] = n**2
print(new_dict_for)
# {0: 0, 8: 64, 2: 4, 4: 16, 6: 36}
# Используем генератор словаря
new_dict_comp = {n:n**2 for n in numbers if n%2 == 0}
print(new_dict_comp)
# {0: 0, 8: 64, 2: 4, 4: 16, 6: 36}</pre>

<h4>Инверсия словаря</h4>
<pre>
d = {'A': 1, 'B': 2, 'C': 3}
 
    inverse_dict = {v: k for k, v in d.items()}
    print(inverse_dict)            # {1: 'A', 2: 'B', 3: 'C'}</pre>

<p>
<h3 align=center><a name="table">Прямоугольная матрица</h3>
Иногда нам приходится использовать таблицы с данными для решения своих задач. Такие таблицы называются матрицами или двумерными массивами.
<p>
В Python подобные таблицы можно представить в виде списка, элементы которого являются другими списками.
<p>
Создать такой массив в Python можно разными способами. Первый способ:
<pre>
# Создание таблицы с размером 3x3, заполненной нулями
a = 3           
mas = [0] * a 
for i in range(a): 
    mas[i] = [0] * a 
print(mas) # Выведет [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</pre>

Второй способ предполагает создание пустого списка с добавлением в него новых списков. Рассмотрим на примере:
<pre>
# Создание таблицы с размером 2x2, заполненной единицами
a = 3
mas = [] 
for i in range(a): 
    mas.append([1] * a)
print(mas) # Выведет [[1, 1, 1], [1, 1, 1], [1, 1, 1]]</pre>
                                 
Третьим и самым простым способом является генератор списков с x строками, которые будут состоять из y элементов. Пример: 
<pre>
# Создание таблицы с размером 3x3, заполненной двойками
a = 3
mas = [[2] * a for i in range(a)]
print(mas) # Выведет [[2, 2, 2], [2, 2, 2], [2, 2, 2]]</pre>
4 способ:  
<pre>a = [[0 for j in range(m)] for i in range(n)]</pre>
Здесь получаем матрицу из n строк и m  столбцов, заполненную нулями.
<p>
Для обработки и <b>вывода двухмерных списков</b> используются два вложенных цикла. Первый цикл – по порядковому номеру строки, второй – по ее элементам. Например, вывести массив можно так:
<pre>
mas = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
for i in range(0, len(mas)):
    for i2 in range(0, len(mas[i])):
        print(mas[i][i2], end=' ')
    print()
# Выведет
1 1 1
1 1 1
1 1 1</pre>
То же самое можно сделать не по индексам, а по значениям массива:
<pre>
mas = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
for i in mas: 
    for i2 in i: 
        print(i2, end=' ') 
    print()
# Выведет
1 1 1
1 1 1
1 1 1
</pre>
</ul>        
        
        

        



<h3 align=center><a name="set" href="https://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html">Множества (set и frozenset)</a></h3>
Множество - объект, который содержит неповторяющие элементы. Оформляется с помощью фигурных скобок.<br>
some_set = {1, 2, 3...}<br>
Но если попробуем так:<br>
test = {}<br>
то создадим не множество, а словарь.
<p>
Пустое множество создается с помощью функции set():<br>
some_set = set()
<p>
<pre>
for _ in range(int(input())):
    wrd |= {i.lower() for i in input().split()}</pre>
Здесь wrd |= {...} отвечает за добавление множества {...} в единое wrd (аналог метода update)
<p>
из stackoverflow:<br>
| - объединяет
<p>
|= -обновляет
<pre>
>>> d1 = {"a": 0, "b": 1, "c": 2}
>>> d2 = {"c": 20, "d": 30}

>>> # Merge, | 
>>> d1 | d2
{"a": 0, "b": 1, "c": 20, "d": 30}
>>> d1 
{"a": 0, "b": 1, "c": 2}

>>> # Update, |=
>>> d1 |= d2
>>> d1 
{"a": 0, "b": 1, "c": 20, "d": 30}</pre>

<h4>Особенности set</h4>
Может содержать только неизменяемые элементы (числа, строки, кортежи - может; списки, другие множества - не может)<br>
Порядок элементов не определён<br>
<b>Индексация элементов отсутствует</b><br>
Особенности связаны с тем, что внутри множества в Python реализованы хеш-таблицей. Если кратко, то от каждого элемента мы 
вычисляем хеш-функцию, и её значение - это индекс в каком-то большом заранее выделенном массиве.
<p>
Отсюда также следует, что для поиска элемента в большом массиве выгоднее (по скорости) использовать множества, а не списки.
<p>
Перебрать элементы множества можно обычным способом с помощью цикла:<br>
<b>for element in some_set:</b>
<p>
<b>Методы множества:</b><br>
<b>Метод add</b><br>
Метод add добавляет элементы в множество. Если элемент уже есть в множестве, то он не дублируется и множество остается в 
исходном состоянии. Элемент добавляется в произвольном порядке, его позиция для множества четко не определяется. В параметре 
метода передаем элемент, который хотим добавить.
<p>
Синтаксис<br>
множество.add(что добавляем)<br>
Пример <br>
Давайте добавим к нашему множеству новый элемент:
<pre>
st = {'a', 'b', 'c'}
st.add('e')
print(st)</pre>
Результат выполнения кода:
<p>
{'e', 'b', 'c', 'a'}
<p>
Пример<br>
А теперь давайте добавим уже существующий элемент:
<pre>
st = {'a', 'b', 'c'}
st.add('b')
print(st)</pre>
После выполнения кода нам вернется наше множество:
<br>{'b', 'a', 'c'}


<li> <h4>Frozenset</h4>
frozenset - это неизменяемое множество. Создано по аналогии с парой список - кортеж, имеет те же самые особенности по сравнению с множеством, что и кортежи по сравнению со списками. Создаётся только с помощью функции frozenset(), своего литерала (как кортеж) не имеет.
<p>
frozenset может использоваться в качестве элементов set.

<h4>Методы множества</h4>
<ol>
<li> name_set.add(element)<br>
Добавляем element в name_set. Если element уже есть, то не добавится.
<p>
<li> name_set.remove(element)<br>
Удаляет element из множества. Если этого элемента нет в множестве, то возникнет ошибка.
<p>
<li> name_set.discard(element)<br>
Аналогично методу remove, только при удалении несуществующего элемента, ошибки не возникнет. 
<p>
<li> name_set.clear(element)<br>
Удалит все элементы множества.
</ol>






<h3 align=center><a name="typle" href="https://pyplanet.ru/article/tuple.html">Кортежи</a></h3>
Кортежи - почти как изученные нами ранее списки, за исключением того, что они неизменяемы.
<p>
Как создаётся кортеж?<br>
Кортеж создаётся способом, походим на то, каким создаются списки, только вместо квадратных скобок - круглые.
<pre>a = (1, 2, 3, 0, -1, 2)</pre>
Скобок может вообще не быть:
<pre>a = 1, 2, 3, 0, -1, 2</pre>
Пустой кортеж:
<pre>a = ()</pre>
А вот кортеж из одного элемента выглядит иначе:
<pre>a = (1, )</pre>
Здесь обязательна запятая, иначе Python не сможет отличить одноэлементный кортеж от просто числа.
<p>
Зачем нужен кортеж, если есть списки?
<ul>
<li> Кортежи занимают немного меньше памяти и работают чуть быстрее до тех пор, пока вы не собираетесь изменять его содержимое
<li> Кортежи лучше защищены от ненамеренного изменения данных
<li> Кортежи могут быть использованы в местах, требующих неизменяемый тип данных
<li> Некоторые функции работают только с кортежами
</ul>
С кортежами можно работать так же, как и со списками, кроме методов, изменяющих список (таких, как append, extend, pop, sort и 
др.). Также есть доступ по индексу, есть срезы (только срез кортежа вернёт кортеж, а не список). 






<h3 align=center><a name="diction" href="https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html">Словарь</a></h3>

<b>Словарь</b> (хэш, ассоциативный массив) - это изменчивая структура данных для хранения пар key-value, где value однозначно 
определяется ключом.<br>
В качестве ключа может выступать неизменчивый тип данных (число, строка, кортеж и т.п.).<br>
Порядок пар ключ-значение произволен (словарь не имеет индекса, вместо индекса ключ).<br>
value может быть строкой, числом, списком.<br>
Задается с помощью фигурных скобок (как множество):
<pre>
       var_dictionary={
                       key1:value1,
                       key2:value2,
                       key3:value3
                      }</pre>
Пример:
<pre>dictionary = {'dog' : 'собака', 'table' : 'стол', 'computer': 'компьютер'}</pre>
Мы можем обращаться к значениям словаря по ключу.
<pre>
print(dictionary['dog'])  # печатаем строку 'собака'
dictionary['dog'] = 'пес' # изменяем значение 'собака' на 'пес'
dictionary['laptop'] = 'ноутбук' # добавляем новый элемент с ключом 'laptop' и значением 'ноутбук' в словарь
del dictionary[dog]       # удаляется пара ключ-значение с данным ключом
</pre>

<b><a href="https://pythonist.ru/kak-dobavit-element-v-slovar/">Как добавить элемент в словарь</a></b><br>
В отличие от списков и кортежей, в работе со словарями методы add(), insert() и append() вам не помощники. Тут необходимо 
создать новый ключ. Позже он будет использоваться для хранения значения.
<p>
Добавляются элементы в словарь так:
<pre>dictionary_name[key] = value</pre>
Рассмотрим пример, чтобы разобраться. В нашем словаре было четыре пары ключ-значение. Этот словарь отражает количество 
булочек, которые продаются в кафе.
<p>
Допустим, мы испекли 10 вишневых булочек. Теперь нам нужно внести их в словарь. Сделать это можно так:
<pre>
scones = {
    "Фрукты": 22,
    "Пустая": 14,
    "Корица": 4,
    "Сыр": 21
}
scones["Вишня"] = 10
print(scones)</pre>
Вывод: 
<pre>
 {'Фрукты': 22, 'Овощи': 14, 'Корица': 4, 'Сыр': 21, 'Вишня': 10}</pre>
Как видите, мы добавили в словарь ключ Вишня и присвоили ему значение 10.
<p>
Сперва мы объявили словарь scones, хранящий информацию о булочках, которые доступны к заказу в нашем кафе. Потом мы добавили в 
наш словарь ключ Вишня и присвоили ему значение 10:
<br> scones["Вишня"] = 10<br>
И, наконец, мы вывели в консоль обновленную версию словаря. 
<p>
добавление и обновление происходит одинаково
Тем же способом мы можем обновить значение ключа. Допустим, мы испекли еще 10 булочек с корицей. Обновить значение этого ключа 
можно так:
<pre>
scones = {
    "Фрукты": 22,
    "Пустая": 14,
    "Корица": 4,
    "Сыр": 21
}
scones["Корица"] = 14
print(scones)</pre>
Вывод: 
<pre>
 {'Фрукты': 22, 'Пустая': 14, 'Корица': 14, 'Сыр': 21}</pre>
То есть, тем же способом мы можем установить новое значение какому-либо ключу. В нашем случае мы присвоили Корица значение 14.

<b>Как добавлять элемент в словарь в цикле:</b>
<pre>
# input data for dict
keys = ['Name', 'Website', 'Topic', 'Founded']
values = ['GeeksforGeeks', 'https://www.geeksforgeeks.org/', 'Programming', 2009]

# creating  an empty dictionary
output = {}

# adding items to the dictionary using a loop
for i in range(len(keys)):
    output.update({keys[i]: values[i]})</pre>
<br>Словарь:
<pre>
dictionary = {
            'dog': 'собака', 'table': 'стол', 'computer': 'компьютер', 'apple': 'яблоко', 1: 'yyy', 0: ['qq', 'ww']}
</pre>
Цикл по всему словарю:
<pre>
<b>for key, val in dictionary.items():</b>   
    print(key, val)
</pre>
Выполнит:
<pre>
dog собака
table стол
computer компьютер
apple яблоко
1 yyy
0 ['qq', 'ww']
</pre>
<b>Цикл по ключам словаря:</b><pre>
for key in dictionary.keys():
   print(key, dictionary[key])
</pre>
Выполнит:
<pre>
dog собака
table стол
computer компьютер
apple яблоко
1 yyy
0 ['qq', 'ww']
</pre>
Можно и так: <b>for key in some_dict:</b>
<p>
<b>Цикл по значениям словаря:</b><pre>
for val in dictionary.values():
    print(val)<br>
собака
стол
компьютер
яблоко
yyy
['qq', 'ww']</pre>
<b>Пополняется словарь dictionary из другого diction2:</b><pre>
diction2={'orange':'мандарин'}
dictionary.update(diction2)
print(dictionary)</pre>
{'dog': 'собака', 'table': 'стол', 'computer': 'компьютер', 'apple': 'яблоко', 1: 'yyy', 0: ['qq', 'ww'], 'orange': 'мандарин'}<p>
<b>Получить одновременно и ключ и значение:</b><br>
for key, value in some_d.items():
<p>
<b>Количество пар в словаре:</b><br>
print(len(dictionary))
<p>
Если попытаемся получить значение в словаре по несуществующему ключу (dict[key]), то получим ошибку. Чтобы не возникало ошибки, используем метод get(key), который вернет объект None, если такого ключа нет.
<p>
<b>Методы словаря</b><br>
<ul>
<li> <b>update()</b><br>
Функция добавляет элемент(ы) в словарь, если ключ отсутствует в словаре. Если ключ находится в словаре, он обновляет ключ новым значением.
<br>Синтаксис: dict.update([other])
<p>
Если update() в Python вызывается без передачи параметров, словарь остается без изменений.
<br>Команда обновляет словарь элементами из объекта словаря или повторяемого объекта пар ключ/значение. Он не возвращает никакого значения (не возвращает None).
<pre>
d = {1: "one", 2: "three"}
d1 = {2: "two"} # updates the value of key
d.update(d1)
print(d)
d1 = {3: "three"} # adds element with key
d.update(d1)
print(d)</pre>
Выход:<br>
{1: 'one', 2: 'two'}<br>
{1: 'one', 2: 'two', 3: 'three'}

</ul>
        
        
        
<h3 align=center><a name="srez" href="https://pyplanet.ru/article/slice.html">Срезы массивов</a></h3>
Иногда необходимо выбрать подмножество массива: убрать первые или последние элементы, выбрать только чётные или нечётные 
элементы.
<p>
Конечно, можно проходить по списку с помощью цикла for, в этом цикле писать условия, и записывать нужный диапазон значений в 
новый массив. Однако в Python есть инструмент, с помощью которого это делать проще.
<p>
Этот инструмент называется срезы (slice).
<p>
<b>Синтаксис срезов:</b></br>
<pre>array[start:stop:step]</pre>
Похоже на взятие по индексу, но здесь у нас вместо одного - 3 целых числа. Начать с индекса start (включая его), закончить на 
индексе stop <b>(не включая его)</b>, с шагом step.
<p>
Например, возьмём срез со второго по третий элемент с шагом 1:
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[1:3:1]
[4, 3]</pre>
Каждый из аргументов может быть опущен. Если опущен start, то он полагается равным нулю; stop - длине массива, step - единице. 
Срез совсем без аргументов вернёт просто копию массива:
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[:]
[1, 4, 3, 3, -2]</pre>
<b>Выбрать чётные и нечётные элементы:</b>
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[::2]
[1, 3, -2]
>>> array[1::2]
[4, 3]</pre>
Аргументы могут быть отрицательными: в случае со start и stop это будет означать нумерацию с конца массива; В случае со step 
элементы среза будут идти в обратном порядке:
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[::-1]
[-2, 3, 3, 4, 1]</pre>
И, поскольку срез списка возвращает список, его можно использовать: присваивать переменной, итерировать в цикле for или while, 
или любым другим необходимым программисту способом.





<h3 align=center><a href="">Форматирование строк</a></h3>
Иногда нужно напечатать строку, в которой присутствует пользовательский ввод. Например, напечатать "Привет, name", где name - 
это введённое пользователем имя.
<p>
Можно это сделать с помощью конкатенации строк, например:
<pre>
name = input("Как вас зовут?")
print("Привет, " + name)</pre>
Однако, если строки станут сложнее, и подстановок станет больше, то выражение, получающееся при применении всех сложений, будет слишком громоздким.<br>
Для облегчения подобных распространённых задач в Python существуют инструменты форматирования строк, аж целых 3.
<h4>Форматирование при помощи оператора %</h4>
Этот оператор форматирования - наследник форматирования строк из языка C, где были строковые подстановки. Если у нас один аргумент для подстановки, то через процент (так же, как и остаток от деления) пишется переменная для подстановки:
<pre>
name = input("Как вас зовут?")
print("Привет, %s" % name)</pre>
Если несколько переменных - то подставлять нужно кортеж (список не подойдёт!) значений.
<pre>
>>> print("Привет, %s, %d лет" % ("Вася", 35))
Привет, Вася, 35 лет</pre>
Спецификаторы преобразования (это те, что %s, %d и т.д.) записываются в следующем порядке:
<ol>
<li> %
<li> Ключ отображения (необязательно), состоящий из последовательности символов в круглых скобках (например, (somename))
<li> Флаги преобразования
<li> Минимальная ширина поля
<li> Точность, начинается с '.', затем - желаемая точность
<li> Модификатор длины (опционально)
<li> Тип преобразования
</ol>
Поясню каждый пункт подробнее.
<p>
2. Есть возможность подставить словарь значений
<pre>
>>> print("Привет, %(name)s, %(age)d лет" % {"name": "Вася", "age": 35})
Привет, Вася, 35 лет</pre>
3. Это флаги, отвечающие за особое отображение чисел. В примере ниже мы отображаем знак числа
<pre>
>>> print("Привет, %s, %+d лет" % ("Вася", 35))
Привет, Вася, +35 лет</pre>
4. Минимальная ширина поля полезна для выравнивания
<pre>
>>> print("Привет, %s, %3d лет" % ("Вася", 35))
Привет, Вася,  35 лет
>>> print("Привет, %s, %3d лет" % ("Вася", 100))
Привет, Вася, 100 лет</pre>
5. Позволяет более точно управлять дробными значениями
<pre>
>>> print("Привет, %s, %.2f лет" % ("Вася", 35 + 1/12))
Привет, Вася, 35.08 лет
>>> print("Привет, %s, %.4f лет" % ("Вася", 35 + 1/12))
Привет, Вася, 35.0833 лет</pre>
6. Это про числа. Наследие C, где можно писать %ld для чисел типа long int; в Python игнорируется
<p>
7. %s, %d - это так называемый тип преобразования (%s - строка, %d - целое число, %f - число с плавающей точкой)
<h4>Форматирование при помощи метода format</h4>
Вместо фигурных скобок в строку, к которой был применён метод format, подставляются значения аргументов
<pre>
>>> print("Привет, {}, {} лет".format("Вася", 35))
Привет, Вася, 35 лет</pre>
Можно внутри фигурных скобок указывать номер аргумента:
<pre>
>>> print("Привет, {1} лет, {0}".format("Вася", 35))
Привет, 35 лет, Вася</pre>
Можно указывать именованные аргументы:
<pre>
>>> print("Привет, {name}, {age} лет".format(name="Вася", age=35))
Привет, Вася, 35 лет</pre>
Можно комбинировать номера и имена:
<pre>
>>> print("Привет, {}, {age} лет".format("Вася", age=35))
Привет, Вася, 35 лет</pre>
Полную спецификацию метода format можно посмотреть <a href="https://docs.python.org/3/library/string.html#formatstrings">здесь (англ.)</a>, но в целом там не очень много различий с оператором %, только все флаги записываются после двоеточия:
<pre>
>>> print("Привет, {:10}, {age:.2f} лет".format("Вася", age=35.0833))
Привет, Вася      , 35.08 лет</pre>
И можно внутри выражения обращаться по индексу
<pre>
>>> print("Привет, {}, {age[0]} лет, {age[1]} месяц(ев)".format("Вася", age=(35, 1)))
Привет, Вася, 35 лет, 1 месяц(ев)</pre>
<h4>f-строки</h4>
В Python версии 3.6 появился новый способ форматирования строк, а именно f-строки.
<p>
Почему f? Из-за способа задания. Как "сырые" строки задаются буквой r в начале, так f-строки задаются буквой f.
<pre>s = f"Это f-строка"</pre>
Значения в f-строку подставляются прямо в строке, в фигурных скобках. В качестве подстановки выступает выражение, внутри можно выполнить некоторый код.
<p>
Также после двоеточия можно записать флаги-модификаторы, как и в format:
<pre>
name = "вася"
age = 35
months = 1
print(f"Привет, {name.title()}, {age} лет, {months} месяц(ев), всего {age + months / 12:.2f} лет")
# Привет, Вася, 35 лет, 1 месяц(ев), всего 35.08 лет</pre>






<h3 align=center><a name="unpack" href="https://pyplanet.ru/article/unpacking.html">Распаковка элементов</a></h3>
Допустим, есть задача: обменять значения двух переменных. Например, a = 5, b = 10. Нам нужно, чтобы стало a = 10, b = 5.
<p>
Можно это сделать через введение временной переменной:
<pre>
a = 5
b = 10

tmp = a
a = b
b = tmp</pre>
А можно воспользоваться инструментом распаковки элементов кортежа / списка. Но для начала о том, что это вообще такое. А это, по сути, операция, обратная созданию кортежа / списка. Мы "распаковываем" кортеж в переменные:
<pre>
a = (1, 2, 3)
(variable_1, variable_2, variable_3) = a</pre>
Так кортеж из трёх элементов теперь "записан" в 3 переменные, с каждой из которых можно работать отдельно.
<p>
Как и при создании кортежа, скобки необязательны:
<pre>
a = (1, 2, 3)
variable_1, variable_2, variable_3 = a</pre>
Так как же можно решить задачу из начала статьи? Очень просто: создадим кортеж со значениями (a, b), и распакуем его в обратном порядке:
<pre>
a = 5
b = 10
(a, b) = (b, a)</pre>
Или, можно без скобок:
<pre>
a = 5
b = 10
a, b = b, a</pre>
<h4>Расширенная распаковка</h4>
Иногда из всего кортежа нам нужен 1-2 элемента; или наоборот, 1-2 элемента нам как раз не нужны.
<p>
В Python для подобных случаев имеется расширенная распаковка: Если поставить перед одной из переменных звёздочку, то ей присвоятся все оставшиеся значения:
<pre>
>>> a = 1, 2, 3, 4
>>> first, *rest = a
>>> print(first)
1
>>> print(rest)
[2, 3, 4]</pre>
<h4>Распаковка в цикле</h4>
Рассмотрим более сложный случай: у нас есть список людей, с полями (фамилия, имя, возраст, рост, вес). И нам нужно вывести только фамилию и возраст.
<pre>
people = [
    ("Иванов", "Иван", 35, 180, 85),
    ("Петров", "Петр", 27, 190, 74),
    ("Сидоров", "Петр", 19, 175, 68),
    ("Иванова", "Анастасия", 42, 172, 75),
]
for surname, name, age, height, weight in people:
    print(surname, age)</pre>
Что происходит во время выполнения кода? В цикле for мы проходимся по элементам списка people. А каждый элемент - это кортеж. Можно его присвоить переменной и распаковать уже внутри блока цикла, однако можно это сделать прямо на месте; и получить, таким образом, 5 переменных на каждой итерации цикла.
<p>
Поскольку после возраста остальные поля нам не нужны, можно также воспользоваться расширенной распаковкой:
<pre>
for surname, name, age, *rest in people:
    print(surname, age)</pre>





<h3 align=center><a name="metod">Методы</h3>
Ссылки: <a href="https://pythonru.com/osnovy/python-join">Методы join() и split()</a>
<p>
<b><a name="join">Метод join - преобразование списка в строку</b><br>
Метод join преобразует список из строк в одну строку, элементы списка будут разделены символом - делимитером между ' '.
<p>
Метод принимает итерируемый объект в качестве аргумента, а поскольку список отвечает этим условиям, то его вполне можно 
использовать. Также список должен состоять из строк. Если попробовать использовать функцию для списка с другим содержимым, то 
результатом будет такое сообщение: <font color=red>TypeError: sequence item 0: expected str instance, int found</font>.
<p>
Примеры:
<pre>
>>> lst = ["a", "e", "i", "o", "u"]
>>> ','.join(lst)
'a,e,i,o,u'
</pre>
ещё:
<pre>
>>> lst = ['a', 'b', 'c']
>>> ' '.join(lst)
'a b c'</pre>
<p>
<a name="split"><b>Метод split()</b><br>
Это метод строки.<br>
Создает на основе строки новый объект список, элементы которого берутся из строки, разделенные по аргументу split(). Если 
аргумента нет, то по пробелу.
<p>
Синтаксис:
<pre>
<b>'stroka'.split(argument)</b></pre>
Примеры:
<pre>
>>> lst = 'a b c d'
>>> lst.split() # без аргумента, разделение будет по умолчанию по пробелу
['a', 'b', 'c', 'd']
>>> lst = 'a : b : c : d'
>>> lst.split(':')
['a ', ' b ', ' c ', ' d']
>>> lst.split(' : ')
['a', 'b', 'c', 'd']
</pre>
ещё:
<pre>
>>> 'a, b, c, d'.split(',')
['a', ' b', ' c', ' d']
>>> 'a, b, c, d'.split(', ')
['a', 'b', 'c', 'd']
</pre>
<p>
<b>index()</b><br>
Метод index() возвращает индекс указанного элемента в списке. Синтаксис метода в Python:
<pre>list.index(element, start, end)</pre>
element – элемент для поиска;<br>
start (необязательно) – начать поиск с этого индекса;<br>
end (необязательно) – искать элемент до этого индекса.
<p>
Метод возвращает индекс данного элемента в списке. Если элемент не найден, возникает исключение ValueError.<br>
<i>Примечание: Команда возвращает только первое вхождение соответствующего элемента.</i>








<h3 align=center><a name="if" href="https://pyplanet.ru/article/if.html">Инструкция if-elif-else</a></h3>
<h4>Синтаксис инструкции if</h4>
Сначала записывается часть if с условным выражением, далее могут следовать одна или более необязательных частей elif, и, наконец, необязательная часть else. Общая форма записи условной инструкции if выглядит следующим образом:
<pre>
if test1:
    state1
elif test2:
    state2
else:
    state3</pre>
Пример:
<pre>
a = int(input())
if a < -5:
    print('Low')
elif -5 <= a <= 5:
    print('Mid')
else:
    print('High')</pre>
    
<h4>Проверка истинности в Python</h4>
<ul>
<li> Любое число, не равное 0, или непустой объект - истина.
<li> Числа, равные 0, пустые объекты и значение None - ложь
<li> Операции сравнения применяются к структурам данных рекурсивно
<li> Операции сравнения возвращают True или False
<li> Логические операторы and и or возвращают истинный или ложный объект-операнд
</ul>   
<h4>Проверки на равенство</h4>
После слова if идёт условие. И только если оно истинное, выполняется блок с отступом от if. Условия могут проверяться самые разные; многие из них задаются операторами.
<ul>
<li> == - проверка на равенство (условие верно, если выражение слева равно выражению справа)
<li> != - проверка на неравенство (условие верно, если выражение слева не равно выражению справа)
<li> > - условие верно, если выражение слева больше выражения справа
<li> >= - условие верно, если выражение слева больше, либо равно выражению справа
<li> < - условие верно, если выражение слева меньше выражения справа
<li> <= - условие верно, если выражение слева меньше, либо равно выражению справа
</ul>
Вообще, условие может быть любым, необязательно сравнение. Например,
<pre>
say = input()
if say:
    print("Ох, вы что-то сказали? Жалко, я не смогу это понять")
else:
    print("Не хотите разговаривать? Ну и ладно")</pre>
Здесь условием выступает просто переменная say. Условие истинно, если строка непустая, и ложно, если она пустая. Истинно также любое отличное от нуля число, и любой непустой объект (например, непустая строка).

<h4>Логические операторы</h4>
Иногда есть необходимость в сложных условиях. Например, если число больше нуля, но не равно 42. Такие условия помогают задавать логические операторы:
<ul>
<li> and - логическое И
<li> or - логическое ИЛИ
<li> not - логическое НЕ
</ul>
Задача выше имеет такое решение:
<pre>
a = 33
if a > 0 and a != 42:
    print("YES")</pre>
Частая ошибка с логическими операторами: допустим, нам надо проверить, что переменная либо 0, либо 42. Некоторые пишут ошибочное решение
<pre>
a = 33
if a == 0 or 42: # Это ОШИБКА, так условие составлять НЕЛЬЗЯ!
    print("YES")</pre>
Здесь условие эквивалентно (a == 0) or (42), и, если первое условие иногда истинно, то второе условие (42) истинно всегда, потому что это отличное от нуля число. Правильно писать так:
<pre>
a = 33
if a == 0 or a == 42:
    print("YES")</pre>
Выражения слева и справа логических операторов выполняются "лениво". Это значит, что, например, если есть условие A or B, и A истинно, то B вычислено не будет. Это может быть важно, если выражение B имеет внешние эффекты (например, там функция input, ожидающая ввода, и она иногда не будет вызвана как раз из-за такого эффекта).
<h4>Приоритет логических операторов</h4>
<ul>
<li> Все арифметические
<li> Все операторы сравнения
<li> not
<li> and
<li> or
</ul>
<pre>
a = 33
if not a == 0 or a == 42:
    # a не 0, или a равно 42; часть с 42 можно убрать
    print("YES")

if not (a == 0 or a == 42):
    # a не 0, и не 42
    print("YES")</pre>
Отличие этих двух if в том, что, если a равно 42, то первый выведет YES, а второй - не выведет. Приоритет операции можно поднять скобками там, где нужно.


<h3 align=center><a href="https://pyplanet.ru/article/switch-case.html">Множественный условный оператор Switch - case</a></h3>
Допустим, мы хотим написать простейшую систему вопрос - ответ. У нас есть заранее известный список потенциальных вопросов и ответов на них.
<p>
Безусловно, можно решить эту задачу, используя конструкцию if-elif-else, но появилась несколько более удобная конструкция для решения подобных задач.<br>
Решение с помощью if-elif-else:
<pre>
question = input()
if question == "Привет?":
    print("Привет!")
elif question == "Что ты знаешь?":
    print("Что-то, да знаю")
elif question == "Как дела?":
    print("Хорошо!")
elif question == "Что делаешь?":
    print("Отвечаю на вопросы кожаных мешков")
elif question == "Кто ты?":
    print("Я - компьютерная программа, написанная на Python")
elif question == "В чем смысл жизни?":
    print("42")
else:
    print("Вопрос непонятен")</pre>
Это достаточно элегантный способ решения, однако эту же задачу можно решить с помощью сравнительно недавно появившегося в Python выражении match - case (на данном этапе обучения считайте его аналогом switch - case из других языков программирования).
<pre>
question = input()
match question:
    case "Привет?":
        print("Привет!")
    case "Что ты знаешь?":
        print("Что-то, да знаю")
    case "Как дела?":
        print("Хорошо!")
    case "Что делаешь?":
        print("Отвечаю на вопросы кожаных мешков")
    case "Кто ты?":
        print("Я - компьютерная программа, написанная на Python")
    case "В чем смысл жизни?":
        print("42")
    case _:
        print("Вопрос непонятен")</pre>
Данный синтаксис появился только в Python 3.10, если у вас более ранняя версия - пример работать не будет, и вы можете смело переходить к следующей лекции.<br>
Здесь match (аналог switch в других языках) - принимает выражение, которое затем сопоставляется с шаблонами в блоках case.
<p>
case _ здесь - аналог слова default в других языках программирования
<p>
Почему match, а не switch<br>
Потому что это не обычный switch-case, это конструкция сопоставления шаблонов.
<p>
В простейшем случае, как в примере выше - оператор имеет поведение такое же, как и switch - case в других языках.
<p>
На самом деле, выражение match - case гораздо мощнее, но с остальными его фишками мы познакомимся позже.
<p>
И case _ тоже не совсем аналог слова default, об этом тоже позже.
<pre>

=====================================================================================================


</pre>
<h3 align=center><a name="loop" href="https://pyplanet.ru/article/while.html">Цикл while</a></h3>
Синтаксис while:
<pre>
while УСЛОВИЕ:
    ТЕЛО_ЦИКЛА</pre>
Выполняет тело цикла до тех пор, пока условие цикла истинно. Что означает УСЛОВИЕ? Да ровно то же самое, что и у оператора if, 
без каких-либо дополнительных ограничений.
<p>
ТЕЛО_ЦИКЛА - это блок кода (одна, или несколько, или много строк кода, другие, вложенные блоки, и т.д.)
<p>
Пример: Напишите программу, которая считывает целые числа с консоли по одному числу в строке.
<br>Для каждого введённого числа проверить:
<br>если число меньше 10, то пропускаем это число;
<br>если число больше 100, то прекращаем считывать числа;
<br>в остальных случаях вывести это число обратно на консоль в отдельной строке.
<pre>
while <b>True</b>:
    number = int(input())
    if number >100:
        break
    if number <10:
        continue
    print(number)</pre>
Второе решение:
<pre>
a = 0
while a <= 100:
    a = int(input())
    if 10 <= a <= 100:
        print(a)</pre>
        
Напишите программу, которая считывает с клавиатуры два числа a и b, считает и выводит на консоль среднее арифметическое всех 
чисел из отрезка [a;b], которые кратны числу 3. 
<pre>
<b>a, b = int(input()), int(input())</b>

sm = 0;
n = 0;

for i in range(a, b + 1):
    if i % 3 == 0:
        sm += i
        n += 1

print(sm / n)</pre>


        

<h3 align=center><a href="https://pyplanet.ru/article/break-continue.html">Операторы break и continue, слово else в циклах</a></h3>
<h4>Оператор break</h4>
Оператор break досрочно прерывает цикл.
<br>Пример:
<pre>
>>> for i in 'hello world':
...     if i == 'o':
...         break
...     print(i * 2, end='')
...
hheellll</pre>

<h4>Оператор continue</h4>
Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)<br>
Пример:
<pre>
>>> for i in 'hello world':
...     if i == 'o':
...         continue
...     print(i * 2, end='')
...
hheellll  wwrrlldd</pre>

<h4>While - else</h4>
Слово else, примененное в цикле for или while, проверяет, был ли произведен выход из цикла инструкцией break, или же "естественным" образом. Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.
<br>Пример:
<pre>
>>> for i in 'hello world':
...     if i == 'a':
...         break
... else:
...     print('Буквы a в строке нет')
...
Буквы a в строке нет</pre>
<p>
Слово else под циклом не имеет ничего общего с выражением if - else! То, к какому блоку относится else, указывается уровнем отступа.


<h3 align=center><a name="for" href="https://pyplanet.ru/article/for.html">Цикл for</a></h3>
Синтаксис цикла for:
<pre>for element in array:
    тело цикла</pre>
array - это объект, поддерживающий протокол итерирования.
<br>in - ключевое слово, которое в данном контексте обозначает примерно "все элементы из array".
<br>element - переменная, куда будет помещено значение элемента массива на каждой итерации. И да, каждую итерацию это будет следующий элемент последовательности, не нужно увеличивать никакой счётчик, как в цикле while (или как в языке Pascal).
<p>
Не следует изменять array внутри самого цикла! Это может привести к непредсказуемым результатам работы программы.
Внутри цикла for, как и внутри цикла while, можно использовать break, continue. Также есть возможность использовать блок else.
<p>
Например, дана задача: вывести первое положительные число в массиве, или написать, что положительных чисел нет.
<pre>
array = [0, -3, -5, 4, -2, -3, 5, 6, 1]
for element in array:
    if element > 0:
        print(element)
        break
else:
    print("Положительных чисел нет")
</pre>
Другой пример.<br>
Напишите программу, на вход которой даются четыре числа a, b, c и d, каждое в своей строке. Программа должна вывести фрагмент 
таблицы умножения для всех чисел отрезка. Мое решение:
<pre>
a = int(input())
b = int(input())+1
c = int(input())
d = int(input()) + 1
for y in range(c,d):
    # формируем шапку
    print('\t',y,end='')
for i in range(a,b):
    print()    
    print(i,end='')
    for y in range(c,d):
        print('\t',i*y,end='')
print()</pre>
<img src="./images/python_base3.png">
<p>
Другое решение:
<pre>
a, b, c, d = int(input()), int(input()), int(input()), int(input())

for i in range(c, d + 1):
    print("\t" + str(i), end="")

print()

for i in range(a, b + 1):
    print(i, end="\t")
    for n in range(c, d + 1):
        print(i * n, end="\t")
    print()
</pre>

<font color=red>Разбор моих ошибок с for:</font>
<pre>
#!/usr/bin/env python3 
num = input().split()
s = 0
i = 0
for i in len(num):
    s = s + int(i)
print(s)
<font color=red>for i in len(num):
TypeError: 'int' object is not iterable</font></pre>
<i>Оператором in можно перебрать элементы в какой-нибудь последовательности, которую можно перебирать - итерировать.
Например - список, кортеж. А Вы пытаетесь применить его к единственному числу - len(s). Вот оно и пишет, что целое число неперебираемо.</i>






<h3 align=center><a name="potok">Вызов методов цепочкой</h3>
Ссылка: <a href="https://pyneng.readthedocs.io/ru/latest/book/04_data_structures/method_chaining.html">Вызов методов цепочкой</a><p>
Часто с данными надо выполнить несколько операций, пример скрипта:
<pre>
line = "switchport trunk allowed vlan 10,20,30"
words = line.split()
vlans_str = words[-1]
vlans = vlans_str.split(",")
print(vlans)</pre>
В этом случае переменные используются для хранения промежуточного результата и последующие методы/действия выполняются уже с 
переменной. Это совершенно нормальный вариант кода, особенно поначалу, когда тяжело воспринимать более сложные выражения.
<p>
Однако в Python часто встречаются выражения, в которых действия или методы применяются один за другим в одном выражении. 
Например, предыдущий код можно записать так:
<pre>
line = "switchport trunk allowed vlan 10,20,30"
vlans = line.split()[-1].split(",")
print(vlans)</pre>
Так как тут нет выражений в скобках, которые бы указывали приоритет выполнения, все выполняется слева направо. Сначала 
выполняется line.split() - получаем список, затем к полученному списку применяется [-1] - получаем последний элемент списка, 
строку 10,20,30. К этой строке применяется метод split(",") и в итоге получаем список ['10', '20', '30'].
<p>
Главный нюанс при написании таких цепочек предыдущий метод/действие должен возвращать то, что ждет следующий метод/дествие. И 
обязательно чтобы что-то возвращалось, иначе будет ошибка.
<pre>


===============================================================================================================



</pre>
<h3 align=center><a name="regul">Регулярные выражения</h3>
Ссылка: <a href="https://habr.com/ru/articles/349860/">Регулярные выражения в Python от простого к сложному.</a><br>
<a href="https://tproger.ru/translations/regular-expression-python">Python RegEx: практическое применение регулярок</a><br>
<a href="https://ru.wikipedia.org/wiki/Регулярные_выражения#Обратная_связь">Регулярные выражения</a>
<p>
Регулярное выражение — это строка, задающая шаблон поиска подстрок в тексте. Одному шаблону может соответствовать много разных 
строчек. Термин «Регулярные выражения» является переводом английского словосочетания «Regular expressions». Перевод не очень 
точно отражает смысл, правильнее было бы «шаблонные выражения».
<p>
Регулярные выражения это, по существу, крошечный язык программирования, встроенный в Python и доступный при помощи модуля 
re. Используя его, вы указывается правила для множества возможных строк, которые вы хотите проверить; это множество может 
содержать английские фразы, или адреса электронной почты, или TeX команды, или все что угодно.
<p>
<h4 align=center>Метасимволы</h4>
Это набор символов:
<pre><b>. ^ $ * + ? { [ ] \ | ( )</b></pre>
<p>
1. Квадратные скобки: <b>[</b> и <b>]</b><br>
Первые метасимволы, что мы рассмотрим это [ и ]. Они используются для определения множества символов (классов), с которыми вы 
ищите совпадение. Символы могут быть перечислены по отдельности, или в виде некоторого диапазона символов, обозначенного 
первым и последним символом, разделенных знаком '-'. Например, [abc] будет соответствовать любому из символов a, b или c; это 
то же самое, что выражение [a-c], использующее диапазон для задания того же множества символов. Если вы хотите сопоставить 
только строчные буквы, РВ будет иметь вид [a-z].
<p>
Метасимволы не активны внутри классов. Например, [akm$] будет соответствовать любому из символов 'a', 'k', 'm' или '$'. Знак 
'$' это обычно метасимвол (как видно из списка символов выше), но внутри класса символов он лишается своей особой природы.
<p>
внутри скобок нужно экранировать только ] и \
<p>
Для того, чтобы находить соответствие символам вне этого класса, в начале класса добавляется символ '^'. Например, выражение 
[^5]  соответствует любому символу, кроме '5'.
<p>
2. Обратная косая черта: <b>\</b><br>
Пожалуй, наиболее важным является метасимвол обратной косой черты \. Как и в строковых литералах Python, за бэкслешем могут 
следовать различные символы, обозначающие разные специальные последовательности. Он также используется для экранирования 
метасимволов, чтобы их можно было использовать в шаблонах; например, если нужно найти соответствие [ или \, для того чтобы 
лишить их своей особой роли метасимволов, перед ним нужно поставить обратную косую черту: \[ или \\.
<p>
Для того, чтобы не было таких нагромождений слешей, перед открывающей кавычкой нужно поставить символ r, что скажет питону «не 
рассматривай \ как экранирующий символ (кроме случаев экранирования открывающей кавычки)». Соответственно можно будет писать 
r'\\par'
<p>
Некоторые из специальных последовательностей, начинающихся с '\' представляют предопределенные наборы символов, часто бывающие 
полезными, такие как набор цифр, набор букв, или множества всего, что не является пробелами, символами табуляции и т. д. 
(whitespace). Полный список последовательностей и расширенных определений классов для Юникод-строк смотрите в последней части 
Regular Expression Syntax.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>

<tr><td>\d</td><td width=65%>любая цифра; эквивалент класса [0-9]</td><td>СУ<b>\d\d</b> &rarr; <font color=green>СУ35</font>, <font 
color=green>СУ11</font>1, АЛ<font color=green>СУ14</font></td></tr>

<tr><td>\D</td><td>любой нечисловой символ; эквивалент класса [^0-9]</td><td>926<b>\D</b>123 &rarr; <font color=green>926)123</
font>, 1<font color=green>926-123</font>4</td></tr>

<tr><td>\s</td><td>соответствует любому символу whitespace; эквивалент [ \t\n\r\f\v]</td><td>бор<b>\s</b>ода &rarr; <font 
color=green>бор ода</font>, <font color=green>бор<br>
ода</font>, борода</td></tr>

<tr><td>\S</td><td>любой не-whitespace символ; эквивалент [^ \t\n\r\f\v]</td><td><b>\S</b>123 &rarr; <font color=green>X123</
font>, <font color=green>я123</font>, <font color=green>!123</font>456, 1 + 123456</td></tr>

<tr><td>\w</td><td>Любая буква (то, что может быть частью слова), а также цифра и _, эквивалент [a-zA-Z0-9_]</td><td>
<b>\w\w\w</b> &rarr; <font color=green>Год</font>, <font color=green>f_3</font>, <font color=green>qwer</font>t
<p>
используя \w, вытащить два последовательных символа, кроме пробельных, из каждого слова:
<pre>
result = re.findall(r'\w\w', 'AV is largest Analytics community')
print result
Результат:
['AV', 'is', 'la', 'rg', 'es', 'An', 'al', 'yt', 'ic', 'co', 'mm', 'un', 'it']</pre></td></tr>

<tr><td>\W</td><td>наоборот; эквивалент [^a-zA-Z0-9_]</td><td>сом<b>\W</b> &rarr; <font color=green>сом!</font>, <font 
color=green>сом?</font></td></tr>

<tr><td>\b</td><td>Начало или конец слова (слева пусто или не-буква, справа буква и наоборот). В отличие от предыдущих 
соответствует позиции, а не символу</td><td><b>\b</b>вал &rarr; <font color=green>вал</font>, перевал, Перевалка</td></tr>

<tr><td>\B</td><td>Не граница слова: либо и слева, и справа буквы, либо и слева, и справа НЕ буквы</td><td><b>\B</b>вал &rarr; 
пере<font color=green>вал</font>, вал, Пере<font color=green>вал</font>ка<br>
<b>\B</b>вал<b>\B</b> &rarr; перевал, вал, Пере<font color=green>вал</font>ка</td></tr>
</table>
<p>
Эти последовательности могут быть включены в класс символов. Например, [\s,.] является характер класс, который будет 
соответствовать любому whitespace-символу или запятой или точке.
<p>
3. Точка: <b>.</b><br>
Один любой символ, кроме новой строки \n.<br>
Пример:<br>
м.л.ко, применяем к <font color=green>молоко</font>, <font color=green>малако</font>,
И<font color=green>м0л0ко</font>Ихлеб
<p>
4. Символ: <b>^</b><br>
Служит для указания, что следующий символ не входит в шаблон.
<p>
Также ^ означает начало текста (или строки при модификаторе ?m)
<p>
Вытащим первое слово, используя ^:
<pre>
result = re.findall(r'^\w+', 'AV is largest Analytics community of India')
print result
Результат:
['AV']</pre>
<p>
===========================================================
<p>
5. <b>Квантификаторы</b><br>
<b>+ ? * {}</b> используются в квантификаторах (указаниях количества повторений). Квантификатор после символа, символьного 
класса или группы определяет, сколько раз предшествующее выражение может встречаться. Следует учитывать, что квантификатор 
может относиться более чем к одному символу в регулярном выражении, только если это символьный класс или группа.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>
<tr><td><b>+</b></td><td>Одно или более, синоним {1,}</td><td>a\)+ &rarr; <font color=green>a)</font>, <font color=green>a))
</font>, <font color=green>a)))</font>, b<font color=green><b>a)</b></font>])</td></tr>

<tr><td><b>?</b></td><td>Ноль или одно вхождение, синоним {0,1}</td><td>валы<b>?</b> &rarr; <font color=green>вал, валы, 
вал</font>ов<br>Символ в паттерне перед ? может или быть или отсутствовать в строке.</td></tr>

<tr><td><b>*</b></td><td>Ноль или более, синоним {0,}</td><td>СУ\d*	&rarr; <font color=green>СУ, СУ1, СУ12</font></td></tr>
</table>

<p>
<h4>Жадность в регулярках и границы найденного шаблона</h4>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>
<tr><td>*?<br>
+?<br>
??<br>
{m,n}?<br>
{,n}?<br>
{m,}?</td><td width=40%>По умолчанию квантификаторы жадные — захватывают максимально возможное число символов.
<b>Добавление ?</b> делает их ленивыми, они захватывают минимально возможное число символов</td><td>\(.*\)	&rarr; <font 
color=green>(a + b) * (c + d) * (e + 
f)</font><br>
\(.*?\) &rarr; <font color=green>(a + b)</font> * (c + d) * (e + f)</td></tr>
</table>
<p>
Как указано выше, по умолчанию квантификаторы жадные. Этот подход решает очень важную проблему — проблему границы шаблона. 
Скажем, шаблон \d+ захватывает максимально возможное количество цифр. Поэтому можно быть уверенным, что перед найденным 
шаблоном идёт не цифра, и после идёт не цифра.
<p>
6. Фигурные скобки: <b>{n}</b><br>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>

<tr><td>{n}</td><td>Ровно n повторений</td><td>d{4} означает 4 цифры: &rarr; 1, 12, 123, <font color=green>1234</font>, 12345
</td></tr>

<tr><td>{m,n}</td><td>От m до n повторений включительно</td><td>\d{2,4}  &rarr; 1, <font color=green>12</font>, 
<font color=green>123</font>, <font color=green>1234</font>, 12345</td></tr>

<tr><td>{m,}</td><td>Не менее m повторений</td><td>\d{3,}  &rarr; <1, 12, <b><font color=green>123</font>, 
<font color=green>1234</font>, <font color=green>12345</font></b></td></tr>

<tr><td>{,n}</td><td>Не более n повторений</td><td>\d{,2}  &rarr; 1, <font color=green>12</font>, <font color=green>12</font>3
</td></tr>
</table>
<p>
7. Знак доллара <b>$</b><br>
Конец строки
<p>
Если мы используем $ вместо ^, то мы получим последнее слово, а не первое:
<pre>
result = re.findall(r'\w+$', 'AV is largest Analytics community of India')
print result
Результат:
[‘India’]</pre>
<p>
<h4>Использование дополнительных флагов в питоне</h4>
Каждой из функций, перечисленных выше, можно дать дополнительный параметр flags, что несколько изменит режим работы регулярок. 
В качестве значения нужно передать сумму выбранных констант, вот они:
<ol>
<li> re.ASCII<br>
По умолчанию \w, \W, \b, \B, \d, \D, \s, \S соответствуют все юникодные символы с соответствующим качеством.<br>
Например, \d соответствуют не только арабские цифры, но и вот такие: ٠١٢٣٤٥٦٧٨٩. re.ASCII ускоряет работу, если все 
соответствия лежат внутри ASCII.
<p>
<li> re.IGNORECASE<br>
Не различать заглавные и маленькие буквы. Работает медленнее, но иногда удобно
<li> re.MULTILINE<br>
Специальные символы ^ и $ соответствуют началу и концу каждой строки
<p>
<li> re.DOTALL<br>
По умолчанию символ \n конца строки не подходит под точку. С этим флагом точка — вообще любой символ
</ol>
<pre>
import re 
print(re.findall(r'\d+', '12 + ٦٧')) 
# -> ['12', '٦٧'] 
print(re.findall(r'\w+', 'Hello, мир!')) 
# -> ['Hello', 'мир'] 
print(re.findall(r'\d+', '12 + ٦٧', <b>flags=re.ASCII</b>)) 
# -> ['12'] 
print(re.findall(r'\w+', 'Hello, мир!', <b>flags=re.ASCII</b>)) 
# -> ['Hello'] 
print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя')) 
# -> ['ааааа', 'яяяя'] 
print(re.findall(r'[уеыаоэяию]+', 'ОООО ааааа ррррр ЫЫЫЫ яяяя', <b>flags=re.IGNORECASE</b>)) 
# -> ['ОООО', 'ааааа', 'ЫЫЫЫ', 'яяяя'] 

text = r""" 
Торт 
с вишней1 
вишней2 
""" 
print(re.findall(r'Торт.с', text)) 
# -> [] 
print(re.findall(r'Торт.с', text, flags=re.DOTALL)) 
# -> ['Торт\nс'] 
print(re.findall(r'виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней1', 'вишней2'] 
print(re.findall(r'^виш\w+', text, flags=re.MULTILINE)) 
# -> ['вишней2'] </pre>
<p>
8. Знак <b>|</b> - перечисления (операция «ИЛИ»)<br>
Чтобы проверить, удовлетворяет ли строка хотя бы одному из шаблонов, можно воспользоваться аналогом оператора or, который 
записывается с помощью символа |. Так, некоторая строка подходит к регулярному выражению A|B тогда и только тогда, когда она 
подходит хотя бы к одному из регулярных выражений A или B. Например, отдельные овощи в тексте можно искать при помощи шаблона 
морковк|св[её]кл|картошк|редиск.
<p>
<h4>Скобочные группы (?:){}</h4>
Зачастую шаблон состоит из нескольких повторяющихся групп. Так, MAC-адрес сетевого устройства обычно записывается как шесть 
групп из двух шестнадцатиричных цифр, разделённых символами - или :. Например, 01:23:45:67:89:ab. Каждый отдельный символ 
можно задать как [0-9a-fA-F], и можно весь шаблон записать так:<br>
[0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}[:-][0-9a-fA-F]{2}
<p>
Ситуация становится гораздо сложнее, когда количество групп заранее не зафиксировано. Чтобы разрешить эту проблему в 
синтаксисе регулярных выражений есть группировка (?:...). Можно писать круглые скобки и без значков ?:, однако от этого у 
группировки значительно меняется смысл, регулярка начинает работать гораздо медленнее. Об этом будет написано ниже. Итак, если 
REGEXP — шаблон, то (?:REGEXP) — эквивалентный ему шаблон. Разница только в том, что теперь к (?:REGEXP) можно применять 
квантификаторы, указывая, сколько именно раз должна повториться группа. Например, шаблон для поиска MAC-адреса, можно записать 
так: [0-9a-fA-F]{2}(?:[:-][0-9a-fA-F]{2}){5}
<p>
<h4>Скобки плюс перечисления</h4>
Также скобки (?:...) позволяют локализовать часть шаблона, внутри которого происходит перечисление. Например, шаблон (?:он|
тот) (?:шёл|плыл) соответствует каждой из строк «он шёл», «он плыл», «тот шёл», «тот плыл», и является синонимом он шёл|он 
плыл|тот шёл|тот плыл.
<p>
Примеры:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10>

<tr><td>Шаблон</td><td>Применяем к тексту</td></tr>

<tr><td>(?:\w\w\d\d)+</td><td>Есть м<font color=green>иг29</font>а, <font color=green>ту15</font>4б. Некоторые делают даже 
м<font color=green>иг29ту15</font>4<font color=green>ил86</font>.</td></tr>

<tr><td>(?:\w+\d+)+</td><td>Есть <font color=green>миг29</font>а, ту154б. Некоторые делают даже <font 
color=green>миг29ту154ил86</font>.</td></tr>

<tr><td>(?:\+7|8)(?:-\d{2,3}){4}</td><td><font color=green>+7-926-123-12-12, 8-926-123-12-12</font></td></tr>

<tr><td>(?:[Хх][аоеи]+)+</td><td>Му<font color=green>ха</font> — <font color=green>хахахехо</font>, ну <font 
color=green>хааахооохе</font>, да <font color=green>хахахехохииии</font>! <font color=green>Ха</font>м трамвайный.</td></tr>

<tr><td>\b(?:[Хх][аоеи]+)+\b</td><td>Муха — <font color=green>хахахехо</font>, ну <font color=green>хааахооохе</font>, да <font color=green>хахахехохииии</font>! Хам трамвайный.</td></tr>

</table>
<p>
Если функции re.search, re.fullmatch не находят соответствие шаблону в строке, то они возвращают None, функция re.finditer не 
выдаёт ничего. Однако если соответствие найдено, то возвращается match-объект. 
<p>
<h4>Группирующие скобки (...) без ?:</h4>
Если в шаблоне регулярного выражения встречаются скобки (...) без ?:, то они становятся группирующими. В match-объекте, 
который возвращают re.search, re.fullmatch и re.finditer, по каждой такой группе можно получить ту же информацию, что и по 
всему шаблону. А именно часть подстроки, которая соответствует (...), а также индексы начала и окончания в исходной строке. 
Достаточно часто это бывает полезно.
<p>
<h4>Группировка</h4>
<b>Обратная связь</b><br>
Одно из применений группировки — повторное использование ранее найденных групп символов (подстрок, блоков, отмеченных 
подвыражений, захватов). При обработке выражения подстро́ки, найденные по шаблону внутри группы, сохраняются в отдельной 
области памяти и получают номер, начиная с единицы. Каждой подстроке соответствует пара скобок в регулярном выражении.
<p>
Обычно поддерживается до 9 нумерованных подстрок с номерами от 1 до 9, но некоторые интерпретаторы позволяют работать с 
бо́льшим 
количеством. Впоследствии в пределах данного регулярного выражения можно использовать обозначения от \1 до \9 для проверки на 
совпадение с ранее найденной подстрокой. В некоторых реализациях вместо бэкслеша используется знак доллара.
<p>
Например, регулярное выражение (та|ту)-\1 найдёт строку та-та или ту-ту, но пропустит строку та-ту.
<p>
Квантификация группы трактуется как многократное сохранение подстроки под одним и тем же номером, то есть запоминается 
последнее вхождение: например, <font color=red>регулярное выражение (.)+\1 найдёт строку abcc, но пропустит abca</font>.
<p>
Также ранее найденные подстро́ки можно использовать при замене по регулярному выражению. В таком случае в замещающий текст 
вставляются те же обозначения, что и в пределах самого выражения.
<p>
<b>Группировка без обратной связи</b><br>
Если группа используется только для группировки и её результат в дальнейшем не потребуется, то можно использовать группировку 
вида (?:шаблон). Под результат такой группировки не выделяется отдельная область памяти и, соответственно, ей не назначается 
номер. Это положительно влияет на скорость выполнения выражения, но понижает удобочитаемость.
<p>
<b>Атомарная группировка</b><br>
Атомарная группировка вида (?>шаблон) так же, как и группировка без обратной связи, не создаёт обратных связей. В отличие от 
неё, такая группировка запрещает возвращаться назад по строке, если часть шаблона уже найдена.
<p>
<img src="./images/python_base10.png">
<p>
<i>Тут нужны группировки. Если туговато с их пониманием, как было у меня, читаем и стараемся понять логику:
<pre>
import re
line = 'abcdef'
pattern = r'(\w)(\w)(\w)(\w+)'
print(re.sub(pattern, r'\3\2\1\4', line))
>>> cbafed</pre>

В нашем шаблоне (pattern) есть (\w) повторённая три раза. Операция повторения () даёт нам возможность запомнить "индекс" 
элемента шаблона. Этот "индекс" в дальнейшем мы можем вызвать например через \1 что соответствует первому элементу группировки 
т.е. \1 == 'a' в данной строке; аналогично и дальше слева направо \2 =='b'    \3 == 'с'    ,а  (\w+) == 'def'  то есть остаток 
нашей строки.
<p>
Таким образом указывая в выводе \3\2\1\4 мы заменяем соответствующие элементы в обратном порядке:  \3\2\1 == 'cba'  то же 
самое 'abc' >>>'cba' и прибавляем к ним 'def' через \4.</i>









<pre>


=================================================================================================================



</pre>
<h3 align=center><a name="def">Функции</h3>
Ссылки: <a href="https://pyplanet.ru/article/def-return.html">Функции, директивы def, return</a><br>
<a href="https://pythonworld.ru/tipy-dannyx-v-python/vse-o-funkciyax-i-ix-argumentax.html">Функции и их аргументы</a>
<p>
<b>Отличие функции от метода:</b><br>
<i>Важно различать функции и методы в Python, поскольку они используются для разных целей. Функции предназначены для 
выполнения общих задач, которые могут быть вызваны из любой части кода, в то время как методы связаны с объектами и 
предназначены для выполнения задач, специфичных для конкретного типа объекта.</i>
<p>
<i>Метод в Python вызывается по имени, но связан с объектом (зависим). Определение метода всегда включает «self» в качестве 
первого параметра. Метод неявно передается объекту, для которого он вызывается. Он может возвращать или не возвращать какие-
либо данные.
<p>
Функция в Python — это блок кода, который вызывается по своему имени. Функция может иметь разные параметры или не иметь их 
вообще. Если передаются какие-либо данные (параметры), они передаются явно. Функция может возвращать или не возвращать какие-
либо данные. Она не имеет дела с классом и концепцией его экземпляра.</i>
<p>
<b>Для чего нужна функция?</b><br>
Часто некоторый код нужно выполнить несколько раз. Либо мы хотим как-то изолировать некоторый код, и вызывать его в 
необходимом месте.<br>
Этого можно достичь написанием функции.
<p>
<b>Определение функции:</b><br>Функция в python - объект, принимающий аргументы и возвращающий значение. Обычная функция 
определяется с помощью инструкции def. Второй способ с помощью lambda.
<p>
Синтаксис:
<pre>
def name_f(arg1, arg2,...):
    return command</pre>
После инструкции def идёт <b>имя функции</b>.
<p>
<b>Аргументы функции</b><br>
Затем, в скобках, пишутся <b>аргументы</b> (или иногда говорят параметры) функции.
<p>
<ul>
<li> По способу передачи аргументов они бывают позиционные (positional arguments) или именованные:<br>
В fun(12, 123, a = 5, b = 10)<br>
a =5 и b = 10 - аргументы именованные, 12 и 123 - аргументы позиционные
<p>
Однако по имени можно передавать только последние аргументы. То есть, можно вызвать add(1, y=2), add(1, 2), add(x=1, y=2), но 
нельзя add(2, x=1).
<p>
<li> <b>Аргументы по умолчанию</b> (positional_args_with_defaults)<br>
Так называются аргументы, если при описывании функции аргументы имеют уже определенное значение.<br>
def f(b, a =10)<br>
Здесь a = 10 является аргументом по умолчанию.
<p>
<i>Следовало бы упомянуть один важный момент: значение по умолчанию вычисляется только один раз - при первом вызове функции. 
При всех последующих вызовах будет повторно использован тот объект, который получили при первом вычислении значения по 
умолчанию.<br>
В случае с неизменяемыми значениями (числа, строки) это поведение ни на что не влияет, а если в значении по умолчанию 
используется изменяемый тип - то все изменения этого аргумента будут сохраняться между вызовами.
<br>В качестве примера используем новый список как значение по умолчанию для аргумента b:
<pre>
>>> def f(a, b=[]):
...     b.append(a)
...     print(b)
...
>>> f(1)
[1]
>>> f(2)
[1, 2]
>>> f(3,b=[])
[3]
>>> f(4)
[1, 2, 4]</pre>
<font color=red>Непонятно чем аргументы по умолчанию отличаются от именнованых аргументов??????</font>
<p>
<li> <b>*args</b> (*pos_args_name)<br>
args - это список позиционных аргументов.
<br><i>По соглашению между программистами в Python  в функции  c произвольным количеством принимающих параметров принято писать *args вместо *(с каким либо другим названием переменной).</i>
<p>


<li> <b>**kwargs</b> (**kw_args_name)<br>
Это словарь из именнованых аргументов.
<p>
Пример:
<pre>
def printab(a=50, b=100, *args, **kwargs):
    print('a =', a)
    print('b =', b)
    print('additional <b>positional arguments</b>:')
    for i in <b>args</b>:  # распечатка кортеджа
        print(i)
    print('additional <b>named arguments</b>:')
    for key in <b>kwargs</b>:  # распечатка словаря
        print(key, '=', kwargs[key])

printab(10, 20, 25, 35, 45, 50, 60, c=30, d=40, jimmi=12</pre>
Результат:
<pre>
результат:

a = 10
b = 20
additional positional arguments:
25
35
45
50
60
additional named arguments:
c = 30
d = 40
jimmi = 123</pre>

<li> Общий синтаксис:
<pre>
def function_name([ positional_args,
                  [ positional_args_with_default,
                  [ *pos_args_name,
                  [ keyword_only_args,
                  [ **kw_args_name]]]]]):</pre>
-позиционные аргументы: a, b, c<br>
-позиц. аргументы со значением по умолчанию: d=0, e=True<br>
-дополнительные позиционные аргументы (которые в инициализации не участвовали) отправляются в кортеж (*args)<br>
<font color=red>-блок аргументов, которые можно передать только по имени: f, g, h=10</font><br>
-именованные аргументы которые в инициализации не участвовали, отправляются в словарь: **kwarqs
<p>
<li>
Ошибка «SyntaxError: positional argument follows keyword argument» в Python возникает, когда один или несколько аргументов 
ключевого слова (например, age=35, name=John) размещаются перед позиционными аргументами (например, 35, John) в вызове функции.
<p>
Согласно синтаксису Python, аргументы ключевого слова должны следовать позиционным аргументам, а не наоборот.
<br>Чтобы исправить эту синтаксическую ошибку, можно воспользоваться одним из следующих подходов:
<p>
Передать аргументы ключевого слова после позиционных аргументов.
<p>
Передать все аргументы в качестве позиционных аргументов.
<p>
Передать все аргументы в качестве аргументов ключевого слова.

</ul>
<p>
<li> <b>Тело функции:</b><br>
В следующей строке с отступом идет <b>тело функции</b>.<br>
Инструкция return говорит, что нужно вернуть значение. В нашем случае функция возвращает сумму x и y.
<p>
Внутри функции может быть какой угодно код, но, если мы хотим вернуть значение, мы обязаны написать return ЧТО_ТО. Если этого не написать, то функция вернёт специальное значение None (некоторый аналог NULL из других языков программирования).
<p>
Код после достижения return внутри функции не выполняется.
<p>
Внутри программы функция может быть вызвана. Например:
<pre>
def add(x, y):
    return x + y

print(add(1, 2))  # Выведет 3</pre>

<b>Согласно PEP 8 после определения функции нужно отступать 2 пустые строчки.</b>


<h4>Локальные и глобальные переменные</h4>
Переменные, объявленные внутри функции, являются локальными. Если их использовать за пределами выполнения функции, то произойдет ошибка.
<p>
Глобальные переменные - это переменные объявленные вне функции.

<li> <b>Стек вызовов</b><br>
Ссылки: <a href="https://stepik.org/lesson/24459/step/6?unit=6764">Функции и стек вызовов</a><br>
Стек вызовов чаще всего служит для хранения функций.<br>
Если интерпретатор видит функцию, он ложит ее в стек, если функция завершает выполнение, он эту функцию снимает.<br>
В стеке всегда в самом низу находится module.
<p>
<li> Если return пустой или его вообще не будет, тогда функция будет возвращать объект None. Тип этого None есть NoneType.
<p>
<li> <b>Рекурсивная функция</b><br>
Это такая функция в теле которой присутствует сама функция.
<p>
<li> <b>Пространство имён и область видимости</b><br>
Ссылки: <a href="https://nuancesprog.ru/p/9211/">Пространства имен и области видимости в Python</a>
<p>
<i>Пространство имён - это совокупность ссылок от имён объектов (переменных, функций, классов и т. д.) к их значениям в оперативной памяти (объектам). То есть, в теории мы могли бы обращаться сразу к значениям в памяти. Но их неудобно понимать, поэтому и придумали пространство имён. Оно, по сути, является переводчиком между понятному человеку названием объекта и его непонятному человеку значению в памяти. Словарь, если угодно.</i></i>
<p>
Пространство имен - это все ссылки на объекты (переменные).<br>
Пространств имён может быть несколько.<br>
<b>Встроенное пространство имен</b> содержит имена всех встроенных объектов, которые всегда доступны при работе в Python. Вы можете перечислить объекты во встроенном пространстве с помощью следующей команды: 
<pre>>>> dir(__builtins__)</pre>

Первое пространство имен - builtins, создается когда запускаем интерпретатор.
<p>
<b>Глобальное пространство имен nain</b> содержит имена, определенные на уровне основной программы, и создаётся сразу при запуске тела этой программы. Сохраняется же оно до момента завершения работы интерпретатора. 
<br>Строго говоря, могут существовать и другие глобальные пространства имен. Интерпретатор также создает пространство данного типа для любого модуля, загружаемого программой при помощи выражения import.
<p>
nain, является глобальным, создается когда создаем функцию или что-то делаем с переменной.
<p>
Интерпретатор создает новое пространство имен при каждом выполнении функции. Это пространство является локальным для функции и 
сохраняется до момента завершения ее действия.<br>
Локальное пространство имен содержит аргументы функции и локальные переменные (объявленные внутри функции).
<p>
Наличие нескольких отличных пространств имен означает, что в процессе выполнения программы Python несколько разных экземпляров 
одного имени могут существовать одновременно. Пока каждый из них находится в собственном пространстве, все они обслуживаются 
по отдельности, и путаницы не происходит. 
<p>
Но тут возникает вопрос. Предположим, что вы ссылаетесь на имя x в коде, а оно существует в нескольких пространствах. Как 
Python узнает, какое именно вы имеете в виду? 
<p>
Ответ кроется в понятии области видимости имени, представляющей из себя часть программы, в которой данное имя обладает 
значением. Интерпретатор определяет эту область в среде выполнения, основываясь на том, где располагается определение имени и 
из какого места в коде на него ссылаются. 
<p>
<pre>
def a():
    print(x) 
def b():
    x = 1
    a() 
b()#NameError</pre>
Функция b() вызывает ф-ю a(), зоны видимости функций не включены друг в друга. Т. е. интерпретатор не найдя имя 'x' в зоне видимости a() перейдёт в глобальную зону видимости, потом в зону видимости builtins - и не обнаружит 'x'. В результате: NameError
<pre>
def b():
    def a():
        print(x)
    x = 1
    a() 
b()#1</pre>
Функция b() также вызывает ф-ю a(), но теперь a() определена внутри b(). Т. е. интерпретатор не найдя имя 'x'  в зоне 
видимости a() перейдёт в зону видимости b() и найдет 'x' . Результат: 1
<p>
<li> <b>global и nonlocal</b><br>
<pre>
def outer_func(who):
    def inner_func():
        print(f"Hello, {who}")
    inner_func()

>>> outer_func("World!")
Hello, World!</pre>
Теперь мы можем передать строку в качестве аргумента функции outer_func(), и inner_func() будет обращаться к этому аргументу 
через имя who. Это имя определяется в локальной области видимости outer_func(). Имена, которые мы определяем в локальной 
области внешней функции, определяются как nonlocal. Они нелокальны с точки зрения inner_func().
</ol>
<pre>

============================================================================================================


</pre>
<h3 align=center><a name="recurs">Рекурсивные функции</h3>
Рекурсивная функция — это функция, которая вызывает сама себя в процессе своего выполнения. Структурно она состоит из двух 
основных частей: базового случая и рекурсивного случая.
<p>
Базовый случай (Base Case): Это условие, которое останавливает рекурсию. Без этого условия рекурсивная функция будет вызывать 
саму себя бесконечно, что приведёт к переполнению стека вызовов. Базовый случай обычно представляет собой простое условие, при 
котором функция возвращает результат без дальнейших рекурсивных вызовов.
<p>
Рекурсивный случай (Recursive Case): Это часть, где функция вызывает сама себя. Здесь важно, чтобы каждый последующий вызов 
приближал функцию к базовому случаю, уменьшая проблему или изменяя данные таким образом, чтобы в конечном итоге достигнуть 
базового случая.
<p>
Для успешной работы рекурсивной функции, чёткое определение базового и рекурсивного случаев является ключевым. Базовый случай 
обеспечивает "точку остановки", предотвращая бесконечную рекурсию. Рекурсивный случай же обрабатывает часть задачи и делает 
рекурсивный вызов с "меньшей" или "измененной" версией исходной задачи.
<p>
В качестве простейшего примера рассмотрите следующий код:
<pre>
def factorial(n):
    if n == 1:  # Базовый случай
        return 1
    else:
        return n * factorial(n - 1)  # Рекурсивный случай</pre>
<p>
<b>Хвостовая рекурсия и её оптимизация</b><br>
Хвостовая рекурсия возникает, когда рекурсивный вызов является последним действием функции, то есть нет необходимости 
сохранять контекст текущего вызова. В хвостово-рекурсивной функции возвращаемое значение рекурсивного вызова сразу же 
возвращается из функции.
<p>
Оптимизация:<br>
Некоторые языки программирования и компиляторы способны оптимизировать хвостовую рекурсию, уменьшая нагрузку на стек вызовов и 
превращая рекурсию в итерацию во время компиляции.<br>
В языках, не поддерживающих оптимизацию хвостовой рекурсии (например, Python), можно переписать рекурсивную функцию в 
итеративный стиль для повышения эффективности.
<p>
<b>Мемоизация в рекурсивных функциях</b><br>
Мемоизация — это техника оптимизации, которая включает сохранение результатов выполнения функций для предотвращения повторных 
вычислений при последующих вызовах с теми же аргументами.
<p>
Применение в рекурсии:<br>
Мемоизация особенно полезна в рекурсивных функциях с большим количеством повторяющихся вызовов, например, при вычислении чисел 
Фибоначчи.<br>
Реализуется путём сохранения возвращаемых значений в структуру данных (например, в словарь) и проверки, был ли данный вызов 
функции уже выполнен ранее.
<p>
Множественная рекурсия<br>
Множественная рекурсия возникает, когда в теле функции происходит более одного рекурсивного вызова.<br>
Примеры:<br>
Примером множественной рекурсии может служить алгоритм быстрой сортировки, где рекурсивные вызовы происходят для двух половин 
массива.<br>
Другой пример — бинарное дерево поиска, где рекурсивные вызовы идут как для левой, так и для правой ветви дерева.
<p>
Разбор рекурсии на примере <a href="python_example.html#text">здесь</a>.


<pre>


==============================================================================================================


</pre>
<h3 align=center><a name="builtins">Встроенные функции</a></h3>
Ссылки: <a href="https://docs.python.org/3/library/functions.html">Документация по Built-in Functions</a><br>
<a href="https://intuit.ru/studies/courses/49/49/lecture/27060?page=">Встроенные функции</a>
<p>
В среде Python без дополнительных операций импорта доступно более сотни встроенных объектов, в основном, функций и исключений. 
Для удобства функции условно разделены по категориям:
<p>
<ul>
<li> <a href="https://pythonworld.ru/osnovy/vstroennye-funkcii.html">Функции преобразования типов и классы</a>: coerce, str, 
repr, int, list, tuple, long, float, complex, dict, super, file, bool, object
<p>
<li> Числовые и строковые функции: abs, divmod, ord, pow, len, chr, unichr, hex, oct, cmp, round, unicode
<p>
abs(x)	Модуль числа x. Результат: |x|.
<p>
divmod(x, y)	Частное и остаток от деления. Результат: (частное, остаток).
<p>
pow(x, y[, m])	Возведение x в степень y по модулю m. Результат: x**y % m.
<p>
round(n[, z])	Округление чисел до заданного знака после (или до) точки.
<p>
ord(s)	Функция возвращает код (или Unicode) заданного ей символа в односимвольной строке.
<p>
chr(n)	Возвращает строку с символом с заданным кодом.
<p>
len(s)	Возвращает число элементов последовательности или отображения.
<p>
oct(n), hex(n)	Функции возвращают строку с восьмеричным или шестнадцатеричным представлением целого числа n.
<p>
cmp(x, y)	Сравнение двух значений. Результат: отрицательный, ноль или положительный, в зависимости от результата 
сравнения.
<p>
unichr(n)	Возвращает односимвольную Unicode-строку с символом с кодом n.
<p>

<li> <a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=4">Функции обработки данных: apply, map, filter, 
reduce, zip, range, xrange, max, min, iter, enumerate, sum</a>


<h3 align=center><a name="filter">Функция filter()</h3>
Осуществляет отбор элементов из указанного итерируемого объекта.
<p>
Синтаксис:
<pre>filter(func, iterables)</pre>
Работает следующим образом. Если функция func возвращает True для текущего элемента итерируемого объекта iterables, то этот 
элемент входит в filter. Если же func возвращает False, то текущий элемент игнорируется.
<p>
<b>Скобки после func не пишутся</b>
<p>
В качестве первого аргумента могут применяться встроенные или собственные функции, lambda функции а также методы итерируемого 
объекта.



<h3 align=center><a name="map">Функция map()</h3>
Синтаксис:
<pre>map(func, iterables)</pre>
map вытаскивает каждый элемент из итерируемого объекта iterables и к этому элементу применяет функцию func.<br>
Пример:<br>
a = [1, -2, -3, 4]<br>
b = list(map(abs, a)) # вернет список из модулей элементов списка a
<p>
b = map(abs, a) вернёт map объект, чтобы увидеть значение этого объекта, нужно применить к нему функцию преобразования типов 
объекта.
<p>
<b>Скобки после func не пишутся</b>


<p>
<a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=5">Списковые включения</a><br>
<a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=6">Итераторы</a>



<h3 align=center><a name="range">Функция range</a></h3>
Функция range обычно применяется в цикле и позволяет перебрать какой-нибудь объект типа список по его индексу.
<pre>
for index range(len(spisok):
    print spisok(index)</pre>
функция range принимает от одного до трех аргументов. Если аргумент всего один, она генерирует список чисел от 0 
(включительно) <b>до заданного числа (исключительно).</b><br>
Если аргументов два, то список начинается с числа, указанного первым аргументом.<br>
Если аргументов три - третий аргумент задает шаг
<pre>
>>> print range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10, 3)
[1, 4, 7]</pre>
Третий аргумент может быть и отрицательным, служит для вывода элементов справа налево:
<pre>
>>> for i in range(10, 5, -1):
...     print(i)</pre>
Получим 10, 9, 8, 7, 6

<p>
Функция <b>xrange()</b> - аналог range(), более предпочтительный для использования при последовательном доступе, например, в 
цикле for или с итераторами. Она возвращает специальный xrange -объект, который ведет себя почти как список, порождаемый 
range(), но не хранит в памяти все выдаваемые элементы.
<p>
<li> Функции определения свойств: hash, id, callable, issubclass, isinstance, type
<p>
<li> Функции для доступа к внутренним структурам: locals, globals, vars, intern, dir
<p>
<li> Функции компиляции и исполнения: eval, execfile, reload, __import__, compile
<p>
<li> Функции ввода-вывода: input, raw_input, open<p>
<li> Функции для работы с атрибутами: getattr, setattr, delattr, hasattr
<p>
<li> Функции-"украшатели" методов классов: staticmethod, classmethod, property
<p>
<li> Прочие функции: buffer, slice
</ul>





<h3 align=center><a name="lambda"">lambda - функции</a></h3>
Ссылки: <a href="https://webdevblog.ru/kak-ispolzovat-v-python-lyambda-funkcii/">Как использовать в Python лямбда-функции</a>
<p>
Синтаксис:
<pre>name = <b>lambda arguments: expression(arguments)</b></pre>
lambda-функциям эквивалентен следующий код:
<pre>
def name(*arguments):
    return expression(arguments)</pre>
<i>expression(arguments)</i> - это выражение. В объект name записывается результат выражения от argument.
<p>    
<b>Шаблоны выполнения анонимной функции:</b>
<p>
<table border=1><tr>
<td>
Через переменную:
<pre>
>>> a = lambda x, y: x + y
>>> a(1, 3)
4</pre>
</td><td>
Можно и без присваивания переменной выполнять лямбду-функцию, через нижнюю черточку:
<pre>
>>> lambda x, y: x + y
&lt;function &lt;lambda&gt; at 0x7f2de74533a0&gt;
>>> _(1, 2)
3
</pre></td><td>
Другой шаблон — это немедленное выполнение лямбда-функции. Это называется <b>выражением немедленного вызова функции</b> (IIFE 
—  Immediately Invoked Function Expression, произносится «iffy»).
<pre>
>>> (lambda x, y: x + y)(2, 3)
5</pre></td>
</tr></table>
<p>
<h4>Аргументы</h4>
Как и обычный объект функции, определенный с помощью def, лямбда поддерживают все различные способы передачи аргументов. Это 
включает:
<ul>
<li> Позиционные аргументы
<li> Именованные аргументы (иногда называемые ключевыми аргументами)
<li> Переменный список аргументов (часто называемый varargs)
<li> Переменный список аргументов ключевых слов
<li> Аргументы только для ключевых слов
</ul>
Следующие примеры иллюстрируют опции, доступные для передачи аргументов в лямбда-выражения:
<pre>
>>> (lambda x, y, z: x + y + z)(1, 2, 3)
6
>>> (lambda x, y, z=3: x + y + z)(1, 2)
6
>>> (lambda x, y, z=3: x + y + z)(1, y=2)
6
>>> (lambda *args: sum(args))(1,2,3)
6
>>> (lambda **kwargs: sum(kwargs.values()))(one=1, two=2, three=3)
6
>>> (lambda x, *, y=0, z=0: x + y + z)(1, y=2, z=3)
6</pre>
<p>
<h4>lambda-функции в качестве аргумента функции или наоборот</h4>
Лямбда-функции часто используются с функциями более высокого порядка, которые принимают одну или несколько функций в качестве 
аргументов или возвращают одну или несколько функций.
<p>
Лямбда-функция может быть функцией более высокого порядка, принимая функцию (нормальную или лямбда-функцию) в качестве 
аргумента, как в следующем надуманном примере:
<pre>
>>> high_ord_func = lambda x, func: x + func(x)
>>> high_ord_func(2, lambda x: x * x)
6
>>> high_ord_func(2, lambda x: x + 3)
7</pre>
Здесь вызывается лямбда-функция по шаблону через переменную с двумя аргументами, где второй аргумент сам является лямбда-
функцией.
<p>

<h4><a name="decorator">Декораторы</h4>
В Python декоратор — это реализация шаблона, который позволяет добавить поведение к функции или классу. Обычно это выражается 
синтаксисом @decorator с префиксом функции. Вот пример:
<pre>
def some_decorator(f):
    def wraps(*args):
        print(f"Calling function '{f.__name__}'")
        return f(args)
    return wraps
@some_decorator
def decorated_function(x):
    print(f"With argument '{x}'")</pre>
В приведенном выше примере some_decorator() — это функция, которая добавляет поведение к decorated_function(), так что при 
вызове decorated_function(2) получается следующий результат:
<pre>
>>> decorated_function(2)
Calling function 'decorated_function'
With argument '(2,)'</pre>
decorated_function() печатает только With argument '(2,)', но декоратор добавляет дополнительное поведение, которое также 
печатает Calling function 'decorated_function'.
<p>
Декоратор может быть применен к лямбде. Хотя невозможно декорировать лямбду с помощью синтаксиса @decorator, декоратор — это 
просто функция, поэтому он может вызывать функцию лямбда:
<table border=1><tr><td>
<pre>
# <b>Определение декоратора</b>
def trace(f):
    def wrap(*args, **kwargs):
          print(f"[TRACE] func: {f.__name__}, args: {args}, kwargs: {kwargs}")
          return f(*args, **kwargs)
  
    return wrap
  
<b># Применение декоратора к функции:</b>
@trace
def add_two(x):
    return x + 2</pre>
</td></tr></table>
<pre>
# Calling the decorated function
>>> add_two(3)
[TRACE] func: add_two, args: (3,), kwargs: {}
5
# <b>Применение декоратора к lambda:</b>
>>> print((trace(lambda x: x ** 2))(3))
[TRACE] func: &lt;lambda&gt;, args: (3,), kwargs: {}
9
</pre>
add_two(), декорирована @trace в строке 11, вызывается с аргументом 3. В отличие от этого, в строке 18 сразу же 
включается лямбда-функция и встраивается в вызов метода trace(), декоратора.
<p>
Посмотрите, как, как вы уже видели, имя лямбда-функции выглядит как &lt;lambda&gt;, тогда как add_two четко идентифицировано 
как обычная функция.
<p>
Декорирование лямбды таким способом может быть полезно для целей отладки, возможно, для отладки поведения лямбды, используемой 
в контексте функции более высокого порядка или ключевой функции.
<p>
Давайте посмотрим пример с map():
<pre>list(map(trace(lambda x: x*2), range(3)))</pre>
Первый аргумент map() — это лямбда, которая умножает свой аргумент на 2. Эта лямбда декорирована trace(). При выполнении 
приведенный выше пример выводит следующее:
<pre>
[TRACE] Calling &lt;lambda&gt; with args (0,) and kwargs {}
[TRACE] Calling &lt;lambda&gt; with args (1,) and kwargs {}
[TRACE] Calling &lt;lambda&gt; with args (2,) and kwargs {}
[0, 2, 4]</pre>
<font color=red>Почему вывелся список [0, 2, 4], непонятно.</font>

<a name="zamik"><h4>Замыкание</h4>
<b>Замыкание</b> — это функция, в которой каждая свободная переменная, кроме параметров, используемых в этой функции, 
привязана к определенному значению, определенному в рамках области видимости этой функции. В сущности, замыкания определяют 
среду, в которой они работают, и поэтому могут вызываться из любого места. Более простое определение замыкания это когда 
функции более низшего порядка имеют доступ к переменным функции более высшего порядка.
<p>
Понятия лямбды и замыкания не обязательно связаны, хотя лямбда-функции могут быть замыканиями так же, как обычные функции 
также могут быть замыканиями. Некоторые языки имеют специальные конструкции для замыкания или лямбды (например, Groovy с 
анонимным блоком кода в качестве объекта Closure) или лямбда-выражения (например, лямбда-выражения Java с ограниченным 
параметром для замыкания).
<p>
Вот пример замыкания, построенное с помощью обычной функции Python:
<pre>
 1 def outer_func(x):
 2     y = 4
 3     def inner_func(z):
 4         print(f"x = {x}, y = {y}, z = {z}")
 5         return x + y + z
 6     return inner_func
 7 
 8 for i in range(3):
 9     closure = outer_func(i)
10     print(f"closure({i+5}) = {closure(i+5)}")</pre>
outer_func() возвращает inner_func(), вложенную функцию, которая вычисляет сумму трех аргументов:
<ul>
<li> x передается в качестве аргумента outer_func().
<li> y является локальной переменной для outer_func().
<li> z аргумент, передаваемый в inner_func() из 10 строки: closure({<b>i+5</b>}).
</ul>
Чтобы продемонстрировать поведение outer_func() и inner_func(), outer_func() вызывается три раза в цикле for, который выводит 
следующее:
<pre>
x = 0, y = 4, z = 5
closure(5) = 9
x = 1, y = 4, z = 6
closure(6) = 11
x = 2, y = 4, z = 7
closure(7) = 13</pre>
В строке 9 кода inner_func(), возвращаемый вызовом outer_func(), привязывается к имени замыкания.<br>
В строке 5 inner_func() захватывает x и y, потому что он имеет доступ к своей области видимости, так что при вызове замыкания 
он может работать с двумя свободными переменными x и y.
<p>
Точно так же лямбда также может быть замыканием. Вот тот же пример с лямбда-функцией Python:
<pre>
def outer_func(x):
    y = 4
    return lambda z: x + y + z
for i in range(3):
    closure = outer_func(i)
    print(f"closure({i+5}) = {closure(i+5)}")
</pre>
Когда вы выполняете приведенный выше код, вы получаете следующий вывод:
<pre>
closure(5) = 9
closure(6) = 11
closure(7) = 13
</pre>
В строке 6 outer_func() возвращает лямбду и присваивает ее переменную замыкания. В строке 3 тело лямбда-функции ссылается на x 
и y. Переменная y доступна во время определения, тогда как x определяется во время выполнения, когда вызывается outer_func().
<p>
В этой ситуации и нормальная функция, и лямбда ведут себя одинаково. В следующем разделе вы увидите ситуацию, когда поведение 
лямбды может быть обманчивым из-за времени его оценки (время определения против времени выполнения).
<p>
<h4>Классические функциональные конструкции</h4>
Лямбда-функции регулярно используются со встроенными функциями map() и filter(), а также functools.reduce(), представленными в 
модуле functools. Следующие три примера являются соответствующими иллюстрациями использования этих функций с лямбда-
выражениями в качестве компаньонов:
<pre>
>>> list(map(lambda x: x.upper(), ['cat', 'dog', 'cow']))
['CAT', 'DOG', 'COW']
>>> list(filter(lambda x: 'o' in x, ['cat', 'dog', 'cow']))
['dog', 'cow']
>>> from functools import reduce
>>> reduce(lambda acc, x: f'{acc} | {x}', ['cat', 'dog', 'cow'])
'cat | dog | cow'</pre>
<p>
<h4>UI Фреймворки</h4>
UI фреймворки, такие как Tkinter, wxPython или .NET Windows Forms с IronPython, используют лямбда-функции для отображения 
действий в ответ на события пользовательского интерфейса.
<p>
Простая программа Tkinter, представленная ниже, демонстрирует использование лямбды, назначенной команде кнопки Reverse:
<pre>
import tkinter as tk
import sys
window = tk.Tk()
window.grid_columnconfigure(0, weight=1)
window.title("Lambda")
window.geometry("300x100")
label = tk.Label(window, text="Lambda Calculus")
label.grid(column=0, row=0)
button = tk.Button(
    window,
    text="Reverse",
    command=lambda: label.configure(text=label.cget("text")[::-1]),
)
button.grid(column=0, row=1)
window.mainloop()</pre>
Нажатие кнопки «Reverse» запускает событие, которое запускает лямбда-функцию, изменяя метку с Lambda Calculus на suluclaC 
adbmaL *:
<p>
<img src="./images/python_base9.png">
<p>
И wxPython, и IronPython используют одинаковый подход для обработки событий. Обратите внимание, что лямбда-это один из 
способов обработки событий, но функцию можно использовать для той же цели. В конечном итоге код становится автономным и менее 
многословным при использовании лямбды, когда объем необходимого кода очень мал.
<pre>

</pre>
==============================================================================================================
<h3 align=center><a name="file" href="https://pyplanet.ru/article/files.html">Работа с файлами: чтение, запись, 
редактирование</a></h3>
В Python, как и в других языках программирования, можно работать с файлами: читать из файла и писать в файл. Это позволяет 
легко манипулировать любыми файлами из Python.
<p>
Файловые объекты должны поддерживать основные методы: read(), write(), readline(), readlines(), seek(), tell(), close() и т.п.
<p>
Прежде, чем работать с файлом, его надо открыть. Открыть файл можно с помощью встроенной функции open:
<pre>
f = open('pyplanet.txt', 'r', encoding='utf-8')</pre>
У функции open много параметров, нам пока важны 3 аргумента.
<p>
Первый, это путь к файлу. Путь к файлу может быть относительным или абсолютным.
<p>
В случае относительного пути поиск файла будет производиться относительно директории, из которой была запущена программа на Python. Как правило, это та папка, в которой находится сама программа.
<p>
Поэтому, чтобы приведённый выше код выполнился, необходимо создать файл pyplanet.txt в той же папке, что и программа, которую вы пишете.
<p>
Однако можно задать и абсолютный путь, например,
<pre>
f = open(r'D:\files\pyplanet.txt', 'r', encoding='utf-8')</pre>
Второй аргумент, это режим, в котором мы будем открывать файл.
<p>
<img src="./images/python_base1.png">
<p>
Режимы могут (и должны) быть объединены, то есть, к примеру, 'rb' - чтение в двоичном режиме. По умолчанию режим равен 'rt'.
<p>
И последний аргумент, encoding, нужен только в текстовом режиме чтения файла. Этот аргумент задает кодировку.
<p>
Какая кодировка идёт по умолчанию? А неизвестно. Начиная с Python версии 3.15 (это примерно к 2026 году) кодировкой по умолчанию станет utf-8.
<p>
В какой же кодировке Ваш файл, зависит от редактора, в котором вы создавали / редактировали файл.
<p>
Как правило, это utf-8, или, в более редких случаях, windows-1251.
<p>
Функция open возвращает объект файла (или по-другому файлового дескриптора).
<h4>Чтение из файла</h4>
Файл мы открыли, а теперь хотим прочитать из него информацию. Для этого есть несколько способов.
<p>
<b>Метод read</b><br>
Метод read файла, читает весь файл целиком, если был вызван без аргументов, и n символов, если был вызван с аргументом (целым числом n).
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> f.read(1)
'H'
>>> f.read()
'ello world!\nThe end.\n\n'</pre>
Каждый последующий вызов read продолжит читать с того места, на котором остановилось чтение.
<h4>Цикл for для чтения файла</h4>
Ещё один прочитать файл - сделать это построчно, воспользовавшись циклом for. Файловый объект в Python - тоже итерируемый объект, и в цикле for он возвращает содержимое файла построчно.
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> for line in f:
...     line
...
'Hello world!\n'
'\n'
'The end.\n'
'\n'</pre>
<h4>readlines</h4>
Метод readlines файла, читает весь файл целиком, и возвращает список всех строк в нём. Этот способ более затратный по памяти, чем цикл for, однако иногда тоже может использоваться.
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> f.readlines()
['Hello world!\n', '\n', 'The end.\n', '\n']</pre>
<h4>Закрытие файла</h4>
После манипуляций с файлом, его необходимо закрыть, таким образом, освободив ресурсы файлового дескриптора.
<pre>f.close()</pre>
Все дескрипторы, конечно, будут освобождены автоматически при выходе из программы, но что, если программа работает долго? Или она открывает много файлов?
<p>
Количество одновременно открытых файлов в системе ограничено.
<p>
Здесь очень сильно может помочь конструкция try - finally, так как при возникновении и перехвате исключения можно забыть закрыть файл:
<pre>
f = open('pyplanet.txt', 'r', encoding='utf-8')
try:
    for line in f:
        do_something(line)
finally:
    f.close()</pre>
<h4>Запись в файл</h4>
Как что-либо записать в файл?
<p>
Во-первых, необходимо открыть файл в режиме "для записи", иначе ничего не получится:
<pre>f = open('pyplanet_output.txt', 'w', encoding='utf-8')</pre>
<ol>
<li> <b>Метод write</b><br>
Метод write, записывает строку в файл:
<pre>f.write("Hello pyplanet!\n")</pre>
Метод write возвращает количество записанных символов. Не пугайтесь, если в интерактивном режиме увидите цифры - это они и есть.<br>
Перенос строки не добавляется автоматически. Не забывайте добавлять его вручную, иначе строки "слипнутся".
<p>
<img src="./images/python_base6.png"><br>
На рисунке показаы 2 способа записи в файл. Число не записывается напрямую, сначало нужно с помощью функции str() преобразовать число в строку.
<p>
<li> <b>Аргумент file функции print</b><br>
Функция print может принимать в качестве аргумента файловый дескриптор для печати.
<p>
Из плюсов - символ переноса строки поставится за вас:
<pre>print("Hello pyplanet!", file=f)</pre>
<p>
<li> <b>Метод writelines</b><br>
Метод writelines, записывает список строк в файл:
<pre>f.writelines(["1\n", "2\n", "3\n"])</pre>
Перенос строки, как и в методе write, не добавляется автоматически. Не забывайте добавлять его вручную, иначе строки "слипнутся".<br>
Для записи более сложных структур в Python есть такие средства, как pickle, json, csv, и многие другие.
<p>
Примеры:<br>
Следующий пример показывает копирование файла:
<pre>
f1 = open("file1.txt", "r")
f2 = open("file2.txt", "w")
for line in f1.readlines():
  f2.write(line)
f2.close()
f1.close()
</pre>

<li> Стоит заметить, что кроме собственно файлов в Python используются и файлоподобные объекты. В очень многих функциях просто 
неважно, передан ли ей объект типа file или другого типа, если он имеет все те же методы (и в том же смысле). Например, 
копирование содержимого по ссылке (URL) в файл file2.txt можно достигнуть, если заменить первую строку из предыдущего примера 
на:
<pre>
import urllib
f1 = urllib.urlopen("http://python.onego.ru")</pre>

<li> <b>with open() as var</b><br>
Открыть файл, выполнить с ним нужные операции и автоматически закрыть его после можно с помощью конструкции:
<pre>
with open('name_file') as var
    s1 = var.readline()
    s2 = var.readline()</pre>
По выполнении блока, файловый дескриптор будет удален (файл закроется). Поэтому такая конструкция with open file as f является 
более рекомендованной по сравнению с f = open file
<li> <b>Полезные методы файлов</b>
<ol>
<li> strip()<br>
Удаляет служебные символы при чтении строк файла.

<li> os.path.join(arg1, arg2,...)<br>
Создает из склеивания аргументов полный путь к файлу.<br>
Для того чтобы выполнить этот метод, нужно импортировать модуль os (import as).
<p>
<img src="./images/python_base5.png">
</ol>
<li> <b>Пример построчного чтения файла</b>
<pre>with open('input.txt') as inf:
  for line in inf:
      line = line.strip()
      print()</pre>
</ol>
<pre>

============================================================================================================


</pre>

<h3 align=center><a name="except">Исключения: try except</h3>
Ошибки в питоне называются <b>исключениями.</b>
С помощью ключевых слов можно реализовать механизм обработки ошибок во время выполнения программы. Он позволяет программе 
продолжить работу после обнаружения ошибки, а не завершаться аварийно. В Python есть встроенные исключения, которые 
обрабатывают большинство типовых ошибок.
<p>
Обычные ошибки:
<ul>
<li> TypeError — операция или функция применяется к объекту несоответствующего типа.
<li> ValueError — операция или функция получает аргумент неподходящего значения. К примеру, исключение возникает, если 
попытаться преобразовать строку в число.
<li> IndexError — обращение к элементу по несуществующему индексу.
<li> ZeroDivisionError — деление числа на ноль.
<li> FileNotFoundError — Python не может найти файл, который мы хотим открыть.
</ul>
Полный список ошибок <a href="https://docs.python.org/3/library/exceptions.html">здесь.</a>
<p>
В Python есть всё необходимое для создания собственных обработчиков исключений. Это полезно, если надо реализовать нетипичное 
для Python поведение, которое не предусмотрели разработчики. Для этого используются блоки try, except, finally, else и raise:
<ul>
<li> В блоке try/except механизм работает таким образом:
<p>
сначала выполняются выражения, которые записаны в блоке try
<p>
если при выполнения блока try не возникло никаких исключений, блок except пропускается, и выполняется дальнейший код
<p>
если во время выполнения блока try в каком-то месте возникло исключение, оставшаяся часть блока try пропускается
<p>
если в блоке except указано исключение, которое возникло, выполняется код в блоке except
<p>
если исключение, которое возникло, не указано в блоке except, выполнение программы прерывается и выдается ошибка
<p>
<pre>
try:
    a = input("Введите первое число: ")
    b = input("Введите второе число: ")
    print("Результат: ", int(a)/int(b))
except (ValueError, ZeroDivisionError):
    print("Что-то пошло не так...")</pre>
Проверка:
<pre>
$ python divide_ver2.py
Введите первое число: wer
Введите второе число: 4
Что-то пошло не так...

$ python divide_ver2.py
Введите первое число: 5
Введите второе число: 0
Что-то пошло не так...</pre>
<p>
<li> <b>try/except/else</b><br>
В конструкции try/except есть опциональный блок else. Он выполняется в том случае, если не было исключения.
<pre>
try:
    a = input("Введите первое число: ")
    b = input("Введите второе число: ")
    result = int(a)/int(b)
except (ValueError, ZeroDivisionError):
    print("Что-то пошло не так...")
else:
    print("Результат в квадрате: ", result**2)</pre>
Пример выполнения:
<pre>
$ python divide_ver3.py
Введите первое число: 10
Введите второе число: 2
Результат в квадрате:  25

$ python divide_ver3.py
Введите первое число: werq
Введите второе число: 3
Что-то пошло не так...</pre>
<p>
<li> <b>try/except/finally</b><br>
Блок finally - это еще один опциональный блок в конструкции try. Он выполняется всегда, независимо от того, было ли исключение 
или нет.
<br>Сюда ставятся действия, которые надо выполнить в любом случае. Например, это может быть закрытие файла.
<p>
Файл divide_ver4.py с блоком finally:
<pre>
# -*- coding: utf-8 -*-

try:
    a = input("Введите первое число: ")
    b = input("Введите второе число: ")
    result = int(a)/int(b)
except (ValueError, ZeroDivisionError):
    print("Что-то пошло не так...")
else:
    print("Результат в квадрате: ", result**2)
finally:
    print("Вот и сказочке конец, а кто слушал - молодец.")</pre>
Проверка:
<pre>
$ python divide_ver4.py
Введите первое число: 10
Введите второе число: 2
Результат в квадрате:  25
Вот и сказочке конец, а кто слушал - молодец.
</pre>
<p>
<li> Ключевое слово <b>as</b> при обработке ошибок используется для присвоения исключению переменной. К примеру, напишем 
собственное исключение для обработки деления на ноль. Ошибку назовём ZeroDivisionError и присвоим переменной e. Теперь к ней 
можно получить доступ для печати названия ошибки в консоль.
<pre>
try:
    1/0
except ZeroDivisionError as e:
    print(f'Исключение: {str(e)}') # Исключение: division by zero</pre>
<p>
<li> Команда <b>raise</b> в Python используется для принудительного вызова исключения. Это может быть полезно, если мы 
столкнулись с условием, которое должно остановить выполнение программы или вызвать ошибку.
<pre>raise ValueError('Недопустимое значение')</pre>

<h4>Создание собственных исключений</h4>
Ссылки: <a href="https://habr.com/ru/companies/piter/articles/537642/">Как определять собственные классы исключений в Python</
a>
<p>
Иногда надо реализовать собственный обработчик ошибок с помощью исключений. Это делает код более безопасным и поддерживаемым. 
Для создания собственного исключения достаточно определить новый класс, который наследуется от базового класса Exception или 
от любого другого встроенного исключения:
<pre>
class ValidationError(Exception):
    pass</pre>

</ul>







<h3><a href="https://pyplanet.ru/article/with-as.html">Конструкция with - as: менеджер контекста</a></h3>
<h3><a href="https://pyplanet.ru/article/magic-methods.html">Магические методы</a></h3>
<h3><a href="https://pyplanet.ru/article/pip.html">Пакетный менеджер pip</a></h3>






<h3 align=center><a href="https://intuit.ru/studies/courses/49/49/lecture/27080">Лекция 12: Создание приложений с графическим интерфейсом</a></h3>














</div>
<br><br><br><br><br></body></html>
