<html><head>
<style>
.menu {
       height: 100%;
       width: 140px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 155px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Основы Python</title>
<div class="menu">
<a href="#sintaks">Синтаксис</a>
<a href="#var">Переменные</a>
<a href="#number">Числа</a>
<a href="#string">Строки</a>
<a href="#list">Список</a>
<a href="#set">Множества</a>
<a href="#typle">Кортеж</a>
<a href="#diction">Словарь</a>
<a href="#gener">Генератор</a>
<a href="#table">Прямоугольная матрица</a>
<a href="#range">Функция range</a>
<a href="#srez">Срез массивов</a>
<a href="#unpack">Распаковка</a>
<a href="#metod">Методы</a>
<a href="#if">Условие if</a>
<a href="#while">Циклы while</a>
<a href="#for">и for</a>
<a href="#potok">Вызов методов цепочкой</a>
<a href="#def">Функции</a>
<a href="#file">Работа с файлами</a>
<a href="#modul">Импорт и создание модулей</a>
<a href="#lib">Стандартная библиотека</a>

</div>
<div class="content">
<h2 align=center><a name="top">Введение в Python</h2>
Ссылки на учебники: <a href="https://pythonworld.ru/samouchitel-python">Самоучитель Python</a><br>
<a href="https://stepik.org/course/67">Программирование на Python (07.10.2024 - 20.10.2024)</a><br>
<a href="https://stepik.org/course/512">Python: основы и применение (20.10.2024 - )</a>
<p>
Языки программирования делятся на два типа:
<ul>
<li> Компилируемые<br>
Специальная программа, компилятор, преобразует исходный код в машинный.<br>
Полученный в результате файл готов к исполнению без дополнительных инструментов.<br>
Примеры: C++, Colang, Rust
<li> Интерпретируемые<br>
Код исполняется строчка за строчкой специальной программой - интерпретатором.<br>
Исполнение возможно только при наличии этой программы.<br>
Примеры: Python, Lua, JavaScript.
</ul>

<h3 align=center><a href="https://pyplanet.ru/article/install.html">Установка Python на linux системы (Ubuntu, Debian и другие)</a></h3>
Откройте консоль (обычно ctrl+alt+t). Введите в консоли:
<pre>python3</pre>
Скорее всего, вас любезно поприветствует python:
<pre>
dmitriy@945G-M3:~$ python3
Python 3.8.10 (default, Sep 11 2024, 16:02:53) 
[GCC 9.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 
</pre></pre>
или узнать версию  python:
<pre>
dmitriy@945G-M3:~$ python3 --version
Python 3.8.10</pre>
Если это так, то можно вас поздравить: у вас уже стоит python. В противном случае нужно установить пакет *python3*:
<pre>sudo apt install python3</pre>
Чтобы загрузить установщики для операционных систем Windows и Mac OS, достаточно перейти по ссылке https://www.python.org/downloads/release/python-351/ ﻿и в самом низу страницы ﻿выбрать ﻿нужный для вашей архитектуры установщик интерпретатора: для windows 64bit - "﻿Windows x86-64 executable installer", для windows 32bit - "Windows x86 executable installer﻿", для Mac OS ﻿64 bit ﻿- ﻿"Mac OS X 64-bit/32-bit installer", ﻿ для Mac OS 32bit/PPC - ﻿﻿"Mac OS X 32-bit i386/PPC installer".


<h3 align=center>На чем писать код и как выпонять?</h3>
<ol>
<li> VS code и Pycharm<br>
для моего компьютера очень тяжелые.
<li> В python для linux нет предустановленной среды IDLE. Если хотите, её можно установить отдельно. Пакет называется idle3 (в более ранних версиях он может называться python3-idle).<br>
Однако, её установка не является обязательной. Вы можете писать в своём любимом текстовом редакторе (gedit, vim, emacs...) и запускать программы через консоль:<br>
python3 path_to_file.py
<p>
Как писать на <a href="https://pyplanet.ru/article/hello-world.html">IDLE</a>
<li> https://repl.it/<br>
Начал на нем.
<li> Jupyter Notebook<br>
Чтобы начать на нем работать, команда:
<pre>jupyter notebook</pre>

<li> <b>Shebang</b> — это специальное выражение, которое указывается в начале файла исполняемого скрипта. Оно сообщает системе, какой интерпретатор использовать для запуска скрипта.
<p>
В случае с Python это может быть один из двух вариантов:
<p>
/usr/bin/env python. Более переносимый вариант, который позволяет системе самой найти нужный интерпретатор Python.
<p>
/usr/local/bin/python. Требует, чтобы интерпретатор Python был установлен именно в этом месте.
<p>
Использование shebang не является обязательным для Python-скриптов. Оно полезно, если скрипт предназначен для запуска из командной строки Unix как самостоятельная программа. Если же скрипт запускается из другого Python-скрипта с помощью функции exec() или подобных, то shebang не требуется.
<p>
Написал простой код 1.py:
<pre>
#!/usr/bin/env python 
print("aggggggg")</pre>
Если выполнить скрипт, просто: <b>1.py</b><br>
<font color=red>то команда не найдена.</font><br>
если: <b>source 1.py</b><br>
<font color=red>то синтаксическая ошибка</font>
<p>
Прочитал, что требуется указывать полный путь к скрипту для его выполнения. Выполнил: 
<pre>/usr/bin/python3 ~/Python/1.py</pre>
Выполнился без ошибок. После этого:
<pre>~/Python/1.py
     /usr/bin/env: «python»: Нет такого файла или каталога</pre>
Очевидно неправильный шебанг.<br>
Исправил:
<pre>
#!/usr/bin/env <font color=green>python3</font> 
print("aggggggg")</pre>
Снова: ~/Python/1.py<br>
Теперь выполнился и без ошибок.
<p>
Если все же выполнить:
<pre>
1.py
1.py: команда не найдена</pre>
То есть все равно нужно указывать явный путь к файлу.py
<p>
<li> <b>Интерактивный режим:</b><br>
Выполняем команду: <b>python3</b> и далее можно выполнять команды сразу после каждой строки.<br>
Выход из интерактивного режима: нажатие Ctrl+z
<p>
Чтобы выполнить скрипт в интерактивном режиме, команда:
<pre>python3 -i ~/Python//mypython/1.py</pre>
</ol>





<h3 align=center><a name="sintaks">Синтаксис</h3>
Синтаксис языка Python очень прост.
<ul>
<li> Конец строки является концом инструкции (точка с запятой не требуется).

<li> Вложенные инструкции объединяются в блоки по величине отступов. Отступ может быть любым, главное, чтобы в пределах одного вложенного блока отступ был одинаков. Однако хорошим тоном считается отступ каждого блока в 4 пробела
<li> Вложенные инструкции в Python записываются в соответствии с одним и тем же шаблоном, когда основная инструкция завершается двоеточием, вслед за которым располагается вложенный блок кода, как правило, с отступом под строкой основной инструкции.
<pre>
Основная инструкция:
    Вложенный блок инструкций</pre>
<h4><a href="https://intuit.ru/studies/courses/49/49/lecture/27058?page=7">Имена</a></h4>    
Имя может начинаться с латинской буквы (любого регистра) или подчеркивания, а дальше допустимо использование цифр. В качестве идентификаторов нельзя применять ключевые слова языка и нежелательно переопределять встроенные имена.<br>
<p>Имена, начинающиеся с подчеркивания или двух подчеркиваний, имеют особый смысл. Одиночное подчеркивание говорит программисту о том, что имя имеет местное применение, и не должно использоваться за пределами модуля. Двойным подчеркиванием в начале и в конце обычно наделяются специальные имена атрибутов - об этом будет говориться в лекции по объектно-ориентированному программированию.
<p>    
В каждой точке программы интерпретатор "видит" три пространства имен: локальное, глобальное и встроенное. Пространство имен - отображение из имен в объекты.
<p>
Для понимания того, как Python находит значение некоторой переменной, необходимо ввести понятие блока кода. В Python блоком кода является то, что исполняется как единое целое, например, тело определения функции, класса или модуля.
<p>
Локальные имена - имена, которым присвоено значение в данном блоке кода. Глобальные имена - имена, определяемые на уровне блока кода определения модуля или те, которые явно заданы в операторе global. Встроенные имена - имена из специального словаря __ builtins __.
<p>
Области видимости имен могут быть вложенными друг в друга, например, внутри вызванной функции видны имена, определенные в вызывающем коде. Переменные, которые используются в блоке кода, но связаны со значением вне кода, называются свободными переменными.
<p>
Так как переменную можно связать с объектом в любом месте блока, важно, чтобы это произошло до ее использования, иначе будет возбуждено исключение NameError. Связывание имен со значениями происходит в операторах присваивания, from, import, в формальных аргументах функций, при определении функции или класса, во втором параметре части except оператора try-except.
<p>
С областями видимости и связыванием имен есть много нюансов, которые хорошо описаны в документации. Желательно, чтобы программы не зависели от таких нюансов, а для этого достаточно придерживаться следующих правил:
<ul>
<li> Всегда следует связывать переменную со значением (текстуально) до ее использования.
<li> Необходимо избегать глобальных переменных и передавать все в качестве параметров. Глобальными на уровне модуля должны остаться только имена-константы, имена классов и функций.
<li> Никогда не следует использовать from модуль import * - это может привести к затенению имен из других модулей, а внутри определения функции просто запрещено.
</ul>
Предпочтительнее переделать код, нежели использовать глобальную переменную. Конечно, для программ, состоящих из одного модуля, это не так важно: ведь все определенные на уровне модуля переменные глобальны.
<p>
Убрать связь имени с объектом можно с помощью оператора del. В этом случае, если объект не имеет других ссылок на него, он будет удален.     
    
    
<h4><a href="https://intuit.ru/studies/courses/49/49/lecture/27058?page=8">Стиль программирования</a></h4>
Ссылки: <a href="https://intuit.ru/studies/courses/49/49/lecture/27058?page=8">Стиль программирования</a><br>
<a href="https://egorovegor.ru/python-pep8/">PEP8: руководство по написанию чистого и читаемого кода на Python</a><br>
<a href="https://peps.python.org/pep-0008/">PEP 8 – Style Guide for Python Code</a>

<p>
Наиболее существенные положения этого стиля перечислены ниже. В случае сомнений хорошим образцом стиля являются модули стандартной библиотеки.
<ul>
<li> Рекомендуется использовать отступы в 4 пробела.
<li> <b>Максимальная длина строки</b><br>
Ограничьте длину строки не более чем 79 символами. Если строка длиннее, разбейте ее на несколько строк. Длинные строки могут быть трудны для чтения, особенно когда они выходят за границы окна редактора. Разбиение длинных строк на несколько строк с помощью продолжения строки с помощью символа обратной косой черты \является хорошей практикой.

<li> Длинные логические строки лучше разбивать неявно (внутри скобок), но и явные методы вполне уместны. Отступы строк продолжения рекомендуется выравнивать по скобкам или по первому операнду в предыдущей строке. Текстовый редактор Emacs в режиме python-mode и некоторые интегрированные оболочки (IDE) автоматически делают необходимые отступы в Python-программах:
<pre>
def draw(figure, color="White", border_color="Black",
         size=5):
    if color == border_color or \
       size == 0:
        raise "Bad figure"
    else:
        _draw(size, size, (color,
                           border_color))</pre>
<li> <b>Пробелы</b><br>
Используйте один пробел между операторами и операндами. Не используйте пробелы для выделения скобок вокруг аргументов функций. Это правило помогает упростить код и сделать его более читабельным.
<br>Например:
<pre>
# Правильно:
x = 2 + 3
y = (1 + 2) * 3
​
# Неправильно:
x=2+3
y = ( 1 + 2 ) * 3</pre>
Не рекомендуется ставить пробелы сразу после открывающей скобки или перед закрывающей, перед запятой, точкой с запятой, перед открывающей скобкой при записи вызова функции или индексного выражения.<br>
Также не рекомендуется ставить более одного пробела вокруг знака равенства в присваиваниях. Пробелы вокруг знака равенства не ставятся в случае, когда он применяется для указания значения по умолчанию в определении параметров функции или при задании именованных аргументов.<br>
Также рекомендуется применение одиночных пробелов вокруг низкоприоритетных операций сравнения и оператора присваивания. Пробелы вокруг более приоритетных операций ставятся в равном количестве слева и справа от знака операции.
<p>
<b>Пробелы вокруг операторов</b><br>
Используйте пустые строки для разделения логически связанных частей кода. Не используйте несколько операторов на одной строке.
<p>
Используйте пробелы вокруг операторов (=, +, -, *, /, //, %, и т. д.), но не используйте пробелы вокруг <b>символа индексирования или среза.</b>
<pre>
# Правильно:
x = 2 + 3
y = x * 4
z = list[0]

# Неправильно:
x=2+3
y = x*4
z = <font color=red>list [0]</font>
</pre>
<p>
<li> <b>Именование</b><br>
Используйте понятные и описательные имена переменных, функций и методов. Для имени переменных используйте строчные буквы, а для имен функций и методов — заглавные буквы. Это правило помогает делать ваш код более читаемым и понятным для других программистов.
<p>
Например:
<pre>
# Правильно:
age = 25
name = "John"

def calculate_sum(numbers):
    return sum(numbers)

# Неправильно:
a = 25
b = "John"

def calc_sum(nums):
    return sum(nums)
</pre>
<p>
<b>Названия функций и методов</b>
Используйте глаголы в названиях функций и методов, используйте нижнее подчеркивание для разделения слов. Это правило помогает делать код более понятным и легче читаемым.
<pre>
# Правильно:
def calculate_sum(numbers):
    return sum(numbers)

def get_user_name(user):
    return user.name

# Неправильно:
def numbersSum(nums):
    return sum(nums)
</pre>
<b>Название переменных</b><br>
Используйте понятные и описательные названия для переменных, избегайте использования одиночных символов в качестве названий переменных, используйте нижнее подчеркивание для разделения слов.
<pre>
# Правильно:
total_sum = 0
list_of_numbers = [1, 2, 3, 4]
user_name = "John"

# Неправильно:
t = 0
n = [1, 2, 3, 4]
un = "John"
</pre>
<p>
Имена модулей лучше давать строчными буквами, например, shelve, string, либо делать первые буквы слов заглавными, StringIO, UserDict. Имена написанных на C модулей расширения обычно начинаются с подчеркивания " _ ", а соответствующие им высокоуровневые обертки - с прописных букв: _tkinter и Tkinter.
<p>
Классы обычно называют, выделяя первые буквы слов прописными, как в Tag или HTTPServer.
<p>
Имена глобальных переменных (если таковые используются) лучше начинать с подчеркивания, чтобы они не импортировались из модуля оператором from-import со звездочкой.
<p>
Имена констант (имен, которые не должны переопределяться) лучше записывать прописными буквами, например: RED, GREEN, BLUE.
<p>
<li> <b>Комментарии</b><br>
Комментарии должны быть короткими, лаконичными и описательными, они должны помогать другим программистам понимать ваш код. Не используйте комментарии для описания очевидных вещей, таких как присваивание переменной значения, и избегайте комментариев в конце строки. После коротких комментариев можно не ставить точку, тогда как длинные лучше писать по правилам написания текста. 
<p>
Комментарии к фрагменту кода следует писать с тем же отступом, что и комментируемый код. После " # " должен идти <b>одиночный пробел</b>. Абзацы можно отделять строкой с " # " на том же уровне.<br>
Блочный комментарий можно отделить пустыми строками от окружающего кода.
<p>
Комментарии, относящиеся к конкретной строке, не следует использовать часто. <b>Символ " # " должен отстоять от комментируемого оператора как минимум на два пробела.</b>
<p>
Хороший комментарий не перефразирует программу, а содержит дополнительную информацию о действии программы в терминах предметной области.
<p>
<li> <b>Импорты</b>
Импортируйте модули в алфавитном порядке, разделяйте группы импортов пустой строкой и избегайте использования символа *. Это правило помогает упростить импорты и улучшить читабельность кода.
<pre>
# Правильно:
import datetime
import os

from math import sqrt

import requests

# Неправильно:
import requests, os, datetime

from math import *

import my_module
</pre>
<p>
<li> 
Все модули, классы, функции и методы, предназначенные для использования за пределами модуля, должны иметь строки документации, описывающие способ их применения, входные и выходные параметры.

<li> <b>Документация:</b><br>
Для строк документации рекомендуется везде использовать утроенные кавычки ( """ ).
<p>
Строка документации для отдельной программы должна объяснять используемые ею ключи, назначение аргументов и переменных среды и другую подобную информацию.
<p>
Однострочная документация пишется в императиве, как команда: "делай это", "возвращай то".
<p>
Многострочная документация содержит расширенное описание модуля, функции, класса. Она будет смотреться лучше, если текст будет написан с тем же отступом, что и начало строки документации.
<p>
Документация для модуля должна перечислять экспортируемые функции, классы, исключения и другие объекты, по одной строке на объект.
<p>
Строка документации для функции или метода должна кратко описывать действия функции, ее входные параметры и возвращаемое значение, побочные эффекты и возможные исключения (если таковые есть). Должны быть обозначены необязательные аргументы и аргументы, не являющиеся частью интерфейса.
<p>
Документация для класса должна перечислять общедоступные методы и атрибуты, содержать рекомендации по применению класса в качестве базового для других классов. Если класс является подклассом, необходимо указать, какие методы полностью заменяют, перегружают, а какие используют, но расширяют соответствующие методы надкласса. Необходимо указать и другие изменения по сравнению с надклассом.
<p>
<li> Контроль версий повышает качество процесса создания программного обеспечения. Для этих целей часто используются RCS или CVS. "Python Style Guide" рекомендует записывать $Revision: 1.31 $ в переменную с именем __version__, а другие данные заключать в комментарии " # ".

</ul>




<h2 align=center><a name="var">Переменные</h2>
Для имени переменной используется любой набор допустимых символов: буквы английского алфавита, цифры, знак _. При этом цифру нельзя ставить в начале.
<p>
<i>В Python переменные являются лишь именованиями объектов. Ссылками на объекты, если так проще.
<p>
Присвоив, скажем, переменной b значение 5 (b = 5) - стоит помнить, что переменная b лишь ссылается на целочисленное значение 5.
<p>
При желании можно объявить переменную b хоть стоковым значением (b = str(b)) и это будет всё та же "5", но уже не целочисленная. И арифметических действий с ней уже не получится. Просто старое значение (ссылка) переменной будет стёрта и теперь она уже будет ссылаться на 5 - объект типа strint (str).
<p>
Точно также и с преобразованием во float - это будет ссылка уже на третий объект, 5.0 типа float.
<p>
Все три объекта в ходе этих операций не менялись, они неизменны. Просто переменная ссылалась то на один, то на другой. 
<p>
По сути, когда вы присваиваете переменной значение - в памяти "создаётся объект". Если дальше значение в этой переменной изменилось, и на старый объект она больше не ссылается - то (при условии, что на старый объект не ссылается какая-нибудь другая переменная) так называемый "Сборщик мусора" (встроенная, автоматическая штука в компиляторе Python, которая облегчает нам всем жизнь) уничтожает этот самый объект (когда на него больше никакая переменная не ссылается, значит - он в памяти больше не нужен). 
<p>
Так что да, технически - объекты этих типов не изменяемы. Надеюсь, не слишком сумбурно изложил.</i>
<p>
Ещё:<br>
<i>В Python есть изменяемые и неизменяемые типы. Изменяемые отличаются тем, что их содержимое можно сменить, не изменив ссылку на них. Неизменяемые объекты приходится пересоздавать, чтобы отразить изменения состояния. При этом все старые ссылки не видят это обновление, потому что указывают на старый объект.
<p>
Поясню на практике. Списки, словари, множества - это изменяемые объекты:
<pre>
l1 = [1, 2, 3]
l2 = l1
print(l1, l2, id(l1), id(l2))  
# [1, 2, 3] [1, 2, 3] 139917408901064 139917408901064

l1[1] = 10
print(l1, l2, id(l1), id(l2))  
# [1, 10, 3] [1, 10, 3] 139917408901064 139917408901064</pre>
Числа, строки, кортежи - это неизменяемые объекты:
<pre>
v1 = 1024
v2 = v1
print(v1, v2, id(v1), id(v2))
# 1024 1024 ...7040 ...7040

v1 = 2048
print(v1, v2, id(v1), id(v2))
# 2048 1024 ...5312 ...7040

t1 = (1, 2, 3)
t2 = t1
print(t1, t2, id(t1), id(t2))
# (1, 2, 3) (1, 2, 3) ...6232 ...6232

# t1[1] = 10  # не сработает, так как кортежи неизменяемые
t1 = (1, 10, 3)
print(t1, t2, id(t1), id(t2))
# (1, 10, 3) (1, 2, 3) ...7240 ...6232</pre></i>


<h3><a name="number">Числа:</h3>
Типы int и float
<p>
Все объекты в Python принадлежат какому-то классу или, другими словами, у всех данных есть свой определенный тип. Чтобы узнать тип данных, можно воспользоваться следующим кодом:
<pre>
print(type(5))
print(type(5.8))</pre>
В первом случае будет выведен результат &lt;class 'int'&gt;, а во втором - &lt;class 'float'&gt;. Целые числа принадлежат классу int, дробные - классу float.
<p>
Тип можно менять:
Функция int(x) - преобразует число x типа float (вещественное) в число типа int (целое)
<pre>
>>> x=2.7666
>>> print(int(x))
2</pre>
float(x) наоборот выводит число int типа в типе float
<pre>
>>> x=7
>>> type(x)
&lt;class 'int'&gt;
>>> print(float(x))
7.0
>>> type(x)
&lt;class 'int'&gt;
>>> print(x)
7</pre>
Нужно иметь в виду, что объекты: числа строки являются неизменяемыми, потому x=7 в примере выше не изменилось, только вывод функции в другом формате.
<p>
<ul>
<li> <b>Операции с числами</b><br>
Над объектами из классов int и float можно производить стандартные арифметические операции:
<pre>
print(5+7)
print(10-4)
print(64/8)
print(9*8+25/5)</pre>

В Python есть 3 типа делений:
<pre>
print(17/2) #обычное деление - результат - число с плавающей точкой (вещественное) 8.5
print(17//2) #целочисленное деление, результат - целая часть при делении
print(17%2) #деление с остатком - результат 1, остаток при делении</pre>
Обратите внимание на текст после знака #. Так в Python обозначаются комментарии. Эта часть кода не обрабатывается интерпретатором, она нужна для вас и других разработчиков, которые будут работать с кодом.
<p>
Многострочные комментарии делаются с помощью тройных кавычек:
<pre>
'''Различные варианты деления в Python
обычное деление
целочисленное деление
деление с остатком'''</pre>
<li> <b>Возведение в степень:</b>
<pre>
print(3**6)
print(10**(-1))
print(25**(1/2))</pre>
Результат выполнения этой программы:
<pre>
729 
0.1
5.0
</pre>
<li> <b>Приоритет арифметических операций</b><br>
Это хоть и кажется иногда очевидным, или несущественным, но на самом деле крайне важно.<br>
Сначала идут выражения в скобках<br>
Затем операция возведения в степень<br>
Затем умножение и деление (обычное, целочисленное)<br>
Сложение и вычитание<br>
При равном приоритете операции выполняются слева направо<br>
Любые арифметические операции выше по приоритету операций сравнения и логических операторов.
<p>
<li> <b>Приоритет логических операций</b><br>
Операция and имеет более высокий приоритет чем or:
<pre>
>>> print(7>5 or 6<10 and 10>11)
True</pre>
Здесь сначала будет выполняться правый логический оператор (and), а потом только левый (or).
<p>

<li> Вещественные числа можно записывать в таком формате: 5e-1 - это число 0,5. Здесь e - это экспонента, равная 10. -1 - это степень.<br>
1234e-2 - это 12,34<br>
<pre>
>>> 23e3
23000.0</pre>

<li> <b>Операторы приращения</b><br>
Сумму x = x + 3 можно записать по-другому: x += 3<br>
Другие операторы приращения:
x -=i это x = x - i<br>
x *=i это x = x*i<br>
x /=i это x = x / i<br>
x //=i это x = x // i<br>
x %=i это x = x % i<br>
x **=i будет означать команду x = x ** i
</ul>



<h3><a name="string">Строки</h3>
<ul>
<li> Строки относятся к классу <font color=red>str</font>
<p>
<li> Строчные переменные можно задать 3 способами:<br>
<ol>
<li> s1="stroka"
<li> s2='stroka'
<li> s3="""stroka""""
</ol>
Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов, не используя экранированные последовательности.
<pre>
>>> string = '"sp"am"'
>>> print(string)
"sp"am"
>>> string = "'sp'am'"
>>> print(string)
'sp'am'</pre>
Тройные кавычки позволяют создавать многостроковые комментарии:
<pre>
""" stroka1
    stroka2
    stroka3 """</pre>
    
<li> Строки имеют индесацию<p>

<li> Если хотим вызвать все символы по отдельности с строки, то можно использовать цикл:
<pre>
s = 'stroka'
for i in s:
    print(i)</pre>
    
<li> <b>Экранированные последовательности</b><br>
Экранированные последовательности позволяют вставить символы, которые сложно, или невозможно ввести с клавиатуры.
<ul>
<li> \n - перевод строки
<li> \f - перевод страницы
<li> \t - горизонтальная табуляция
<li> \v - вертикальная табуляция
</ul>

<li> "Сырые" строки - подавляют экранирование<br>
Если перед открывающей кавычкой стоит символ 'r' (в любом регистре), то механизм экранирования отключается.
<pre>S = r'C:\newt.txt'</pre>
"Сырая" строка не может заканчиваться символом обратного слэша. Его придётся добавлять (или убирать) вручную. Также неочевидно работает экранирование кавычек. Оно происходит, но символ обратного слэша также добавляется в строку. А не экранировать кавычку того же типа, что и в литерале, нельзя.

<li> Операции над строками<br>
Строка в Python ведёт себя как массив символов, а значит, можно применять индексы и срезы:
<pre>
>>> string = "Привет, pyplanet"
>>> string[0]
'П'
>>> string[-1]
't'
>>> string[8:]
'pyplanet'
>>> string[::-1]
'tenalpyp ,тевирП'
>>> string[::2]
'Пие,ppae'</pre>
Полный список строковых методов есть в <a href="https://pyplanet.ru/article/string-methods.html">нашем справочнике</a>.
<p>
Несколько примеров:
<pre>
>>> string = "Привет, pyplanet"
>>> string.upper()
'ПРИВЕТ, PYPLANET'
>>> string.replace("и", "е")
'Превет, pyplanet'
>>> string.split()
['Привет,', 'pyplanet']</pre>

<li> Строки можно складывать. При сложении они склеиваются.
<pre>
str1 = 'Hello, '
str2 = 'world!'
print(str1+str2)</pre>
Результат: “Hello, world!”
<p>
<li> Строку можно умножить на число:
<pre>print(str1*5)</pre>
Результат - это повторение строки str1 5 раз.
<p>
<li> Часто нам будет полезно уметь определять длину строки. Для этого существует функция len( ):
<pre>
print(len('строка'))</pre>
<li> Обратите внимание, что когда мы считываем данные с помощью функции input( ), мы считываем именно строковый тип. Если мы в дальнейшем хотим работать с введенными данными как с числами, то можно воспользоваться приведением типов:
<pre>
a = int(input())
b = float(input())
</pre>

<li> <b>Строки являются неизменяемыми:</b>
<pre>
>>> s='asdf'
>>> s[0]='a'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment</pre>
объект 'str' не поддерживает назначение элемента

<li> <b>Методы объекта строка</b>
<ul>
<li> count(arg) - считает сколько раз в строке встречается символ(ы) arg
<pre>
s = input()
n = s.count('g') + s.count('G') + s.count('c') + s.count('C')
print(n * 100 / len(s))</pre>
<li> upper() - переводит строку в верхний регистр
<li> lower() - наоборот в нижний регистр
<li> find(arg) - выдает индекс arg в строке. Если arg не будет в строке, то результат будет -1<br>
более рекомендуется конструкция: <b>if 'arg' in s:</b>
<li> replace(arg1,arg2) - меняет все arg1 в строке на arg2
</ul>
Нужно иметь в виду, что метод создает новый объект, как результат выполнения метода, но оригинальный объект не меняется.

<li> <b>Срез (диапазон строки)</b><br>
Общий шаблон:
<pre>
s = 'stroka'
print(s[x1:x2:x3]</pre>
Здесь напечатается строка из символов, где x1 - это индекс первого нужного символа в строке. Если не указан, то по умолчанию равен 0 Может иметь отрицательное значение, тогда индекс считается с првой стороны, <b>но все равно далее символы смотрятся в првую сторону.</b><br>
x2 -  индекс последнего нужного символа. Может иметь отрицательное значение, то есть отсчет с правой стороны.<br>
x3 - шаг приращения индекса, если не указан, то по умолчанию 1. Может иметь отрицательное значение. s[::-1] просто перевернёт строку.
</ul>

<h4>Логический тип данных</h4>
В Python существует логический тип данных - класс bool. Переменные этого типа могут принимать только 2 значения: True и False. Подробнее с этим типом данных мы столкнемся, когда будем рассматривать логические выражения и условные конструкции.


<h3>Тип данных None</h3>
В Python существует зарезервированное слово None, которое обозначает отсутствие типа.
<pre>
a = None
print(type(a))</pre>

<h3>Параметры функции print</h3>
<ul>
<li> Без параметров print() будет выводить в цикле результат на новой строке.
<li> print('stroka', end='')<br>
Здесь результаты будут выводиться на одной строке через пробел.
<li> Функция print(arg1, arg2, ..., argN) выводит аргументы через пробел. Если указать флаг sep="\n", то каждый аргумент выведется на новой строке, пример print(arg1, arg2 , sep="\n")
<li> print(*list[])<br>
это "распаковка" списка (да и не только). позволяет вывести не список (с [] и запятыми между  элементами), а только элементы.
<li> <i>можно было даже писать еще через f, к примеру у тебя есть переменная username тебе её надо вывести через print ты не ставишь запятые или +, а просто пишешь print(f'Его зовут {username}') так гораздо удобнее писать код</i>
</ul>

<h3>input()</h3>
<ul>
<li>
<pre>a, b = (int(i) for i in input().split())</pre>
<font color=red>В этой команде вводим число из нескольких цифр, функция split расщепляет это число на отдельные цифры и они присваиваются переменным a и b</font>
<br>Проверил, у меня если одно число ввести, то вызывает ошибку, что дескать нужно ввести два числа. Ввел 2 числа через пробел, теперь все верно, переменным присвоились эти значения.<p>
<li> <font color=brpwn>Команда input() выдает объект типа строка, даже если напечатаем число</font>. Поэтому с числа надо input приводить к типу int или float.
</ul>





<h3 align=center><a name="list" href="https://pyplanet.ru/article/array-list.html">Список</a></h3>
<b>Список</b> - переменная, содержащая список данных (элементов), внутри квадратных скобок идущих через запятую. Элементы строки можно в отличии от строки изменять.
<pre>
list = [] # пустой список
array = [1, 2, 3, 4, 5, 6, 7] # список из целых чисел int
print(type(array)) # класс list
ar = [2, 4.6, 'str', [1, 2, 3]] # список, состоящий из целого числа,
# из числа с плавающей точкой, из строки и из списка
</pre>

<h4>Индексация списков:</h4>
Индексация элементов списка имеет 2 способа, традиционная с 0 и с конца списка с -1.
Например есть список a = [1, 2, 3, 4]<br>
Тогда по обычной индексации элемент 1 имеет индекс 0 (a[0] = 1, a[1] = 2, a[2] = 3, a[3] = 4)<br>
По индексации с конца последний элемент имеет индекс -1 и далее левее на -1 индекс растет: a[-1] = 4, a[-2] = 3, a[-3] = 2, a[-4] = 1
<br>Индекс, в общем случае, не обязан быть числом. К элементам хеш-таблиц (которые мы рассмотрим позже) можно обращаться по строковому индексу.<br>
Также, поскольку списки - изменяемый тип данных, то по индексу возможно присвоение:
<pre>
>>> array = [1, 2, 3, 0, 1.4, -2]
>>> array[1] = 42
>>> array
[1, 42, 3, 0, 1.4, -2]</pre>
    
<h3>Методы списка</h3>
<p>
<img src="./images/python_base.png">
<p>
<ul>
<li> <b>append()</b><br>
<pre>array.append(8)</pre>
В список array добавили элемент 8 с помощью метода append.
<p>
Другой способ добавления в конец списка нового элемента - оператор приращения:
<pre>array +=[8]</pre>
Интересный пример по этому случаю:
<pre>
>>> students = ['Ivan', 'Masha', 'Sasha']
>>> students += ['Olga']
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga']
>>> students += 'Olga'
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a']</pre>
Видна разница между добавлением элемента с помощью модуля append и оператором +=.<br>
И списки, и строки - это последовательности (см. https://docs.python.org/3/library/stdtypes.html?highlight=mutable%20sequence#) . 
<br>+= складывает список с элементами последовательности ﻿по отдельности.
<br>А append прибавляет к списку новый элемент списка, сколько бы вложенных элементов в этом элементе ни было .
<br>Продолжение:
<pre>
>>> students += ['Dmitriy', 'Alexei']
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei']
>>> students.append(['Anna', 'Elena'])
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei', ['Anna', 'Elena']]</pre>
<p>

<li> <b><a href="https://skillbox.ru/media/code/kak-udalit-element-iz-spiska-v-python/">Способы удаления элементов из списка:
</a></b>
<p>
<ol>
<li> <b>remove() - удаление <b>одного</b> элемента из списка по имени</b><br>
Параметров может быть только один, то есть можно удалить за раз только один элемент:
<pre>
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei', ['Anna', 'Elena']]
>>> students.remove('o', 'l', 'g', 'a', ['Anna', 'Elena'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: remove() takes exactly one argument (5 given)
>>> students.remove(['Anna', 'Elena'])
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei']</pre>
<p>
<li> <b>Метод pop(): удаление по индексу</b><br>
pop() подойдёт, когда известно точное местоположение удаляемого элемента. В качестве аргумента pop() получает индекс, а 
возвращает удалённое значение:
<pre>
>>> lst = [1, 2, 3, 5]
>>> lst.pop(3)
5
>>> print(lst)
[1, 2, 3]</pre>
Если передать отрицательное значение, то pop() будет считать индексы не с нуля, а с -1
<p>
Если оставить pop() без аргумента, то удалится последний элемент — потому что -1 является аргументом по умолчанию.
<p>
При попытке обратиться в методе pop() к несуществующему индексу, интерпретатор выбросит исключение IndexError.

<p>
<li> <b>Метод clear(): очищение списка</b>
clear() удаляет из списка всё, то есть буквально очищает его. Он не принимает аргументов и не возвращает никаких значений:
<pre>
print(lst)
[1, 2, 3]
>>> lst.clear()
>>> print(lst)
[]</pre>
<p>
<li> <b>Ключевое слово del: удаление срезов</b><br>
del, как и метод pop(), удаляет элементы списка по индексу. При этом с его помощью можно избавиться как от единичного объекта, 
так и от целого среза:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[2]
print(new_list)

>>> ['ноль', 1, 3, 'IV']</pre>
Если передать срез, то элемент с правым индексом не удалится. В примере ниже это строка 'IV':
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[1:4]
print(new_list)

>>> ['ноль', 'IV']</pre>
Чтобы очистить список, достаточно передать полный срез [:]:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[:]
print(new_list)

>>> []</pre>
Также del можно использовать с отрицательными индексами:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[-4]
print(new_list)

>>> ['ноль', [2.1, 'два и два'], 3, 'IV']</pre>
Со срезами это тоже работает:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[-3:-1]
print(new_list)

>>> ['ноль', 1, 'IV']</pre>
Если при удалении единичного элемента указать несуществующий индекс, то Python выдаст ошибку IndexError.

</ol>
<p>
<li> <b>sort()</b> - сортировка элементов по возрастанию
<pre>
>>> students.sort()
>>> students
['Alexei', 'Dmitriy', 'Ivan', 'Masha', 'Olga', 'Sasha', 'a', 'g', 'l']</pre>
Здесь строки отсортировались по алфавитному порядку, буквы также по алфавиту, но после строк.
<p>
Второй способ, использовать функцию sorted():
<pre>
>>> number = [1, 1000, 6, 9, 4, 0]
>>> sorted(number)
[0, 1, 4, 6, 9, 1000]
>>> number
[1, 1000, 6, 9, 4, 0]</pre>
В отличии от метода sort() функция sorted() не меняет порядок списка

<p>
<b>insert(par1, par2)</b> - вставка элемента par2 по индексу par1
<pre>
>>> list = [0, 2, 3, 4]
>>> list.insert(1, 1)
>>> list
[0, 1, 2, 3, 4]
</pre>

<li> <b>Метод  reverse()</b><br>
Этот метод перевернет список в обратном порядке.
<p>
Функция reversed() делает тоже самое.
</ul>
<h4>Функции</h4>
<font color=red>Чем вообще функции отличаются от методов?</font>
<p>
<ul>
<li> <b>Функция sum()</b><br>
Для суммирования элементов списка.<br>
Она принимает два аргумента:
<p>
iterable — итерируемый объект (например, список), элементы которого нужно суммировать.
<p>
start (необязательный) — начальное значение суммы. По умолчанию равно 0.
<p>
Пример использования:
<pre>
numbers = [1, 2, 3, 4, 5]
total = sum(numbers)
print(total)</pre>
В этом примере sum(numbers) возвращает сумму всех элементов списка numbers.
<p>
<li> <b>Функции max() и min()</b><br>
Эти функции возвращают максимальное и минимальное значение из списка.
<p>
<li>
Можно определить длину списка new_array:
           <pre>
           len(new_array)
           </pre>
Найти сумму элементов списка:
           <pre>
           sum(new_array)
           </pre>

<li> Списки можно складывать (склеивать):
           <pre>array2 = [9, 10]
                new_array = array + array2
                new_array = [0, 2, 3, 4, 5, 6, 7, 8, 9, 10]
                </pre>

<li> <b>Списки можно умножать</b>:
<pre>
>>> list=['f',4,5,'r']
>>> list
['f', 4, 5, 'r']
>>> list*5
['f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r']
>>></pre>

<li> <b>Как узнать входит ли 'stroka' в список list</b>
<pre>
if 'stroka' in list:
    # true, входит
else:
    # false, не входит</pre>
Можно для этой цели использовать модуль index(var):
<pre>
>>> students.index('Sasha')
2</pre>
Здесь если строка Sasha входит в список, то вернется индекс этого элемента, иначе вернет ошибку.
<p>
<li> <b>Присвоение списков</b><br>
В питоне:
<pre>
>>> a = [1, 2, 3, 4]
>>> b = a
>>> b
[1, 2, 3, 4]
>>> a[3] = 10
>>> a
[1, 2, 3, 10]
>>> b
[1, 2, 3, 10]</pre>
Видно, что если изменили значение элемента в списке a, то изменится и список b, хотя обычно в других языках так не должно быть.<br>
<i>Когда вы пишите  a = [1, 2, 3], то а лишь указывает на список  [1, 2, 3], это как ярлык, который вы прикрепили к данному списку.
Затем, делая b=a, вы не копируете список, вы просто создаете новый ярлык к списку, на который указывает а.
Изменяя a, вы меняете также b. Потому﻿ что они указывают на один и тот же список.</i><br>
Чтобы a и b открепить друг от друга, нужно одному из них присвоить новый список (или любой объект другого типа).
</ul>




<h3 align=center><a name="gener">Генератор, генерация списков</h3>
Генератор — это объект, который сразу при создании не вычисляет значения всех своих элементов.
<p>
Он хранит в памяти только последний вычисленный элемент, правило перехода к следующему и условие, при котором выполнение прерывается.
<p>
Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется.
<p>
Этим генераторы отличаются от списков — те хранят в памяти все свои элементы, и удалить их можно только программно. Вычисления с помощью генераторов называются ленивыми, они экономят память.
<p>
Генераторы создают с помощью функции или выражения:
<p>
Если создают с помощью функции, то в отличии от обычной функции используют ключевое слово yield вместо return.

<h4>Создание генератора с помощью выражения</h4>
Как и выражения создающие списки, выражения создающие генераторы позволяют быстро получить объект генератора с помощью всего одной строчки кода. Использоваться они могут в тех же случаях, что и выражения создающие списки, но при этом у них есть одно дополнительное преимущество. Их можно создавать не удерживая весь объект в памяти перед итерацией. Если перефразировать, вы не будете расходовать память при использовании генератора.
<p>
Возьмем возведение в квадрат некоторых чисел:
<pre>
nums_squared_lc = [num**2 for num in range(5)]
nums_squared_gc = (num**2 for num in range(5))</pre>
И nums_squared_lc, и nums_squared_gc выглядят практически одинаково, но есть одно ключевое отличие. Вы сможете его заметить? Для первого объекта использовались квадратные скобки и это привело к созданию списка. Для второго использовались круглые скобки, и это привело к созданию генератора. Посмотрите, что произойдет, если мы выведем содержание каждого из этих объектов:
<pre>
nums_squared_lc
[0, 1, 4, 9, 16]
nums_squared_gc
&lt;generator object &lt;genexpr&gt; at 0x107fbbc78&gt;</pre>
Это подтверждает тот факт, что с помощью круглых скобок вы создали объект генератора, а также то, что он отличается от списка.
<p>
<i>не стоит путать «генераторы коллекций» (comprehensions, они же «включения») и «генераторы-итераторы». Первые — мощный синтаксический сахар для генерации коллекций «на лету», вторые — способ получения значений по запросу. </i>

<h4>Генерация списков:</h4>
Список можно создавать с помощью так называемых генераторных выражений, шаблон:
<pre>(выражение for j in итерируемый объект if условие)</pre>
Где for, in, if — ключевые слова, j — переменная.
<p>
Пример: <pre>a = (i**2 for i in range(1,5))</pre>
<pre>num = [int(i) for i in input().split()]</pre>
Если на вход подавать числа, то на выходе будет список из чисел.<br>
Если же для получения списка использовать попроще конструкцию:
<pre>num = input().split()</pre>
то здесь даже если подавать на вход числа, на выходе будет список из односимвольных строк.
<pre>
>>> numbers = [int(i) for i in input().split()]
1 3 5 6 10
>>> numbers
[1, 3, 5, 6, 10]
>>> num = input().split()
1 3 5 6 10
>>> num
['1', '3', '5', '6', '10']</pre>

<h4>Генерация словарей:</h4>
Общий шаблон генераторов словарей в Python:
БзкуЮ
dict_variable = {key:value for (key,value) in dictonary.items()}</pre>
Это самый простой вариант генератора. При добавлении условий код усложнится.
<p>
Генератор словарей — мощная концепция, которую можно использовать для замены циклов и лямбда-функций. При этом не все циклы for могут быть записаны как генератор словаря, но любой генератор можно переписать с использованием цикла for.
<p>
Рассмотрим следующую задачу. Вы хотите создать новый словарь, где ключами будут четные числа в диапазоне от 0 до 10, а значениями — квадраты этих чисел.
<p>
Давайте посмотрим, как можно решить эту проблему, используя цикл for и генератор словарей:
<pre>
numbers = range(10)
new_dict_for = {}
# Добавляем значения в `new_dict` с помощью цикла for 
for n in numbers:
    if n%2==0:
        new_dict_for[n] = n**2
print(new_dict_for)
# {0: 0, 8: 64, 2: 4, 4: 16, 6: 36}
# Используем генератор словаря
new_dict_comp = {n:n**2 for n in numbers if n%2 == 0}
print(new_dict_comp)
# {0: 0, 8: 64, 2: 4, 4: 16, 6: 36}</pre>

<h4>Инверсия словаря</h4>
<pre>
d = {'A': 1, 'B': 2, 'C': 3}
 
    inverse_dict = {v: k for k, v in d.items()}
    print(inverse_dict)            # {1: 'A', 2: 'B', 3: 'C'}</pre>

<p>
<h3 align=center><a name="table">Прямоугольная матрица</h3>
Иногда нам приходится использовать таблицы с данными для решения своих задач. Такие таблицы называются матрицами или двумерными массивами.
<p>
В Python подобные таблицы можно представить в виде списка, элементы которого являются другими списками.
<p>
Создать такой массив в Python можно разными способами. Первый способ:
<pre>
# Создание таблицы с размером 3x3, заполненной нулями
a = 3           
mas = [0] * a 
for i in range(a): 
    mas[i] = [0] * a 
print(mas) # Выведет [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</pre>

Второй способ предполагает создание пустого списка с добавлением в него новых списков. Рассмотрим на примере:
<pre>
# Создание таблицы с размером 2x2, заполненной единицами
a = 3
mas = [] 
for i in range(a): 
    mas.append([1] * a)
print(mas) # Выведет [[1, 1, 1], [1, 1, 1], [1, 1, 1]]</pre>
                                 
Третьим и самым простым способом является генератор списков с x строками, которые будут состоять из y элементов. Пример: 
<pre>
# Создание таблицы с размером 3x3, заполненной двойками
a = 3
mas = [[2] * a for i in range(a)]
print(mas) # Выведет [[2, 2, 2], [2, 2, 2], [2, 2, 2]]</pre>
4 способ:  
<pre>a = [[0 for j in range(m)] for i in range(n)]</pre>
Здесь получаем матрицу из n строк и m  столбцов, заполненную нулями.
<p>
Для обработки и <b>вывода двухмерных списков</b> используются два вложенных цикла. Первый цикл – по порядковому номеру строки, второй – по ее элементам. Например, вывести массив можно так:
<pre>
mas = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
for i in range(0, len(mas)):
    for i2 in range(0, len(mas[i])):
        print(mas[i][i2], end=' ')
    print()
# Выведет
1 1 1
1 1 1
1 1 1</pre>
То же самое можно сделать не по индексам, а по значениям массива:
<pre>
mas = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
for i in mas: 
    for i2 in i: 
        print(i2, end=' ') 
    print()
# Выведет
1 1 1
1 1 1
1 1 1
</pre>
</ul>        
        
        

        



<h3 align=center><a name="set" href="https://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html">Множества (set и frozenset)</a></h3>
<ul>
<li> Множество - объект, который содержит неповторяющие элементы. Оформляется с помощью фигурных скобок.<br>
some_set = {1, 2, 3...}<br>
Но если попробуем так:<br>
test = {}<br>
то создадим не множество, а словарь.
<p>
Пустое множество создается с помощью функции set():<br>
some_set = set()
<p>
<li>
<pre>
for _ in range(int(input())):
    wrd |= {i.lower() for i in input().split()}</pre>
Здесь wrd |= {...} отвечает за добавление множества {...} в единое wrd (аналог метода update)
<p>
из stackoverflow:<br>
| - объединяет
<p>
|= -обновляет
<pre>
>>> d1 = {"a": 0, "b": 1, "c": 2}
>>> d2 = {"c": 20, "d": 30}

>>> # Merge, | 
>>> d1 | d2
{"a": 0, "b": 1, "c": 20, "d": 30}
>>> d1 
{"a": 0, "b": 1, "c": 2}

>>> # Update, |=
>>> d1 |= d2
>>> d1 
{"a": 0, "b": 1, "c": 20, "d": 30}</pre>

<li> <h4>Особенности set</h4>
Может содержать только неизменяемые элементы (числа, строки, кортежи - может; списки, другие множества - не может)<br>
Порядок элементов не определён<br>
Особенности связаны с тем, что внутри множества в Python реализованы хеш-таблицей. Если кратко, то от каждого элемента мы вычисляем хеш-функцию, и её значение - это индекс в каком-то большом заранее выделенном массиве.
<p>
Отсюда также следует, что для поиска элемента в большом массиве выгоднее (по скорости) использовать множества, а не списки.
<p>
Перебрать элементы множества можно обычным способом с помощью цикла:<br>
<b>for element in some_set:</b>


<li> <h4>Frozenset</h4>
frozenset - это неизменяемое множество. Создано по аналогии с парой список - кортеж, имеет те же самые особенности по сравнению с множеством, что и кортежи по сравнению со списками. Создаётся только с помощью функции frozenset(), своего литерала (как кортеж) не имеет.
<p>
frozenset может использоваться в качестве элементов set.

<li> <h4>Методы множества</h4>
<ol>
<li> name_set.add(element)<br>
Добавляем element в name_set. Если element уже есть, то не добавится.
<p>
<li> name_set.remove(element)<br>
Удаляет element из множества. Если этого элемента нет в множестве, то возникнет ошибка.
<p>
<li> name_set.discard(element)<br>
Аналогично методу remove, только при удалении несуществующего элемента, ошибки не возникнет. 
<p>
<li> name_set.clear(element)<br>
Удалит все элементы множества.
</ol>
</ul>





<h3 align=center><a name="typle" href="https://pyplanet.ru/article/tuple.html">Кортежи</a></h3>
Кортежи - почти как изученные нами ранее списки, за исключением того, что они неизменяемы.
<p>
Как создаётся кортеж?<br>
Кортеж создаётся способом, походим на то, каким создаются списки, только вместо квадратных скобок - круглые.
<pre>a = (1, 2, 3, 0, -1, 2)</pre>
Скобок может вообще не быть:
<pre>a = 1, 2, 3, 0, -1, 2</pre>
Пустой кортеж:
<pre>a = ()</pre>
А вот кортеж из одного элемента выглядит иначе:
<pre>a = (1, )</pre>
Здесь обязательна запятая, иначе Python не сможет отличить одноэлементный кортеж от просто числа.
<p>
Зачем нужен кортеж, если есть списки?
<ul>
<li> Кортежи занимают немного меньше памяти и работают чуть быстрее до тех пор, пока вы не собираетесь изменять его содержимое
<li> Кортежи лучше защищены от ненамеренного изменения данных
<li> Кортежи могут быть использованы в местах, требующих неизменяемый тип данных
<li> Некоторые функции работают только с кортежами
</ul>
С кортежами можно работать так же, как и со списками, кроме методов, изменяющих список (таких, как append, extend, pop, sort и 
др.). Также есть доступ по индексу, есть срезы (только срез кортежа вернёт кортеж, а не список). 






<h3 align=center><a name="diction" href="https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html">Словарь</a></h3>
<ul>
<li>
<b>Словарь</b> (хэш, ассоциативный массив) - это изменчивая структура данных для хранения пар key-value, где value однозначно определяется ключом.<br>
В качестве ключа может выступать неизменчивый тип данных (число, строка, кортеж и т.п.).<br>
Порядок пар ключ-значение произволен (словарь не имеет индекса, вместо индекса ключ).<br>
value может быть строкой, числом, списком.<br>
Задается с помощью фигурных скобок (как множество):
<pre>
       var_dictionary={
                       key1:value1,
                       key2:value2,
                       key3:value3
                      }</pre>
Пример:
<pre>dictionary = {'dog' : 'собака', 'table' : 'стол', 'computer': 'компьютер'}</pre>
Мы можем обращаться к значениям словаря по ключу.
<pre>
print(dictionary['dog'])  # печатаем строку 'собака'
dictionary['dog'] = 'пес' # изменяем значение 'собака' на 'пес'
dictionary['laptop'] = 'ноутбук' # добавляем новый элемент с ключом 'laptop' и значением 'ноутбук' в словарь
del dictionary[dog]       # удаляется пара ключ-значение с данным ключом
</pre>

<li> <b><a href="https://pythonist.ru/kak-dobavit-element-v-slovar/">Как добавить элемент в словарь</a></b><br>
В отличие от списков и кортежей, в работе со словарями методы add(), insert() и append() вам не помощники. Тут необходимо создать новый ключ. Позже он будет использоваться для хранения значения.
<p>
Добавляются элементы в словарь так:
<pre>dictionary_name[key] = value</pre>
Рассмотрим пример, чтобы разобраться. В нашем словаре было четыре пары ключ-значение. Этот словарь отражает количество булочек, которые продаются в кафе.
<p>
Допустим, мы испекли 10 вишневых булочек. Теперь нам нужно внести их в словарь. Сделать это можно так:
<pre>
scones = {
    "Фрукты": 22,
    "Пустая": 14,
    "Корица": 4,
    "Сыр": 21
}
scones["Вишня"] = 10
print(scones)</pre>
Вывод: 
<pre>
 {'Фрукты': 22, 'Овощи': 14, 'Корица': 4, 'Сыр': 21, 'Вишня': 10}</pre>
Как видите, мы добавили в словарь ключ Вишня и присвоили ему значение 10.
<p>
Сперва мы объявили словарь scones, хранящий информацию о булочках, которые доступны к заказу в нашем кафе. Потом мы добавили в наш словарь ключ Вишня и присвоили ему значение 10:
<br> scones["Вишня"] = 10<br>
И, наконец, мы вывели в консоль обновленную версию словаря. 
<p>
добавление и обновление происходит одинаково
Тем же способом мы можем обновить значение ключа. Допустим, мы испекли еще 10 булочек с корицей. Обновить значение этого ключа можно так:
<pre>
scones = {
    "Фрукты": 22,
    "Пустая": 14,
    "Корица": 4,
    "Сыр": 21
}
scones["Корица"] = 14
print(scones)</pre>
Вывод: 
<pre>
 {'Фрукты': 22, 'Пустая': 14, 'Корица': 14, 'Сыр': 21}</pre>
То есть, тем же способом мы можем установить новое значение какому-либо ключу. В нашем случае мы присвоили Корица значение 14.

<li> <b>Как добавлять элемент в словарь в цикле:</b>
<pre>
# input data for dict
keys = ['Name', 'Website', 'Topic', 'Founded']
values = ['GeeksforGeeks', 'https://www.geeksforgeeks.org/', 'Programming', 2009]

# creating  an empty dictionary
output = {}

# adding items to the dictionary using a loop
for i in range(len(keys)):
    output.update({keys[i]: values[i]})</pre>
<li><br>
Словарь:
<pre>
dictionary = {
            'dog': 'собака', 'table': 'стол', 'computer': 'компьютер', 'apple': 'яблоко', 1: 'yyy', 0: ['qq', 'ww']}
</pre>
Цикл по всему словарю:
<pre>
<b>for key, val in dictionary.items():</b>   
    print(key, val)
</pre>
Выполнит:
<pre>
dog собака
table стол
computer компьютер
apple яблоко
1 yyy
0 ['qq', 'ww']
</pre>
<b>Цикл по ключам словаря:</b><pre>
for key in dictionary.keys():
   print(key, dictionary[key])
</pre>
Выполнит:
<pre>
dog собака
table стол
computer компьютер
apple яблоко
1 yyy
0 ['qq', 'ww']
</pre>
Можно и так: <b>for key in some_dict:</b>
<p>
<b>Цикл по значениям словаря:</b><pre>
for val in dictionary.values():
    print(val)<br>
собака
стол
компьютер
яблоко
yyy
['qq', 'ww']</pre>
<b>Пополняется словарь dictionary из другого diction2:</b><pre>
diction2={'orange':'мандарин'}
dictionary.update(diction2)
print(dictionary)</pre>
{'dog': 'собака', 'table': 'стол', 'computer': 'компьютер', 'apple': 'яблоко', 1: 'yyy', 0: ['qq', 'ww'], 'orange': 'мандарин'}<p>
<b>Получить одновременно и ключ и значение:</b><br>
for key, value in some_d.items():
<p>
<b>Количество пар в словаре:</b><br>
print(len(dictionary))
<p>
Если попытаемся получить значение в словаре по несуществующему ключу (dict[key]), то получим ошибку. Чтобы не возникало ошибки, используем метод get(key), который вернет объект None, если такого ключа нет.
<p>
<li> <b>Методы словаря</b><br>
<ul>
<li> <b>update()</b><br>
Функция добавляет элемент(ы) в словарь, если ключ отсутствует в словаре. Если ключ находится в словаре, он обновляет ключ новым значением.
<br>Синтаксис: dict.update([other])
<p>
Если update() в Python вызывается без передачи параметров, словарь остается без изменений.
<br>Команда обновляет словарь элементами из объекта словаря или повторяемого объекта пар ключ/значение. Он не возвращает никакого значения (не возвращает None).
<pre>
d = {1: "one", 2: "three"}
d1 = {2: "two"} # updates the value of key
d.update(d1)
print(d)
d1 = {3: "three"} # adds element with key
d.update(d1)
print(d)</pre>
Выход:<br>
{1: 'one', 2: 'two'}<br>
{1: 'one', 2: 'two', 3: 'three'}

</ul>
        
        
        
<h3 align=center><a name="srez" href="https://pyplanet.ru/article/slice.html">Срезы массивов</a></h3>
Иногда необходимо выбрать подмножество массива: убрать первые или последние элементы, выбрать только чётные или нечётные элементы.
<p>
Конечно, можно проходить по списку с помощью цикла for, в этом цикле писать условия, и записывать нужный диапазон значений в новый массив. Однако в Python есть инструмент, с помощью которого это делать проще.
<p>
Этот инструмент называется срезы (slice).
<p>
<b>Синтаксис срезов:</b></br>
<pre>array[start:stop:step]</pre>
Похоже на взятие по индексу, но здесь у нас вместо одного - 3 целых числа. Начать с индекса start (включая его), закончить на индексе stop (не включая его), с шагом step.
<p>
Например, возьмём срез со второго по третий элемент с шагом 1:
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[1:3:1]
[4, 3]</pre>
Каждый из аргументов может быть опущен. Если опущен start, то он полагается равным нулю; stop - длине массива, step - единице. Срез совсем без аргументов вернёт просто копию массива:
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[:]
[1, 4, 3, 3, -2]</pre>
<b>Выбрать чётные и нечётные элементы:</b>
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[::2]
[1, 3, -2]
>>> array[1::2]
[4, 3]</pre>
Аргументы могут быть отрицательными: в случае со start и stop это будет означать нумерацию с конца массива; В случае со step элементы среза будут идти в обратном порядке:
<pre>
>>> array = [1, 4, 3, 3, -2]
>>> array[::-1]
[-2, 3, 3, 4, 1]</pre>
И, поскольку срез списка возвращает список, его можно использовать: присваивать переменной, итерировать в цикле for или while, или любым другим необходимым программисту способом.





<h3 align=center><a href="">Форматирование строк</a></h3>
Иногда нужно напечатать строку, в которой присутствует пользовательский ввод. Например, напечатать "Привет, name", где name - это введённое пользователем имя.
<p>
Можно это сделать с помощью конкатенации строк, например:
<pre>
name = input("Как вас зовут?")
print("Привет, " + name)</pre>
Однако, если строки станут сложнее, и подстановок станет больше, то выражение, получающееся при применении всех сложений, будет слишком громоздким.<br>
Для облегчения подобных распространённых задач в Python существуют инструменты форматирования строк, аж целых 3.
<h4>Форматирование при помощи оператора %</h4>
Этот оператор форматирования - наследник форматирования строк из языка C, где были строковые подстановки. Если у нас один аргумент для подстановки, то через процент (так же, как и остаток от деления) пишется переменная для подстановки:
<pre>
name = input("Как вас зовут?")
print("Привет, %s" % name)</pre>
Если несколько переменных - то подставлять нужно кортеж (список не подойдёт!) значений.
<pre>
>>> print("Привет, %s, %d лет" % ("Вася", 35))
Привет, Вася, 35 лет</pre>
Спецификаторы преобразования (это те, что %s, %d и т.д.) записываются в следующем порядке:
<ol>
<li> %
<li> Ключ отображения (необязательно), состоящий из последовательности символов в круглых скобках (например, (somename))
<li> Флаги преобразования
<li> Минимальная ширина поля
<li> Точность, начинается с '.', затем - желаемая точность
<li> Модификатор длины (опционально)
<li> Тип преобразования
</ol>
Поясню каждый пункт подробнее.
<p>
2. Есть возможность подставить словарь значений
<pre>
>>> print("Привет, %(name)s, %(age)d лет" % {"name": "Вася", "age": 35})
Привет, Вася, 35 лет</pre>
3. Это флаги, отвечающие за особое отображение чисел. В примере ниже мы отображаем знак числа
<pre>
>>> print("Привет, %s, %+d лет" % ("Вася", 35))
Привет, Вася, +35 лет</pre>
4. Минимальная ширина поля полезна для выравнивания
<pre>
>>> print("Привет, %s, %3d лет" % ("Вася", 35))
Привет, Вася,  35 лет
>>> print("Привет, %s, %3d лет" % ("Вася", 100))
Привет, Вася, 100 лет</pre>
5. Позволяет более точно управлять дробными значениями
<pre>
>>> print("Привет, %s, %.2f лет" % ("Вася", 35 + 1/12))
Привет, Вася, 35.08 лет
>>> print("Привет, %s, %.4f лет" % ("Вася", 35 + 1/12))
Привет, Вася, 35.0833 лет</pre>
6. Это про числа. Наследие C, где можно писать %ld для чисел типа long int; в Python игнорируется
<p>
7. %s, %d - это так называемый тип преобразования (%s - строка, %d - целое число, %f - число с плавающей точкой)
<h4>Форматирование при помощи метода format</h4>
Вместо фигурных скобок в строку, к которой был применён метод format, подставляются значения аргументов
<pre>
>>> print("Привет, {}, {} лет".format("Вася", 35))
Привет, Вася, 35 лет</pre>
Можно внутри фигурных скобок указывать номер аргумента:
<pre>
>>> print("Привет, {1} лет, {0}".format("Вася", 35))
Привет, 35 лет, Вася</pre>
Можно указывать именованные аргументы:
<pre>
>>> print("Привет, {name}, {age} лет".format(name="Вася", age=35))
Привет, Вася, 35 лет</pre>
Можно комбинировать номера и имена:
<pre>
>>> print("Привет, {}, {age} лет".format("Вася", age=35))
Привет, Вася, 35 лет</pre>
Полную спецификацию метода format можно посмотреть <a href="https://docs.python.org/3/library/string.html#formatstrings">здесь (англ.)</a>, но в целом там не очень много различий с оператором %, только все флаги записываются после двоеточия:
<pre>
>>> print("Привет, {:10}, {age:.2f} лет".format("Вася", age=35.0833))
Привет, Вася      , 35.08 лет</pre>
И можно внутри выражения обращаться по индексу
<pre>
>>> print("Привет, {}, {age[0]} лет, {age[1]} месяц(ев)".format("Вася", age=(35, 1)))
Привет, Вася, 35 лет, 1 месяц(ев)</pre>
<h4>f-строки</h4>
В Python версии 3.6 появился новый способ форматирования строк, а именно f-строки.
<p>
Почему f? Из-за способа задания. Как "сырые" строки задаются буквой r в начале, так f-строки задаются буквой f.
<pre>s = f"Это f-строка"</pre>
Значения в f-строку подставляются прямо в строке, в фигурных скобках. В качестве подстановки выступает выражение, внутри можно выполнить некоторый код.
<p>
Также после двоеточия можно записать флаги-модификаторы, как и в format:
<pre>
name = "вася"
age = 35
months = 1
print(f"Привет, {name.title()}, {age} лет, {months} месяц(ев), всего {age + months / 12:.2f} лет")
# Привет, Вася, 35 лет, 1 месяц(ев), всего 35.08 лет</pre>






<h3 align=center><a name="unpack" href="https://pyplanet.ru/article/unpacking.html">Распаковка элементов</a></h3>
Допустим, есть задача: обменять значения двух переменных. Например, a = 5, b = 10. Нам нужно, чтобы стало a = 10, b = 5.
<p>
Можно это сделать через введение временной переменной:
<pre>
a = 5
b = 10

tmp = a
a = b
b = tmp</pre>
А можно воспользоваться инструментом распаковки элементов кортежа / списка. Но для начала о том, что это вообще такое. А это, по сути, операция, обратная созданию кортежа / списка. Мы "распаковываем" кортеж в переменные:
<pre>
a = (1, 2, 3)
(variable_1, variable_2, variable_3) = a</pre>
Так кортеж из трёх элементов теперь "записан" в 3 переменные, с каждой из которых можно работать отдельно.
<p>
Как и при создании кортежа, скобки необязательны:
<pre>
a = (1, 2, 3)
variable_1, variable_2, variable_3 = a</pre>
Так как же можно решить задачу из начала статьи? Очень просто: создадим кортеж со значениями (a, b), и распакуем его в обратном порядке:
<pre>
a = 5
b = 10
(a, b) = (b, a)</pre>
Или, можно без скобок:
<pre>
a = 5
b = 10
a, b = b, a</pre>
<h4>Расширенная распаковка</h4>
Иногда из всего кортежа нам нужен 1-2 элемента; или наоборот, 1-2 элемента нам как раз не нужны.
<p>
В Python для подобных случаев имеется расширенная распаковка: Если поставить перед одной из переменных звёздочку, то ей присвоятся все оставшиеся значения:
<pre>
>>> a = 1, 2, 3, 4
>>> first, *rest = a
>>> print(first)
1
>>> print(rest)
[2, 3, 4]</pre>
<h4>Распаковка в цикле</h4>
Рассмотрим более сложный случай: у нас есть список людей, с полями (фамилия, имя, возраст, рост, вес). И нам нужно вывести только фамилию и возраст.
<pre>
people = [
    ("Иванов", "Иван", 35, 180, 85),
    ("Петров", "Петр", 27, 190, 74),
    ("Сидоров", "Петр", 19, 175, 68),
    ("Иванова", "Анастасия", 42, 172, 75),
]
for surname, name, age, height, weight in people:
    print(surname, age)</pre>
Что происходит во время выполнения кода? В цикле for мы проходимся по элементам списка people. А каждый элемент - это кортеж. Можно его присвоить переменной и распаковать уже внутри блока цикла, однако можно это сделать прямо на месте; и получить, таким образом, 5 переменных на каждой итерации цикла.
<p>
Поскольку после возраста остальные поля нам не нужны, можно также воспользоваться расширенной распаковкой:
<pre>
for surname, name, age, *rest in people:
    print(surname, age)</pre>





<h3 align=center><a name="metod">Методы</h3>
Ссылки: <a href="https://pythonru.com/osnovy/python-join">Методы join() и split()</a>
<ol>
<li> <b>Метод join - преобразование списка в строку</b><br>
Метод join в Python отвечает за объединение списка строк с помощью определенного указателя. Часто это используется при конвертации списка в строку. Например, так можно конвертировать список букв алфавита в разделенную запятыми строку для сохранения.
<p>
Метод принимает итерируемый объект в качестве аргумента, а поскольку список отвечает этим условиям, то его вполне можно использовать. Также список должен состоять из строк. Если попробовать использовать функцию для списка с другим содержимым, то результатом будет такое сообщение: <font color=red>TypeError: sequence item 0: expected str instance, int found</font>.
<p>
Пример объединения списка для создания строки:
<pre>
vowels = ["a", "e", "i", "o", "u"]
vowels_str = ",".join(vowels) # метод применяется к строке ','
print("Строка гласных:", vowels_str)</pre>
Результат: <pre>Строка гласных: a,e,i,o,u</pre>
<p>
join() — это метод строки, но не списка.<br>
То есть <font color=red>vowels_str = vowels.join(",")</font> будет ошибкой. Это нужно иметь в виду при использовании этого метода.
<p>
<b>Объединение списка с несколькими типами данных</b><br>
Посмотрим на программу, где предпринимается попытка объединить элементы списка разных типов:
<pre>
names = ['Java', 'Python', 1]
delimiter = ','
single_str = delimiter.join(names)</pre>
Вывод:
<pre>
Traceback (most recent call last):
  File "test.py", line 3, in <module>
    single_str = delimiter.join(names)
TypeError: sequence item 2: expected str instance, int found</pre>
Это лишь демонстрация того, что join нельзя использовать для объединения элементов разного типа. Только строковые значения.
<br>Что бы избежать этой ошибки, превратите все элементы списка в строки:
<pre>
names = ['Java', 'Python', 1]
names = [str(i) for i in names]</pre>
<p>
<b>Разбитие строки с помощью join</b>
Также функцию join() можно использовать, чтобы разбить строку по определенному разделителю.
<pre>
>>> print(",".join("Python"))
P,y,t,h,o,n</pre>
Если передать в качестве аргумента функции строку, то она будет разбита по символам с определенным разделителем.
<p>
<li> <b>метод split() - обратное преобразование строки в список</b><br>
Помимо join() есть и функция split(), которая используется для разбития строки. Она работает похожим образом. Посмотрим на код:
<pre>
names = ['Java', 'Python', 'Go']
delimiter = ','
single_str = delimiter.join(names)
print('Строка: {0}'.format(single_str))

split = single_str.split(delimiter)
print('Список: {0}'.format(split))</pre>
Вывод:
<pre>
Строка: Java,Python,Go
Список: ['Java', 'Python', 'Go']</pre>
Вот и все что нужно знать об объединении и разбитии строк.
<p>
<li> <b>index()</b><br>
Метод index() возвращает индекс указанного элемента в списке. Синтаксис метода в Python:
<pre>list.index(element, start, end)</pre>
element – элемент для поиска;<br>
start (необязательно) – начать поиск с этого индекса;<br>
end (необязательно) – искать элемент до этого индекса.
<p>
Метод возвращает индекс данного элемента в списке. Если элемент не найден, возникает исключение ValueError.<br>
<i>Примечание: Команда возвращает только первое вхождение соответствующего элемента.</i>

</ol>






<h3 align=center><a name="if" href="https://pyplanet.ru/article/if.html">Инструкция if-elif-else</a></h3>
<h4>Синтаксис инструкции if</h4>
Сначала записывается часть if с условным выражением, далее могут следовать одна или более необязательных частей elif, и, наконец, необязательная часть else. Общая форма записи условной инструкции if выглядит следующим образом:
<pre>
if test1:
    state1
elif test2:
    state2
else:
    state3</pre>
Пример:
<pre>
a = int(input())
if a < -5:
    print('Low')
elif -5 <= a <= 5:
    print('Mid')
else:
    print('High')</pre>
    
<h4>Проверка истинности в Python</h4>
<ul>
<li> Любое число, не равное 0, или непустой объект - истина.
<li> Числа, равные 0, пустые объекты и значение None - ложь
<li> Операции сравнения применяются к структурам данных рекурсивно
<li> Операции сравнения возвращают True или False
<li> Логические операторы and и or возвращают истинный или ложный объект-операнд
</ul>   
<h4>Проверки на равенство</h4>
После слова if идёт условие. И только если оно истинное, выполняется блок с отступом от if. Условия могут проверяться самые разные; многие из них задаются операторами.
<ul>
<li> == - проверка на равенство (условие верно, если выражение слева равно выражению справа)
<li> != - проверка на неравенство (условие верно, если выражение слева не равно выражению справа)
<li> > - условие верно, если выражение слева больше выражения справа
<li> >= - условие верно, если выражение слева больше, либо равно выражению справа
<li> < - условие верно, если выражение слева меньше выражения справа
<li> <= - условие верно, если выражение слева меньше, либо равно выражению справа
</ul>
Вообще, условие может быть любым, необязательно сравнение. Например,
<pre>
say = input()
if say:
    print("Ох, вы что-то сказали? Жалко, я не смогу это понять")
else:
    print("Не хотите разговаривать? Ну и ладно")</pre>
Здесь условием выступает просто переменная say. Условие истинно, если строка непустая, и ложно, если она пустая. Истинно также любое отличное от нуля число, и любой непустой объект (например, непустая строка).

<h4>Логические операторы</h4>
Иногда есть необходимость в сложных условиях. Например, если число больше нуля, но не равно 42. Такие условия помогают задавать логические операторы:
<ul>
<li> and - логическое И
<li> or - логическое ИЛИ
<li> not - логическое НЕ
</ul>
Задача выше имеет такое решение:
<pre>
a = 33
if a > 0 and a != 42:
    print("YES")</pre>
Частая ошибка с логическими операторами: допустим, нам надо проверить, что переменная либо 0, либо 42. Некоторые пишут ошибочное решение
<pre>
a = 33
if a == 0 or 42: # Это ОШИБКА, так условие составлять НЕЛЬЗЯ!
    print("YES")</pre>
Здесь условие эквивалентно (a == 0) or (42), и, если первое условие иногда истинно, то второе условие (42) истинно всегда, потому что это отличное от нуля число. Правильно писать так:
<pre>
a = 33
if a == 0 or a == 42:
    print("YES")</pre>
Выражения слева и справа логических операторов выполняются "лениво". Это значит, что, например, если есть условие A or B, и A истинно, то B вычислено не будет. Это может быть важно, если выражение B имеет внешние эффекты (например, там функция input, ожидающая ввода, и она иногда не будет вызвана как раз из-за такого эффекта).
<h4>Приоритет логических операторов</h4>
<ul>
<li> Все арифметические
<li> Все операторы сравнения
<li> not
<li> and
<li> or
</ul>
<pre>
a = 33
if not a == 0 or a == 42:
    # a не 0, или a равно 42; часть с 42 можно убрать
    print("YES")

if not (a == 0 or a == 42):
    # a не 0, и не 42
    print("YES")</pre>
Отличие этих двух if в том, что, если a равно 42, то первый выведет YES, а второй - не выведет. Приоритет операции можно поднять скобками там, где нужно.


<h3 align=center><a href="https://pyplanet.ru/article/switch-case.html">Множественный условный оператор Switch - case</a></h3>
Допустим, мы хотим написать простейшую систему вопрос - ответ. У нас есть заранее известный список потенциальных вопросов и ответов на них.
<p>
Безусловно, можно решить эту задачу, используя конструкцию if-elif-else, но появилась несколько более удобная конструкция для решения подобных задач.<br>
Решение с помощью if-elif-else:
<pre>
question = input()
if question == "Привет?":
    print("Привет!")
elif question == "Что ты знаешь?":
    print("Что-то, да знаю")
elif question == "Как дела?":
    print("Хорошо!")
elif question == "Что делаешь?":
    print("Отвечаю на вопросы кожаных мешков")
elif question == "Кто ты?":
    print("Я - компьютерная программа, написанная на Python")
elif question == "В чем смысл жизни?":
    print("42")
else:
    print("Вопрос непонятен")</pre>
Это достаточно элегантный способ решения, однако эту же задачу можно решить с помощью сравнительно недавно появившегося в Python выражении match - case (на данном этапе обучения считайте его аналогом switch - case из других языков программирования).
<pre>
question = input()
match question:
    case "Привет?":
        print("Привет!")
    case "Что ты знаешь?":
        print("Что-то, да знаю")
    case "Как дела?":
        print("Хорошо!")
    case "Что делаешь?":
        print("Отвечаю на вопросы кожаных мешков")
    case "Кто ты?":
        print("Я - компьютерная программа, написанная на Python")
    case "В чем смысл жизни?":
        print("42")
    case _:
        print("Вопрос непонятен")</pre>
Данный синтаксис появился только в Python 3.10, если у вас более ранняя версия - пример работать не будет, и вы можете смело переходить к следующей лекции.<br>
Здесь match (аналог switch в других языках) - принимает выражение, которое затем сопоставляется с шаблонами в блоках case.
<p>
case _ здесь - аналог слова default в других языках программирования
<p>
Почему match, а не switch<br>
Потому что это не обычный switch-case, это конструкция сопоставления шаблонов.
<p>
В простейшем случае, как в примере выше - оператор имеет поведение такое же, как и switch - case в других языках.
<p>
На самом деле, выражение match - case гораздо мощнее, но с остальными его фишками мы познакомимся позже.
<p>
И case _ тоже не совсем аналог слова default, об этом тоже позже.



<h3 align=center><a name="while" href="https://pyplanet.ru/article/while.html">Цикл while</a></h3>
Синтаксис while:
<pre>
while УСЛОВИЕ:
    ТЕЛО_ЦИКЛА</pre>
Выполняет тело цикла до тех пор, пока условие цикла истинно. Что означает УСЛОВИЕ? Да ровно то же самое, что и у оператора if, без каких-либо дополнительных ограничений.
<p>
ТЕЛО_ЦИКЛА - это блок кода (одна, или несколько, или много строк кода, другие, вложенные блоки, и т.д.)
<p>
Пример: Напишите программу, которая считывает целые числа с консоли по одному числу в строке.
<br>Для каждого введённого числа проверить:
<br>если число меньше 10, то пропускаем это число;
<br>если число больше 100, то прекращаем считывать числа;
<br>в остальных случаях вывести это число обратно на консоль в отдельной строке.
<pre>
while <b>True</b>:
    number = int(input())
    if number >100:
        break
    if number <10:
        continue
    print(number)</pre>
Второе решение:
<pre>
a = 0
while a <= 100:
    a = int(input())
    if 10 <= a <= 100:
        print(a)</pre>
        
Напишите программу, которая считывает с клавиатуры два числа a и b, считает и выводит на консоль среднее арифметическое всех чисел из отрезка [a;b], которые кратны числу 3. 
<pre>
<b>a, b = int(input()), int(input())</b>

sm = 0;
n = 0;

for i in range(a, b + 1):
    if i % 3 == 0:
        sm += i
        n += 1

print(sm / n)</pre>


        

<h3 align=center><a href="https://pyplanet.ru/article/break-continue.html">Операторы break и continue, слово else в циклах</a></h3>
<h4>Оператор break</h4>
Оператор break досрочно прерывает цикл.
<br>Пример:
<pre>
>>> for i in 'hello world':
...     if i == 'o':
...         break
...     print(i * 2, end='')
...
hheellll</pre>

<h4>Оператор continue</h4>
Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)<br>
Пример:
<pre>
>>> for i in 'hello world':
...     if i == 'o':
...         continue
...     print(i * 2, end='')
...
hheellll  wwrrlldd</pre>

<h4>While - else</h4>
Слово else, примененное в цикле for или while, проверяет, был ли произведен выход из цикла инструкцией break, или же "естественным" образом. Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.
<br>Пример:
<pre>
>>> for i in 'hello world':
...     if i == 'a':
...         break
... else:
...     print('Буквы a в строке нет')
...
Буквы a в строке нет</pre>
<p>
Слово else под циклом не имеет ничего общего с выражением if - else! То, к какому блоку относится else, указывается уровнем отступа.


<h3 align=center><a name="for" href="https://pyplanet.ru/article/for.html">Цикл for</a></h3>
Синтаксис цикла for:
<pre>for element in array:
    тело цикла</pre>
array - это объект, поддерживающий протокол итерирования.
<br>in - ключевое слово, которое в данном контексте обозначает примерно "все элементы из array".
<br>element - переменная, куда будет помещено значение элемента массива на каждой итерации. И да, каждую итерацию это будет следующий элемент последовательности, не нужно увеличивать никакой счётчик, как в цикле while (или как в языке Pascal).
<p>
Не следует изменять array внутри самого цикла! Это может привести к непредсказуемым результатам работы программы.
Внутри цикла for, как и внутри цикла while, можно использовать break, continue. Также есть возможность использовать блок else.
<p>
Например, дана задача: вывести первое положительные число в массиве, или написать, что положительных чисел нет.
<pre>
array = [0, -3, -5, 4, -2, -3, 5, 6, 1]
for element in array:
    if element > 0:
        print(element)
        break
else:
    print("Положительных чисел нет")
</pre>
Другой пример.<br>
Напишите программу, на вход которой даются четыре числа a, b, c и d, каждое в своей строке. Программа должна вывести фрагмент 
таблицы умножения для всех чисел отрезка. Мое решение:
<pre>
a = int(input())
b = int(input())+1
c = int(input())
d = int(input()) + 1
for y in range(c,d):
    # формируем шапку
    print('\t',y,end='')
for i in range(a,b):
    print()    
    print(i,end='')
    for y in range(c,d):
        print('\t',i*y,end='')
print()</pre>
<img src="./images/python_base3.png">
<p>
Другое решение:
<pre>
a, b, c, d = int(input()), int(input()), int(input()), int(input())

for i in range(c, d + 1):
    print("\t" + str(i), end="")

print()

for i in range(a, b + 1):
    print(i, end="\t")
    for n in range(c, d + 1):
        print(i * n, end="\t")
    print()
</pre>

<font color=red>Разбор моих ошибок с for:</font>
<pre>
#!/usr/bin/env python3 
num = input().split()
s = 0
i = 0
for i in len(num):
    s = s + int(i)
print(s)
<font color=red>for i in len(num):
TypeError: 'int' object is not iterable</font></pre>
<i>Оператором in можно перебрать элементы в какой-нибудь последовательности, которую можно перебирать - итерировать.
Например - список, кортеж. А Вы пытаетесь применить его к единственному числу - len(s). Вот оно и пишет, что целое число неперебираемо.</i>






<h3 align=center><a name="potok">Вызов методов цепочкой</h3>
Ссылка: <a href="https://pyneng.readthedocs.io/ru/latest/book/04_data_structures/method_chaining.html">Вызов методов цепочкой</a><p>
Часто с данными надо выполнить несколько операций, пример скрипта:
<pre>
line = "switchport trunk allowed vlan 10,20,30"
words = line.split()
vlans_str = words[-1]
vlans = vlans_str.split(",")
print(vlans)</pre>
В этом случае переменные используются для хранения промежуточного результата и последующие методы/действия выполняются уже с переменной. Это совершенно нормальный вариант кода, особенно поначалу, когда тяжело воспринимать более сложные выражения.
<p>
Однако в Python часто встречаются выражения, в которых действия или методы применяются один за другим в одном выражении. Например, предыдущий код можно записать так:
<pre>
line = "switchport trunk allowed vlan 10,20,30"
vlans = line.split()[-1].split(",")
print(vlans)</pre>
Так как тут нет выражений в скобках, которые бы указывали приоритет выполнения, все выполняется слева направо. Сначала выполняется line.split() - получаем список, затем к полученному списку применяется [-1] - получаем последний элемент списка, строку 10,20,30. К этой строке применяется метод split(",") и в итоге получаем список ['10', '20', '30'].
<p>
Главный нюанс при написании таких цепочек предыдущий метод/действие должен возвращать то, что ждет следующий метод/дествие. И обязательно чтобы что-то возвращалось, иначе будет ошибка.










<h3 align=center><a name="def">Функции, директивы def, return</h3>
Ссылки: <a href="https://pyplanet.ru/article/def-return.html">Функции, директивы def, return</a><br>
<a href="https://pythonworld.ru/tipy-dannyx-v-python/vse-o-funkciyax-i-ix-argumentax.html">Функции и их аргументы</a>
<p>
<ol>
<li> Часто некоторый код нужно выполнить несколько раз. Либо мы хотим как-то изолировать некоторый код, и вызывать его в необходимом месте.<br>
Этого можно достичь написанием функции.
<p>
Функция в python - объект, принимающий аргументы и возвращающий значение. Обычная функция определяется с помощью инструкции def. Второй способ с помощью lambda.
<p>
Синтаксис:
<pre>
def name_f(arg1, arg2,...):
    return command</pre>
После инструкции def идёт <b>имя функции</b>.
<p>
<li> <b>Аргументы функции</b><br>
Затем, в скобках, пишутся <b>аргументы</b> (или иногда говорят параметры) функции.
<p>
<ul>
<li> По способу передачи аргументов они бывают позиционные (positional arguments) или именованные:<br>
В fun(12, 123, a = 5, b = 10) a =5 и b = 10 - аргументы именованные, 12 и 123 - аргументы позиционные
<p>
Однако по имени можно передавать только последние аргументы. То есть, можно вызвать add(1, y=2), add(1, 2), add(x=1, y=2), но нельзя add(2, x=1).
<p>
<li> <b>Аргументы по умолчанию</b> (positional_args_with_defaults)<br>
Так называются аргументы, если при описывании функции аргументы имеют уже определенное значение.<br>
def f(b, a =10)<br>
Здесь a = 10 является аргументом по умолчанию.
<p>
<i>Следовало бы упомянуть один важный момент: значение по умолчанию вычисляется только один раз - при первом вызове функции. При всех последующих вызовах будет повторно использован тот объект, который получили при первом вычислении значения по умолчанию.<br>
В случае с неизменяемыми значениями (числа, строки) это поведение ни на что не влияет, а если в значении по умолчанию используется изменяемый тип - то все изменения этого аргумента будут сохраняться между вызовами.
<br>В качестве примера используем новый список как значение по умолчанию для аргумента b:
<pre>
>>> def f(a, b=[]):
...     b.append(a)
...     print(b)
...
>>> f(1)
[1]
>>> f(2)
[1, 2]
>>> f(3,b=[])
[3]
>>> f(4)
[1, 2, 4]</pre>
<font color=red>Непонятно чем аргументы по умолчанию отличаются от именнованых аргументов??????</font>
<p>
<li> <b>*args</b> (*pos_args_name)<br>
args - это список позиционных аргументов.
<br><i>По соглашению между программистами в Python  в функции  c произвольным количеством принимающих параметров принято писать *args вместо *(с каким либо другим названием переменной).</i>
<p>


<li> <b>**kwargs</b> (**kw_args_name)<br>
Это словарь из именнованых аргументов.
<p>
Пример:
<pre>
def printab(a=50, b=100, *args, **kwargs):
    print('a =', a)
    print('b =', b)
    print('additional <b>positional arguments</b>:')
    for i in <b>args</b>:  # распечатка кортеджа
        print(i)
    print('additional <b>named arguments</b>:')
    for key in <b>kwargs</b>:  # распечатка словаря
        print(key, '=', kwargs[key])

printab(10, 20, 25, 35, 45, 50, 60, c=30, d=40, jimmi=12</pre>
Результат:
<pre>
результат:

a = 10
b = 20
additional positional arguments:
25
35
45
50
60
additional named arguments:
c = 30
d = 40
jimmi = 123</pre>

<li> Общий синтаксис:
<pre>
def function_name([ positional_args,
                  [ positional_args_with_default,
                  [ *pos_args_name,
                  [ keyword_only_args,
                  [ **kw_args_name]]]]]):</pre>
-позиционные аргументы: a, b, c<br>
-позиц. аргументы со значением по умолчанию: d=0, e=True<br>
-дополнительные позиционные аргументы (которые в инициализации не участвовали) отправляются в кортеж (*args)<br>
<font color=red>-блок аргументов, которые можно передать только по имени: f, g, h=10</font><br>
-именованные аргументы которые в инициализации не участвовали, отправляются в словарь: **kwarqs<br>

</ul>
<p>
<li> <b>Тело функции:</b><br>
В следующей строке с отступом идет <b>тело функции</b>.<br>
Инструкция return говорит, что нужно вернуть значение. В нашем случае функция возвращает сумму x и y.
<p>
Внутри функции может быть какой угодно код, но, если мы хотим вернуть значение, мы обязаны написать return ЧТО_ТО. Если этого не написать, то функция вернёт специальное значение None (некоторый аналог NULL из других языков программирования).
<p>
Код после достижения return внутри функции не выполняется.
<p>
Внутри программы функция может быть вызвана. Например:
<pre>
def add(x, y):
    return x + y

print(add(1, 2))  # Выведет 3</pre>

<b>Согласно PEP 8 после определения функции нужно отступать 2 пустые строчки.</b>


<h4>Локальные и глобальные переменные</h4>
Переменные, объявленные внутри функции, являются локальными. Если их использовать за пределами выполнения функции, то произойдет ошибка.
<p>
Глобальные переменные - это переменные объявленные вне функции.

<li> <b>Стек вызовов</b><br>
Ссылки: <a href="https://stepik.org/lesson/24459/step/6?unit=6764">Функции и стек вызовов</a><br>
Стек вызовов чаще всего служит для хранения функций.
<p>
<li> Если return пустой или его вообще не будет, тогда функция будет возвращать объект None. Тип этого None есть NoneType.
<p>
<li> <b>Рекурсивная функция</b><br>
Это такая функция в теле которой присутствует сама функция.
<p>
<li> <b>Пространство имён и область видимости</b><br>
Ссылки: <a href="https://nuancesprog.ru/p/9211/">Пространства имен и области видимости в Python</a>
<p>
<i>Пространство имён - это совокупность ссылок от имён объектов (переменных, функций, классов и т. д.) к их значениям в оперативной памяти (объектам). То есть, в теории мы могли бы обращаться сразу к значениям в памяти. Но их неудобно понимать, поэтому и придумали пространство имён. Оно, по сути, является переводчиком между понятному человеку названием объекта и его непонятному человеку значению в памяти. Словарь, если угодно.</i></i>
<p>
Пространство имен - это все ссылки на объекты (переменные).<br>
Пространств имён может быть несколько.<br>
<b>Встроенное пространство имен</b> содержит имена всех встроенных объектов, которые всегда доступны при работе в Python. Вы можете перечислить объекты во встроенном пространстве с помощью следующей команды: 
<pre>>>> dir(__builtins__)</pre>

Первое пространство имен - builtins, создается когда запускаем интерпретатор.
<p>
<b>Глобальное пространство имен nain</b> содержит имена, определенные на уровне основной программы, и создаётся сразу при запуске тела этой программы. Сохраняется же оно до момента завершения работы интерпретатора. 
<br>Строго говоря, могут существовать и другие глобальные пространства имен. Интерпретатор также создает пространство данного типа для любого модуля, загружаемого программой при помощи выражения import.
<p>
nain, является глобальным, создается когда создаем функцию или что-то делаем с переменной.
<p>
Интерпретатор создает новое пространство имен при каждом выполнении функции. Это пространство является локальным для функции и сохраняется до момента завершения ее действия.<br>
Локальное пространство имен содержит аргументы функции и локальные переменные (объявленные внутри функции).
<p>
Наличие нескольких отличных пространств имен означает, что в процессе выполнения программы Python несколько разных экземпляров одного имени могут существовать одновременно. Пока каждый из них находится в собственном пространстве, все они обслуживаются по отдельности, и путаницы не происходит. 
<p>
Но тут возникает вопрос. Предположим, что вы ссылаетесь на имя x в коде, а оно существует в нескольких пространствах. Как Python узнает, какое именно вы имеете в виду? 
<p>
Ответ кроется в понятии области видимости имени, представляющей из себя часть программы, в которой данное имя обладает значением. Интерпретатор определяет эту область в среде выполнения, основываясь на том, где располагается определение имени и из какого места в коде на него ссылаются. 
<p>
<i><pre>
def a():
    print(x) 
def b():
    x = 1
    a() 
b()#NameError</pre>
Функция b() вызывает ф-ю a(), зоны видимости функций не включены друг в друга. Т. е. интерпретатор не найдя имя 'x' в зоне видимости a() перейдёт в глобальную зону видимости, потом в зону видимости builtins - и не обнаружит 'x'. В результате: NameError
<pre>
def b():
    def a():
        print(x)
    x = 1
    a() 
b()#1</pre>
Функция b() также вызывает ф-ю a(), но теперь a() определена внутри b(). Т. е. интерпретатор не найдя имя 'x'  в зоне видимости a() перейдёт в зону видимости b() и найдет 'x' . Результат: 1
<p>
<li> global и nonlocal
</ol>




<h3 align=center><a href="https://intuit.ru/studies/courses/49/49/lecture/27060?page=2">Встроенные функции</a></h3>
В среде Python без дополнительных операций импорта доступно более сотни встроенных объектов, в основном, функций и исключений. Для удобства функции условно разделены по категориям:<p>
<ul>

<li> <a href="https://pythonworld.ru/osnovy/vstroennye-funkcii.html">Функции преобразования типов и классы</a>: coerce, str, repr, int, list, tuple, long, float, complex, dict, super, file, bool, object<p>
<li> Числовые и строковые функции: abs, divmod, ord, pow, len, chr, unichr, hex, oct, cmp, round, unicode
<p>
abs(x)	Модуль числа x. Результат: |x|.
<p>
divmod(x, y)	Частное и остаток от деления. Результат: (частное, остаток).
<p>
pow(x, y[, m])	Возведение x в степень y по модулю m. Результат: x**y % m.
<p>
round(n[, z])	Округление чисел до заданного знака после (или до) точки.
<p>
ord(s)	Функция возвращает код (или Unicode) заданного ей символа в односимвольной строке.
<p>
chr(n)	Возвращает строку с символом с заданным кодом.
<p>
len(s)	Возвращает число элементов последовательности или отображения.
<p>
oct(n), hex(n)	Функции возвращают строку с восьмеричным или шестнадцатеричным представлением целого числа n.
<p>
cmp(x, y)	Сравнение двух значений. Результат: отрицательный, ноль или положительный, в зависимости от результата сравнения.
<p>
unichr(n)	Возвращает односимвольную Unicode-строку с символом с кодом n.
<p>

<li> <a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=4">Функции обработки данных: apply, map, filter, reduce, zip, range, xrange, max, min, iter, enumerate, sum</a><br>
<a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=5">Списковые включения</a><br>
<a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=6">Итераторы</a>



<h3 align=center><a name="range">Функция range</a></h3>
Функция range обычно применяется в цикле и позволяет перебрать какой-нибудь объект типа список по его индексу.
<pre>
for index range(len(spisok):
    print spisok(index)</pre>
функция range принимает от одного до трех аргументов. Если аргумент всего один, она генерирует список чисел от 0 (включительно) до заданного числа (исключительно).<br>
Если аргументов два, то список начинается с числа, указанного первым аргументом.<br>
Если аргументов три - третий аргумент задает шаг
<pre>
>>> print range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10, 3)
[1, 4, 7]</pre>
Третий аргумент может быть и отрицательным:
<pre>
>>> for i in range(10, 5, -1):
...     print(i)</pre>
Получим 10, 9, 8, 7, 6

<p>
Функция <b>xrange()</b> - аналог range(), более предпочтительный для использования при последовательном доступе, например, в цикле for или с итераторами. Она возвращает специальный xrange -объект, который ведет себя почти как список, порождаемый range(), но не хранит в памяти все выдаваемые элементы.
<p>
<li> Функции определения свойств: hash, id, callable, issubclass, isinstance, type
<p>
<li> Функции для доступа к внутренним структурам: locals, globals, vars, intern, dir
<p>
<li> Функции компиляции и исполнения: eval, execfile, reload, __import__, compile
<p>
<li> Функции ввода-вывода: input, raw_input, open<p>
<li> Функции для работы с атрибутами: getattr, setattr, delattr, hasattr
<p>
<li> Функции-"украшатели" методов классов: staticmethod, classmethod, property
<p>
<li> Прочие функции: buffer, slice
</ul>

<h4>Функции как параметры и результат</h4>
функции являются такими же объектами Python как числа, строки или списки. Это означает, что их можно передавать в качестве параметров функций или возвращать из функций.
<p>
Функции, принимающие в качестве аргументов или возвращающие другие функции в результате, называют функциями высшего порядка. В Python функции высшего порядка применяются программистами достаточно часто. В большинстве случаев таким образом строится механизм обратных вызовов (callbacks), но встречаются и другие варианты. Например, алгоритм поиска может вызывать переданную ему функцию для каждого найденного объекта.





<h3><a href="https://pyplanet.ru/article/lambda.html">Анонимные lambda-функции</a></h3>
<h3><a href="https://pyplanet.ru/article/args-kwargs.html">Функции с переменным числом аргументов; args, kwargs</a></h3>
<h3><a href="https://pyplanet.ru/article/scopes-global-nonlocal.html">Области видимости; инструкции global, nonlocal</a></h3>
<h3><a href="https://pyplanet.ru/article/try-except.html">Конструкция try - except для обработки исключений</a></h3>





<h3 align=center><a name="file" href="https://pyplanet.ru/article/files.html">Работа с файлами: чтение, запись, редактирование</a></h3>
В Python, как и в других языках программирования, можно работать с файлами: читать из файла и писать в файл. Это позволяет легко манипулировать любыми файлами из Python.
<p>
Файловые объекты должны поддерживать основные методы: read(), write(), readline(), readlines(), seek(), tell(), close() и т.п.
<p>
Прежде, чем работать с файлом, его надо открыть. Открыть файл можно с помощью встроенной функции open:
<pre>
f = open('pyplanet.txt', 'r', encoding='utf-8')</pre>
У функции open много параметров, нам пока важны 3 аргумента.
<p>
Первый, это путь к файлу. Путь к файлу может быть относительным или абсолютным.
<p>
В случае относительного пути поиск файла будет производиться относительно директории, из которой была запущена программа на Python. Как правило, это та папка, в которой находится сама программа.
<p>
Поэтому, чтобы приведённый выше код выполнился, необходимо создать файл pyplanet.txt в той же папке, что и программа, которую вы пишете.
<p>
Однако можно задать и абсолютный путь, например,
<pre>
f = open(r'D:\files\pyplanet.txt', 'r', encoding='utf-8')</pre>
Второй аргумент, это режим, в котором мы будем открывать файл.
<p>
<img src="./images/python_base1.png">
<p>
Режимы могут (и должны) быть объединены, то есть, к примеру, 'rb' - чтение в двоичном режиме. По умолчанию режим равен 'rt'.
<p>
И последний аргумент, encoding, нужен только в текстовом режиме чтения файла. Этот аргумент задает кодировку.
<p>
Какая кодировка идёт по умолчанию? А неизвестно. Начиная с Python версии 3.15 (это примерно к 2026 году) кодировкой по умолчанию станет utf-8.
<p>
В какой же кодировке Ваш файл, зависит от редактора, в котором вы создавали / редактировали файл.
<p>
Как правило, это utf-8, или, в более редких случаях, windows-1251.
<p>
Функция open возвращает объект файла (или по-другому файлового дескриптора).
<h4>Чтение из файла</h4>
Файл мы открыли, а теперь хотим прочитать из него информацию. Для этого есть несколько способов.
<p>
<b>Метод read</b><br>
Метод read файла, читает весь файл целиком, если был вызван без аргументов, и n символов, если был вызван с аргументом (целым числом n).
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> f.read(1)
'H'
>>> f.read()
'ello world!\nThe end.\n\n'</pre>
Каждый последующий вызов read продолжит читать с того места, на котором остановилось чтение.
<h4>Цикл for для чтения файла</h4>
Ещё один прочитать файл - сделать это построчно, воспользовавшись циклом for. Файловый объект в Python - тоже итерируемый объект, и в цикле for он возвращает содержимое файла построчно.
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> for line in f:
...     line
...
'Hello world!\n'
'\n'
'The end.\n'
'\n'</pre>
<h4>readlines</h4>
Метод readlines файла, читает весь файл целиком, и возвращает список всех строк в нём. Этот способ более затратный по памяти, чем цикл for, однако иногда тоже может использоваться.
<pre>
>>> f = open('pyplanet.txt', 'r', encoding='utf-8')
>>> f.readlines()
['Hello world!\n', '\n', 'The end.\n', '\n']</pre>
<h4>Закрытие файла</h4>
После манипуляций с файлом, его необходимо закрыть, таким образом, освободив ресурсы файлового дескриптора.
<pre>f.close()</pre>
Все дескрипторы, конечно, будут освобождены автоматически при выходе из программы, но что, если программа работает долго? Или она открывает много файлов?
<p>
Количество одновременно открытых файлов в системе ограничено.
<p>
Здесь очень сильно может помочь конструкция try - finally, так как при возникновении и перехвате исключения можно забыть закрыть файл:
<pre>
f = open('pyplanet.txt', 'r', encoding='utf-8')
try:
    for line in f:
        do_something(line)
finally:
    f.close()</pre>
<h4>Запись в файл</h4>
Как что-либо записать в файл?
<p>
Во-первых, необходимо открыть файл в режиме "для записи", иначе ничего не получится:
<pre>f = open('pyplanet_output.txt', 'w', encoding='utf-8')</pre>
<ol>
<li> <b>Метод write</b><br>
Метод write, записывает строку в файл:
<pre>f.write("Hello pyplanet!\n")</pre>
Метод write возвращает количество записанных символов. Не пугайтесь, если в интерактивном режиме увидите цифры - это они и есть.<br>
Перенос строки не добавляется автоматически. Не забывайте добавлять его вручную, иначе строки "слипнутся".
<p>
<img src="./images/python_base6.png"><br>
На рисунке показаы 2 способа записи в файл. Число не записывается напрямую, сначало нужно с помощью функции str() преобразовать число в строку.
<p>
<li> <b>Аргумент file функции print</b><br>
Функция print может принимать в качестве аргумента файловый дескриптор для печати.
<p>
Из плюсов - символ переноса строки поставится за вас:
<pre>print("Hello pyplanet!", file=f)</pre>
<p>
<li> <b>Метод writelines</b><br>
Метод writelines, записывает список строк в файл:
<pre>f.writelines(["1\n", "2\n", "3\n"])</pre>
Перенос строки, как и в методе write, не добавляется автоматически. Не забывайте добавлять его вручную, иначе строки "слипнутся".<br>
Для записи более сложных структур в Python есть такие средства, как pickle, json, csv, и многие другие.
<p>
Примеры:<br>
Следующий пример показывает копирование файла:
<pre>
f1 = open("file1.txt", "r")
f2 = open("file2.txt", "w")
for line in f1.readlines():
  f2.write(line)
f2.close()
f1.close()
</pre>

<li> Стоит заметить, что кроме собственно файлов в Python используются и файлоподобные объекты. В очень многих функциях просто 
неважно, передан ли ей объект типа file или другого типа, если он имеет все те же методы (и в том же смысле). Например, 
копирование содержимого по ссылке (URL) в файл file2.txt можно достигнуть, если заменить первую строку из предыдущего примера 
на:
<pre>
import urllib
f1 = urllib.urlopen("http://python.onego.ru")</pre>

<li> <b>with open() as var</b><br>
Открыть файл, выполнить с ним нужные операции и автоматически закрыть его после можно с помощью конструкции:
<pre>
with open('name_file') as var
    s1 = var.readline()
    s2 = var.readline()</pre>
По выполнении блока, файловый дескриптор будет удален (файл закроется).
<li> <b>Полезные методы файлов</b>
<ol>
<li> strip()<br>
Удаляет служебные символы при чтении строк файла.

<li> os.path.join(arg1, arg2,...)<br>
Создает из склеивания аргументов полный путь к файлу.<br>
Для того чтобы выполнить этот метод, нужно импортировать модуль os (import as).
<p>
<img src="./images/python_base5.png">
</ol>
<li> <b>Пример построчного чтения файла</b>
<pre>with open('input.txt') as inf:
  for line in inf:
      line = line.strip()
      print()</pre>
</ol>


<h3 align=center><a name="modul" href="https://pyplanet.ru/article/import.html">Импорт и создание модулей</a></h3>
<b>Модулем</b> в Python называется любой файл с программой.
<p>
Каждая программа может подключить модуль и получить доступ к его классам, функциям и объектам.
<p>
Модуль может быть написан не только на Python, но и, например, на C или C++.
<p>
К примеру, модуль math написан как раз на C и имеет интерфейс для вызова из Python.
<p>
В языке Python набор модулей, посвященных одной проблеме, можно поместить в <b>пакет</b>. Хорошим примером такого пакета является пакет xml, в котором собраны модули для различных аспектов обработки XML.
<p>
В программе на Python модуль представлен объектом-модулем, атрибутами которого являются имена, определенные в модуле:
<pre>
>>> import datetime
>>> d1 = datetime.date(2004, 11, 20)</pre>
В данном примере импортируется модуль datetime. В результате работы оператора import в текущем пространстве имен появляется объект с именем datetime.
<p>
Модули для использования в программах на языке Python по своему происхождению делятся на обычные (написанные на Python) и модули расширения, написанные на другом языке программирования (как правило, на C). С точки зрения пользователя они могут отличаться разве что быстродействием. Бывает, что в стандартной библиотеке есть два варианта модуля: на Python и на C. Таковы, например, модули pickle и cPickle. Обычно модули на Python в чем-то гибче, чем модули расширения.
<p>
Модуль оформляется в виде отдельного файла с исходным кодом. Стандартные модули находятся в каталоге, где их может найти соответствующий интерпретатор языка.<br>
При импорте модуля интерпретатор Python пытается найти модуль в следующих местах:
<ul>
<li> Директория, где находится файл, в котором вызывается команда импорта.

<li> Директория, определённая в консольной переменной PYTHONPATH (если модуль не найден с первого раза).

<li> Путь, заданный по умолчанию (если модуль не найден в предыдущих двух случаях).
</ul>
Путь поиска сохраняется в переменной path в системном модуле sys. Переменная sys.path включает в себя все три вышеописанных места поиска.<br>
<img src="./images/python_base2.png">
<p>
Чтобы получить полный список модулей, установленных на ПК, используют команду help("modules") или по конкретному модулю атрибуты: help("name_modul")


<p>
Чтобы получить доступ к функциям из модуля, его необходимо импортировать. Сделать это можно несколькими способами:
<h4>Инструкция import</h4>
После ключевого слова import указывается название модуля.<br>
Название модуля - это имя файла без расширения.
<p>
Одной инструкцией можно подключить несколько модулей (для этого они указываются через запятую), хотя это не рекомендуется делать, так как снижает читаемость кода. Импортируем модуль math:
<pre>import math</pre>
После импортирования модуля его название становится переменной, через которую можно получить доступ к атрибутам (функциям) 
модуля. Например чтобы вычислить синус числа импортируем сначало модуль (математическую библиотеку) math и после этого можем использовать его функцию sin:
<pre>
>>> import math
>>> math.sin(1)
0.8414709848078965</pre>
Стоит отметить, что если указанный атрибут модуля не будет найден, возникнет исключение AttributeError. А если не удастся найти модуль для импортирования, то ModuleNotFoundError.

<h4>Использование псевдонимов</h4>
Если название модуля слишком длинное, или оно вам не нравится по каким-то другим причинам, то для него можно создать псевдоним, с помощью ключевого слова as.
<pre>
>>> import math as m
>>> m.sin(1)
0.8414709848078965</pre>
Теперь доступ ко всем атрибутам модуля math осуществляется только с помощью переменной m, а переменной math в этой программе уже не будет (если, конечно, вы после этого не напишете import math, тогда модуль будет доступен как под именем m, так и под именем math).
<h4>Инструкция from ... import ...</h4>
Подключить только определенные атрибуты (функции) модуля, а не полностью весь модуль можно с помощью инструкции from:
<pre><b>from &lt;Название модуля&gt; import &lt;Атрибут 1&gt; [ as &lt;Псевдоним 1&gt; ], [&lt;Атрибут 2&gt; [ as &lt;Псевдоним 2&gt; ] ...]</b></pre>
Эта инструкция позволяет подключить из модуля только указанные вами атрибуты. При этом сам модуль не записывается в переменную, а в глобальную область видимости добавляются те функции и объекты, которые вы импортировали. Для длинных имён также можно назначить псевдоним, указав его после ключевого слова as.
<pre>
>>> from math import sin, ceil as c
>>> sin(1)
0.8414709848078965
>>> c(4.6)
5</pre>
Импортируемые атрибуты можно разместить на нескольких строках, если их много, для лучшей читаемости кода:
<pre>
from math import (
    sin, cos,
    tan, atan
)</pre></pre>
<h4>Инструкция from ... import *</h4>
Второй формат инструкции from позволяет подключить все (точнее, почти все) переменные из модуля.
<p>
Данным способом импортируются только атрибуты, определённые в переменной __all__ у модуля (если создатель модуля об этом побеспокоился). Или только те атрибуты, которые не начинаются с _ (это соглашение о "скрытых" переменных, его мы рассмотрим в дальнейших лекциях).
<pre>from math import *</pre>
С данным способом нужно быть крайне аккуратным. Имена в модуле, совпадающие с именами в главной программе, во время импорта инструкцией from будут перезаписаны (и наоборот, переменные в главной программе будут перезаписывать функции с такими же названиями из импортированного модуля). И в целом, забивать пространство имён - не самая удачная идея.
<h4>Создание своего модуля на Python</h4>
Теперь пришло время создать свой модуль. Это можно сделать, просто создав файл с программой, например, назовём его mymodule.py, в котором определим какую-нибудь функцию:
<pre>
def hello():
    print('Hello, world!')</pre>
Теперь в этой же папке создадим другой файл, например, main.py:
<pre>
import mymodule

mymodule.hello()</pre>
Выведет Hello, world!.
<p>
Иии... это всё! Вы сделали свой модуль! В конце отвечу на несколько вопросов, связанных с созданием модулей.
<p>
Можно ли использовать модуль как самостоятельную программу?<br>
Можно. Однако следует помнить, что при импортировании модуля его код выполняется полностью, то есть, если программа что-то печатает, то при её импортировании это будет напечатано.
<p>
Подобного эффекта можно избежать, если проверять, запущен ли скрипт как программа, или импортирован. Это можно сделать с помощью магической переменной __name__, которая определена в любой программе, и равна "__main__", если скрипт запущен в качестве главной программы, и имя модуля, если он импортирован. Например, mymodule.py может выглядеть вот так:
<pre>
def hello():
    print('Hello, world!')

if __name__ == "__main__":
    hello()</pre>
<b>Как назвать модуль?</b><br>
Помните, что вы (или другие люди) будут его импортировать и использовать в качестве переменной.
<p>
Модуль нельзя именовать так же, как и ключевое слово:
<pre>
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield</pre>
Имена модулей нельзя начинать с цифры
<p>
Не нужно называть модуль также, как какую-либо из встроенных функций. Технически так сделать, конечно, можно, но это создаст большие неудобства при его последующем использовании
<p>
<b>Куда поместить модуль?</b><br>
Туда, где его потом можно будет найти.
<p>
Пути поиска модулей указаны в переменной sys.path. В него включены текущая директория (то есть модуль можно оставить в папке с основной программой), а также директории, в которых установлен python.
<p>
Кроме того, переменную sys.path можно изменять вручную, что позволяет положить модуль в любое удобное для вас место (главное, не забыть в главной программе модифицировать sys.path).










<h3 align=center><a name="lib">Обзор стандартной библиотеки</h3>
Ссылки: <a href="https://intuit.ru/studies/courses/49/49/lecture/27060?page=4">Обзор стандартной библиотеки</a><br>
<a href="https://docs.python.org/3/library/">Список модулей стандартной библиотеки</a><br>
<a href="https://pythonworld.ru/moduli">Модули</a>
<p>
Помимо создания собственных модулей python содержит большое количество собственных модулей, называемых библиотекой стандартных  модулей.<br>
Модули стандартной библиотеки можно условно разбить на группы по тематике.
<ol>
<li> Сервисы периода выполнения. Модули: <b>sys</b>, atexit, copy, traceback, math, cmath, random, time, calendar, datetime, sets, array, struct, itertools, locale, gettext.


<h4>Модуль sys</h4>
Ссылки: <a href="https://python-scripts.com/module-sys">Разбираем модуль sys</a>
<p>
 Модуль sys предоставляет системе особые параметры и функции.
<ol>
<li> <b>sys.argv</b><br>
Значение sys.argv – это список аргументов командной строки, которые причастны к скрипту Python. Первый аргумент, argv[0], 
имеет аналогичное скрипту Python наименование. В зависимости от платформы, на которой вы работаете, первый аргумент может 
содержать полный путь к скрипту или к названию файла. Для дополнительных деталей обратитесь к документации. А тем временем, 
попробуем поработать с парочкой примеров, чтобы познакомиться с этим инструментом:<br>
В интерпретаторе выполним:
<pre>
>>> import sys
>>> print(sys.argv)
['']</pre>
Получили пустой список, потому что никакую программу не запускали.
<p>
Если создадим скрипт 1.py с кодом:
<pre>
import sys
print(sys.argv)</pre>
и запустим его с командной строки:
<br><img src="./images/python_base7.png">
<p>
<li> sys.executable
<li> sys.exit
<li> sys.modules
<li> sys.path
<li> sys.platform
<li> sys.stdin/stdout/stderr
</ol>

<h4>Модуль subprocess</h4>
Ссылки: <a href="https://python-scripts.com/subprocess">Модуль subprocess — Работаем с процессам</a>
<p>
Модуль subprocess дает разработчику возможность запускать процессы программ из Python. Другим словами, вы можете запускать 
приложения и передавать им аргументы при помощи модуля subprocess. Модуль subprocess был внедрен в Python 2.4 для замены 
настроек вызовов модуля os, таких как os.popen, os.spawn и os.system, а также для замены popen2 и старых командных модулей.
<p>
<ul>
<li> <b>Функция вызова call</b><br>
Модуль subprocess содержит функцию под названием call. Эта функция позволяет вам вызывать другую программу, дожидаться 
завершения команды и вернуть код возврата. Она принимает один или несколько аргументов, а также следует ключевым аргументам (с 
их значениями): stdin=None, stdout=None, stderr=None, shell=False.<br>
Взглянем на простой пример:
<pre>
import subprocess
 
# Для Windows
subprocess.call("notepad.exe")
 
# Для linux
subprocess.call("gedit")</pre>
Если вы запустите этот код на машине, которая работает на Windows Python, вы увидите открывшийся блокнот. Обратите внимание на 
то, что IDLE (<font color=red>наверное это имя интерпретатора</font>) ожидает, пока вы закроете блокнот, после чего вернет 
нулевой код (0).
<br>Это значит, что код был выполнен успешно. Если вы получите что-либо, что не является ноль, то вы столкнулись с какой-то 
ошибкой.
<p>
Метод call также принимает аргументы, для передачи программе, которую вы выполняете. Давайте взглянем на то, как это работает:
<pre>
import subprocess
code = subprocess.call(["ping", "www.yahoo.com"])</pre>
В ответе получим результат пингования сайта.<br>
Обратите внимание на то, что в данном примере мы передали список аргументов. Первый объект в списке это программа, которую мы 
хотим вызвать. Все остальное в списке – это аргументы, которые мы хотим передать программе. Так что в данном примере мы 
выполняем пинг на сайте Yahoo. Также обратите внимание на то, что код возврата нулевой, так что все прошло успешно. 
</ul>
<p>
Модуль copy содержит функции для копирования объектов.<p>
В модулях math cmath собраны математические функции для действительных и комплексных аргументов.<p>
Модуль random генерирует псевдослучайные числа для нескольких различных распределений.<p>
модуль time дает функции для получения текущего времени и преобразования форматов времени.<p>
Модуль sets реализует тип данных для множеств.<p>
Модули array и struct реализуют низкоуровневый массив и структуру данных. Основное их назначение - разбор двоичных форматов данных.<p>
Модуль itertools содержит набор функций для работы с итераторами. Итераторы позволяют работать с данными последовательно, как если бы они получались в цикле. Альтернативный подход - использование списков для хранения промежуточных результатов - требует подчас большого количества памяти, тогда как использование итераторов позволяет получать значения на момент, когда они действительно требуются для дальнейших вычислений.<p>
Модуль locale применяется для работы с культурной средой. В конкретной культурной среде могут использоваться свои правила для написания чисел, валют, времени и даты и т.п.<p>
Модуль gettext При интернационализации программы важно не только предусмотреть возможность использования нескольких культурных сред, но и перевод сообщений и меню программы на соответствующий язык.   <p>

<li> Поддержка цикла разработки. Модули: pdb, hotshot, profile, unittest, pydoc. Пакеты docutils, distutils.<br>
Модули этого раздела помогают поддерживать документацию, производить регрессионное тестирование, отлаживать и профилировать программы на Python, а также обслуживают распространение готовых программ, создавая среду для конфигурирования и установки пакетов.<p>

<li> Взаимодействие с ОС (файлы, процессы). Модули: os, os.path, getopt, glob, popen2, shutil, select, signal, stat, tempfile.
<p>
<li> Обработка текстов. Модули: string, re, StringIO, codecs, difflib, mmap, sgmllib, htmllib, htmlentitydefs. Пакет xml.
<p>
<li> Многопоточные вычисления. Модули: threading, thread, Queue.
<p>
<li> Хранение данных. Архивация. Модули: pickle, shelve, anydbm, gdbm, gzip, zlib, zipfile, bz2, csv, tarfile.<br>
К этой категории отнесены модули, которые работают с внешними хранилищами данных.
<p>
<li> Платформо-зависимые модули. Для UNIX: commands, pwd, grp, fcntl, resource, termios, readline, rlcompleter. Для Windows: msvcrt, _winreg, winsound.
<p>
<li> Поддержка сети. Протоколы Интернет. Модули: cgi, Cookie, urllib, urlparse, httplib, smtplib, poplib, telnetlib, socket, asyncore. Примеры серверов: SocketServer, BaseHTTPServer, xmlrpclib, asynchat.<br>
Почти все модули из этой категории, обслуживающие клиентскую часть протокола, построены по одному и тому же принципу: из модуля необходим только класс, объект которого содержит информацию о соединении с сервером, а методы реализуют взаимодействие с сервером по соответствующему протоколу. Таким образом, чем сложнее протокол, тем больше методов и других деталей требуется для реализации клиента.<br>
Примеры серверов используются по другому принципу. В модуле с реализацией сервера описан базовый класс, из которого пользователь модуля должен наследовать свой класс, реализующий требуемую функциональность. Правда, иногда замещать нужно всего один или два метода.
<p>
<li> Поддержка Internet. Форматы данных. Модули: quopri, uu, base64, binhex, binascii, rfc822, mimetools, MimeWriter, multifile, mailbox. Пакет email.<br>
В стандартной библиотеке Python имеются разноуровневые модули для работы с различными форматами, применяющимися для кодирования данных в сети Интернет и тому подобных приложениях.<br>
Сегодня наиболее мощным инструментом для обработки сообщений в формате является пакет email. С его помощью можно как разбирать сообщения в удобном для программной обработки виде, так и формировать сообщение на основе данных о полях и основном содержимом (включая вложения).
<p>
<li> Python о себе. Модули: parser, symbol, token, keyword, inspect, tokenize, pyclbr, py_compile, compileall, dis, compiler.
<p>
<li> Графический интерфейс. Модуль Tkinter.<br>
Почти все современные приложения имеют графический интерфейс пользователя. Такие приложения можно создавать и на языке Python. 
В стандартной поставке имеется модуль Tkinter, который есть не что иное, как интерфейс к языку Tcl/Tk, на котором можно 
описывать графический интерфейс.

Следует отметить, что существуют и другие пакеты для программирования графического интерфейса: wxPython (основан на 
wxWidgets), PyGTK и т.д. Среди этих пакетов в основном такие, которые работают на одной платформе (реже - на двух).
</ol>
Примечание:<br>
Очень часто модули содержат один или несколько классов, с помощью которых создается объект нужного типа, а затем речь идет уже 
не об именах из модуля, а об атрибутах этого объекта. И наоборот, некоторые модули содержат лишь функции, достаточно общие для 
того, чтобы работать над произвольными объектами (либо достаточно большой категорией объектов).






<h3 align=center>Дополнительные библиотеки</h3>
Python  может работать с дополнительными библиотеками, которые в состав python не входят и их нужно устанавливать в систему.
<ol>
<li> <b>Библиотека requests</b><br>
Служит для отправки запросов на сервер и получения от него ответа.
<p>
Для установки служит команда: <b>pip3 install requests</b><br>
У меня установлен уже в python.
<p>
Пример простого запроса в программе:
<pre>
import requests
r = requests.get('htpp://example.com')  # простой get-запрос
print(r.text) # вывод ответа от сервера</pre>
<img src="./images/python_base8.png">


<li> <b>Библиотека pandas</b><br>
Ссылки: <a href="https://education.yandex.ru/handbook/python/article/modul-pandas">Модуль pandas</a>
<p>
Применяется для обработки и анализа табличных данных. В этой библиотеке используется numpy для удобного хранения данных и вычислений.
 <b>Установка:</b>
<pre>pip install pandas</pre>

<li> NumPy - работа с числовыми массивами<br>
<b>Установка:</b><br>
sudo apt-get install python3-numpy<br>
или<br>
sudo pip3 install numpy
<p>
<b>Функции:</b><br>
n.ndim - количество строк в двухмерном массиве<br>
n.shape - количество строк и столбцов в двухмерном массиве<br>
n.size - количество элементов в двухмерном массиве<br>
array() - создаёт массив<br>
linspace(start, end, количество чисел в интервале от start до end) - генерирует числа<br>
reshape(количество строк, коли-во столбцов) - превращает одномерный массив в двухмерный.
<p>
<i>Когда вы используете
from numpy import *
<p>
Это значит, что будут подключены все имеющиеся библиотеки питона. И это очень плохо. Во-первых, все это счастье грузится ну очень долго. А во-вторых, если среди ваших библиотек окажутся взаимоисключающие, т.е. разные библиотеки, но использующие одинаковые имена функций, то ваш питон начнет пестрить сообщениями об ошибках, поскольку он не будет знать из какой библиотеки ему использовать ту или иную функцию. Чтобы этого не происходило, забудьте про эту строку и подключайте только то, что вам действительно необходимо в работе.
<p>
Допустим, мы хотим pапустить код из примера:
<pre>
x = linspace(0, 5, 10)
y = x ** 2
print(x)
print(y)

figure()
plot(x, y, 'r')
xlabel('x')
ylabel('y')
title('title')
show()</pre>

в этом коде используется linspace из numpy и figure(), plot(), xlabel(), ylabel(), title(), show() из matplotlib. Понятно, что подключать ради них абсолютно все библиотеки крайне глупо. Как мы можем поступить в данном случае? Ну, вариантов у нас несколько:
<pre>
--- Вариант 1 ---
from numpy import *
from matplotlib.pyplot import *

x = linspace(0, 5, 10)
y = x ** 2
print(x)
print(y)

figure()
plot(x, y, 'r')
xlabel('x')
ylabel('y')
title('title')
show()

--- Вариант 2 ---
import numpy, matplotlib.pyplot

x = numpy.linspace(0, 5, 10)
y = x ** 2
print(x)
print(y)

matplotlib.pyplot.figure()
matplotlib.pyplot.plot(x, y, 'r')
matplotlib.pyplot.xlabel('x')
matplotlib.pyplot.ylabel('y')
matplotlib.pyplot.title('title')
matplotlib.pyplot.show()

--- Вариант 3 (второй вариант, но чуть короче) ---
import numpy as a
import matplotlib.pyplot as b

x = a.linspace(0, 5, 10)
y = x ** 2
print(x)
print(y)

b.figure()
b.plot(x, y, 'r')
b.xlabel('x')
b.ylabel('y')
b.title('title')
b.show()
</pre>
Можно отдельно каждую функцию импортировать и переименовать... ну и так далее. По большому счету все зависит от того как у вас настроено рабочее окружение питона, т.е. какие библиотеки у него прописаны, а какие установлены, но по каким-то причинам не попадают в поле зрения. Например, данный вариант будет работать на Ubuntu Linux 17.10, но заставить его работать в Slackware Linux окажется весьма не просто.</i>
<p>
<li> matplotlob - построение графиков<br>
Ссылки: <a href="https://stepik.org/lesson/7629/step/1?unit=1285">библиотека matplotlob</a><br>
<a href="https://stepik.org/lesson/196432/step/1?auth=registration&unit=172894">matplotlib</a>
<p>
<i>В чем разница между matplotlib и pylab? Что такое pylab?Почему вызываем его а не matplotlib?<br>
matplotlib - ﻿это пакет, pylab﻿ - ﻿библиотека из него.<br>
https://matplotlib.org/api/pyplot_api.html</i>
<p>
<i>Импорт рylab неявным образом импортирует все функции из numpy и matplotlib россыпью? Пояснять неплохо бы. Не лучшее решение, по-моему. Во-первых, не очевидно для новичков, во-вторых, пространство имен засоряется неимоверно. Там еще обе библиотеки как np и plt модули импортируются.
<p>
Лучше явно:<pre>
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(0, 5, 10)
y = x**2
plt.figure()
plt.plot(x, y, 'r')</pre>

...и так далее.</i>
<p>
<li> SciPy - функции для научных вычислений
<p>
<li> Scikit-learn - алгоритмы машинного обучения
<p>
<li> PythonSeaborn - визулизация статистических данных


</ol>





<h3><a href="https://pyplanet.ru/article/with-as.html">Конструкция with - as: менеджер контекста</a></h3>
<h3><a href="https://pyplanet.ru/article/magic-methods.html">Магические методы</a></h3>
<h3><a href="https://pyplanet.ru/article/pip.html">Пакетный менеджер pip</a></h3>






<h3 align=center><a href="https://intuit.ru/studies/courses/49/49/lecture/27080">Лекция 12: Создание приложений с графическим интерфейсом</a></h3>














</div>
<br><br><br><br><br></body></html>
