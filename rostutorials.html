<html><head>
<style>
.menu {
       height: 100%;
       width: 160px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  */color: #818181;
  display: block;
          }     
.content {
           margin-left: 170px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Перевод учебника</title>
<div class="menu">
<a href="index.html">Начальная</a><br>
<a href="ros_set.html">Установка / настройка ROS</a>
<a href="ros_message.html">Сообщения</a>
<a href="ros_service.html">Сервисы (services)</a>
<a href="ros_message.html">Сообщения</a>
<a href="rosparam.html">Сервер параметров (Parameter Server)</a>
<a href="ros_rqt.html">Графические утилиты</a>
<a href="ros_launch.html">Команда roslaunch</a>
<a href="ros_control.html">ROS Control</a>
<a href="ros_difficult.html">Средний уровень</a>
<a href="ros2.html">ROS2</a><br>
<a href="rviz.html">Rviz</a><br>
Перевод учебника:
<a href="#package">Создание пакета</a>
</div>
<div class="content">
Ссылка: <a href="https://wiki.ros.org/ru/ROS/Tutorials">Учебник по ROS</a></h3>
<h3 align=center><a name="package" href="http://wiki.ros.org/ROS/Tutorials/CreatingPackage">Создание пакетов</a></h3>
<ol>
<li> <h4>Что такое catkin пакет?</h4>
Чтобы catkin пакет считался таким, он должен иметь признаки:
 <ul>
  <li> пакет должен содержать файл package.xml
  <li> должен содержать файл  CMakeLists.txt
  <li> У каждого пакета должна быть своя собственная папка. Это означает, что нет ни вложенных пакетов, ни нескольких пакетов, использующих один и тот же каталог.
 </ul>
Пакет находится в каталоге src .
<p>
<li> <h4>Пакеты в catkin workspace</h4>
Обычный catkin workspace:<br>
<img src="./images/catkin_ws.png">
<p>
<li> Создание catkin-пакета.<br>
    Общий синтаксис команды создания пакета:<br>
    <font color="green">catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</font><br>
catkin_create_pkg требует, чтобы вы указали ему имя пакета и, возможно, список зависимостей, от которых зависит этот пакет.<br>
Пример:<br>
    <font color="green">cd ~/catkin_ws/src</font> переходим в каталог src<br>
    <font color="green">catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</font><br>
    <img src="./images/catkin_create_pkg.png"><br>
    Создаем пакет beginner_tutorials, который зависит от нод std_msgs, rospy и roscpp.В результате будет создана папка beginner_tutorials, содержащая файлы package.xml и CMakeLists.txt, которые были частично заполнены информацией, которую вы предоставили catkin_create_pkg.
<p>
<b>CMakeLists.txt</b> - файл сборки, где описано какие библиотеки добавлять в пакет, какие ноды входят в пакет.
<p>
<b>package.xml</b> - файл, где с помощью тегов описаны зависимости.
<p>
Еще стандартной папкой в пакете является папка <b>include</b>.
<p>
Папка <b>launch</b> содержит файлы.launch, которые позволяют запускать одновременно несколько нод либо одну ноду с какими-то параметрами.
<p>
<b>src</b> - папка, где лежат скрипты наших нод. Возможно будет папка scripts, выполняющая аналогичные функции.
<li><h3>Изменение рабочего пространства catkin (catkin workspace) с учетом нового пакета и исполнение setup файла</h3>
    <font color="green">cd ~/catkin_ws<br>
    catkin_make</font><br>
    После создания рабочей области в подпапке devel будет создана аналогичная структура, которую вы обычно находите в /opt/ros/noetic<br>
    Чтобы добавить переменные, нужно выполнить команду:<br>
    <font color="green">. ~/catkin_ws/devel/setup.bash</font>
<li><b>Пакетные зависимости:</b><br>
    <ul>
    <li> <b>Зависимости первого порядка</b><br>
            При использовании catkin_create_pkg ранее были предоставлены несколько зависимостей от пакетов. Эти зависимости первого порядка теперь можно просмотреть с помощью инструмента rospack:<br>
            <font color="green">rospack depends1 &lt;package_name&gt;</font><br>
           Выдаст список зависимостей, которые были установлены во время выполнения команды catkin_create_pkg. Эти зависимости хранятся в файле package.xml.<br>
        <img src="./images/rospack_depends1.png">
    <li> <b>Косвенные зависимости</b><br>
        Во многих случаях у зависимостей также будут свои собственные зависимости. Например, у rospy есть другие зависимости.<br>
        <img src="./images/rospack_depends2.png"><br>
        Пакет может иметь много косвенных зависимостей:<br>
        <font color="green">rospack depends &lt;package_name&gt;</font> - выведет все зависимости.
    <li> <b>Файл package.xml содержит:</b>
<ul>
<li>тег description<br>
    <img src="./images/description.png">
<li> тег maintainer<br>
    Это обязательный и важный тег для package.xml потому что он позволяет другим пользователям узнать, к кому обратиться по поводу пакета. Требуется как минимум один специалист по сопровождению, но вы можете нанять их много, если хотите. Имя сопровождающего указано в тексте тега, но также есть атрибут электронной почты, который необходимо заполнить<br>
    <img src="./images/maintainer.png">
<li> теги лицензий<br> Обязательный. Наиболее распространенными лицензиями с открытым исходным кодом являются BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1 и LGPLv3. Вы можете прочитать о некоторых из них в разделе Open Source Initiative. В этом руководстве мы будем использовать лицензию BSD, поскольку остальные компоненты core RODS уже используют ее
теги зависимостей<br>
<img src="./images/license.png">
<li> <b>теги зависимостей:</b><br>
Следующий набор тегов описывает зависимости вашего пакета. Зависимости разделены на:<br>
build_depend<br>
buildtool_depend<br>
exec_depend<br>
test_depend<br>
Более подробное объяснение этих тегов приведено в документации о зависимостях Catkin. Поскольку мы передали std_msgs, roscpp и rospy в качестве аргументов для catkin_create_pkg, зависимости будут выглядеть следующим образом:
<img src="./images/tag_depends.png">
<li> тег конца файла <b>&lt;/package&gt;</b>
</ul>
</ul>
</ol>


<h2 align=center>Создание publisher-ноды talker.cpp на языке C++ для пакета beginner_tutorials</h2>
<a href="https://github.com/ros/ros_tutorials/tree/noetic-devel/ros_tutorials">Репозиторий ROS, откуда берутся коды нод.</a>
<ol>
<li> Перейдем в каталог пакета: <b>roscd beginner_tutorials</b>
<li> Создадим внутри каталог src: <b>mkdir -p src</b><br>
Этот каталог будет содержать все исходные файлы (ноды) для нашего пакета beginner_tutorials.
<li> Внутри этого созданного каталога создадим файл talker.cpp, код скопируем с https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp:<br>
<b>nano src/talker.cpp</b><br>
<img src="./images/talker.cpp.png">
<p>
Разберем код по пунктам:
 <ol>
   <li> <img src="./images/ros.h.png"><br>
   ros/ros.h - это раздел, который включает в себя все заголовки, необходимые для использования наиболее распространенных элементов системы ROS.
   <li> <img src="./images/std_msgs.png"><br>
   включает в себя сообщение std_msgs/String, которое находится в пакете std_msgs. Это заголовок, автоматически генерируемый из файла String.msg в этом пакете.
 <li> <img src="./images/ros_init.png"><br>
 Инициализируем (вызываем) ROS. Позволяет ROS выполнять переназначение имен через командную строку - сейчас это не важно. Здесь мы также указываем имя нашего узла (ноды). Имена узлов должны быть уникальными в запущенной системе. Используемое имя должно быть базовым, т.е. в нем не может быть символа /.
 <li> <img src="./images/ros_handle.png"><br>
 NodeHandle является основной точкой доступа для обмена данными с системой ROS. Первый созданный NodeHandle полностью инициализирует этот узел, а последний уничтоженный NodeHandle закроет узел.
 <li> <img src="./images/publisher.png"><br>
 Сообщите мастеру ROS, что мы собираемся опубликовать сообщение типа std_msgs/String в топик chatter. Это позволяет мастеру сообщить любым узлам, прослушивающим chatter, что мы собираемся опубликовать данные в этот топик. Вторым аргументом является размер нашей очереди публикации. В этом случае, если мы публикуем слишком быстро, в буфере будет храниться максимум 1000 сообщений, прежде чем мы начнем выбрасывать старые.
 <li> <img src="./images/loop_rate.png"><br>
 Объект ros::Rate позволяет вам указать частоту, с которой вы хотели бы выполнять цикл. Он будет отслеживать, сколько времени прошло с момента последнего вызова функции Rate::sleep(), и будет находиться в режиме ожидания в течение необходимого периода времени. Сейчас мы говорим, что хотим работать на частоте 10 Гц.
 <li> <img src="./images/ros_ok.png"><br>
 По умолчанию roscpp установит обработчик SIGINT, который обеспечивает обработку Ctrl-C, что приведет к тому, что ros::ok() вернет значение false, если это произойдет.<br>
ros::ok() вернет значение false, если:
<ul>
<li> получено значение SIGINT (Ctrl-C)
<li> мы были отключены от сети другим узлом с таким же именем
<li> функция ros::shutdown() была вызвана другой частью приложения.
<li> все функции ros::Nodehandle были уничтожены
</ul>
Как только функция ros::ok() вернет значение false, все вызовы ROS завершатся ошибкой.
<li> <p><img src="./images/fill_messages.png"><br>
Мы передаем сообщение в ROS, используя класс, адаптированный для сообщений, который обычно генерируется из msg-файла. Возможны более сложные типы данных, но пока мы будем использовать стандартное строковое сообщение, которое состоит из одного элемента: "данные".
<li><p><img src="./images/chatter_pub.png"><br>
Функция publish() - это способ отправки сообщений. Параметр в скобках - это объект message. Тип этого объекта должен совпадать с типом, заданным в качестве параметра шаблона для вызова advertise().
<li><p><img src="./images/ros_console.png"><br>
ROS_INFO и friends - это наша замена printf/cout. Дополнительную информацию смотрите в <a hre="https://wiki.ros.org/rosconsole">документации rosconsole</a>.
<li><p><img src="./images/spin_once.png"><br>
Вызов ros::spinOnce() здесь не требуется для этой простой программы, потому что мы не получаем никаких обратных вызовов. Однако, если бы вы добавили подписку в это приложение и у вас не было бы функции ros::spinOnce(), ваши обратные вызовы никогда бы не были вызваны. Так что добавьте это для пущей убедительности.
<li><p><img src="./images/rate_sleep.png"><br>
Используем объект ros::Rate для перехода в спящий режим на оставшееся время, чтобы достичь скорости публикации 10 Гц.
 </ol>
 Краткая версия того, что делаем в talker.cpp:<br>
Инициализируем систему ROS<br>
Объявляем, что мы собираемся публиковать сообщения std_msgs/String в топик chatter для master ROS<br>
Цикл публикации сообщений в chatter выполняется 10 раз в секунду
</ol>



<h2 align=center>Создание ноды-подписчика listener.cpp на языке C++</h2>
<b>nano src/listener.cpp</b>
<br>Код скопировал с https://raw.githubusercontent.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp
<p>
Разбор кода по пунктам:
<ol>
<li><p><img src="./images/callback.png"><br>
Это функция обратного вызова callback(), которая будет вызываться при поступлении нового сообщения в топик chatter. Сообщение передается с помощью boost shared_ptr, что означает, что вы можете сохранить его, если хотите, не беспокоясь о том, что оно будет удалено под вами, и не копируя исходные данные.
<li><p><img src="./images/subskriber.png"><br>
Подписывается на топик chatter с мастером. ROS будет вызывать функцию chatterCallback() всякий раз, когда поступает новое сообщение. Второй аргумент - это размер очереди, на случай, если мы не сможем обрабатывать сообщения достаточно быстро. В этом случае, если очередь достигнет 1000 сообщений, мы начнем отбрасывать старые сообщения по мере поступления новых.
<p>
Функция NodeHandle::subscribe() возвращает объект ros::Subscriber, который вы должны сохранить, пока не захотите отказаться от подписки. Когда объект Подписчика будет уничтожен, он автоматически отпишется от темы chatter.
<p>
Существуют версии функции NodeHandle::subscribe(), которые позволяют указать функцию-член класса или даже что-либо, вызываемое с помощью Boost.Функциональный объект. Более подробная информация содержится в обзоре roscpp.
<li><p><img src="./images/ros_spin.png"><br>
функция ros::spin() переходит в цикл, вызывая обратные вызовы сообщений как можно быстрее. Но не волнуйтесь, если ей нечего делать, она не будет использовать много ресурсов процессора. функция ros::spin() завершит работу, как только функция ros::ok() вернет значение false, что означает, что функция ros::shutdown() была вызвана либо обработчиком Ctrl-C по умолчанию, либо мастером, сообщающим нам о завершении работы, либо вызвана вручную.
<p>
Существуют и другие способы обработки обратных вызовов, но мы не будем здесь о них беспокоиться. В пакете roscpp_tutorials есть несколько демонстрационных приложений, которые это демонстрируют. В обзоре roscpp также содержится дополнительная информация.
</ol>
Краткая версия того, что происходит в listener.cpp:<br>
Инициализируем систему ROS<br>
Подписываемся на топик chatter<br>
Запускаем, ожидая поступления сообщений<br>
Когда приходит сообщение, вызывается функция chatterCallback()
<h3>Building нод</h3>
<ol>
<li> Редактируем CMakeLists.txt, добавляем эти строки:<br>
<pre>
add_executable(talker src/talker.cpp)
target_link_libraries(talker ${catkin_LIBRARIES})
add_dependencies(talker beginner_tutorials_generate_messages_cpp)

add_executable(listener src/listener.cpp)
target_link_libraries(listener ${catkin_LIBRARIES})
add_dependencies(listener beginner_tutorials_generate_messages_cpp)
</pre>
<p>
Это создаст два исполняемых файла, talker и listener, которые по умолчанию будут помещены в каталог пакетов вашего пространства разработки, расположенный по умолчанию по адресу ~/catkin_ws/devel/lib/&lt;package name&gt;.
<p>
Строка из CMakeLists.txt: <b>add_dependencies(talker beginner_tutorials_generate_messages_cpp)</b> гарантирует, что заголовки сообщений (Headers) этого пакета будут сгенерированы перед использованием. Если вы используете сообщения из других пакетов в своем рабочем пространстве catkin, вам также необходимо добавить зависимости к их соответствующим целям генерации, поскольку catkin создает все проекты параллельно. Начиная с *Groovy*, вы можете использовать следующую переменную для определения всех необходимых целей:<br>
<b>target_link_libraries(talker ${catkin_LIBRARIES})</b>
<p>
Переформируем наши пакеты настройки:<br>
<font color=green>cd ~/catkin_ws<br>
catkin_make</font>



<h2 align=center>Написание простых Publisher and Subscriber на Python</h2>
<h3>Создадим узел (ноду) publisher ("talker"), который будет постоянно транслировать сообщение.</h3>
<ol>
<li> <b>roscd beginner_tutorials</b><br>
Создадим папку scripts, которая будет хранить файлы.py<br>
<b>mkdir scripts</b><br>
В эту папку скачаем готовый talker.py из гитхаба:<br>
<b>wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/talker.py</b><br>
Сделаем его исполняемым:<br>
<b>chmod +x talker.py</b>
<p>
<img src="images/rostutorials.png">
<p>
Код talker.py:
<p>
<img src="./images/code_talker.png">
<p>Разъяснение кода:
<ul>
<li> <b>#!/usr/bin/env python</b> с этой строки начинается каждая нода (скрипт) на python.</li>
<li><p><img src="./images/rospy.png"><br>
Вам необходимо импортировать rospy, если вы пишете ROS-узел. Импорт std_msgs.msg необходим для того, чтобы мы могли повторно использовать тип сообщения std_msgs/String (простой строковый контейнер) для публикации.</li>
<li><p><img src="./images/pub_rospy.png"><br>
Этот раздел кода определяет интерфейс talker для остальной части ROS. pub = rospy.Издатель("chatter", String, queue_size=10) объявляет, что ваш узел публикует в топике chatter, используя тип сообщения String. String здесь на самом деле является классом std_msgs.msg.String. Аргумент queue_size является новым в ROS hydro и ограничивает количество сообщений в очереди, если какой-либо подписчик не получает их достаточно быстро. В старых дистрибутивах ROS этот аргумент просто не используется.
<p>
Следующая строка, rospy.init_node(NAME, ...), очень важна, поскольку она сообщает rospy имя вашего узла - пока у rospy не будет этой информации, он не сможет начать взаимодействие с мастером ROS. В этом случае ваш узел получит имя talker. ПРИМЕЧАНИЕ: имя должно быть базовым, т.е. оно не должно содержать никаких косых черт "/".
<p>
anonymous = True гарантирует, что ваш узел будет иметь уникальное имя, добавляя случайные числа в конец имени. Обратитесь к разделу Инициализация и завершение работы - Инициализация вашего узла ROS в документации rospy для получения дополнительной информации о параметрах инициализации узла.
<li><p><img src="./images/rate_rospy.png"><br>
Эта строка создает объект Rate rate. С помощью своего метода sleep() он предлагает удобный способ зацикливания с желаемой скоростью. С его аргументом 10 мы должны ожидать, что цикл будет выполняться 10 раз в секунду (до тех пор, пока наше время обработки не превысит 1/10 секунды!).
<li><p><img src="./images/whail_not.png"><br>
Этот цикл представляет собой довольно стандартную конструкцию rospy: проверка флага rospy.is_shutdown() и последующее выполнение работы. Вы должны проверить is_shutdown(), чтобы проверить, должна ли ваша программа завершаться (например, при наличии комбинации клавиш Ctrl-C или иным образом). В данном случае "работа" - это вызов pub.publish(hello_str), который публикует строку в нашей теме chatter. Цикл вызывает функцию rate.sleep(), которая находится в режиме ожидания, достаточном для поддержания желаемой скорости в цикле.
<p>
(Вы также можете столкнуться с функцией rospy.sleep(), которая похожа на функцию time.sleep(), за исключением того, что она также работает с имитируемым временем (см. Часы).)
<p>
Этот цикл также вызывает rospy.loginfo(str), который выполняет тройную функцию: сообщения выводятся на экран, записываются в файл журнала узла и записываются в rosout. rosout - это удобный инструмент для отладки: вы можете извлекать сообщения с помощью rqt_console вместо того, чтобы искать окно консоли с выводом вашего узла.
<p>
std_msgs.msg.String - это очень простой тип сообщения, поэтому вам может быть интересно, как выглядит публикация более сложных типов. Общее правило заключается в том, что аргументы конструктора располагаются в том же порядке, что и в файле .msg. Вы также можете не вводить никаких аргументов и инициализировать поля напрямую, например:<br>
<b>msg = String()<br>
msg.data = str</b><br>
или же вы можете инициализировать некоторые поля, а для остальных оставить значения по умолчанию:<br>
<b>String(data=str)</b>
<li><p><img src="./images/try_pass.png"><br>
В дополнение к стандартной проверке Python __main__check, при этом обнаруживается ошибка rospy.Исключение ROSInterruptException, которое может быть вызвано методами rospy.sleep() и rospy.Rate.sleep() при нажатии Ctrl-C или при выключении вашего узла иным образом. Причина, по которой возникает это исключение, заключается в том, что вы случайно не продолжаете выполнение кода после sleep().
</ul>

<li> В CMakeLists.txt добавить строки:
<p><pre>
catkin_install_python(PROGRAMS scripts/talker.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
</pre>
</ol>
<h3>Написание ноды subscriber:</h3>
<ul>
<li>
<ul>
<li> roscd beginner_tutorials/scripts/
<li> wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/listener.py
<li> chmod +x listener.py
</ul>
<img src="./images/rostutorials1.png">
<li><p>
Код:
<br><img src="./images/code_listener.png">
<li><p>
В CMakeLists.txt добавляем строки:
<p>
<pre>
catkin_install_python(PROGRAMS scripts/talker.py scripts/listener.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
</pre>
<li><p><img src="./images/rospy_init.png"><br>
Это означает, что ваш узел подписан на тему chatter, которая имеет тип std_msgs.msgs.Строка. При получении новых сообщений вызывается обратный вызов с этим сообщением в качестве первого аргумента.
<p>
Мы также немного изменили вызов rospy.init_node(). Мы добавили аргумент ключевого слова anonymous=True. ROS требует, чтобы у каждого узла было уникальное имя. Если появляется узел с таким же именем, он повторяет предыдущий. Это значит, что неисправные узлы могут легко быть выкинут из сети. Анонимные=флаг True рассказывает rospy чтобы создать уникальное имя для узла, так что вы можете иметь несколько узлов listener.py легко работать.
<p>
Последнее дополнение: функция rospy.spin() просто не позволяет вашему узлу завершать работу до тех пор, пока он не будет выключен. В отличие от roscpp, функция rospy.spin() не влияет на функции обратного вызова абонента, поскольку у них есть свои собственные потоки.
<li>Мы используем CMake в качестве нашей системы сборки, и, да, вы должны использовать ее даже для узлов Python. Это необходимо для того, чтобы убедиться, что автоматически сгенерированный код Python для сообщений и служб создан.
<br>Перейдите в свое рабочее пространство catkin и запустите catkin_make:<br>
<b>cd ~/catkin_ws<br>
catkin_make</b>
</ul>


<h2 align=center><a href="https://wiki.ros.org/ROS/Tutorials/ExaminingPublisherSubscriber">Выполнение publisher</a></h2>
Первой командой вызовем мастера:<br>
<b>roscore</b><br>
Еесли вы используете catkin, убедитесь, что у вас есть исходный код для вашего рабочего пространства setup.sh файл после вызова catkin_make, но перед выполнением нашего публишера:<br>
<b>cd ~/catkin_ws<br>
source ./devel/setup.bash</b><br>
Выполним нашего созданного публишера на python:<br>
<b>rosrun beginner_tutorials talker.py</b><br>
или <b>rosrun beginner_tutorials talker</b> (C++)<br>
Работает:<br>
<img src="./images/hello_world.png">
<h3 align=center><a href="https://wiki.ros.org/ROS/Tutorials/ExaminingPublisherSubscriber">Теперь выполнение подписчика listener.py</a></h3>
<b>rosrun beginner_tutorials listener.py</b> или <b>rosrun beginner_tutorials listener</b> на языке C++<br>
Работает.


<h2 align=center>Recording data (creating a bag file) Запись данных (создание bag файла)</h2>
В этом разделе руководства вы узнаете, как записывать данные по топикам из запущенной системы ROS. Данные по топикам будут накапливаться в файле bag.
<p>
Сначала выполните следующие команды в отдельных терминалах:
<br>
<b>roscore</b> - первый терминал<br>
2 терминал - <b>rosrun turtlesim turtlesim_node</b><br>
3 терминал - <b>rosrun turtlesim turtle_teleop_key</b>
<p>
Это запустит два узла - визуализатор turtlesim и узел turtle_teleop_key, который позволяет управлять turtlesim с клавиатуры с помощью клавиш со стрелками на клавиатуре.
<p>
<b>rostopic list -v</b> - в 4 терминале, выведем список запущенных в данный момент топиков.<br>
<img src="./images/rostopic_list_v.png"><br>
Список published (публикуемых) топиков - это единственные типы сообщений, которые потенциально могут быть занесены в файл журнала данных, поскольку в журнал записываются только публикуемые сообщения. Топик /turtle 1/cmd_vel - это командное сообщение, опубликованное teleop_turtle, которое принимается в качестве входных данных программой turtlesim. Сообщения /turtle1/color_sensor и /turtle1/pose являются выходными сообщениями, опубликованными turtlesim.
<p>
Теперь мы запишем публикуемые данные. Откройте новое окно терминала. В этом окне выполните следующие команды:<br>
<b>mkdir ~/bagfiles<br>
cd ~/bagfiles<br>
rosbag record -a</b><br>
<img src="./images/rosbag.png"><br>
Создаем временный каталог для записи данных, а затем запускаем rosbag record с параметром -a, указывающим, что все публикуемые топики должны быть собраны в файле bag.
<p>
Примерно 10 секунд двигаем черепаху.<br>
В окне, где запустили rosbag нажать Ctrl-C. Теперь изучите содержимое каталога ~/bagfiles. Должны увидеть файл с именем, которое начинается с года, даты и времени и суффикса .bag. Это файл пакета, содержащий все топики, опубликованные любым узлом за время работы rosbag record.<br>
еперь, когда мы записали файл bag с помощью rosbag record, мы можем просмотреть его и воспроизвести с помощью команд rosbag info и rosbag play. Сначала мы посмотрим, что записано в файле bag. Мы можем выполнить команду info - эта команда проверяет содержимое файла bag без его воспроизведения. Выполните следующую команду из каталога файлов bag:<br>
<font color=green>rosbag info &lt;your bagfile&gt;</font>
<p>
<img src="./images/rosbag_info.png">
<p>
Следующим шагом в этом руководстве будет воспроизведение файла bag, чтобы воспроизвести поведение в запущенной системе. Сначала завершите работу программы teleop, которая, возможно, все еще запущена из предыдущего раздела - нажмите Ctrl-C в терминале, где вы запустили turtle_teleop_key. Оставьте turtlesim запущенным. В окне терминала запустите следующую команду в каталоге, из которого смотрели инфо о бэгфайле:<br>
<font color=green>rosbag play &lt;your bagfile&gt;</font>
<p>
<img src="./images/rosbag_play.png">
<p>
В режиме по умолчанию rosbag play будет ждать в течение определенного периода времени (0,2 секунды) после объявления каждого сообщения, прежде чем начнет публиковать содержимое файла пакета. Некоторое время ожидания позволяет любому подписчику сообщения получать уведомления о том, что сообщение было объявлено и что за ним могут последовать другие сообщения. Если rosbag play публикует сообщения сразу после публикации рекламы, подписчики могут не получить первые несколько опубликованных сообщений. Период ожидания можно указать с помощью параметра -d.
<p>
В конечном итоге тема /turtle 1/cmd_vel будет опубликована, и черепаха должна начать перемещаться в turtlesim по схеме, аналогичной той, которую вы выполнили из программы teleop. Время между запуском rosbag play и перемещением черепашки должно быть примерно равно времени между запуском оригинальной записи rosbag и вводом команд с клавиатуры в начальной части руководства. Вы можете сделать так, чтобы воспроизведение rosbag не начиналось с начала файла bag, а начиналось на некоторое время позже начала, используя аргумент -s. Последним параметром, который может представлять интерес, является параметр -r, который позволяет вам изменять скорость публикации на определенный коэффициент. Если вы выполните:<br>
<b>rosbag play -r 2 &lt;your bagfile&gt;</b><br>
вы должны увидеть, как черепаха совершает несколько иную траекторию - это траектория, которая получилась бы, если бы вы вводили команды с клавиатуры в два раза быстрее.

<h3 align=center>Запись подмножества данных</h3>
При запуске сложной системы, такой как программный комплекс pr2, могут публиковаться сотни разделов, а в некоторых разделах, таких как потоки изображений с камер, потенциально публикуются огромные объемы данных. В такой системе часто нецелесообразно записывать лог-файлы, содержащие все темы, на диск в виде одного файла bag. Команда rosbag record поддерживает запись только определенных тем в файл bag, позволяя пользователям записывать только те темы, которые их интересуют.
<p>
Если какие-либо узлы turtlesim запущены, закройте их и перезапустите файл запуска keyboard teleop:<br>
<b>rosrun turtlesim turtlesim_node<br>
rosrun turtlesim turtle_teleop_key</b><br>
В вашем каталоге bagfiles выполните следующую команду:<br>
<b>rosbag record -O subset /turtle1/cmd_vel /turtle1/pose</b>
<p>
<img src="./images/rosbag_subset.png">
<p>
Аргумент -O указывает rosbag record на доступ к файлу с именем subset.bag, а аргументы topic указывают на то, что rosbag record подписывается только на эти две темы. Перемещайте черепашку в течение нескольких секунд, используя команды со стрелками на клавиатуре, а затем нажмите Ctrl-C на записи rosbag.<p>
Теперь проверьте содержимое файла bag (rosbag info subset.bag). Вы должны увидеть что-то вроде этого, только с указанными темами: <b>rosbag info subset.bag</b>
<p>
<img src="./images/rosbag_info_subnet.png">


<h2 align=center>Чтение сообщений из bag файла</h2>
Ссылки: <a href="https://habr.com/ru/articles/393811/">ROS на Raspberry Pi: Использование rosbag для сохранения данных топиков</a><br>
<a href="https://wiki.ros.org/ROS/Tutorials/reading%20msgs%20from%20a%20bag%20file">Reading messages from a bag file</a>
<p>
Предполагая, что вы используете систему с уже запущенным ROS, вот быстрая команда для записи 30-секундного фрагмента данных в файл пакета только для интересующих вас тем, например: /topic1, /topic2 и /topic3. Поскольку мы устанавливаем продолжительность в 30 секунд, по истечении этого времени запись автоматически остановится:<br>
<b>rosbag record --duration=30 --output-name=/tmp/mybagfile.bag \<br>
    /topic1 /topic2 /topic3</b><br>
<p>
Остальная часть этого руководства будет выполнена при условии, что скачали с помощью команды:<br>
<b>wget https://open-source-webviz-ui.s3.amazonaws.com/demo.bag</b><br>
<font color=red>У меня не удаётся скачать, выдаёт ошибку 403</font>
<p>
 У вас будет два варианта чтения/извлечения сообщений из файла bag.
<p>
<i>Обратите внимание, что в любой из приведенных ниже команд команда time добавляется перед началом просто потому, что она выводит время выполнения каждой команды, а поскольку иногда эти команды могут занимать много времени, полезно использовать команду time, чтобы получить представление о том, сколько времени должна занять данная команда. Если вы не хотите его использовать, вы можете удалить временную часть любой из приведенных ниже команд.</i>
<h3>Вариант 1: немедленно воспроизвести сообщения и просмотреть выходные данные на нескольких терминалах.</h3>
Вам нужно знать точные названия тем, которые вы хотели бы прочитать в файле bag. Итак, давайте посмотрим, что находится в файле bag. В любом терминале вручную проверьте все опубликованные темы и количество сообщений, опубликованных в каждой теме, с помощью этой команды:<br>
<b>time rosbag info /tmp/mybagfile.bag</b><br>  
или если знаете имена нужных топиков:<br>
<b>time rosbag info /tmp/mybagfile.bag | grep -E "(topic1|topic2|topic3)"</b>
<p>
<img src="./images/rostutorials4.png">

<h3 align=center>Вариант 2: используем скрипт ros_readbagfile, чтобы извлечь интересующие темы</h3>
<b>Установка команды ros_readbagfile:</b>
<ul>
<li> Скачал <b>wget https://raw.githubusercontent.com/ElectricRCAircraftGuy/eRCaGuy_dotfiles/master/useful_scripts/ros_readbagfile.py</b>
<li> Выполнил: <b>chmod +x ros_readbagfile.py</b>
<li> Убедититься, что есть каталог ~/bin для личных двоичных файлов: <b>mkdir -p ~/bin</b>
<li> Переместить этот файл в ~/bin: <b>mv ros_readbagfile.py ~/bin/ros_readbagfile</b>
<li> Переустановите свой файл ~/.profile, чтобы убедиться, что ~/bin находится на вашем пути и вы можете использовать эту новую команду `ros_readbag file`, которую вы только что установили.<br>
Команда: <b>. ~/.profile</b><br>
Выполнил.
<li> Установка python-зависимостей:<br>
<b>sudo apt install python3-rosbag</b><br>
<b>ln -si "${PWD}/ros_readbagfile.py" ~/bin/gs_ros_readbagfile<br>
ln -si "${PWD}/ros_readbagfile.py" ~/bin/ros_readbagfile<br>
. ~/.profile</b><br>
Теперь можем выполнять команды: `gs_ros_readbagfile` или `ros_readbagfile`
<p>
Примечание: если ваш терминал по-прежнему сообщает, что не может найти команду при попытке ее запуска, возможно, вам потребуется убедиться, что ~/bin является частью вашей переменной PATH.
</ul>

<b>Работа с командой ros_readbagfile.py:</b><br>
Использовать команду буду на bag.файле /home/dmitriy/bagfiles/2024-07-21-19-21-13.bag
<ul>
<li> Определим точные имена тем, которые вы хотели бы прочитать в файле bag:<br>
<b>time rosbag info 2024-07-21-19-21-13.bag</b><br> 
<img src="./images/rosbag_info_file.png">
<li> Общий синтаксис команды readbagfile:<br>
<font color=green>time ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...]</font><br>
Выведу только 1 топик /turtle1/cmd_vel:<br>
<b>time ros_readbagfile 2024-07-21-19-21-13.bag /turtle1/cmd_vel</b><br>
<li> Запишем сообщения 2024-07-21-19-21-13.bag /turtle1/cmd_vel в файл topics.yaml без вывода в терминал:<br>
<b>time ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...] > topics.yaml</b><br>
<img src="images/rostutorials2.png">
<p>
 Если хотим одновременно записывать в файл и выводить на экран, то использовать команду такого формата:
 <p>
<font color=green>time ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...] | tee topics.yaml</font>
<p>
<img src="images/rostutorials3.png">
<p>
При желании, чтобы увидеть "прогресс", наблюдая, как увеличивается размер файла yaml, в новом терминале запустить команду:<br>
<b>watch -n 1 'du -sk topics.yaml | awk '\''{printf "%.3f MiB %s\n", $1/1024, $2}'\'''</b>
<p>
Теперь просмотрите topics.yaml в вашем предпочтительном текстовом редакторе, чтобы просмотреть все сообщения, извлеченные из файла bag.
<h3 align=center>Анализ topics.yaml</h3>
Имеем файл topics.yaml, созданный на основе файла.bag. Теперь научимся извлекать из него нужную нам информацию.<br>
Для начала установим: <b>sudo apt update && sudo apt install ripgrep</b>
<p>
Допустим хотим найти список всех ключевых элементов, которые начинаются с "piksi_". Вы можете сделать это, выполнив поиск по строке "ключ: "piksi_" следующим образом:<br>
<b>time rg 'key: "piksi_' topics.yaml | sort -V | awk '!seen[$0]++'</b><br>
Часть rg 'key: "piksi_" topics.yaml выполняет поиск в текстовом файле "topics.yaml" строки : "piksi_",<br>
 часть sort -V сортирует все выходные строки,<br>
  а часть awk '!seen[$0]++" удаляет повторяющиеся записи, так что вы видите только одну строку каждого совпадения.
<p>
Другое применение:<br>
Давайте выполним поиск по всем ключевым элементам данных, которые начинаются с "GPS", "Duration" или "Minimum". Поиск по регулярным выражениям типа "OR" выполняется в общем формате: (str1|str2|str3|и т.д.), где | в данном случае читается как "or". Итак, поиск "GPS", "Duration" или "Minimum" может быть выполнен с помощью следующей строки поиска по регулярному выражению:<br>
'(key: "GPS|key: "Duration|key: "Minimum)'.<br>
Команда: <b>time rg '(key: "GPS|key: "Duration|key: "Minimum)' topics.yaml | sort -V | awk '!seen[$0]++'</b>
<p>
<h3 align=center>Зачем использовать для этой цели "ros_readbag file" вместо `rostopic echo -b`?</h3>
<ul>
<li> Потому что rostopic работает очень медленно! Например, выполнение этой команды на быстродействующем компьютере (4-ядерный/8-поточный Pentium i7 с SSD-накопителем m.2) занимает 11,5 минут для чтения файла bag объемом 18 ГБ!<br>
Однако скрипту ros_readbagfile требуется всего 1 минута 37 секунд на том же компьютере, чтобы прочитать ту же тему из того же файла bag объемом 18 ГБ! Таким образом, ros_readbagfile работает в 11,5/(1+37/60) = ~в 7 раз быстрее!
<li> Потому что rostopic может одновременно читать только одну тему, в то время как ros_readbagfile может читать любое количество тем одновременно!
</ul>
<pre>



</pre></div></body></html>
