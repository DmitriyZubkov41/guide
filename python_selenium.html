<html><head>
<style>
.menu {
       height: 100%;
       width: 150px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 150px; /* То же, что и ширина боковой панели */
           padding: 0px 0px 0px 16px;
           h2 {
               color: brown;
              }
           h3 {
               color: green;
              }
         }
</style>
</head><body>
<title>Пакет Selenium</title>
<div class="menu">
<a href="index.html">Начальная</a>
<a href="python_base.html">Основы</a>
<a href="python_collection.html">Коллекции</a>
<a href="python_library.html">Библиотеки</a>
<a href="python_parsing.html">Парсинг</a>
<a href="python_example_file.html">Примеры с файлами</a><br>
&nbsp;&nbsp;&nbsp;&nbsp; Selenium:
<a href="#webdriver">WebDriver</a>
<a href="#search">Поиск элемента</a>
<a href="#wevelement">WebElement</a>
<a href="#options">ChromeOptions</a>
<a href="#metod">Методы selenium</h3>
<a href="#cook"><font color=brown>Работа с cookies</font></a>
<a href="#scrolling">Прокрутка страниц</a>
<a href="#scroll_script">&nbsp;&nbsp;&nbsp; execute_script()</a>
<a href="#scroll_keys">&nbsp;&nbsp;&nbsp; Keys</a>
<a href="#actionchains">ActionChains</a>
<a href="#vkladka">Работа с вкладками</a>
<a href="#size">Размеры окна</a>
<a href="#wait">Явное и неявное ожидание</h3>
<a href="#title">Ожидание заголовка</a>
<a href="#display">Видимость элементов</a>
<a href="#check">Проверка текста</a>
<a href="#alert">Ожидание окон</a>
<a href="#drop">Drag and Drop (перетаскивание)</a>
</div>

<div class="content">
<a name="selenium"><h2 align=center>Пакет Selenium</h3>
Ссылки: <a href="https://sky.pro/wiki/python/avtomatizaciya-veb-testirovaniya-s-selenium/">Автоматизация веб-тестирования с Selenium</a><br>
Курс <a href="https://stepik.org/course/119495">Selenium Python</a>
<p>
Selenium всегда используется как запасной вариант, когда никакие другие методы не помогают. Это связано с тем, что библиотека запускает полноценный браузер — это расходует больше времени и ресурсов.
<p>
Рассмотрим, в каких случаях использование эмуляции браузера будет оправдано:
<ul>
<li> Сложная навигация. Если контент появляется только после серии кликов или скроллов.
<p> 
<li> Интерактивность. Необходимо выполнить вход в личный кабинет, ввести CAPTCHA (или обойти ее), заполнить форму и так далее.
<p>
<li> Точность. Если нужно получить данные в той же форме, в которой их видит реальный пользователь — чтобы не собирать данные частями по запросам во вкладке Network.
</ul>
<p>
Также предпочтительны сценарии, когда Selenium используется только для авторизации и последующего получения куки-файлов. Сами запросы в таком случае выполняются без эмуляции браузера, через библиотеку requests. Это значительно сократит потребление ресурсов.
<h4 align=center>Установка и настройка Selenium</h4>
Для начала работы с Selenium необходимо установить несколько компонентов. Рассмотрим установку на примере языка Python.
<p>
<b>Установка Python и pip</b><br>
Если у вас еще не установлен Python, скачайте и установите его с официального сайта. Убедитесь, что во время установки вы отметили опцию "Add Python to PATH". Это позволит вам запускать Python и pip из командной строки.
<p>
После установки Python, установите менеджер пакетов pip, если он еще не установлен. Обычно он идет в комплекте с Python, но если по каким-то причинам его нет, вы можете установить его вручную, следуя инструкциям на официальном сайте pip.
<p>
<b>Установка Selenium</b><br>
Для установки Selenium используйте команду pip:
<pre>
pip install selenium
</pre>
У меня во время установки (24.03.2025):
<pre>
<font color=red>ERROR: mu-editor 1.2.0 has requirement click<=8.0.4, but you'll have click 8.1.8 which is incompatible.</font>
</pre> 
Убедиться, что установка прошла успешно, запустив Python и импортировав Selenium:
<pre>
import selenium
print(selenium.__version__)
</pre>
Я проверил по-другому, попроще:
<pre>
pip show selenium

Вывод:
Name: selenium
<b>Version: 4.27.1</b>
Summary: Official Python bindings for Selenium WebDriver
Home-page: https://www.selenium.dev
Author: None
Author-email: None
License: Apache 2.0
Location: /home/dmitriy/.local/lib/python3.8/site-packages
Requires: typing-extensions, urllib3, websocket-client, trio-websocket, trio, certifi
Required-by:
</pre>
Ссылки: <a href="https://timeweb.cloud/tutorials/python/selenium-parsing-dinamicheskih-sajtov">Парсинг динамических сайтов при помощи Python и Selenium</a>
<p>
В семейство Selenium входят такие вещи как:
<ul>
<li> Selenium RC – это предыдущая версия библиотеки для управления браузерами.
<li> Selenium Server – это сервер, который позволяет управлять браузером с удалённой машины, по сети.
<li> Selenium Grid – это кластер, состоящий из нескольких Selenium-серверов.
<li> Selenium IDE – плагин к браузеру Firefox, который может записывать действия пользователя.
<li> Selenium WebDriver — библиотека для управления браузерами.
</ul>
<a name="webdriver"><h3 align=center>WebDriver</h3>
Главная составляющая Selenium — это <b>WebDriver</b>, который взаимодействует с движком конкретного браузера (Chrome, Firefox, Edge и другими).<br>
Принцип работы следующий:
<ol>
<li> Ваш скрипт на Python отправляет команды WebDriver (вроде «открой URL», «нажми на элемент» и т.д.).
<p>
<li> WebDriver передает эти команды соответствующему драйверу (например, chromedriver).
<p>
<li> Драйвер уже напрямую управляет браузером, совершая запрашиваемые действия.
</ol>
<h4 align=center>Установка веб-драйвера</h4>
Начиная с версии 4.6 в selenium установлен встроенный Selenium Manager, который автоматически загружает подходящую версию драйвера. Но например я хотел парсить в браузере яндекс-браузер, для него надо скачивать вебдрайвер и встраивать его в коде скрипта.
<p>
Если нужно по каким-то причинам скачивать драйвер, то для работы с Chrome необходимо скачать ChromeDriver с официального сайта. Аналогично, для Firefox используется GeckoDriver, который можно скачать с официального сайта.
<p>
После скачивания распакуйте файл и добавьте его в системный PATH. Это позволит Selenium автоматически находить драйвер и использовать его для запуска браузера.
<p>
<h4 align=center>Как я устанавливал вебдрайвер для яндекс-браузера</h4>
На https://github.com/yandex/YandexDriver/releases скачал yandexdriver-25.2.1.799-linux.zip (последний релиз 25.2.1-stable на 24.03.2025). Ниже еще были ссылки: Source code (zip) и (tar.gz) , непонятно для чего. Скачал только по верхней ссылке, распаковал. Вытащенный yandexdriver перетащил в python . Далее добавляю путь в PATH:
<pre>
export PATH="/home/dmitriy/python:$PATH"
</pre>
Чтобы изменения вступили в силу, вам нужно будет запустить .bashrc или выйти из системы/войти в неё (или перезапустить терминал). Чтобы запустить .bashrc, просто введите:
<pre>
source ~/.bashrc
</pre>
<font color=red>Выполнил все эти шаги, но почему-то /home/dmitriy/python не появился в PATH</font>, тогда перетащил драйвер в ~/bin, благо этот каталог есть в PATH.<br>
<i>На странице https://www.selenium.dev/documentation/webdriver/troubleshooting/errors/driver_location/ сказано как добавить каталог в PATH, но решил не менять ~/bin.</i>
<p>
Код скрипта взял из https://ru.stackoverflow.com/questions/1537956/selenium-с-Яндекс-браузером-не-удается-запустить:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from selenium import webdriver
from selenium.webdriver.chrome.service import Service

options = webdriver.ChromeOptions()

#binary_yandex_driver_file = '/home/dmitriy/bin/yandexdriver.exe' # в Windows
binary_yandex_driver_file = '/home/dmitriy/bin/yandexdriver'

service = webdriver.chrome.service.Service(executable_path=binary_yandex_driver_file) #v4.10+
#service = webdriver.ChromeService(executable_path=binary_yandex_driver_file)           #v4.11+ 

driver = webdriver.Chrome(service=service, options=options)
driver.get('https://yandex.ru')
while True:
    pass
</pre></td></tr></table>
<p>
yandexdriver.exe работает в системах Windows, в Linux нужно использовать yandexdriver.
<p>
Возникла ошибка с разрешением на выполнение, проверил, файл yandexdriver был не исполняемым, сделал исполняемым: chmod +x yandexdriver
<p>
Запускаю скрипт: python3 test1.py
<p>
Вывод:
<pre>
selenium.common.exceptions.SessionNotCreatedException: Message: session not created:
 This version of ChromeDriver only supports Chrome version 132
Current browser version is 134.0.6998.165 with binary path /opt/google/chrome/chrome
</pre>
<p>
Удалил хром: sudo apt-get remove google-chrome-stable<br>
Далее пытаюсь установить версию 132:
По ссылке https://www.ubuntuupdates.org/package/google_chrome/stable/main/base/google-chrome-stable смотрю номера релизов, копирую нужный и вставляю в шаблонную строку установки хрома:
<pre>
wget http://dl.google.com/linux/chrome/deb/pool/main/g/google-chrome-stable/<b>google-chrome-stable_132.0.6834.83-1_amd64.deb</b>
sudo apt install ./google-chrome-stable_132.0.6834.83-1_amd64.deb -y
</pre>
Проверяю установку: pip show chrome<br>
Странно: WARNING: Package(s) not found: chrome<br>
Тогда открываю браузер и в нем смотрю версию:<br>
Версия 132.0.6834.83 (Официальная сборка), (64 бит)<br>
Отлично, то что нужно.
<p>
Запускаю скрипт.<br>
<font color=red size=5>Открылся хром-браузер.</font> Что дальше делать, не знаю.
<p>
Помогли в Степике:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.chrome.options import Options

# pip install webdriver-manager
from webdriver_manager.chrome import ChromeDriverManager

# Путь к Yandex Browser
YANDEX_BROWSER_PATH = "/opt/yandex/browser/yandex-browser"

# Настройки
options = Options()
options.binary_location = YANDEX_BROWSER_PATH  # 👈 Указываем путь к браузеру

# WebDriver Manager сам подберет и установит нужный ChromeDriver
service = Service(ChromeDriverManager().install())

# Создаем WebDriver
driver = webdriver.Chrome(service=service, options=options)

driver.get('https://yandex.ru')
</pre></td></tr></table>
<p>
Понадобилось установить webdriver-manager:
<pre>
pip install webdriver-manager
</pre>
и после этого <font color=green size=5>яндекс-браузер открылся</font><br>
Проблема решена.
<p>
<h4>Написание простого теста с использованием Selenium</h4>
Теперь, когда мы установили и настроили Selenium, давайте напишем простой тест. Этот тест будет открывать страницу Google, вводить запрос в поисковую строку и нажимать кнопку поиска.
<p>
Пример кода:
<pre>
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

# Инициализация веб-драйвера
driver = webdriver.Chrome()

# Открытие страницы Google
driver.get("https://www.google.com")

# Поиск элемента по имени и ввод текста
search_box = driver.find_element_by_name("q")
search_box.send_keys("Selenium")
search_box.send_keys(Keys.RETURN)

# Закрытие браузера
driver.quit()
</pre>
Этот код демонстрирует основные шаги для автоматизации теста: инициализация веб-драйвера, открытие веб-страницы, поиск элемента, взаимодействие с элементом и закрытие браузера. Вы можете расширить этот тест, добавив проверки результатов поиска или автоматизировав другие действия на странице.
<p>
Пример создания экземпляра WebDriver для Google Chrome:
<pre>
from selenium import webdriver

browser = webdriver.Chrome()
browser.get("http://example.com")
</pre>
<p>
<b>WebElement</b><br>
это элемент на веб-странице, с которым Selenium может взаимодействовать. Это может быть кнопка, ссылка, текстовое поле и любой другой элемент на странице. Каждый WebElement обладает методами для взаимодействия, такими как клик click(), ввод текста send_keys(), получение текста элемента text и многими другими.<br>
Пример взаимодействия с WebElement:
<pre>
element = browser.find_element(By.ID, 'q')  # Находим элемент по его имени
element.send_keys('Selenium')               # Вводим текст в текстовое поле
element.submit()                            # Отправляем форму
</pre>
<p>
<b>Класс By</b><br>
By - это класс в Selenium, который предоставляет набор методов для нахождения элементов на странице. Эти методы используются вместе с методами <b>find_element(By.TAG_NAME)</b> и <b>find_elements.(By.ID)</b>. Существуют различные стратегии поиска, такие как поиск по идентификатору (ID), имени (NAME), классу (CLASS_NAME), CSS-селектору (CSS_SELECTOR), XPath (XPATH) и другие.<br>
Пример использования класса By:
<pre>
from selenium.webdriver.common.by import By

element = browser.find_element(By.NAME, 'q')  # Находим элемент по имени
</pre>
<p>
<b>Ожидания (Waits)</b><br>
Ожидания в Selenium используются для управления временем ожидания появления элементов на веб-странице. Существует два типа ожиданий:
<ul>
<li> Неявные ожидания (Implicit Waits): Устанавливают общее время ожидания появления элемента перед тем, как выбросить исключение.
<p>
<li> Явные ожидания (Explicit Waits): Позволяют задать условие для ожидания конкретного элемента, что обеспечивает большую гибкость по сравнению с неявными ожиданиями.
</ul>
<p>
<b>Работа с элементами</b><br>
После того как элемент был найден с помощью локатора, Selenium позволяет выполнять с ним различные действия, такие как:
<ul>
<li> Ввод текста send_keys()
<li> Клики click()
<li> Получение текста элемента .text
<li> Проверка видимости элемента is_displayed()
</ul>
<p>
<b>Selenium IDE</b><br>
Selenium IDE — это плагин для браузеров Firefox и Chrome, который позволяет записывать, редактировать и воспроизводить тесты. IDE хорошо подходит для быстрого создания тестов без необходимости писать код, однако его возможности ограничены по сравнению с WebDriver.
<p>
<b>Selenium Grid</b><br>
Selenium Grid позволяет одновременно запускать тесты на разных машинах и в разных браузерах. Это обеспечивает возможность параллельного тестирования, что значительно ускоряет процесс тестирования и помогает проверить работу веб-приложения в различных условиях.
<h4>Первый скрипт</h4>
Итак, чтобы наш первый скрипт заработал, необходимо написать минимальный набор команд:
<p>
1️⃣ Импортировать webdriver и модуль time, потому что без него все произойдет - молниеносно, и мы даже не успеем понять, что произошло.
<pre>
from selenium import webdriver
import time
</pre>
2️⃣ Создать экземпляр класса webdriver.Chrome(для удобства мы будем использовать имя browser) то есть к нему далее мы будем обращаться, чтобы манипулировать браузером.
<pre>
browser = webdriver.Chrome()
</pre>
3️⃣ И воспользоваться методом класса get, благодаря которому у нас и открывается страница, а так же задействовать команду time.sleep(), которая приостанавливает выполнение программы на указанное в скобках количество секунд, чтобы увидеть результат.
<pre>
browser.get("http://stepik.org/a/104774")
time.sleep(5)
</pre>
4️⃣ И обязательно завершить работу браузера. Позже я расскажу вам о нескольких конструкциях, которые можно использовать для завершения работы браузера, и почему этот так важно.
<pre>
browser.quit()
</pre>
Итоговый скрипт:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
<pre>
# Импорт модуля webdriver из библиотеки Selenium для управления браузером
from selenium import webdriver

# Импорт модуля time для работы с задержками
import time

# Создание экземпляра webdriver браузера Chrome
browser = webdriver.Chrome()

# Открытие сайта "stepik.org" в браузере
browser.get("http://stepik.org/a/104774")

# Пауза на 5 секунд, чтобы страница успела загрузиться
time.sleep(5)

# Закрытие браузера
browser.quit()
</pre></td></tr></table>
<p>
<b>Что происходит, когда мы запускаем наш скрипт?</b><br>
Selenium Client Library:
<ul>
<li> Получает команду webdriver.Chrome().
<li> Понимает, что для управления браузером нужен ChromeDriver.
<li> Запускает ChromeDriver как отдельный процесс с помощью системного вызова.
<li> ChromeDriver открывает локальный HTTP-сервер на случайном порту (например, localhost:9515) Этот сервер будет слушать команды от Webdriver
</ul>
<p>
<b>Webdriver:</b><br>
отправляет HTTP-запрос формата JSON на сервер ChromeDriver для создания новой сессии.
<p>
<b>ChromeDriver:</b>
<ul>
<li> получает запрос, создаёт новую сессию, запускает браузер Chrome и возвращает ответ с session ID.
<li> Как драйвер передаёт команды в браузер? ChromeDriver, когда взаимодействует с браузером Chrome, использует Chrome DevTools Protocol (CDP) для управления браузером на более низком уровне. Это набор API, который позволяет управлять внутренними аспектами работы браузера.
</ul>
Все. Связь установлена, теперь все последующие команды (например, browser.get()) отправляются с использованием этого session ID.
Например, открытие страницы команда: browser.get("http://stepik.org/a/104774")БикЮ
Действие: Selenium отправляет HTTP-запрос через WebDriver API на URL http://localhost:&lt;порт>/session/&lt;sessionId>/url.
<p>
Пример HTTP-запроса:
<pre>
POST /session/<sessionId>/url HTTP/1.1
Content-Type: application/json
Host: localhost:&lt;порт>

{
    "url": "http://stepik.org/a/104774"
}
</pre>
Ответ: Браузер переходит на указанный URL. Драйвер возвращает статус успешного выполнения.
<pre>

</pre>
<a name="search"><h3 align=center>Поиск элемента</h3>
Для поиска используется метод <b>find_elements</b> , возвращающий список всех найденных элементов или <b>find_element()</b> возвращающий один элемент.
<p>
Первым аргументом этих функций является <b>локатор</b> - метод поиска элемента.
<p>
Для использования локаторов нужно импортировать класс By:
<pre><font color=brown size=5>
from selenium.webdriver.common.by import By
</font></pre>
Список локаторов:
<ul>
<li> <b>CLASS_NAME</b> - поиск по значению атрибута class
<pre>
element = browser.find_element(<b>By.CLASS_NAME</b>, 'class=["stroka"]')
</pre>
<p>
<li> <b>CSS_SELECTOR</b> - Поиск элемента или элементов, используя селекторы CSS. Это гибкий и мощный метод, который может выразить сложные критерии поиска.
<pre>
elements = browser.find_elements(By.CSS_SELECTOR, ".some_class")
</pre>
<p>
<li> <b>ID</b> - поиск по значению атрибута ID
<p>
<li> <b>NAME</b> - поиск по значению атрибута name
<p>
<li> <b>LINK_TEXT</b> - поиск по значению видимомого текста
<pre>
element = driver.find_element(By.LINK_TEXT, "Selenium Official Page")
</pre>
<p>
<li> <b>PARTIAL_LINK_TEXT</b> - Находит элементы, видимый текст которых содержит искомое значение. Если найдено несколько подходящих элементов, будет выбран только первый.
<p>
<li> <b>TAG_NANE</b> - поиск по имени тега
<p>
<li> <b>XPATH</b> -поиск по xpath-выражению<br>
<pre>
browser.find_element(By.XPATH, "//h3[@data-reactid = '64']")
</pre>
будет найден первый атрибут data-reactid=64 внутри тега h3
</pre>
</ul>
<p>
<h4 align=center>Поиск по By.CSS_SELECTOR</h4>
По моему опыту общий синтаксис:
<pre>
element = browser.find_element(By.CSS_SELECTOR, 'tag[attribut="value_atribut"]')
</pre>
<p>
<b>Найди элемент по имени атрибута</b><br>
Один из самых простых сценариев — поиск элементов по наличию определённого атрибута. Рассмотрим веб-страницу с несколькими кнопками, каждая из которых помечена пользовательским атрибутом «data-action.». Допустим, мы хотим найти все кнопки на странице с этим атрибутом. В таких случаях мы можем использовать локатор [attribute]:
<pre>
driver.findElements(By.cssSelector("[data-action]"));
</pre>
Судя по наличию в конце точки с запятой - это на языке С++. На Python я бы записал так:
<pre>
driver.find_elements(By.CSS_SELECTOR, "[data-action]")
</pre>
В приведенном выше коде [data-action] выберет все элементы на странице с атрибутом data-action, и мы получим список WebElements.
<p> <b>Найдите элемент по значению атрибута</b><br>
Если нам нужно найти конкретный элемент с уникальным значением атрибута, мы можем использовать вариант строгого соответствия CSS-локатора [attribute=value]. Этот метод позволяет находить элементы с точным соответствием значений атрибутов. Давайте продолжим работу с нашей веб-страницей, где кнопки имеют атрибут «data-action», каждому из которых присвоено отдельное значение действия. Например, data-action=’delete’, data-action=’change’ и так далее. Если мы хотим найти кнопки с определённым действием, например «delete», мы можем использовать селектор атрибутов с точным соответствием:
<pre>
driver.findElement(By.cssSelector('[data-action='delete']'));
</pre>
На Python:
<pre>
driver.find_elements(By.CSS_SELECTOR, '[data-action="delete"]')
</pre>
<p>
<b>Найдите элемент по стартовому значению атрибута</b><br>
В ситуациях, когда точное значение атрибута может меняться, но начинается с определённой подстроки, мы можем использовать другой подход. Давайте рассмотрим сценарий, в котором в нашем приложении есть множество всплывающих окон, в каждом из которых есть кнопка «Принять» с пользовательским атрибутом «data-action». У этих кнопок могут быть разные идентификаторы, добавляемые после общего префикса, например «btn_accept_user_pop_up», «btn_accept_document_pop_up» и так далее. Мы можем написать универсальный локатор в базовом классе, используя локатор [attribute^=value]:
<pre>
driver.findElement(By.cssSelector("[data-action^='btn_accept']"));
</pre>
На python:
<pre>
driver.find_elements(By.CSS_SELECTOR, '[data-action^="btn_accept"]')
</pre>
Этот локатор найдёт элемент, значение атрибута «data-action» которого начинается с «btn_accept», поэтому мы можем написать базовый класс с универсальным локатором кнопки «Принять» для каждого всплывающего окна.
<p>
<b>Найдите Элемент, завершив значение атрибута</b><br>
Аналогичным образом, когда значение нашего атрибута заканчивается определённым суффиксом, мы используем [attribute$=value]. Представьте, что у нас есть список URL-адресов на странице, и мы хотим получить все ссылки на PDF-документы:
<pre>
driver.findElements(By.cssSelector("[href$='.pdf']"));
</pre>
На python:
<pre>
driver.find_elements(By.CSS_SELECTOR, '[href$=".pdf"]')
</pre>
В этом примере драйвер найдёт все элементы, значение атрибута «href» которых заканчивается на «.pdf».
<p>
<b>Найдите элемент по части значения атрибута</b><br>
Если мы не уверены в префиксе или суффиксе атрибута, нам поможет метод contains [attribute*=value]. Давайте рассмотрим сценарий, в котором мы хотим получить все элементы со ссылкой на конкретный путь к ресурсу:
<pre>
driver.findElements(By.cssSelector("[href*='archive/documents']"));
</pre>
На python:
<pre>
driver.find_elements(By.CSS_SELECTOR, '[href*="archive/documents"]')
</pre>
В этом примере мы получим все элементы со ссылкой на документ из папки с архивом.
<p>
<b>Найдите элемент по определенному классу</b><br>
Мы можем найти элемент, используя его класс в качестве атрибута. Это распространённый приём, особенно при проверке, включён ли элемент, отключён ли он или получил ли какие-либо другие возможности, отражённые в его классе. Предположим, что мы хотим найти отключённую кнопку, которая содержит несколько class и другие атрибуты:<br>
&lt;a href="#" class="btn btn-primary btn-lg disabled" role="button" aria-disabled="true">Accept&lt;/a>
<p>
На этот раз давайте использовать полное соответствие для role и не полное соответствие для class:
<pre>
driver.findElement(By.cssSelector("[role='button'][class*='disabled']"));
</pre>
На python:
<pre>
driver.find_elements(By.CSS_SELECTOR, '[role="button"][class*="disabled"]')
</pre>
В этом примере «class» использовался в качестве локатора атрибутов [attribute*=value] и обнаружил в значении «btn btn-primary btn-lg disabled» часть «disabled».
<p>
Другой пример, есть html-код:
<pre>
&lt;html>
 &lt;body>
  &lt;p class="content">Site content goes here.&lt;/p>
&lt;/body>
&lt;html>
</pre>
Элемент “p” может быть определен следующим образом:
<pre>
content = driver.find_element(By.CSS_SELECTOR, 'p.content')
</pre>
<pre>

</pre>
<h4 align=center>Поиск элементов By.XPATH</h4>
Вы можете использовать XPath для поиска элемента как по абсолютному пути (не рекомендуется), так и по относительному. Абсолютный путь XPath содержит в себе все узлы дерева от корня (html) до необходимого элемента, и, как следствие, подвержен ошибкам в результате малейших корректировок исходного кода страницы. Если найти ближайщий элемент с атрибутами id или name (в идеале один из элементов-родителей), можно определить искомый элемент, используя связь «родитель-подчиненный». Эти связи будут куда стабильнее и сделают ваши тесты устойчивыми к изменениям в исходном коде страницы.
<p>
<b>XPath всегда начинается с символа / или //<br>
Символ / аналогичен символу > в CSS-селекторах, а символ // — пробелу в CSS.</b>
<p>
Квадратные скобки [ ] служат для записи внутри фильтров.
<p>
Для примера, рассмотрим следующий исходный код страницы:
<pre>
&lt;html>
 &lt;body>
  &lt;<b>form</b> id="loginForm">
   &lt;input name="<b>username</b>" type="text" />
   &lt;input name="password" type="password" />
   &lt;input name="continue" type="submit" value="Login" />
   &lt;<b>input</b> name="continue" type="button" value="Clear" />
  &lt;/form>
&lt;/body>
&lt;html>
</pre>
Элемент form может быть определен следующими способами:
<pre>
login_form = driver.find_element_by_xpath("/html/body/form[1]")
login_form = driver.find_element_by_xpath("//form[1]")
login_form = driver.find_element_by_xpath("//form[@id='loginForm']")
</pre>
<ol>
<li> Абсолютный путь (поломается при малейшем изменении структуры HTML страницы)
<li> Первый элемент form в странице HTML
<li> Элемент form, для которого определен атрибут с именем id и значением loginForm
</ol>
Элемент username может быть найден так:
<pre>
username = driver.find_element_by_xpath("//form[input/@name='username']")
username = driver.find_element_by_xpath("//form[@id='loginForm']/input[1]")
username = driver.find_element_by_xpath("//input[@name='username']")
</pre>
<ol>
<li> Первый элемент form с дочерним элементом input, для которого определен атрибут с именем name и значением username
<li> Первый дочерний элемент input элемента form, для которого определен атрибут с именем id и значением loginForm
<li> Первый элемент input, для которого определен атрибут с именем name и значением username
</ol>
Кнопка “Clear” может быть найдена следующими способами:
<pre>
clear_button = driver.find_element_by_xpath("//input[@name='continue'][@type='button']")
clear_button = driver.find_element_by_xpath("//form[@id='loginForm']/input[4]")
</pre>
<ol>
<li> Элемент input, для которого заданы атрибут с именем name и значением continue и атрибут с именем type и значением button
<li> Четвертый дочерний элемент input элемента form, для которого задан атрибут с именем id и значением loginForm
</ol>
<p>
<b>Поиск по тексту внутри тега</b><br>
Поиск по тексту между открывающимся  и закрывающимся тегами можно осуществить только с помощью XPATH.<br>
Извлекаем текст с помощью функции text() (например, //div[text()='S - Subscriber'] укажет нам именно на дочерний элемент div, а //div[contains(., 'S - Subscriber')] укажет нам на родительский элемент div, если я ничего не перепутал). 
<pre>

</pre>
<h4>Поиск по By.ID</h4>
Пример, имеется страница https://parsinger.ru/html/headphones/5/5_1.html<br>
Задача вывести имя товара (id="p_header") и цену (&lt;span id="price">620 руб&lt;/span>)
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
<pre>
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("https://parsinger.ru/html/headphones/5/5_1.html")

name_id = browser.<font color=green>find_element(By.ID, "p_header")</font>
print(name_id.text)                                 # Defender Warhead G-160

name_id1 = browser.<font color=green>find_element(By.CSS_SELECTOR, "#p_header")</font>
print(name_id1.text)                                # Defender Warhead G-160

# name_id2 = browser.find_element(By.ID, "<font color=red>#</font>p_header") # ошибка

# <font color=red>print(browser.find_element(By.CSS_SELECTOR, [id='p_header']))</font>  # SyntaxError: invalid syntax

print(browser.find_element(By.ID, 'price').text)    # 620 руб

price = browser.find_element<b>s</b>(By.ID, 'price') # метод find_elements в отличии от find_element создаёт список
print(type(price))                                  # &lt;class 'list'>
for i in price:
    print(i.text)                                   # 620 руб

browser.quit()
</pre></td></tr></table>
<p>
<h4>By.CLASS_NAME</h4>
Пример:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
<pre>
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("https://parsinger.ru/html/headphones/5/5_1.html")

name_class = browser.find_element(By.<b>CLASS_NAME</b>, "description")
print(name_class.text)

browser.quit()
</pre></td></tr></table>
<p>
Выведет все тексты внутри тега с классом=description:
<pre>
Defender Warhead G-160
Артикул: 80333758
Бренд: Defender
Модель: Warhead G-160
Тип наушников: Накладные
Диапазон частот: 20–20000 Гц
Микрофон: Есть
Длина провода: 2.5 м
Подключение: USB
Особенность: С регулятором громкости
В наличии: 17
620 руб
910 руб
Купить
</pre>
Другой синтаксис:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
<pre>
from selenium import webdriver
from selenium.webdriver.common.by import By

browser = webdriver.Chrome()
browser.get("https://parsinger.ru/html/headphones/5/5_1.html")

name_class = browser.find_element(<b>By.CSS_SELECTOR, '.sale'</b>)
print(name_class.text)
browser.quit()
</pre></td></tr></table>
<p>
Вывод:
<pre>
620 руб
910 руб
Купить
</pre>
<p>
<li> <b>по имени тега</b>:
<pre>
elements = driver.find_elements(<b>By.TAG_NAME, 'p'</b>)
</pre>
<p>
<li> <b>по значению атрибута</b><br>
<pre>
element = driver.find_element(By.NAME, "newsletter")
</pre>
где "newsletter" - значение какого-то атрибута
<p>
В DevTools: [name="4_1"], где name - это имя атрибута, а 4_1 - значение этого атрибута.
</ul>
Для поиска используются квадратные скобки. Примеры: [id='brand'], [class="headers"], [name="4_1"]
Задача, найти все теги p с двойным атрибутом class и data-example.
<pre>
# Комбинированный поиск: ищем все абзацы с классом "my_class" и атрибутом "data-example"
paragraphs = browser.find_elements(By.CSS_SELECTOR, 'p.my_class[data-example]')

# Выводим найденные элементы
for p in paragraphs:
    print(f'Найденный элемент: {p.text}')

# Закрываем браузер
browser.quit()
</pre>
Вывод: "Найденный элемент: Это абзац с классом my_class и атрибутом data-example."
<p>
<b>Составные селекторы</b><br>
.author .text - это означает, что мы ищем тег с классом text, родителем которого является тег с классом author. Элемент .text может находиться на любом уровне вложенности от элемента .author и между ними может быть сколько угодно других тегов.
<p>
<b>Потомки или дочерние элементы</b><br>
">" — символ, который, в отличие от пробела, используется для выбора непосредственных дочерних элементов относительно указанного родительского элемента. В контексте парсинга веб-страниц, это означает, что селектор будет сосредоточен на более узком диапазоне элементов, исключая те, которые находятся на других уровнях вложенности.<br>
.img_box > .name_item — данный синтаксис позволяет нам точно определить и выбрать элемент с классом .name_item, который является непосредственным дочерним элементом (англ, "child") с классом .img_box. В этом случае, .img_box выступает в роли родительского элемента (англ,"parent").
<p>
<b>Поиск по порядковому номеру дочернего элемента</b><br>
#description > li:nth-child(3) — этот синтаксис чрезвычайно полезен, особенно если вы хотите найти конкретный элемент в списке. Функция :nth-child() позволяет выбирать элемент на основе его порядкового номера в списке дочерних элементов. В данном примере мы ищем третий элемент в списке.<br>
Забавный факт: в большинстве языков программирования индексация начинается с 0, но в контексте поиска по HTML-структуре счёт начинается с 1. Это одна из тех мелочей, которую просто необходимо запомнить, чтобы избежать ошибок и неточностей при парсинге.
<p>
<b>Использование двух классов и более </b><br>
Предположим, у вас есть HTML-элемент с классами class1 и class2. Если нужно найти элемент, который имеет именно эти два класса, вы можете использовать селектор .class1.class2 (без пробела между ними).<br>
Это особенно полезно, когда вы сталкиваетесь с более сложными структурами HTML, где одни и те же классы могут использоваться в разных контекстах. С помощью такой комбинации классов вы сможете точнее находить нужные вам теги.<br>
Ключевой момент здесь — отсутствие пробела между именами классов. Это говорит парсеру, что искомый элемент должен иметь оба эти класса одновременно. Стоит это запомнить, чтобы уточнить вашу стратегию парсинга и сделать её максимально эффективной.
<pre>

</pre>
<p>
<ol>
<li> <b>Поиск по тэгу (элементу):</b><br>
Если на странице есть элементы типа &lt;p>, то с помощью XPath можно найти их, указав просто название тега:
<pre>
//p
</pre>
Это найдет все теги &lt;p> на странице.
<p>
<li> <b>Поиск по атрибутам:</b><br>
Если у тега есть атрибут, например class, то можно найти его по этому атрибуту. Например, у нас есть такой элемент:<br>
&lt;p class="text">Это параграф с классом text&lt;/p>
<p>
Для поиска по атрибуту class со значением text пишем:
<pre>
//*[@class="text"]
</pre>
Это найдет атрибут class со значением text.
<p>
<li> <b>Поиск по тексту внутри элемента:</b><br>
Если нужно найти элемент, который содержит определенный текст, используем функцию text(). Например имеется:
<pre>
&lt;p>Привет, мир!&lt;/p>
&lt;p>Как дела?&lt;/p>
</pre>
Чтобы найти параграф с текстом "Как дела?", напишем:
<pre>
//p[text()="Как дела?"]
</pre>
<p>
Другой пример: найти элемент &lt;h2>Подзаголовок в Статье&lt;/h2> , для этого необходимо написать путь:
<pre>
//article/header/h2[text()='Подзаголовок в Статье']
</pre>
Этот XPath-запрос делает следующее:
<ol>
<li> //article - ищет все элементы article на странице, начиная с корневого элемента и далее по всему дереву.
<li> /header - переходит к непосредственному дочернему элементу header каждого найденного article.
<li> /h2 - переходит к непосредственному дочернему элементу h2 каждого найденного header.
<li> [text()='Подзаголовок в Статье'] - фильтрует элементы h2 по их текстовому содержимому, оставляя только те, которые имеют текст "Подзаголовок в Статье".
</ol>
<p>
<li> <b>Поиск по частичному совпадению текста:</b><br>
Если текст в элементе может быть разным, но начинается или заканчивается с определенной фразы, можно использовать функцию contains(). Например:
<pre>
//p[contains(text(), "Как")]
</pre>
Это найдет все теги &lt;p>, которые содержат слово "Как".
<p>
<li> <b>Поиск с использованием нескольких условий:</b><br>
XPath позволяет комбинировать условия. Например, если нужно найти &lt;p> с классом text и с текстом "Как дела?", то пишем:
<pre>
//p[@class="text" and text()="Как дела?"]
</pre>
<p>
<li> <b>Поиск дочерних элементов:</b><br>
Если элемент находится внутри другого, используем / для перехода по уровням. Например:
<pre>
&lt;div>
    &lt;p>Это параграф внутри div&lt;/p>
&lt;/div>
</pre>
Чтобы найти параграф внутри div, пишем:
<pre>
//div/p
</pre>
Одиночный слэш означает, что p является прямым потомком тега div . Если же их разделял двойной слэш, то тег p находится внутри div, но на любом уровне вложенности.
<p>
Важная особенность: если начать XPath-запрос с символа /, корнем запроса всегда будет элемент с тегом &lt;html>. Пример: /html/body/header.<br>
Если же запрос начинается с //, это означает, что нужно найти все потомки корневого элемента, без уточнения, кто является корнем. Так, если нужно найти хедер, можно просто использовать //header, предполагая, что других элементов с таким названием на странице нет.
<p>
<li> <b>Поиск по индексу:</b><br>
Иногда нужно выбрать элемент по его порядковому номеру. Например, если нужно выбрать второй параграф:
<pre>
//p[2]
</pre>
Это выберет второй параграф на странице.
<p>
<li> <b>Символ * - Команда выбора всех элементов</b><br>
В XPath символ * используется для выбора всех элементов, соответствующих заданному критерию. Это особенно полезно, если вы не знаете точный тег элемента, который пытаетесь найти. Допустим, вы хотите найти текст цены в определённом заголовке на сайте. В таком случае, запрос:
<pre>
 //div/*[@class="price"]
</pre>
будет искать все элементы внутри тега div с классом "price", независимо от их типа.<br>
Этот способ удобен для широкого поиска, однако важно помнить, что такая "широкая сеть" может ловить и нежелательные элементы. В нашем примере найдено 8 элементов, что уже подсказывает о том, что следует быть осторожным и, возможно, уточнить критерии поиска.
</ol>
<p>
Пример использования XPath в Selenium:<br>
Предположим, у нас есть такой HTML-код:
<pre>
&lt;html>
    &lt;body>
        &lt;div class="content">
            &lt;p class="text">Первый параграф&lt;/p>
            &lt;p class="text">Второй параграф&lt;/p>
        &lt;/div>
    &lt;/body>
&lt;/html>
</pre>
Чтобы выбрать второй параграф с помощью XPath, напишем код в Selenium:
<pre>
from selenium import webdriver

driver = webdriver.Chrome()
driver.get("http://example.com")  # Замените на URL страницы

# Ищем второй параграф
element = driver.<b>find_element_by_xpath</b>('//p[2]')
print(element.text)

driver.quit()
</pre>
Этот код найдет второй параграф на странице и выведет его текст.
<p>
В общем, XPath — это мощный инструмент для поиска элементов на веб-странице. На практике ты будешь комбинировать эти методы для точного выбора нужных элементов.
</ol>
<p>
Предпочтение CSS-селекторам: Если у вас есть возможность использовать CSS-селекторы — такие как class, id или name — лучше придерживаться их. Они более наглядны и, как правило, менее подвержены изменениям на сайте.
<pre>
# Используйте это 
//button[@id='clickMe']

# Вместо этого
//div[1]/div[2]/div[3]
</pre>
Поиск по тексту и атрибутам: XPath позволяет выполнять поиск по полному или частичному совпадению текста и любых атрибутов. Это может быть полезно, но помните, что такой метод может быть нестабильным, особенно на мультиязычных сайтах.
<pre>
# Поиск по полному совпадению текста
# Этот XPath выберет кнопку с текстом "Купить".
//button[text()="Купить"]

# Поиск по частичному совпадению текста
# Этот XPath выберет все элементы p, в которых содержится текст "Артикул".
//p[contains(text(), "Артикул")]

# Поиск по полному совпадению атрибута
# Этот XPath выберет все ссылки, у которых атрибут href равен "https://example.com".
//a[@href="https://example.com"]

# Поиск по частичному совпадению атрибута
# Этот XPath выберет все элементы li с классом, который частично совпадает с "item".
//li[contains(@class, "item")]
</pre>
Навигация по документу: Одним из преимуществ XPath является удобная навигация по структуре документа. Вы можете легко переходить от родителей к потомкам и обратно, что может быть полезно при сложных задачах парсинга.
<pre>
# Переход к дочерним элементам
# Здесь мы находим все дочерние элементы div с id='parent'.
//div[@id='parent']/child::*

# Переход к родительскому элементу
# Этот запрос вернет родительский элемент div с id='child'.
<font color=red>//div[@id='child']/parent::*</font>

# Переход к следующему соседнему элементу
# Этот запрос вернет все следующие соседние элементы после div с id='prev_sibling'.
//div[@id='prev_sibling']/following-sibling::*

# Переход к предыдущему соседнему элементу
# Этот запрос вернет все предыдущие соседние элементы перед div с id='next_sibling'.
//div[@id='next_sibling']/preceding-sibling::*

# Переход к конкретному дочернему элементу
# Этот запрос вернет первый дочерний элемент p у div с id='parent'.
//div[@id='parent']/child::p[1]

# Поиск по вложенным элементам
# Этот запрос вернет все элементы span, являющиеся потомками div с id='ancestor'.
//div[@id='ancestor']//child::span
</pre> 
При отсутствии атрибутов: Если у сайта плохо с атрибутами, XPath становится вашим спасением. Он позволяет искать элементы по их структурному расположению, что может быть единственным выходом в некоторых случаях.
<pre>
# Поиск первого дочернего элемента
# Этот запрос вернет первые дочерние элементы для всех div.
//div/*[1]

# Поиск последнего дочернего элемента
# Здесь мы находим последние дочерние элементы для всех div.
//div/*[last()]

# Поиск по порядковому номеру
# Этот запрос вернет третий элемент li в каждом ul.
//ul/li[position()=3]

# Поиск элементов, имеющих дочерние элементы
# Этот запрос вернет все div, которые имеют хотя бы одного потомка.
//div[count(*) > 0]

# Поиск элементов на определенной глубине
# Этот запрос вернет все элементы p, находящиеся на четвертом уровне вложенности.
//*/*/*/*[name()='p']
</pre>
Остерегайтесь автоматических генераторов XPath: Использование различных расширений для браузера для автоматического создания XPath-селекторов может привести к генерации переусложненных и нечитаемых селекторов. Намного лучше потратить время и разобраться в синтаксисе самостоятельно. Он не так уж и сложен, а понимание придет с опытом.
<pre>

</pre>
<h4 align=center>Метод quit()</h4>
Когда скрипт отработает, мы бы хотели, чтобы он закрылся сам и тем самым корректно завершил свою работу. Но это может не произойти по некоторым причинам. Поэтому мы должны указать браузеру, что он должен закрыть окно после завершения работы, командой browser.quit(). Важно закрывать окно, потому что при создании webdriver.Chrome() создается процесс в ОС, который продолжит висеть.
<p>
Если ошибка произойдет во время выполнения кода до команды .quit(), сеанс WebDriver не будет закрыт должным образом, и файлы не будут удалены из памяти. Для того, чтобы код гарантированно завершил свою работу командой  quit(), используем конструкцию  try/finally. Весь код после finally: будет гарантированно выполнен.
<p>
Есть еще третий способ — это менеджер контекста with/as. С этим способом нам вообще не нужно думать о том, когда закрывать браузер, менеджер контекста делает это за нас в тот момент, когда это нужно.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
<pre>
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/html/watch/1/1_1.html')
    button = browser.find_element(By.ID, "sale_button")
    time.sleep(2)
    button.click()
    time.sleep(2)
</pre></td></tr></table>
<p>
Разница между close() и quit()<br>
browser.close() — закрывает текущее окно браузера, если во время работы вы открыли новое окно или вкладку.
<p>
browser.quit() — закрывает все окна, вкладки, процессы веб-драйвера, которые были запущены во время сессии.
<p>
Некоторые проблемы WebDriver (из сети и личного опыта):
<ul>
<li> Поведение Selenium может отличаться в разных браузерах;
<li> Иногда возникают сложности с поиском элементов (XPath и другие методы иногда просто не работают, хотя должны);
<li> Необъяснимые падения драйвера прямо посреди работы скрипта;
<li> Взаимодействие возможно только с активной вкладкой браузера, хотя драйвер позволяет открывать новые вкладки и новые окна, но не позволяет одновременно в них работать, только поочерёдно.
</ul>
<pre>

</pre>
<a name="wevelement"><h3 align=center>WebElement и его методы</h3>
Когда вы ищете элемент через методы вроде find_element() или find_elements(), возвращаемым типом данных является объект <b>WebElement</b>. Сам же объект WebElement в Selenium представляет собой DOM-дерево которое находится на странице. Этот объект предоставляет методы и атрибуты для взаимодействия с элементом, такие как клик, ввод текста или извлечение атрибутов и др.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
<pre>
from selenium import webdriver
from selenium.webdriver.common.by import By

url = 'http://parsinger.ru/selenium/3/3.html'
browser = webdriver.Chrome()
browser.get(url)
elem = browser.find_element(By.CLASS_NAME, 'text')
print(elem)
browser.quit()
</pre></td></tr></table>
<p>
Вывод:
<pre>
&lt;selenium.webdriver.remote.webelement.WebElement (session="a86f9c5223a7fa5ac8d6c1911f5bfc16", 
 element="9F9569F9515A0E022F0E665284FFB19D_element_2")>
</pre>
Давайте разберём каждую часть подробнее:
<ul>
<li> selenium.webdriver.remote.webelement.WebElement: Это путь к классу в исходном коде Selenium, который представляет элемент на веб-странице.
<p>
<li> session="a86f9c5223a7fa5ac8d6c1911f5bfc16": Это идентификатор сессии браузера, который используется WebDriver для отслеживания вашего взаимодействия с браузером. Каждая сессия уникальна и связывает ваш код с одним конкретным открытым окном браузера.
<p>
<li> element="9F9569F9515A0E022F0E665284FFB19D_element_2": Это уникальный идентификатор элемента на странице в рамках текущей сессии. WebDriver использует этот ID для определения, какой именно элемент должен быть манипулирован.
<p>
<li> element_2: Это просто часть уникального идентификатора, который скорее всего генерируется автоматически. Он не несет много информации для нас как разработчиков.
</ul>
Объект WebElement — ваш ключ к манипуляциям с элементом на странице. Вы можете применять к нему различные методы, такие как:
<pre>
<b>.click()</b> для симуляции клика мышью.
browser.find_element(By.ID, "some_button_id").click()
 
<b>.send_keys()</b> для ввода текста (полезно для текстовых полей).
browser.find_element(By.NAME, "some_textbox_name").send_keys("Hello, World!")

<b>.get_attribute('some_attribute')</b> для получения атрибутов, например, href у ссылок.
browser.find_element(By.TAG_NAME, "a").get_attribute("href")
 
<b>.text</b> для получения видимого текста элемента.
browser.find_element(By.CLASS_NAME, "some_class_name").text
</pre>
<pre>

</pre>
<h3 align=center>Использование методов .find_element() и .find_elements()</h3>
Комбинирование find_element() и find_elements() дает вам гибкость и уровень контроля над автоматизацией веб-страниц.
<p>
<b>Сценарий 1: Каскадный поиск</b><br>
Иногда, чтобы добраться до конкретного элемента, нужно сначала найти его "родительский" элемент, и уже внутри него искать дочерний.
<pre>
# Ищем родительский элемент
parent_element = browser.find_element(By.ID, 'parent')

# Ищем дочерний элемент внутри родительского
child_element = parent_element.find_element(By.CLASS_NAME, 'child')

# Или тот же самый поиск в одну строку
element = browser.find_element(By.ID, 'parent').find_element(By.CLASS_NAME, 'child')
</pre>
Имейте ввиду что в данном случаи вернется первый элемент.
<p>
<b>Сценарий 2: Поиск внутри списка элементов</b><br>
Представьте, что у вас на странице несколько однотипных блоков, и в каждом из них есть кнопка или какой-то другой элемент, с которым нужно взаимодействовать.
<pre>
# Ищем все блоки
blocks = browser.find_elements(By.CLASS_NAME, 'block')

# Проходим по каждому блоку и кликаем на кнопку внутри
for block in blocks:
    button = block.find_element(By.CLASS_NAME, 'button')
    button.click()
</pre>
<p>
<b>Сценарий 3: Проверка существования элементов</b><br>
Вы можете сначала проверить, есть ли на странице интересующие вас элементы, и только затем с ними взаимодействовать.
<pre>
# Ищем все элементы с классом 'some_class'
elements = browser.find_elements(By.CLASS_NAME, 'some_class')

# Если элементы найдены, кликаем на первый
if elements:
    elements[0].click()
</pre>
Другие способы проверки существования вебэлемента:<br>
Использовать try/except с find_element() и отловом исключения. Другой — явное ожидание через WebDriverWait, но там также нужно отлавливать исключение:
<pre>
try:
    element = WebDriverWait(browser, 10).until(
        EC.presence_of_element_located((By.ID, 'block'))
    ) # Этот механизм проверяет наличие элемента в течение заданного времени
except TimeoutException:
    element = None
</pre>
Разбор отличия методов на примере:  есть <a href="http://parsinger.ru/selenium/3/3.html">страница</a> с очень простой структурой дерева HTML. На этой странице есть 100 блоков &lt;div class="text">, в каждом три тега &lt;p>, которые не имеют ни class, ни id. Допустим мы хотим  собрать каждый первый элемент &lt;p>.<br>
<pre>
from selenium import webdriver
from selenium.webdriver.common.by import By

url = 'http://parsinger.ru/selenium/3/3.html'
with webdriver.Chrome() as browser:
    browser.get(url)
    link = browser.find_element(By.CLASS_NAME, 'text')
</pre>
link будет содержать DOM первого найденного блока с классом='text' . Он содержит три абзаца с тегом p. Первое, что нужно иметь, вебэлементы не поддерживают срезы или индексацию, как обычные списки. Поэтому, чтобы вытащить скажем первый абзац, можем применять XPath:
<pre>
.find_element(By.XPATH, "//div[@class='text']/p[1]")
</pre>
 эта команда найдет первый тег p внутри первого тега div с классом 'text', который будет обнаружен на странице первым, и вернет его как объект WebElement.
<p>
<i><font size=5 color=green>Нумерация в xpath начинается с 1, а не 0, как в обычных списках python.</font></i>
<p>
<pre>
.find_element<b>s</b>(By.XPATH, "//div[@class='text']/p[2]")
</pre>
вернёт все найденные теги p, расположенные на вторых позициях, во всех найденных тегах div class="text".
<pre>

</pre>
<h3>Запуск расширений в браузере</h3>
Ссылка: <a href="https://stepik.org/lesson/731850/step/1?unit=733385">Запуск браузера с расширениями</a>
<p>
После того как расширение установили, его надо упаковать. Упакованное расширение будет иметь расширение .crx
Далее запускаем через selenium браузер с расширением:
<pre>
import time
from selenium import webdriver

options_chrome = webdriver.ChromeOptions()
options_chrome.add_extension('/path/coordinates.crx')     # путь к нашему упакованному расширению

with webdriver.Chrome(options=options_chrome) as browser:
    url = 'https://stepik.org/course/104774'
    browser.get(url)
    time.sleep(15)
</pre>
<p>
Некоторые популярные расширения.
<ol>
<li> AdBlock / uBlock Origin: для блокировки рекламы.
<p>
<li> EditThisCookie: для работы с куками.
<p>
<li> User-Agent Switcher: для смены User-Agent.
<p>
<li> Firebug / Chrome Developer Tools: для отладки и анализа.
<p>
<li> Screenshot: для скриншотов и записи экрана.
<p>
<li> LastPass / 1Password: для автоматического заполнения форм, если это нужно в тестах.
<p>
<li> Proxy SwitchyOmega: для работы с прокси-серверами.
<p>
<li> Wappalyzer: для определения технологий, используемых на веб-сайте.
<p>
<li> Tampermonkey: Для запуска пользовательских скриптов, что может быть полезно для автоматизации сложных действий на веб-странице.
</ol>
<h3>Запуск браузера в скрытом режиме</h3>
Для этого нам потребуется  передать параметр <b>--headless или --headless=new в метод .add_argument()</b>. В качестве примера откроем страницу курса и получим первую найденную ссылку.
<pre>
from selenium import webdriver
from selenium.webdriver.common.by import By

# Создание объекта ChromeOptions для дополнительных настроек браузера
options_chrome = webdriver.ChromeOptions()

# Добавление аргумента '--headless' для запуска браузера в фоновом режиме
<b>options_chrome.add_argument('--headless')</b>

# Инициализация драйвера Chrome с указанными опциями
# Использование менеджера контекста 'with' для автоматического закрытия браузера после выполнения кода
with webdriver.Chrome(options=options_chrome) as browser:
    url = 'https://stepik.org/course/104774'
    browser.get(url)
    
    # Ищем элемент по тегу 'a' (ссылку)
    a = browser.find_element(By.TAG_NAME, 'a')
    
    # Выводим атрибут 'href' найденного элемента (URL ссылки)
    print(a.get_attribute('href'))  # https://stepik.org/catalog
</pre>
Классический headless-режим (--headless) был первым способом запуска Chrome без графического интерфейса. Он позволяет выполнять большинство тестов, но имеет некоторые ограничения:
<ul>
<li> Рендеринг и поведение: Рендеринг страниц и обработка некоторых веб-API могут отличаться от обычного (headful) режима, что порой приводит к несовпадению с тем, как страница отображается при обычном запуске браузера.
<li> Ограниченная функциональность: Некоторые функции или сценарии (например, связанные с анимациями, расширенными эффектами) могут работать не так, как ожидается.
</ul>
<p>
<b>--headless=new</b><br>
Новый headless-режим (--headless=new) был введён для устранения ограничений --headless и ближе имитирует поведение обычного браузера. Рекомендуется для Хрома со 109-й версии. Его отличия:
<ul>
<li> Более точное воспроизведение headful-режима: Улучшенный рендеринг, обработка JavaScript и поддержка современных веб-технологий. Это особенно полезно при тестировании сложных веб-приложений.
<li> Совместимость и производительность: Новый режим может работать быстрее и стабильнее в ряде сценариев, а также менее детектироваться сайтами, которые пытаются определить работу в headless режиме.
</ul>
<p>
<b>--disable-gpu</b><br>
Параметр --disable-gpu отключает использование графического процессора (GPU) при отрисовке. Этот параметр часто использовался для обхода некоторых проблем с драйверами видеокарт в прошлых версиях браузеров и операционных систем. Сейчас его актуальность несколько уменьшилась, но он всё равно может быть полезным на системах, где GPU вызывает проблемы или не поддерживается.<br>
Часто эти два параметра используются вместе в следующем виде:
<pre>
options = webdriver.ChromeOptions()
options.add_argument('--headless')
options.add_argument('--disable-gpu')
</pre>
Это делается из соображений совместимости и стабильности. Например, на некоторых системах, запуск в режиме --headless без отключения GPU может привести к нежелательным сайд-эффектам или ошибкам.
<p>
Хотя --headless и --disable-gpu могут казаться похожими на первый взгляд, они служат разным целям:
<ul>
<li> --headless убирает графический интерфейс для ускорения загрузки страниц и снижения потребления ресурсов.
<p>
<li> --headless=new продвинутая версия --headless
<p>
<li> --disable-gpu просто отключает использование графического процессора для рендеринга, что может быть полезным на машинах с проблемными или отсутствующими графическими драйверами.
</ul>
<p>
Запуск браузера в скрытом (или "--headless") режиме с расширением — это не совсем тривиальная задача, которая может быть полезна для различных сценариев веб-автоматизации или парсинга. Обычно расширения используются для модификации поведения браузера, например, для блокировки рекламы, изменения пользовательского агента или управления cookies.<br>
И если вам потребуется запустить браузер с расширениями  и в режиме --headless, то необходимо прописать<br> <b>options.add_argument("--headless=chrome")</b>
 <pre>
from selenium import webdriver

options = webdriver.ChromeOptions()
options.add_argument('--headless=chrome')
options.add_extension('путь/к/вашему/расширению.crx')
</pre>
<h3 align=center>Перенос профиля с основного браузера Chrome в браузер под управлением Selenium</h3>
Перенос профиля пользователя из основного браузера Chrome в браузер, управляемый через Selenium, позволяет сохранить все настройки, закладки и историю просмотров и т.д. Это может быть особенно полезно для автоматизации тестирования в условиях, максимально приближенных к реальному пользовательскому опыту, или для автоматизации задач без необходимости настройки профиля с нуля.
<ul>
<li> Определение пути к профилю Chrome:<br>
Откройте браузер Chrome и введите в адресной строке chrome://version/.<br>
Найдите строку "Путь к профилю:" — это и будет путь к вашему профилю пользователя. 
<p>
<li> Использование пути к профилю в Selenium:<br>
Чтобы использовать этот профиль в Selenium, необходимо указать путь к директории профиля пользователя в качестве аргумента при инициализации драйвера браузера через ChromeOptions в метод .add_argument()
</ul>
Пример кода:
<pre>
import time
from selenium import webdriver

# Задаем опции для Chrome
options_chrome = webdriver.ChromeOptions()
# Указываем путь к профилю пользователя
options_chrome.add_argument('user-data-dir=C:\\Users\\user\\AppData\\Local\\Google\\Chrome\\User Data')

# Инициализируем драйвер с указанными опциями
with webdriver.Chrome(options=options_chrome) as browser:
    url = 'https://yandex.ru/'
    browser.get(url)  # Открываем страницу
    time.sleep(10)  # Даем время на загрузку страницы
</pre>
Если все сделано правильно, то у вас запустится окно браузера с вашими параметрами, историей, закладками. Если при запуске этого кода возникает ошибка, сообщающая, что директория данных пользователя уже используется (например, "invalid argument: user data directory is already in use, please specify a unique value for"), это означает, что ваш основной браузер Chrome в данный момент использует этот профиль. Вам нужно закрыть основной браузер и повторить попытку.<br>
Если вам нужно одновременно работать с основным окном браузера и сессией Selenium, скопируйте папку User Data в другое место и укажите путь к этой копии в user-data-dir, как это делалось выше.
<h3>Proxy и Selenium</h3>
<pre>
Прокси должен быть вида IP:PORT

import time
from selenium import webdriver
from selenium.webdriver.common.by import By

proxy = '8.210.83.33:80'
url = 'https://2ip.ru/'

chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument('--proxy-server=%s' % proxy)

with webdriver.Chrome(options=chrome_options) as browser:
    browser.get(url)
    print(browser.find_element(By.ID, 'd_clip_button').find_element(By.TAG_NAME, 'span').text)
    time.sleep(5)
</pre>
<p>
Для настройки прокси с авторизацией вам потребуется отдельно установить расширение seleniumwire. Делается это так:<br>
Установка:
<pre>
pip install selenium-wire
</pre>
Скрипт:
<pre>
from seleniumwire import webdriver
import time
from selenium.webdriver.common.by import By
from seleniumwire import webdriver

options = {'proxy': {
    'http': "socks5://D2Frs6:75JjrW@194.28.210.39:9867",
    'https': "socks5://D2Frs6:75JjrW@194.28.210.39:9867",
    }}

url = 'https://2ip.ru/'

with webdriver.Chrome(seleniumwire_options=options) as browser:
    browser.get(url)
    print(browser.find_element(By.ID, 'd_clip_button').find_element(By.TAG_NAME, 'span').text)
    time.sleep(5)
</pre>
<a name=options><h3 align=center>ChromeOptions</h3>
ChromeOptions — это класс в библиотеке Selenium, предназначенный для настройки опций Chrome. Когда вы создаете объект этого класса, вы получаете возможность конфигурировать различные параметры и свойства браузера, прежде чем он будет запущен.
<pre>
# Создание объекта ChromeOptions
options = webdriver.ChromeOptions()
</pre>
Это включает в себя такие вещи как аргументы командной строки, использование прокси-сервера, установка расширений и множество других.
<p>
Метод add_argument() этого объекта служит для добавления аргументов командной строки к запуску браузера. Аргументы командной строки — это флаги или параметры, которые можно передать при запуске Chrome из командной строки, чтобы модифицировать его поведение. В контексте Selenium, add_argument() делает это за вас, передавая эти параметры при инициализации webdriver.Chrome().
<pre>
# Добавление аргументов командной строки
options.add_argument('--headless')  # Запуск браузера в фоновом режиме (без GUI)
options.add_argument('--disable-gpu')  # Отключение GPU (полезно для старых версий Chrome)
options.add_argument('--no-sandbox')  # Отключение режима "песочницы" (sandbox)
</pre>
Объект ChromeOptions затем передается в конструктор webdriver.Chrome(), чтобы эти настройки были применены к новому экземпляру браузера. 
<pre>
# Запуск экземпляра браузера Chrome с заданными опциями
browser = webdriver.Chrome(options=options)
</pre>
<p>
Команда   описание
<ul>
<li> --disable-gpu	Отключает аппаратное ускорение GPU. Иногда это делается для избежания проблем с графикой.
<li> --no-sandbox	Запускает браузер без дополнительных мер безопасности.
<li> --incognito	Запускает браузер в режиме инкогнито. В этом режиме не сохраняются куки и история просмотров.
<li> --window-size=width,height	Устанавливает начальный размер окна браузера.
<li> --start-maximized	Запускает браузер на весь экран.
<li> --disable-extensions	Отключает все установленные расширения.
<li> --user-data-dir=path	Устанавливает директорию для хранения профиля пользователя.
<li> --disable-infobars	Убирает информационные строки в верхней части окна.
<li> --ignore-certificate-errors	Игнорирует ошибки SSL-сертификатов. Полезно, если нужно обращаться к сайтам с недействительными сертификатами.
<li> --lang=ru	Устанавливает язык интерфейса браузера на русский.
<li> --disable-popup-blocking	Отключает блокировку всплывающих окон. Может быть полезным при автоматизации некоторых сценариев.
<li> --allow-running-insecure-content	Позволяет загружать небезопасный контент на страницы, загруженные по HTTPS. Опасная опция, используйте с осторожностью.
<li> --disable-notifications	Отключает уведомления браузера. Особенно полезно при автоматизированном тестировании.
<li> --disable-web-security	Отключает меры безопасности веба. Не рекомендуется для обычного просмотра, но может быть полезно для тестирования.
<li> --disable-client-side-phishing-detection	Отключает обнаружение фишинга на клиентской стороне.
<li> --enable-logging	Включает журналирование в файл.
<li> --log-level=0	Устанавливает уровень журналирования (0-3).
<li> --disable-cache	Отключает кэш браузера. Полезно для тестирования изменений на веб-страницах в реальном времени.
<li> --enable-automation	Подсказывает браузеру, что он управляется программой. Это может изменить поведение некоторых веб-сайтов.
<li> --disable-setuid-sandbox	Отключает песочницу безопасности для браузера. Также не рекомендуется для обыденного использования.
<li> --disable-sync	Отключает синхронизацию с аккаунтом Google.
</ul>
Фишинг на клиентской стороне – это механизм защиты браузера, который анализирует страницы на признаки мошенничества и предупреждает пользователя. Отключая его, вы исключаете возможность ложных срабатываний, когда Selenium-парсер посещает "боевые сайты", которые могут выглядеть подозрительно для системы защиты.
<p>
Отключение кэша браузера гарантирует, что вы всегда получаете свежую, актуальную версию страницы, а не устаревшие данные, сохранённые в кэше. Это особенно важно при парсинге боевых сайтов, где информация быстро обновляется и свежесть данных имеет решающее значение.
<a name="metod"><h3 align=center>Основные методы selenium</h3>
<b>browser.back()</b> - С помощью этого метода вы можете вернуться на предыдущую страницу, как если бы нажали стрелочку "назад" в браузере.
<p>
<b>browser.forward()</b> - Аналогично предыдущему, но перемещает вперёд по истории браузера.
<p>
<b>browser.refresh()</b> -  Этот метод обновляет текущую страницу, как если бы вы нажали кнопку обновления в браузере.
<p>
<b>Работа со скриншотами</b><br>
<b>browser.get_screenshot_as_file("../file_name.jpg")</b> - Сохраняет скриншот страницы в файл по указанному пути. Возвращает True если всё прошло успешно, и False при ошибках ввода-вывода.
<p>
<b>browser.save_screenshot("file_name.jpg")</b> - Сохраняет скриншот в папке с проектом. Похоже устарел. Вместо него:<br>
browser.find_element(By.ID, 'this_pic').screenshot("11.png")
<p>
<b>browser.get_screenshot_as_png()</b> - Возвращает скриншот в виде двоичных данных (binary data), которые можно передать или сохранить в файл в конструкторе with/as;
<p>
<b>browser.get_screenshot_as_base64()</b> - Возвращает скриншот в виде строки в кодировке Base64. Удобно для встроенных изображений в HTML.
<p>
<b>Открытие и закрытие страниц и браузера</b><br>
<b>browser.get("http://example_url.ru")</b> - Открывает указанный URL в браузере.
<p>
<b>browser.quit()</b> - Закрывает все вкладки и окна, завершает процесс драйвера, освобождает ресурсы.
<p>
<b>browser.close()</b> закрывает только текущую вкладку.
<pre>

</pre>
<h4 align=center>Исполнение JavaScript</h4>
<b>browser.execute_script("script_code")</b> - Выполняет JavaScript код на текущей странице.<br>
Метод execute_script() позволяет выполнять JavaScript-код непосредственно в контексте веб-страницы. Это мощный инструмент, который расширяет возможности Selenium.<br>
Основной синтаксис: 
<pre>
browser.execute_script(script, *args)
</pre>
script - строка с JavaScript кодом
<p>
*args - дополнительные аргументы, доступные в скрипте через arguments[index]
<p>
<b>Передача аргументов</b>
<pre>
# Пример передачи элемента в JavaScript
element = browser.find_element(By.ID, 'my-button')
browser.execute_script("arguments[0].click();", element) # Эмуляция клика

# Пример передачи нескольких аргументов
browser.execute_script(
    "arguments[0].style.backgroundColor = arguments[1];", 
    element, 
    "red"
)
</pre>
<b>Возврат значений</b><br>
Для получения значений из JavaScript используйте ключевое слово return:
<pre>
# Получение значения из JavaScript
height = browser.execute_script("return window.innerHeight;")
print(f"Высота окна: {height}px")

# Получение нескольких значений
dimensions = browser.execute_script("""
    return {
        width: window.innerWidth,
        height: window.innerHeight,
        scrollY: window.scrollY
    }
""")
print(f"Размеры окна: {dimensions}")
</pre>
<b>Манипуляции с элементами</b>
<pre>
# Изменение стилей
browser.execute_script("""
    arguments[0].style.border = '2px solid red';
    arguments[0].style.backgroundColor = 'yellow';
""", element)

# Изменение атрибутов
browser.execute_script("""
    arguments[0].setAttribute('data-test', 'value');
    arguments[0].removeAttribute('disabled');
""", element)
</pre>
В методе .execute_script() можно использовать различные полезные параметры. Ниже приведены те, которые чаще всего используются при написании парсеров:<br>
<ul>
<li> <b>.execute_script("return arguments[0].scrollIntoView(true);", element)</b> — прокручивает родительский контейнер элемента таким образом, чтобы element, для которого вызывается scrollIntoView, был виден пользователю.
<p>
<li> <b>.execute_script("window.open('http://parsinger.ru', 'tab2');") — создаст новую вкладку в браузере с именем "tab2".</b>
<p>
<li> .execute_script("return document.body.scrollHeight") — вернёт значение высоты элемента <body>.
<p>
<li> .execute_script("return window.innerHeight") — вернёт значение высоты окна браузера.
<p>
<li> .execute_script("return window.innerWidth") — вернёт значение ширины окна браузера.
<p>
<li> <b>.execute_script("window.scrollBy(X, Y)")</b> — прокрутит документ на заданное число пикселей по осям X и Y.<br>
X — смещение в пикселях по горизонтали.<br>
Y — смещение в пикселях по вертикали.
<p>
<li> .execute_script("alert('Ура Selenium')") — вызывает модальное окно Alert.
<p>
<li> .execute_script("return document.title;") — возвращает title открытого документа.
<p>
<li> .execute_script("return document.documentURI;") — возвращает URL документа.
<p>
<li> .execute_script("return document.readyState;") — возвращает состояние загрузки страницы; вернёт "complete", если страница загрузилась.
<p>
<li> .execute_script("return document.anchors;") — возвращает список всех якорей на странице.
<p>
[x.tag_name for x in browser.execute_script("return document.anchors;")] — этот код позволяет получить список всех тегов с якорями. Очень полезная инструкция, особенно если при скроллинге элемент для "зацепления" не найден.
<p>
<li> .execute_script("return document.cookie;") — возвращает строку, содержащую все cookies документа, разделённые точкой с запятой.
<p>
<li> .execute_script("return document.domain;") — возвращает домен текущего документа.
<p>
<li> .execute_script("return document.forms;") — возвращает список всех форм на странице.
<p>
<li> .execute_script("window.scrollTo(x-coord, y-coord);") — прокручивает документ до указанных координат:<br>
x-coord — позиция по горизонтальной оси, которая будет отображена вверху<br>
y-coord — позиция по вертикальной оси, которая будет отображена вверху слева.
<p>
<li> .execute_script("return document.getElementsByClassName('container');") — возвращает список всех элементов с классом 'container'.
<p>
<li> .execute_script("return document.getElementsByTagName('container');") — возвращает список всех элементов с тегом 'container'.
<p> 
<li> .execute_script("return document.getElementById('some-id');") —  возвращает элемент с указанным ID 'some-id'.
</ul>
<p>
<b>browser.execute_async_script("script_code" , *args )</b> - Асинхронно выполняет JavaScript код. Удобно для работы с AJAX и промисами.
<p>
<b>Время ожидания</b><br>
<b>browser.set_page_load_timeout()</b> - Устанавливает таймаут на загрузку страницы. Выбрасывает исключение, если время вышло.
<p>
<b>Поиск элементов</b><br>
<b>browser.find_element(By.ID, 'example_id')</b> - Возвращает первый найденный элемент по заданному локатору.
<p>
<b>browser.find_elements(By.ID, 'example_id')</b> - Возвращает список всех элементов, соответствующих локатору.
<p>
<b>Работа с окном браузера</b><br>
<b>browser.get_window_position()</b> - Возвращает словарь с текущей позицией окна браузера ({'x': 10, 'y': 50}).
<p>
<b>browser.maximize_window()</b> - Разворачивает окно на весь экран.
<p>
<b>browser.minimize_window()</b> - Сворачивает окно.
<p>
<b>browser.fullscreen_window()</b>  - Переводит окно в полноэкранный режим, как при нажатии F11.
<p>
<b>browser.get_window_size()</b> - Возвращает размер окна в виде словаря ({'width': 945, 'height': 1020}).
<p>
<b>browser.set_window_size(800,600)</b> - Устанавливает новый размер окна.
<p>
<b>Ожидание элементов</b><br>
<b>browser.implicitly_wait(10)</b> - Устанавливает неявное ожидание на поиск элементов или выполнение команд.
<p>
<b>WebDriverWait(browser, timeout).until(condition)</b>
<p>
<b>Работа с элементами</b><br>
<b>element.click()</b> - Симулирует клик по элементу.
<p>
<b>element.send_keys("text")</b> - Вводит текст в текстовое поле. Очень полезно для автоматизации ввода данных.
<p>
<b>element.clear()</b> - Очищает текстовое поле.
<p>
<b>element.is_displayed()</b> - Проверяет, отображается ли элемент на странице.
<p>
<b>element.is_enabled()</b> - Проверяет, доступен ли элемент для взаимодействия (например, не заблокирован).
<p>
<b>element.is_selected()</b> - Проверяет, выбран ли элемент (актуально для радиокнопок и чекбоксов).
<p>
<b>element.get_attribute("attribute")</b> - Возвращает значение указанного атрибута элемента.
<p>
<b>element.text</b> - Возвращает текст элемента.
<p>
<b>element.submit()</b> - Отправляет форму, в которой находится элемент.
 <p>
<b>Фреймы</b><br>
<b>browser.switch_to.frame("frame_name")</b> - Переключает фокус на указанный фрейм.
<p>
<b>browser.switch_to.default_content()</b> - Возвращает фокус на основное содержимое страницы, выходя из фрейма.
<p>
<b>JavaScript Alerts</b><br>
<b>browser.switch_to.alert</b> - Переключает фокус на всплывающее окно JavaScript.
</ul>
<a name="cook"><h3 align=center><font color=brown>Работа с cookies</font></h3>
<b>browser.get_cookies()</b>  - Возвращает список словарей, где значение в словаре - это куки.
<p>
<b>browser.get_cookie(name_cookie)</b> - Возвращает конкретную cookie по имени.
<p>
<b>browser.add_cookie(cookie_dict)</b> - Добавляет новую cookie к вашему текущему сеансу;<br>
это метод, который добавляет cookie в ваш браузер. Он принимает словарь, но с определёнными ограничениями: мы не можем передать в cookie что угодно. В браузере есть заранее подготовленные поля, в которые мы можем передавать данные.
<pre>
# Добавляет файл cookie в текущий контекст браузера.
browser.add_cookie({"name": "key", "value": "value"})
</pre>
Доступные поля для cookie можно посмотреть в любом браузере. Эти поля доступны для передачи их в словаре.
<ul>
<li> "name" — устанавливает имя cookie-файла;
<p> 
<li> "value" — устанавливает значение cookie; это значение может либо идентифицировать пользователя, либо содержать любую другую служебную информацию;
<p>
<li> "expires" и "max-age" — определяют срок жизни cookie; после истечения этого срока, cookie будет удалён из памяти браузера. Если не указывать эти значения, содержимое cookie будет удалено после закрытия браузера;
<p> 
<li> "path" — указывает путь к директории на сервере, для которой будут доступны cookie. Чтобы cookie были доступны по всему домену, необходимо указать "/";
 <p>
<li> "domain" — хранит в себе информацию о домене или поддомене, которые имеют доступ к этой cookie. Если необходимо, чтобы cookie были доступны по всему домену и всем поддоменам, указывается базовый домен, например, www.example.ru;
<p>
<li> "secure" — указывает серверу, что cookie должны передаваться только по защищённому HTTPS-соединению;
<p>
<li> "httponly"— этот параметр запрещает доступ к cookie через JavaScript (API браузера document.cookie). Предотвращает кражу cookie посредством XSS-атак. Если флаг установлен в True, вы сможете получить доступ к этой cookie только через браузер, в том числе и через Selenium;
<p>
<li> "samesite"— ограничивает передачу cookie между сайтами и предотвращает кражу cookie посредством XSS-атак. Имеет три состояния.<br>
SameSite=None — на передачу cookie нет никаких ограничений;<br>
SameSite=Lax — разрешает передачу только безопасным HTTP-методам;<br>
SameSite=Strict или SameSite — самое строгое состояние, которое запрещает отправку cookie на другие сайты.
</ul>
Пример:
<pre>
import time
from pprint import pprint
from selenium import webdriver

cookie_dict = {
    'name': 'any_name_cookie',    # Любое имя для cookie
    'value': 'any_value_cookie',  # Любое значение для cookie
    'expiry': 2_000_000_000,      # Время жизни cookie в секундах
    'path': '/',                  # Директория на сервере дял которой будут доступны cookie
    'domain': 'parsinger.ru',     # Информация о домене и поддомене для которых доступны cookie
    'secure': True,  # or False   # Сигнал браузера о том что передать cookie только по защищённому HTTPS
    'httpOnly': True,  # or False # Ограничивает достук к cookie по средствам API
    'sameSite': 'Strict',  # or lax or none # Ограничение на передачу cookie между сайтами
}

with webdriver.Chrome() as browser:
    browser.get('https://parsinger.ru/methods/4/index.html')
    browser.add_cookie(cookie_dict)
    pprint(browser.get_cookies())
    time.sleep(100)
</pre>
<p>
Все ключи словаря cookie_dict={} соответствуют полям cookie в браузере. Поэтому изменять ключи в этом словаре не рекомендуется: если вы это сделаете, ничего не произойдёт. Словарь просто не запишется в cookie браузера. Изменять можно только значения этого словаря, и то, следуя определённым правилам. <b>Вы имеете полную свободу изменения только для значений ключей "name" и "value"; остальные значения в ключах подчиняются строгим правилам</b>. Это могут быть правила касающиеся времени жизни cookie (Expires, Max-Age), домена (Domain), пути (Path), флагов безопасности (Secure, HttpOnly) и так далее.
<p>
<i>Интересная особенность. Попробовал скопировать куки в браузер через селениум, чтобы степик открывался с авторизацией от своего имени в новом окне. Всё прошло успешно... Почти. НО! Если вы попытаетесь сначала ввести куки, а уже потом обратиться по url, чтобы зайти авторизированным, то получите ошибку домена: selenium.common.exceptions.InvalidCookieDomainException: Message: invalid cookie domain<br>
Селениум запрещает ставить куки, если вы не обратились к конкретному домену заранее. Поэтому сначала делаем .get(url) , и только после этого устаналиваем куки. Далее я делал .refresh() и оказывался авторизированным.</i>
<p>
<b>browser.delete_cookie(name_cookie)</b> - Удаляет cookie по имени.
<p>
<b>browser.delete_all_cookies()</b> - удаляет все файлы cookie в рамках текущего сеанса;
<pre>

</pre>
<a name="scrolling"><h2 align=center>Способы прокрутки страницы</h2>
Страница может быть динамически изменяемой и потому find_elements может выдать неполный список.<br>
Пример:<br>
Допустим, вы открыли сайт с бесконечной лентой. Пока вы не пролистаете страницу вниз, в DOM дереве будут только видимые элементы, которые загрузились вначале страницы. Вы выполняете поиск всех элементов с классом post:<br>
posts = find_elements(By.CLASS_NAME, "post")<br>
На данный момент в переменной posts хранится 10 элементов. Вы можете проитерировать их и извлечь необходимые данные. Но что произойдет, если вы прокрутите страницу дальше? Элементы динамически подгрузились в DOM-дерево. Однако переменная posts этого «не заметила», ведь она не обновляется автоматически. Это и есть основная проблема динамической подгрузки элементов. Чтобы избежать этой проблемы, необходимо вести учет обработанных элементов в отдельном списке.
<p>
Динамическая подгрузка (или «бесконечный скролл») означает, что:
<ul>
<li> Не все данные загружаются сразу – в DOM-дереве видны лишь первые элементы.
<li> Новые элементы подгружаются при прокрутке – сервер добавляет их только тогда, когда пользователь добирается до конца текущей порции данных.
<li> Есть задержки в загрузке – поскольку серверу требуется время для обработки запроса, код должен учитывать возможные паузы и дожидаться появления новых элементов, а не пытаться получить их мгновенно.
</ul>
Вывод: Ваш код должен не только прокручивать страницу, но и следить за появлением новых элементов. В противном случае:
<ul>
<li> Вы получите не весь набор данных.
<li> Ваш парсер может столкнуться с ошибками, если попытается работать с еще не загруженными элементами.
</ul>
<a name="scroll_script"><h3 align=center>Прокрутка страницы с помощью скрипта execute_script()</h3>
Полоса прокрутки представляет собой тонкую, длинную часть на краю дисплея компьютера. Используя полосу прокрутки, мы можем просматривать весь контент или всю страницу, прокручивая её вверх и вниз или влево и вправо с помощью мыши. Самый простой способ <b>прокрутки страницы по пикселям</b> — это использование метода .execute_script(), который выполняет код JavaScript на странице. К примеру, window.scrollBy(0, 5000) прокрутит страницу вниз на 5000 пикселей.
<p>
<b>window.scrollBy(X, Y)</b><br>
X - смещение в пикселях по горизонтали;<br>
Y - смещение в пикселях по вертикали.
<pre>
import time
from selenium import webdriver

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/scroll/1/')
    browser.<b>execute_script("window.scrollBy(0,5000)")</b>
    time.sleep(10)
</pre>
Такой способ имеет свои преимущества, простота использования — одно из них. Недостаток такого способа заключается в том, что если сайт отдаёт данные при каждом скроллинге, вам придётся ждать, пока сервер загрузит данные. К примеру, на Степике комментарии загружаются по 17 штук, и если под степом 170 комментариев, то вам придётся сделать 10 скроллов, чтобы получить их все. Каждая загрузка 17 комментариев занимает примерно 2–3 секунды, соответственно, вам необходимо устанавливать тайминги. Самый простой способ сделать это — time.sleep(3).
<p>
Представим, что у вас есть сайт, который имеет разные высоты страниц. Мы можем получить значение высоты непосредственно той части сайта, которая попадает в область вашей видимости, или значение высоты всего сайта.
<p>
Команда <b>return document.body.scrollHeight</b> вернёт значение высоты основного элемента на странице — body.
<pre>
import time
from selenium import webdriver

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/scroll/1/')
    height = browser.<b>execute_script("return document.body.scrollHeight")</b>
    time.sleep(2)
    print(height)

>>>81000
</pre>
Наш сайт имеет высоту 81 000 пикселей. Для вычисления высоты видимой области сайта используется скрипт.
<p>
Код <b>window.innerHeight</b> используется для получения высоты, а <b>window.innerWidth</b> — для получения ширины <b>видимой области</b>.
<pre>
from selenium import webdriver

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/scroll/1/')
    height = browser.<b>execute_script("return window.innerHeight"</b>)  # видимая часть страницы
    print(height)

>>> 887
</pre>
На нашем сайте видимая область составляет 887 пикселей. Определённые методы, такие как .click() или .send_keys()и др., могут быть выполнены только в случае, если нужный элемент расположен в этой видимой зоне экрана.
<h4>Прокрутка страницы до самого низа</h4>
Если вам необходимо прокрутить страницу до самого низа, до последнего пикселя, одним из самых простых способов будет использование скрипта <b>window.scrollTo(0, document.body.scrollHeight)</b>.
<pre>
import time
from selenium import webdriver

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/scroll/1/')
    browser.<b>execute_script("window.scrollTo(0, document.body.scrollHeight);")</b>  # до конца всей страницы
    time.sleep(2)
</pre>
Где значение 0 означает горизонтальное смещение в пикселях от начальной точки прокрутки. В данном случае, 0 говорит о том, что прокрутка будет совершена без горизонтального смещения, то есть по вертикали.
<p>
Можно еще написать код прокрутки страницы при помощи f строк:
<pre>
import time
from selenium import webdriver

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/scroll/1/')
    <b>height = browser.execute_script('return document.body.scrollHeight')
    browser.execute_script(f'window.scrollBy(0, {height})')</b>
    time.sleep(1)
</pre>
<p>
При написании парсеров часто необходимо сначала совершить необходимое количество скроллинга, чтобы загрузилась вся нужная вам информация. После того, как вся необходимая информация появилась на странице, мы собираем всё при помощи метода .find_elements().
<a name="scroll_keys"><h3 align=center>Прокрутка содержимого страницы с помощью класса Keys (нажатия определенных клавиш)</h3>
В Selenium представлены различные действия, которые можно выполнить с помощью клавиатуры. В основном, можно выполнять два действия:
<ul>
<li> Нажать клавишу,
<li> Отпустить нажатую клавишу.
</ul>
Класс Keys в <b>selenium.webdriver.common.keys</b> – это просто набор констант для клавиш (например, Keys.ENTER, Keys.SHIFT). Но сами методы key_down() и key_up() принадлежат классу <b>ActionChains</b>, который используется для эмуляции сложных взаимодействий с клавиатурой и мышью, который мы рассмотрим с следующем уроке.
<p>
<b>Нажатие клавиши (Key down)</b>:
<pre>
<b>from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains</b>

browser = ... # инициализация драйвера
<b>ActionChains(browser).key_down(Keys.SHIFT).send_keys("abc").perform()</b>
</pre>
<p>
<b>Отпускание клавиши (Key up)</b>
<pre>
ActionChains(browser).key_down(Keys.SHIFT).send_keys("a").<b>key_up(Keys.SHIFT).send_keys("b").perform()</b>
</pre>
Импортируем:  
<pre>
from selenium.webdriver import Keys 
</pre>
или 
<pre>
from selenium.webdriver.common.keys import Keys
</pre>
<p>
Откроем наш <a href="http://parsinger.ru/scroll/1/">сайт</a>. На нём находится 100 тегов &lt;input>, с которыми мы будем взаимодействовать с помощью класса Keys. Таким образом взаимодействовать можно только с интерактивными элементами:
<p>
<b>Интерактивные элементы</b> предназначены для взаимодействия с пользователем. Это могут быть кнопки, которые можно нажать, ссылки, по которым можно перейти, или поля ввода, в которые можно ввести текст. Они реагируют на действия пользователя, такие как клики мышью или нажатия клавиш. Примеры таких элементов включают в себя кнопки (&lt;button>), ссылки (&lt;a>), поля ввода (&lt;input>) и другие подобные элементы.
 <p>
<b>Неинтерактивные элементы</b>, напротив, предназначены в основном для отображения информации. Они не реагируют на действия пользователя так, как это делают интерактивные элементы. Примеры включают в себя абзацы с текстом (&lt;p>), элементы списка (&lt;li>), табличные элементы (&lt;tr>, &lt;td>) и так далее.
<pre>
import time
from selenium.webdriver import Keys
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/scroll/1/')
    browser.find_element(By.TAG_NAME, 'input').<b>send_keys(Keys.TAB)</b>
    time.sleep(10)
</pre>
.send_keys(Keys.TAB) симулирует ввод с клавиатуры. В данном случае симулируется нажатие клавиши TAB. Это может переместить фокус на следующий интерактивный элемент на странице после найденного &lt;input>.
<p>
Чтобы взаимодействовать подобным образом с остальными элементами &lt;input>, нам потребуется цикл while, если мы не знаем точного количества элементов, или цикл for, если точное количество элементов нам известно(не забываем фактор бесконечной загрузки элементов в боевых условиях).
<pre>
import time
from selenium.webdriver import Keys
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/scroll/1/')
    tags_input = browser.find_element<b>s</b>(By.TAG_NAME, 'input')

    for input in tags_input:
        input.send_keys(<b>Keys.DOWN</b>)
        time.sleep(1)
</pre>
В цикле for код проходит по каждому найденному элементу input и выполняет следующие действия:<br>
input.send_keys(Keys.DOWN): "нажимает" клавишу "Вниз" (DOWN) в текущем элементе input. Это может привести к изменению значения элемента или к другому действию, в зависимости от типа и функционала элемента.
Запустите этот код у себя, и вы увидите, что он поочередно выделяет (берет в фокус) все элементы &lt;input> на странице. Страница сайта-тренажера сразу отображает весь список тегов &lt;input>.
<p>
Для понимания следующего примера откройте любой степ на Степике с более чем 100 комментариями и попробуйте пролистать до самого последнего комментария. Вы увидите несколько загрузок с сервера. Приведенный выше пример с циклом for обработал бы только первые 17 элементов, так как они были загружены при открытии страницы. Чтобы решить эту проблему и обрабатывать все подгружаемые элементы, давайте модифицируем этот код.
<pre>
import time
from selenium.webdriver import Keys
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get(r"https://parsinger.ru/selenium/5.7/3/index.html")

    list_input = []      # Инициализируем пустой список для хранения обработанных элементов ввода
    while True:          # Начинаем бесконечный цикл

        # Ищем все элементы input на веб-странице и добавляем их в список input_tags
        input_tags = [x for x in browser.find_elements(By.TAG_NAME, 'input')]

        # Обходим каждый элемент input в списке
        for tag_input in input_tags:
            # Проверяем, не обрабатывали ли мы уже этот элемент ранее
            if tag_input not in list_input:
                tag_input.send_keys(Keys.DOWN)     # Отправляем клавишу "Вниз"          
                tag_input.click()                  # Кликаем на элемент
                time.sleep(.3)
                list_input.append(tag_input)       # Добавляем элемент в список обработанных элементов
</pre>
Обратите внимание, что страница имитирует "бесконечную" ленту. Перейдите на неё вручную и прокрутите вниз, наблюдая за появляющимися HTML-тегами. В тот момент, когда вы достигнете финала прокрутки, именно так ведёт себя "бесконечная" прокрутка (Infinite scroll).<br>
Пояснение к коду:
<ul>
<li> Создаём пустой список list_input, который будет использоваться для хранения элементов &lt;input>, с которыми уже произведены какие-либо действия (нажатия клавиш или клики).
<pre>
list_input = []  # Инициализируем пустой список для хранения обработанных элементов ввода
</pre>
<li> Выполняем поиск всех элементов с тегом &lt;input> на текущей веб-странице и сохраняет их в список input_tags.
<pre>
input_tags = [x for x in browser.find_elements(By.TAG_NAME, 'input')]
</pre>
<li> Перебираем каждый найденный элемент &lt;input>.
<pre>
for tag_input in input_tags:
</pre>
<li> Проверяем, находится ли текущий элемент tag_input в списке list_input. Если элемент уже был обработан ранее, он будет в этом списке, и следующие действия с ним производиться не будут.
<pre>
if tag_input not in list_input:
</pre>
<li> Симулируем нажатие клавиши "Вниз" (Keys.DOWN) в текущем элементе tag_input, для прокрутки страницы с элементами вниз.
<pre>
tag_input.send_keys(Keys.DOWN)  # Отправляем клавишу "Вниз"
</pre>
<li> Затем симулируется клик по текущему элементу tag_input, если это необходимо вашей задачей.
<pre>
tag_input.click()  # Кликаем на элемент
</pre>
<li> Наконец, текущий элемент tag_input добавляется в список list_input, чтобы в будущем не обрабатывать его повторно.
<pre>
list_input.append(tag_input)  # Добавляем элемент в список обработанных элементов
</pre> 
</ul>
Важно: если использовать send_keys(Keys.DOWN) и убрать time.sleep() то возможны пропуски чек-боксов. Это происходит по нескольким причинам: 
<ol>
<li> DOM может не успевать обновляться<br>
Некоторые страницы используют JavaScript, который может изменять DOM после клика на чекбокс. Если time.sleep(0.3) убрать, Selenium может слишком быстро проходить по input_tags, не дожидаясь обновления.
<li> Некорректное обновление списка input_tags<br>
После клика может происходить динамическое обновление DOM (например, добавление новых элементов или изменение атрибутов), но код не делает паузу, чтобы дождаться этого.
<li> Слишком быстрое выполнение цикла<br>
Если чекбоксы обрабатываются слишком быстро, возможны ситуации, когда Selenium не фиксирует клик, либо происходит конфликт, если страница обновляет чекбоксы асинхронно.
</ol>
<p>
Доступные к применению клавиши:
<pre>
ADD	ALT	ARROW_DOWN
ARROW_LEFT	ARROW_RIGHT	ARROW_UP
BACKSPACE	BACK_SPACE	CANCEL
CLEAR	COMMAND	CONTROL
DECIMAL	DELETE	DIVIDE
DOWN	UP	ENTER
EQUALS	ESCAPE	F1
F10	F11	F12
F2	F3	F4
F5	F6	F7
F8	F9	HELP
HOME	INSERT	LEFT
LEFT_ALT	LEFT_CONTROL	LEFT_SHIFT
META	MULTIPLY	NULL
NUMPAD0	NUMPAD1	NUMPAD2
NUMPAD3	NUMPAD4	NUMPAD5
NUMPAD6	NUMPAD7	NUMPAD8
NUMPAD9	PAGE_DOWN	PAGE_UP
PAUSE	RETURN	RIGHT
SEMICOLON	SEPARATOR	SHIFT
SPACE	SUBTRACT	
TAB

END
</pre>
<pre>

</pre>
<a name="actionchains"><h3 align=center>ActionChains(browser)(Цепочка действий)</h3>
Это способ автоматизации низкоуровневых взаимодействий, таких как движения мыши, действия с кнопками мыши, нажатие клавиш и взаимодействие с контекстным меню.<br>
ActionChains — класс, предназначенный для автоматизации сложных последовательностей действий пользователя.
<pre>
# Import 
from selenium.webdriver.common.action_chains import ActionChains


# Использование ActionChains для выполнения последовательности действий

actions = ActionChains(browser) # Создаём экземпляр класса ActionChains
actions.move_to_element(menu)  # Переместить курсор на элемент меню
actions.click(submenu)         # Кликнуть по подменю
actions.perform()              # Выполнить накопленные действия
</pre>
Особенности и преимущества:
<ul>
<li> Цепочка действий: Одной из ключевых особенностей ActionChains является возможность создания цепочек действий, которые выполняются последовательно. Это позволяет имитировать сложные действия пользователя.
<p>
<li> Гибкость: С помощью ActionChains можно легко комбинировать различные действия, такие как клики, двойные клики, нажатия клавиш и другие, чтобы создать сложные сценарии взаимодействия.
<p>
<li> Точное взаимодействие: Для сценариев, где требуется высокая точность (например, рисование на холсте или игры), ActionChains предоставляет методы для точного управления движением мыши.
</ul>
<h4>Методы ActionChains(browser):</h4>
<pre>
​​​​​​​actions = ActionChains(browser) # Создаём экземпляр класса ActionChains
element = browser.find_element(By.ID, "draggable") # Находим необходимый элемент/тег
</pre> 
<ul>
<li> <b>action.perform(self)</b> — Метод используется для выполнения всех сохраненных операций в экземпляре действия класса ActionChains. Запускает всю цепочку действий. 
<p>
<li> <b>action.click(element)</b> — Кликает по элементу.
<p>
<li> <b>action.double_click(element)</b> — Имитация двойного клика левой кнопки мыши.
<p>
<li> <b>action.click_and_hold(element)</b> — Удерживает левую кнопку мыши на элементе.
<pre>
# Использование ActionChains для удержания левой кнопки мыши на элементе
actions = ActionChains(browser)
actions.click_and_hold(element_to_hold).perform()
</pre>
<p> 
<li> <b>action.context_click(element)</b> — Используется для выполнения контекстного щелчка (щелчка правой кнопкой мыши) по элементу.
<p>
<li> <b>action.drag_and_drop(source, target)</b> — Удерживает левую кнопку мыши на исходном элементе, затем перемещается к целевому элементу и отпускает кнопку мыши. 
<pre>
# Найти исходный и целевой элементы на странице с использованием локаторов By
source = browser.find_element(By.ID, "source_element_id")
target = browser.find_element(By.ID, "target_element_id")

# Использование ActionChains для выполнения перетаскивания элемента
actions = ActionChains(browser)
actions.drag_and_drop(source, target).perform()
</pre>
source: Это исходный элемент, который вы хотите перетащить. source представляет собой тег, который вы хотите "взять" или начать перетаскивание. Обычно это элемент, который вы хотите переместить на другое место на веб-странице.
<p>
target: Это целевой элемент, на который или к которому вы хотите перетащить исходный элемент. target представляет собой тег, на который или к которому вы хотите "отпустить" или завершить перетаскивание исходного элемента. Это место назначения, куда вы хотите переместить исходный элемент на веб-странице.
​​​​​​​<p>
<li> <b>action.release(self, on_element=None)</b>  — Метод release используется для отпускания удерживаемой кнопки мыши на элементе.
<p>
self: Относится к текущему экземпляру объекта ActionChains, с которым вы работаете.
<p>
on_element=None: Это параметр, который представляет собой элемент, на котором вы хотите отпустить кнопку мыши. Если этот параметр не указан (по умолчанию None), кнопка мыши будет отпущена на текущем положении курсора. Если вы укажете конкретный элемент в качестве on_element, кнопка мыши будет отпущена на этом элементе.
<p>
<li> <b>action.drag_and_drop_by_offset(source, xoffset, yoffset)</b>  — Удерживает левую кнопку мыши на исходном элементе, затем перемещается к заданному смещению и отпускает кнопку мыши. Этот метод используется для перемещения элемента на заданное расстояние по координатам (x, y) относительно его текущего положения.
<pre>
# Использование ActionChains для выполнения перетаскивания элемента на заданное смещение
actions = ActionChains(browser)
actions.drag_and_drop_by_offset(source_element, 50, 100).perform()  # Перемещает элемент на 50px вправо и 100px вниз
</pre>
source: Элемент для мыши.<br>
xoffset: X смещение для перехода.<br>
yoffset: Y смещение для перехода.
<p>
<li> <b>action.key_down(value, element)</b> — Отправляет только нажатие клавиши, не отпуская ее. Следует использовать только с клавишами-модификаторами (Control, Alt и Shift).
<pre>
# Использование ActionChains для удержания клавиш
actions = ActionChains(browser)
actions.key_down(Keys.CONTROL, element) \
       .key_down(Keys.ALT) \
       .key_down(Keys.SHIFT) \
       .key_down('T') \
       .perform()
</pre>
value: Параметр представляет собой значение клавиши, которую вы хотите нажать. value может быть любой клавишей на клавиатуре, любыми клавишами (A, B, C и т. д.). Значения для этих клавиш обычно определены в классе Keys в Selenium. 
<p> 
element: Параметр представляет собой элемент на веб-странице, к которому вы хотите отправить команду нажатия клавиши. Если этот параметр указан, клавиша будет "нажата" на этом конкретном элементе.
<p>
<li> <b>action.key_up(value, element)</b>  — Метод используется для отпускания нажатой клавиши с помощью метода key_down.
<pre>
# После выполнения необходимых действий, не забудьте отпустить клавиши
actions.key_up(Keys.CONTROL) \
       .key_up(Keys.ALT) \
       .key_up(Keys.SHIFT) \
       .key_up('T') \
       .perform()
</pre>
value: параметр представляет собой значение клавиши, которую вы хотите отпустить. В контексте функции key_up, value обычно представляет собой константу из класса Keys, которая соответствует определенной клавише на клавиатуре. Например, Keys.CONTROL, Keys.ALT или Keys.SHIFT.
<p>
element:параметр, который представляет собой элемент, на котором вы хотите выполнить действие отпускания клавиши. Если этот параметр указан, клавиша будет отпущена на указанном элементе. Если этот параметр не указан, клавиша будет отпущена на текущем элементе в фокусе.
<p>
<li> <b>action.move_by_offset(xoffset, yoffset)</b>  — Позволяет перемещать курсор мыши на определенное расстояние от его текущего положения на экране. Это особенно полезно, когда вы хотите выполнить точное перемещение курсора без необходимости ссылаться на конкретный элемент на веб-странице.
<pre>
# Использование move_by_offset для перемещения курсора мыши на 50px вправо и 100px вниз
actions.move_by_offset(50, 100).perform()
</pre>
xoffset: Горизонтальное смещение, на которое вы хотите переместить курсор мыши относительно его текущего положения. Значение может быть положительным (для перемещения вправо) или отрицательным (для перемещения влево).
<p>
yoffset: Вертикальное смещение, на которое вы хотите переместить курсор мыши относительно его текущего положения. Значение может быть положительным (для перемещения вниз) или отрицательным (для перемещения вверх).
<p>
<li> <b>action.move_to_element(to_element)</b>  — Метод используется для перемещения мыши в середину элемента.
<pre>
# Найти элемент на странице, к которому вы хотите переместить курсор
menu_element = browser.find_element(By.ID, "menu_item")

# Использование ActionChains для перемещения курсора к элементу
actions = ActionChains(browser)
actions.move_to_element(menu_element).perform()
</pre>
to_element: Элемент, к которому вы хотите переместить курсор мыши. В контексте функции, to_element должен быть объектом WebElement, который вы хотите указать или на который хотите навести курсор.
<p>
<li> <b>action.move_to_element_with_offset(to_element, xoffset, yoffset)</b> — Метод используется для перемещения мыши на смещение указанного элемента. Смещения относятся к верхнему левому углу элемента.
<pre>
# Переместить курсор мыши на 50px вправо и 30px вниз от верхнего левого угла элемента element_to_hover
actions.move_to_element_with_offset(element_to_hover, 50, 30).perform()
</pre>
to_element: WebElement, к которому нужно перейти.<br>
xoffset: X смещение для перехода.<br>
yoffset: Y смещение для перехода.
<p>
<li> <b>action.pause(seconds)</b> — Метод паузы используется для приостановки всех входящих данных на указанное время в секундах. Метод паузы очень важен и полезен в случае выполнения какой-либо команды, для загрузки которой требуется какой-либо JavaScript, или в подобной ситуации, когда между двумя операциями есть временной промежуток.
<p>
<li> <b>action.send_keys(Keys.DOWN)</b> — метод используется для отправки ключей текущему элементу в фокусе;<br>
Keys.DOWN:  - значения  клавиши определены в классе Keys. 
<p>
<li> <b>action.send_keys_to_element(element, *keys_to_send)</b> — Метод используется для отправки клавиш в конкретный элемент на веб-странице.
<pre>
# Найти элемент на странице с использованием локатора By
input_element = browser.find_element(By.ID, "inputField")

# Использование ActionChains для отправки нажатия клавиш элементу
actions = ActionChains(browser)
actions.send_keys_to_element(input_element, "Hello", Keys.SPACE, "World!").perform()
</pre>
element: Элемент, к которому вы хотите отправить нажатия клавиш. Это должен быть объект WebElement, который вы уже нашли на веб-странице.
<p>
*keys_to_send: Последовательность клавиш, которые вы хотите отправить к указанному элементу. Вы можете отправить одну или несколько клавиш, используя этот параметр. Клавиши могут быть представлены строками (например, "Hello") или константами из класса Keys (например, Keys.ENTER или Keys.TAB). Звездочка (*) перед keys_to_send в сигнатуре функции указывает на то, что метод может принимать переменное количество аргументов, переданных как отдельные параметры.
<p>
<li> <b>action.scroll(x, y, delta_x, delta_y, duration, origin=element)</b>  —  Выполняет скроллинг на элементе, где установлен курсор. Очень полезный скроллинг, позволяет прицельно скролить окна маленьких размеров;
<p>
x: Координата по горизонтали, где установлен курсор. Она определяет начальное положение курсора по оси X перед началом скроллинга.<br>
y: Координата по вертикали, где установлен курсор. Она определяет начальное положение курсора по оси Y перед началом скроллинга.<br>
delta_x: Расстояние, на которое курсор будет прокручиваться по горизонтали (оси X). Положительное значение прокрутит содержимое вправо, отрицательное — влево.<br>
delta_y: Расстояние, на которое курсор будет прокручиваться по вертикали (оси Y). Положительное значение прокрутит содержимое вниз, отрицательное — вверх.<br>
duration: Время (в секундах), которое будет затрачено на выполнение скроллинга. Это позволяет контролировать скорость прокрутки.<br>
origin: Элемент, относительно которого будет выполняться скроллинг. Если этот параметр не указан, скроллинг будет выполняться относительно текущего положения курсора. Если указан конкретный элемент, скроллинг будет выполняться относительно этого элемента.
​​​​​​​<p>
<li> <b>action.reset_actions(self)</b> — Метод очищает действия, которые уже сохранены локально и в ActionChains. Это один из наиболее часто используемых методов, так как после какой-либо операции необходимо сбросить экземпляр ActionChains для выполнения следующей операции.
<p>
​​​​​​​<li> <b>action.scroll_by_amount(delta_x, delta_y)</b><br>
В версии Selenium 4.2 появился замечательный метод .scroll_by_amount(), который позволяет скролить любое окно на заданное количество пикселей. Этот метод намного упрощает взаимодействие с окнами, в которых присутствует элемент скроллинга. Чтобы этот метод заработал, обновите ваш selenium до последней версии.
<p> 
- delta_x: расстояние по оси X для прокрутки с помощью колеса. Отрицательное значение прокручивается влево.
<p>  
- delta_y: расстояние по оси Y для прокрутки с помощью колеса. Отрицательное значение прокручивается вверх.
Этот метод работает в цепочке событий ActionChains.
<p>
Пример:
<pre>
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get('https://parsinger.ru/infiniti_scroll_2/')
    div = browser.find_element(By.XPATH, '//*[@id="scroll-container"]/div')
    while True:
        ActionChains(browser).<b>move_to_element(div).scroll_by_amount(1, 500)</b>.perform()
</pre>
Как это работает:
<ol>
<li> В переменной div мы определяем окно, которое мы собираемся прокручивать, оно должно иметь полосу прокрутки, иначе ничего не произойдет.
<li> Цикл while для постоянной прокрутки, без цикла скроллинг происходит один раз, что не подойдет для бесконечно подгружаемых элементов.
<li> ActionChains(browser) - создаем цепочку событий.<br>
.move_to_element(div) - перемещаемся к элементу веб драйвера, который мы записали в переменную div.<br>
.scroll_by_amount(1, 500)  - скроллинг применяется к элементу в методе  .move_to_element(div).
</ol>
Как итог, мы получаем код, который бесконечно скролит элемент, и нужно думать над его прерыванием. Если мы знаем, какой длины список, мы можем использовать цикл for. Если вы уверены, что вам хватит прокрутить элемент 10 раз по 500px, то можно использовать такой подход.
<pre>
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get('https://parsinger.ru/infiniti_scroll_2/')
    div = browser.find_element(By.XPATH, '//*[@id="scroll-container"]/div')
    for x in range(10):
        ActionChains(browser).<b>move_to_element(div).scroll_by_amount(1, 500)</b>.perform()
</pre>
Ещё пример:
<pre>
actions = ActionChains(browser)
actions.<b>scroll_by_amount(delta_x=50, delta_y=100)</b>.perform()  # Прокрутка на 50 пикселей вправо и 100 пикселей вниз
</pre>
<p>
<li> <b>action.scroll_from_origin(scroll_origin, delta_x, delta_y)</b> — Выполняет прокрутку на указанное расстояние (delta_x, delta_y) относительно исходного положения (scroll_origin).
<p>
Чтобы импортировать ScrollOrigin в Selenium, используй следующий импорт:
<pre>
from selenium.webdriver.common.action_chains import ScrollOrigin
</pre>
scroll_origin: Точка, откуда начинается прокрутка. Может быть область просмотра (viewport) или центр элемента (element). 
<pre>
scroll_origin = ScrollOrigin.from_element(element_to_scroll)
# либо 
scroll_origin = ScrollOrigin.from_viewport(x_offset=0, y_offset=0)

# Метод ScrollOrigin.from_viewport() в Selenium используется для установки точки, относительно 
# которой будет происходить прокрутка. По умолчанию эта точка находится в центре экрана (viewport).

# И потом передаем scroll_origin первым аргументом
actions = ActionChains(browser)
actions.scroll_from_origin(scroll_origin, 0, 100).perform()
</pre>
delta_x: Расстояние по оси X для прокрутки с помощью колеса. Отрицательное значение прокручивает влево.<br>
delta_y: Расстояние по оси Y для прокрутки с помощью колеса. Отрицательное значение прокручивает вверх.
<pre>
# Находим элемент, который хотим прокрутить
element_to_scroll = browser.find_element(By.ID, "someElement")

# Создаем точку отсчета прокрутки от элемента
scroll_origin = ScrollOrigin.from_element(element_to_scroll)

# Создаем цепочку действий
actions = ActionChains(browser)

# Прокручиваем элемент вниз на 100 пикселей
actions.scroll_from_origin(scroll_origin, 0, 100).perform()
</pre>
<p>
<li> <b>action.scroll_to_element(element)</b> — Метод предназначен для автоматического прокручивания страницы к указанному элементу.
<pre>
# Найти элемент на странице
element = browser.find_element(By.ID, "someElement")

# Использование ActionChains для прокрутки к элементу
actions = ActionChains(browser)
actions.scroll_to_element(element).perform()
</pre>
</ul>
<pre>

</pre>
<a name="vkladka"><h3 align=center>Работа с вкладками</h3>
Вкладка браузера — это отдельное окно внутри одного окна браузера. Мы можем открывать сколько угодно вкладок, но работать можем только с активной. Если написать такой код:
<pre>
from selenium import webdriver
import time

with webdriver.Chrome() as browser:
    pass
    time.sleep(5)
</pre>
У вас откроется браузер с пустой вкладкой data
<p>
data: – стартовая вкладка, открываемая Selenium, имеет URL вида data:, или data:text/html,. Это тоже пустая страница, но она создаётся динамически. Из-за отсутствия полноценного HTML-контента, такой документ может не иметь тега &lt;title>, поэтому browser.title возвращает пустую строку.
<p>
Если написать такой код:
<pre>
from selenium import webdriver
import time

with webdriver.Chrome() as browser:
    browser.get("about:blank")
    time.sleep(5)
</pre>
about:blank – специальный URL, который загружает пустую страницу. Если вызвать browser.get("about:blank"), вы получите чистую страницу, с которой можно начать работу.
<h4>Открытие новой вкладки</h4>
Способ 1<br>
Используйте метод browser.<b>switch_to.new_window('tab')</b>, который создаёт новую вкладку и автоматически переключается на неё (берёт в фокус). И все последующие browser.get() запросы или поиск элементов будет выполняться на этой странице. Это простой и рекомендуемый способ.
<pre>
browser.switch_to.new_window('tab')
browser.get("Укажите любой URL")
</pre>
<p>
Способ 2<br> 
Открытие вкладки через JavaScript.<br>
Метод browser.<b>execute_script('window.open("https://icloud.com", "_blank");')</b> открывает новую вкладку.
<p>
<font color=brown>Важно: Фокус остаётся на текущей вкладке, и для работы с новой вкладкой нужно явно переключиться.</font>
<pre>
from selenium import webdriver
import time

with webdriver.Chrome() as browser:
    browser.get("https://ya.ru")
    browser.execute_script('window.open("https://icloud.com", "_blank");')
    time.sleep(5)
    print(browser.title)
    browser.get("https:google.com")
    time.sleep(5)
    print(browser.title)
    time.sleep(5)
</pre>
<p>
<font color=brown>Обратите внимание! После запуска кода выше, в браузере фокус будет на вкладке icloud.com, но это лишь визуально.</font> На самом деле вкладка icloud.com не в фокусе. Если вы попробуете открыть другую страницу через browser.get("https://google.com"), то получите следующий результат: google.com откроется в первой вкладке, несмотря на то, что визуально мы смотрим на icloud.com, но по факту работаем с первой вкладкой. Такое поведение наблюдается при использовании методов который работают с JS (browser.execute_script(...) имейте это в виду. (1 способ не требует явного переключения на вкладку).
<p>
Чтобы открыть новую вкладку, перейти туда и открыть URL без JS (Selenium 4+):
<pre>
# 'tab' - открыть новую вкладку, 'window' - новое окно
browser.switch_to.new_window('tab')
browser.get(URL)
</pre>
<p>
<i>Есть хорошее правило: если можно сделать без JS - делай это без JS<br>
Не понимаю зачем автор делает тут на JS... К тому же переключение вкладок идет хаотично (как будто асинхронно), а судя коду должно быть последовательным.<br>
Вот пример на Selenum, с правильным переключением вкладок:</i>
<pre>
with webdriver.Chrome() as browser:
    urls = [
        "http://parsinger.ru/blank/0/1.html",
        "http://parsinger.ru/blank/0/2.html",
        "http://parsinger.ru/blank/0/3.html",
        "http://parsinger.ru/blank/0/4.html",
        "http://parsinger.ru/blank/0/5.html",
        "http://parsinger.ru/blank/0/6.html"
    ]

    # Открытие каждой ссылки в новой вкладке
    for url in urls:
        browser.switch_to.new_window('tab')  # Создание новой вкладки и переключение на нее
        browser.get(url)  # Открытие URL

    # Переключение на каждую вкладку и получение информации
    for x in range(len(browser.window_handles)):
        browser.switch_to.window(browser.window_handles[x])  # Переключение на вкладку
        time.sleep(1)
        print(browser.title, browser.window_handles[x])  # Получение title и handle текущей вкладки
</pre>
<pre>

</pre>
<h3 align=center>Переключение между вкладками</h3>
Когда вы открыли несколько вкладок, Selenium хранит информацию о каждой из них. Для переключения фокуса на другую вкладку нам нужно знать, какие вкладки открыты. Каждая вкладка имеет свой уникальный <b>идентификатор (дескриптор</b>). С его помощью Selenium понимает, с какой вкладкой работать.
<p>
Дескрипторы — это сущности, которые помогают нам манипулировать вкладками.
<ul>
<li> browser.<b>window_handles</b> — возвращает список всех дескрипторов открытых новых вкладок; 
<p>
<li> browser.<b>current_window_handle</b> — возвращает дескриптор текущей вкладки;
<p>
<li> browser.<b>switch_to.window(window_handles[0])</b> — переключает фокус между вкладками по индексу, если вы обращаетесь к списку дескрипторов полученных методом .window_handles
<p>
<li> browser.<b>switch_to.window(descriptor)</b> — либо передать сам дескриптор напрямую
</ul>
<p>
Пример ниже открывает первую вкладку методом browser.get("URL"), затем открывает ещё три вкладки через метод открытия новой вкладки  browser.new_window("tab") которая сразу переносит фокус после этого печатает все дескрипторы открытых вкладок.
<pre>
from selenium import webdriver
import time

with webdriver.Chrome() as browser:
    result = []
    browser.get('http://parsinger.ru/blank/2/1.html')
    time.sleep(1)
    browser.switch_to.new_window("tab")
    browser.get("http://parsinger.ru/blank/2/2.html")
    browser.switch_to.new_window("tab")
    browser.get("http://parsinger.ru/blank/2/3.html")
    browser.switch_to.new_window("tab")
    browser.get("http://parsinger.ru/blank/2/4.html")
    time.sleep(2)
    print(browser.window_handles)
</pre>
Вывод:<br>
['7B25666AFB6FDC95B8F6A623BE4B6DA6', 'B2916B076EA6A49AC4C1BC8F9A24E663', 'DB9FDC2E38940CFDE2DB9F45EC6D9CAE', 'F827B7CA78023CC395BF17B1A4BA0E5F']
<p>
Так же вы можете передать аргумент "window" в метод browser.<b>new_window("window")</b>, чтобы открыть <b>новое отдельное окно браузера</b>(!не вкладку).
<p>
Работать мы можем со всеми вкладками, но только по очереди и только в активной. Запустите у себя в терминале код ниже, чтобы наблюдать за работой Selenium во всех вкладках по очереди. Обратите внимание на то, что мы получаем длину списка и итерируем по индексу дескрипторов в списке. Так же, прошу заметить что код не падает на странице степика потому что если find_elements не нашел элементов, то возвращается пустой список.
<pre>
from selenium import webdriver
from selenium.webdriver.common.by import By
import time

with webdriver.Chrome() as browser:
    browser.get("https://stepik.org/course/104774/promo")
    browser.switch_to.new_window("tab")
    browser.get("http://parsinger.ru/blank/2/1.html")
    browser.switch_to.new_window("tab")
    browser.get("http://parsinger.ru/blank/2/2.html")
    browser.switch_to.new_window("tab")
    browser.get("http://parsinger.ru/blank/2/3.html")
    browser.switch_to.new_window("tab")
    browser.get("http://parsinger.ru/blank/2/4.html")
    time.sleep(2)
    for x in range(len(browser.window_handles)):  # reversed(range(len(browser.window_handles))) Для итерирования
        browser.switch_to.window(browser.window_handles[x]) # от последней вкладки к первой
        for y in browser.find_elements(By.CLASS_NAME, 'check'):
            y.click()
        time.sleep(1)
</pre>
<h4>Особенности window_handles с использованием JS.</h4>
Проблема в том, что execute_script('window.open(...)') открывает новые вкладки, но не переключает на них автоматически, в отличие от browser.switch_to.new_window("tab"). 
<p>
execute_script('window.open(...)') открывает все вкладки разом, но их порядок в window_handles не гарантирован!
<ul>
<li> Chrome не добавляет их строго по очереди, а может вставлять в browser.window_handles в произвольном порядке.
<p>
<li> Вкладки могут быть добавлены в browser.window_handles асинхронно, в зависимости от скорости загрузки.
<p>
<li> browser.window_handles после выполнения всех execute_script(...) может выглядеть так:
<pre>
# (не по порядку!)
['HANDLE_3', 'HANDLE_1', 'HANDLE_5', 'HANDLE_0', 'HANDLE_2', 'HANDLE_6', 'HANDLE_4']
</pre>
</ul>
Чтобы лучше понять, как происходит итерирование по вкладкам, я создал следующий пример. Запустите код ниже у себя в терминале и посмотрите на процесс итерирования. Также обратите внимание на то, что вкладка с именем "data" не возвращает своего имени, так как не содержит тега &lt;title>.
<pre>
import time
from selenium import webdriver
with webdriver.Chrome() as browser:
    time.sleep(1)
    browser.execute_script('window.open("http://parsinger.ru/blank/0/1.html", "_blank1");')
    browser.execute_script('window.open("http://parsinger.ru/blank/0/2.html", "_blank2");')
    browser.execute_script('window.open("http://parsinger.ru/blank/0/3.html", "_blank3");')
    browser.execute_script('window.open("http://parsinger.ru/blank/0/4.html", "_blank4");')
    browser.execute_script('window.open("http://parsinger.ru/blank/0/5.html", "_blank5");')
    browser.execute_script('window.open("http://parsinger.ru/blank/0/6.html", "_blank6");')

    for x in range(len(browser.window_handles)):
        browser.switch_to.window(browser.window_handles[x])
        time.sleep(1)
        print(browser.execute_script("return document.title;"), browser.window_handles[x])
</pre>
Вывод:
<pre>
 6C76B23F8A69E115482A1AC9735EE59A  # это пустой handle, data:,
5 5E7C82AAF18939E69DA055538021A6DA
4 A25877CDAFC4A1957CAAC2CDDBF08F2B
3 CA4A99789377CCB6B54A9A2C3137918D
6 216BFDD5434BF042ED80736D041ED432
1 A417C3446EEE4B3E87BD33238450AB07
2 437A1DB5211569E0EDF0607F06B7EDAB
</pre>
<a name="size"><h3 align=center>Размеры окна браузера .set_window_size()</h3>
Задать размер окна браузера можно методом browser.<b>set_window_size(X, Y)</b><br>
Где X – это ширина окна;<br>
Где Y – это высота окна.
<p>
Важно знать, что минимальный размер окна браузера может быть следующим: ширина - 516px, высота - 134px, включая все элементы управления браузера, а не только рабочую область сайта.
<pre>
import time
from selenium import webdriver
with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/window_size/1/')
    browser.set_window_size(1200, 720)
    time.sleep(5)
</pre>
Код выше откроет окно браузера размером x:1200px,  y:720px. Рабочая область сайта в данном случае будет равна x:1184px, y:587px. Не путайте с общим размером окна браузера.
<ul>
<li> 16px занимают боковые границы браузера: левая и правая.
<li> 133px занимает верхняя панель управления браузера и нижняя граница.
</ul>
Важно: При работе с различными браузерами учитывайте, что размеры элементов интерфейса могут отличаться:
<ul>
<li> Chrome и Edge имеют схожие размеры интерфейса
<li> Firefox может иметь другие значения
<li> При использовании расширений высота верхней панели может увеличиваться
</ul>
Учитывайте эту особенность при написании кода для решения задач.
<h4>Метод .get_window_size() для получения размеров окна</h4>
Для получения размеров окна браузера используется метод .<b>get_window_size()</b>. Этот метод имеет встроенный другой метод .get(), который принимает два параметра: 'height' и 'width' соответственно. Они возвращают высоту и ширину окна браузера.
Этот метод возвращает размер окна в виде словаря. {'width': 1202, 'height': 722}
<pre>
from selenium import webdriver


with webdriver.Chrome() as browser:
    
    # Открываем указанный URL в браузере.
    browser.get('http://parsinger.ru/window_size/1/')
    
    # Устанавливаем размер окна браузера на 1200 пикселей в ширину и 720 пикселей в высоту.
    browser.<b>set_window_size(1200, 720)</b>
    
    # Получаем текущий размер окна браузера в виде словаря, где 'height' - высота окна,
    # 'width' - ширина окна. И затем печатаем значение высоты окна.
    print(browser.<b>get_window_size().get('height')</b>)
    
    # Аналогично печатаем значение ширины окна.
    print(browser.<b>get_window_size().get('width')</b>)

# После завершения выполнения кода в блоке 'with', браузер автоматически закрывается.

>>> 720
    1200
</pre>
<p>
.get_window_size().get('height'):
<p>
.get('height'): Метод get — это альтернативный способ извлечения значения из словаря. Он вернет значение, соответствующее ключу 'height', или None, если такого ключа нет в словаре. В данном контексте это выражение также вернет высоту окна браузера.
<p>
.get_window_size().get('width'):<br>
.get('width'): Метод get извлекает значение из словаря по ключу 'width'. Таким образом, это выражение вернет ширину окна браузера.
<p>
Как и при работе с любым словарем, мы можем получить доступ к ширине или высоте по ключу ["width"] и  ["height"].
<pre>
from selenium import webdriver


with webdriver.Chrome() as browser:
    
    # Загрузка указанного URL ('http://parsinger.ru/window_size/1/') в открытом окне браузера.
    browser.get('http://parsinger.ru/window_size/1/')
    
    # Установка размера окна браузера: ширина — 1200 пикселей и высота — 720 пикселей.
    browser.set_window_size(1200, 720)
    
    # Получение текущего размера окна браузера и вывод его ширины на экран.
    # Обращаемся к ключу "width" в полученном словаре.
    print(<b>browser.get_window_size()["width"]</b>)
    
    # Получение текущего размера окна браузера и вывод его высоты на экран.
    # Обращаемся к ключу "height" в полученном словаре.
    print(browser.<b>get_window_size()["height"]</b>)

>>> 1200
    720
</pre>
<h3 align=center>Модальные окна</h3>
Модальное окно — это окно, которое блокирует работу пользователя до тех пор, пока это окно не закроют. В этом степе мы поговорим только про те окна, которые использует браузер. О тех, которые формируются при помощи JavaScript создателями сайта, мы говорить не будем, но этими окнами можно управлять другими средствами Selenium, о которых мы говорили в других уроках.
<p>
<b>Основные функции применяемые к модальным окнам.</b>
<ul>
<li> <b>.switch_to</b> - позволяет переключить фокус на модальное окно. Это необходимо, чтобы взаимодействовать с содержимым этого окна.
<pre>
# Переключение фокуса на модальное окно
browser.switch_to.alert
</pre>
<p>
<li> <b>.accept()</b> - имитирует нажатие на кнопку "ОК" в модальном окне. Обычно используется для подтверждения какого-либо действия.
<pre>
# Подтвердить содержимое модального окна
browser.switch_to.alert.accept()
</pre>
<p>
<li> <b>.dismiss()</b> - имитирует нажатие на кнопку "Отмена" в модальном окне. Позволяет отказаться от выполнения какого-либо действия или закрыть окно без подтверждения.
<pre>
# Или отклонить содержимое модального окна
browser.switch_to.alert.dismiss()
</pre>
<p>
<li> <b>.send_keys()</b> - позволяет отправить текст в текстовое поле внутри модального окна. Например, это может быть поле для ввода пароля или комментария.
<pre>
# Отправка текста в текстовое поле модального окна
browser.switch_to.alert.send_keys("Текст для отправки")
</pre>
<p>
<li> <b>.text</b> - возвращает заголовок (title) модального окна. Это может пригодиться для проверки того, что правильное окно отображается на экране.
<pre>
# Получение title модального окна
modal_title = browser.switch_to.alert.text
</pre>
</ul> 
<p>
Переключение на все виды модальных окон выполняется командой browser.switch_to.alert
<p>
<b>Виды модальных окон.</b>
<ol>
<li> Alert ⚠️ - выводит пользователю сообщение, содержит кнопку "ОК";
<p>
<li> Prompt ✏️ - запрашивает у пользователя ввод каких-либо текстовых данных, содержит кнопки "ОК" и "Отмена";
<p>
<li> Confirm ✅ - выводит окно с вопросом, содержит кнопки "ОК" и "Отмена".
</ol>
<p> 
Модальное окно Alert<br>
Код, представленный ниже, выполняет клик на кнопку с id="alert", вызывая тем самым модальное окно alert. Затем он переключается на это окно с помощью функции browser.switch_to.alert и выводит содержимое title этого окна.
<pre>
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/blank/modal/1/index.html')
    browser.find_element(By.ID, 'alert').click()
    time.sleep(1)
    alert = browser.switch_to.alert # Если вы планируете что-то делать с этим событием, можно добавить его в переменную
    print(alert.text)
    time.sleep(1)
    alert.accept()
    time.sleep(1)
</pre>
<p>
Особенности работы с Alert:
<ul>
<li> Alert блокирует выполнение JavaScript на странице
<li> Нельзя взаимодействовать с основной страницей, пока Alert активен
<li> Alert всегда отображается поверх всех окон
<li> Стиль Alert окна нельзя изменить через CSS
</ul>
<p>
<b>Модальное окно Prompt ✏️</b><br>
С помощью функции .send_keys("") можно отправлять текст в модальное окно prompt.
<pre>
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/blank/modal/1/index.html')
    browser.find_element(By.ID, 'prompt').click()
    time.sleep(2)
    prompt = browser.switch_to.alert
    prompt.send_keys('Введёный текст')
    prompt.accept()
    time.sleep(.5)
    print(browser.find_element(By.ID, 'result').text)
    time.sleep(1)
</pre>
Приведённый выше код сначала нажимает на кнопку с id="prompt", вызывая модальное окно prompt. Затем он отправляет текст в текстовое поле этого окна и подтверждает ввод, нажимая кнопку "OK" с помощью функции .accept(). После того как кнопка "OK" была нажата, на странице в теге с id="result" отображается текст, введённый пользователем.
<p>
Столкнулись с проблемой при работе в Chrome: введённый текст в окне prompt не отображается, хотя вышеуказанный код возвращает нам введённое значение. Это подтверждает, что функция .send_keys() работает, но, возможно, не совсем корректно. Причиной может быть как Selenium, так и сам Chrome. Например, в браузерах Firefox или Opera такой проблемы не обнаружено.
<p>
<b>Модальное окно Confirm ✅</b><br>
Модальное окно confirm имеет всего две кнопки: "Ok" и "Отмена". Взаимодействовать с ними можно с помощью функций .accept() и .dismiss().
<pre>
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/blank/modal/1/index.html')
    browser.find_element(By.ID, 'confirm').click()
    time.sleep(2)
    confirm = browser.switch_to.alert
    confirm.accept() #Замените на .dismiss() чтобы нажать на кнопку "Отмена"
    time.sleep(.5)
</pre>
Код выше нажимает на кнопку Confirm и в появившемся окне — на кнопку Ok.
<p>
Иногда модальное окно может не появляться мгновенно, и стоит использовать ожидания для его появления. Это поможет избежать ошибок в тестах. Пока можете использовать time.sleep(), а уже в следущем модуле мы изучим явные/неявные ожидания.
<pre>

</pre>
<h3 align=center>Работа с фреймами iframe</h3>
Данная тема важная, потому что необходимо уметь работать с фреймами, ведь большинство капч загружается именно во фреймы. Работа с фреймами напоминает работу с alert-окнами, далее вы поймете разницу, ведь мы используем тот же самый синтаксис.
<p>
Частые случаи использования iframe:
<ol>
<li> Встраивание видео с YouTube или других платформ
<li> Интеграция карт (Google Maps, Яндекс.Карты)
<li> Размещение форм оплаты и платёжных систем
<li> Загрузка CAPTCHA для защиты форм
<li> Встраивание виджетов социальных сетей
</ol>
<p>
Формула для переключения на фрейм:
<pre>
browser.switch_to.frame(iframe)
</pre>
<i>Важно! Если вы попытаетесь нажать на кнопку внутри iFrame с помощью selenium без переключения на этот iFrame, вы получите ошибку. Selenium осведомлен только о элементах в документе верхнего уровня.</i><br>
<p>
<b>Распространённые ошибки при работе с iframe:</b>
<ol>
<li> NoSuchElementException - элемент не найден (забыли переключиться на фрейм)
<p>
<li> StaleElementReferenceException - элемент устарел (фрейм перезагрузился)
<p>
<li> TimeoutException - превышено время ожидания загрузки фрейма
<p>
<li> InvalidArgumentException - неверный аргумент при переключении на фрейм
</ol>
<p>
<b>Способы переключения на фрейм:</b>
<ul>
<li> Используя WebElement: Это наиболее гибкий вариант. Вы можете найти фрейм с помощью вашего предпочтительного селектора и переключиться на него.
<pre>
iframe = browser.find_element(By.CSS_SELECTOR, "#modal > iframe")
browser.switch_to.frame(iframe)
browser.find_element(By.TAG_NAME, 'button').click()
</pre> 
<p>
<li> Используя имя или ID: Если у вашего фрейма или iFrame есть атрибуты id или name, вы можете использовать их.
<pre>
browser.switch_to.frame('buttonframe')
browser.find_element(By.TAG_NAME, 'button').click()
</pre> 
<p>
<li> Используя индекс: Также можно использовать индекс фрейма.
<pre>
browser.switch_to.frame(1)
</pre>
</ul> 
<p>
<b>Выход из фрейма:</b><br>
 Чтобы выйти из iFrame или frameset, вернитесь к содержимому по умолчанию.
<pre>
browser.switch_to.default_content()
</pre>
Зачем нужен выход из фрейма ?
<ol>
<li> Ограниченная область видимости: Когда вы находитесь внутри фрейма (или iFrame), ваша область видимости ограничена только этим фреймом. Это означает, что вы не можете взаимодействовать с элементами вне этого фрейма.
<li> Взаимодействие с основным содержимым: После завершения работы внутри фрейма, вам, возможно, потребуется взаимодействовать с элементами основного документа. Чтобы это сделать, вы должны выйти из фрейма.
<li> Переключение между фреймами: Если на странице есть несколько фреймов и вам нужно переключиться с одного фрейма на другой, вы сначала должны вернуться к основному содержимому, прежде чем переключиться на другой фрейм.
<li> Избегание ошибок: Если вы пытаетесь взаимодействовать с элементом, который находится вне текущего фрейма, без выхода из этого фрейма, вы получите ошибку, такую как "NoSuchElementException". Чтобы избежать таких ошибок, важно знать, в каком контексте (фрейме) вы находитесь, и при необходимости выходить из него.
</ol>
<p>
Лучшие практики работы с iframe:
<ol>
<li> Всегда проверяйте наличие фрейма перед переключением
<li> Используйте явные ожидания для загрузки фрейма
<li> Создавайте отдельные функции для работы с каждым фреймом
<li> Не забывайте возвращаться к основному контенту после работы с фреймом
</ol>
<p>
Жизненный цикл работы с iframe:
<ol>
<li> Поиск фрейма на странице
<li> Ожидание загрузки фрейма
<li> Переключение на фрейм
<li> Выполнение действий внутри фрейма
<li> Возврат к основному контенту
</ol>
<p>
Код ниже откроет страницу, переключится на фрейм получит всё HTML содержимое текущего фрейма.
<pre>
from selenium import webdriver
from selenium.webdriver.common.by import By

with webdriver.Chrome() as browser:
    browser.get('https://parsinger.ru/selenium/5.8/4/index.html')

    # Переключаемся на iframe
    iframe_element = browser.find_element(By.TAG_NAME, 'iframe')
    browser.switch_to.frame(iframe_element)

    # Извлекаем HTML содержимое из iframe
    iframe_content = browser.page_source

    print(iframe_content)
</pre>
Разберём код:<br>
Переключение на iframe:
<pre>
iframe_element = browser.find_element(By.TAG_NAME, 'iframe')
browser.switch_to.frame(iframe_element)
</pre>
Сначала мы ищем элемент iframe на странице с помощью метода find_element и критерия поиска By.TAG_NAME. Это означает, что мы ищем первый попавшийся элемент с тегом iframe.<br>
Затем мы переключаемся на этот iframe с помощью метода switch_to.frame(iframe_element). После этого все действия Selenium будут выполняться внутри этого iframe, как будто это основная страница.
<p>
Извлечение содержимого iframe:
<pre>
iframe_content = browser.page_source
</pre>
После переключения на iframe, <b>метод page_source</b> возвращает исходный HTML код текущей страницы, который в этом контексте является содержимым iframe.
<pre>

</pre>
<a name="wait"><h2 align=center>Явное ожидание(Explicit waits) и неявное ожидание(Implicit waits)</h2>
В наши дни большинство веб-приложений используют технологии AJAX. Когда браузер загружает страницу, элементы на этой странице могут загружаться с разной скоростью. Это затрудняет поиск элементов: если элемент ещё не присутствует в DOM, функция поиска выдаст исключение ElementNotVisibleException. С помощью ожидания мы можем решить эту проблему. Ожидание обеспечивает некоторую задержку между выполняемыми действиями — в основном поиском элемента или любой другой операцией с элементом. Selenium Webdriver предоставляет два типа ожидания: <b>явное</b> и <b>неявное</b>. При явном ожидании WebDriver ожидает выполнения определённого условия, прежде чем продолжить выполнение. При неявном ожидании WebDriver опрашивает DOM в течение определённого времени при попытке найти элемент.
<h4 align=center>Явные ожидания (Explicit waits)</h4>
Явное ожидание — это код, который вы определяете для ожидания выполнения определённого условия перед продолжением выполнения кода. Крайним случаем является функция time.sleep(), которая устанавливает точное время ожидания. Существуют удобные методы, которые помогают писать код, ожидающий ровно столько, сколько необходимо. Одним из способов добиться этого является использование WebDriverWait в сочетании с ExpectedCondition.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from selenium import webdriver
from selenium.webdriver.common.by import By
<b>from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC</b>

driver = webdriver.Firefox()
driver.get("http://somedomain/url_that_delays_loading")
<font color=green>
try:
    element = WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.ID, "myDynamicElement"))
    )</font>
finally:
    driver.quit()
</pre></td></tr></table>
<p>
В приведенном выше коде Selenium будет ожидать максимум 10 секунд, пока не будет найден элемент, соответствующий заданным критериям. Если за это время элемент не будет найден, будет сгенерировано исключение TimeoutException. По умолчанию WebDriverWait вызывает ExpectedCondition каждые 500 миллисекунд, пока не будет получен успешный результат. ExpectedCondition возвращает true (логическое значение) в случае успешного поиска или не равно null, если поиск элемента не удался.
<p>
Еще пример:
<pre>
import time

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait

with webdriver.Chrome() as browser:
    browser.get('http://parsinger.ru/expectations/1/index.html')
    <b>element = WebDriverWait(browser, 10).until(EC.element_to_be_clickable((By.ID, "btn"))).click()</b>
    time.sleep(3)
    print(browser.find_element(By.ID, 'result').text)
</pre>
<p>
<ol>
<li> Импортировал модуль expected_conditions из библиотеки webdriver и назвал его EC, чтобы не писать каждый раз его длинное название.
<pre>
from selenium.webdriver.support import expected_conditions as EC
</pre>
<li> Импортировал сам класс для работы с ожиданиями WebDriverWait;
<pre>
from selenium.webdriver.support.ui import WebDriverWait
</pre>
<li> Использовал функцию EC.<b>element_to_be_clickable</b>, которая ожидает пока элемент станет кликабельным;
<pre>
WebDriverWait(browser, 10).until(EC.element_to_be_clickable(...
</pre>
В данном случае, мы создаем объект WebDriverWait, передавая ему два аргумента:
<ol>
<li> browser: это экземпляр драйвера браузера, с которым мы работаем (в нашем случае, это Chrome).
<li> 10: это максимальное количество времени (в секундах), в течение которого WebDriverWait будет пытаться выполнить условие, указанное в методе until.
</ol>
<p>
.until(...)​​ — Этот метод указывает, какое условие мы ожидаем выполнить. Он будет опрашивать условие каждые несколько миллисекунд  до тех пор, пока условие не выполнится или пока не истечет максимальное время ожидания (в данном случае 10 секунд).
<p>
EC.element_to_be_clickable((By.ID, "btn")):<br>
EC (или expected_conditions) — это модуль в Selenium, который содержит набор предустановленных условий, которые можно использовать с WebDriverWait(далее подробно про EC).
<p>
element_to_be_clickable() — это одно из этих условий. Оно проверяет, что элемент не только присутствует на странице, но и видим, а также активен, так что по нему можно кликнуть.
<p>
(By.ID, "btn") — это способ указать, какой именно элемент мы ищем. В данном случае, мы ищем элемент по его идентификатору (ID), который равен "btn".
<li> Как только элемент стал кликабельным, управление программой передается далее, и метод совершает клик по элементу.
<pre>
...(By.ID, "btn"))).click()
</pre>
</ol>
<p>
<b>Пользовательские Wait Conditions</b><br>
Вы также можете создавать собственные условия ожидания, если ни один из предыдущих удобных методов не соответствует вашим требованиям. Собственное условие ожидания можно создать с помощью класса с методом __call__, который возвращает False, если условие не выполняется.
<pre>
class element_has_css_class(object):
  """An expectation for checking that an element has a particular css class.

  locator - used to find the element
  returns the WebElement once it has the particular css class
  """
  def __init__(self, locator, css_class):
    self.locator = locator
    self.css_class = css_class

  def __call__(self, driver):
    element = driver.find_element(*self.locator)   # Finding the referenced element
    if self.css_class in element.get_attribute("class"):
        return element
    else:
        return False

# Wait until an element with id='myNewInput' has class 'myCSSClass'
wait = WebDriverWait(driver, 10)
element = wait.until(element_has_css_class((By.ID, 'myNewInput'), "myCSSClass"))
</pre>
<h3 align=center>expected_conditions as EC</h3>
<img src="images/selenium.png">
<p>
Expected Conditions (EC) - это набор предопределенных условий, которые можно использовать с WebDriverWait для ожидания определенных событий на странице.<p>
Список этих условий можно посмотреть на <a href="https://www.selenium.dev/selenium/docs/api/py/webdriver_support/selenium.webdriver.support.expected_conditions.html#selenium.webdriver.support.expected_conditions.invisibility_of_element_located">этой странице</a>.
<p>
​Параметры WebDriverWait:
<ol>
<li> browser: Экземпляр WebDriver (например, Ie, Firefox, Chrome или Remote)
<p>
<li> poll_frequency=float: (необязательный): Интервал ожидания между попытками. По умолчанию равен значению 0.5.
<p>
<li> timeout=float: Количество секунд до таймаута
<p>
<li> .until(method): Ожидает, пока предоставленный method вернет что-либо, кроме False. Если method продолжает возвращать False до истечения времени ожидания, будет вызвано исключение TimeoutException.
<p>
<li> .until_not(method): Ожидает, пока предоставленный method не вернет False. Если метод не вернет False до истечения времени ожидания, будет вызвано исключение TimeoutException.
</ol>
<p>
Как  работаетuntil() и until_not()?<br>
Когда вы вызываете метод until(method), Selenium регулярно (с интервалом, заданным параметром poll_frequency=0.5) проверяет, выполняется ли указанное вами условие.
<p>
<b>Лучшие практики:</b> Можно записать явное ожидание через заранее созданный объект WebDriverWait. Это делает код чище и удобнее для повторного использования.
<pre>
# Создание объекта ожидания
wait = WebDriverWait(browser, 10)

# Ожидание, пока элемент станет кликабельным
wait.until(EC.element_to_be_clickable((By.ID, "btn")))
</pre>
<p>
Лямбда-функции в until удобны, когда нужно задать кастомное условие.<br>
Пример: Ожидание, пока текст элемента станет "Готово":
<pre>
wait.until(lambda browser: browser.find_element(By.ID, "status").text == "Готово")
</pre>
Примечание: Лямбда-функции полезны, если нет стандартного EC-условия или нужно что-то специфическое.
<h4>Популярные условия EC</h4>
<ol>
<li> element_to_be_clickable<br>
Ожидает, пока элемент не станет кликабельным
<pre>
EC.element_to_be_clickable((By.ID, "btn"))
</pre>
<li> presence_of_element_located<br>
Ожидает появления элемента в DOM
<pre>
EC.presence_of_element_located((By.CLASS_NAME, "item"))
</pre>
<li> visibility_of_element_located<br>
Ожидает, пока элемент не станет видимым
<pre>
EC.visibility_of_element_located((By.XPATH, "//div[@id='content']"))
</pre>
<li> text_to_be_present_in_element<br>
Ожидает появления текста в элементе
<pre>
EC.text_to_be_present_in_element((By.ID, "status"), "Загрузка завершена")
</pre>
<li> invisibility_of_element_located<br>
Ожидает исчезновения элемента
<pre>
EC.invisibility_of_element_located((By.ID, "loader"))
</pre>
</ol>
<h4>Советы по отладке:</h4>
<ol>
<li> Используйте try-except для обработки TimeoutException
<li> Увеличивайте timeout для медленных страниц
<li> Уменьшайте poll_frequency для более частых проверок
<li> Комбинируйте условия с помощью lambda-функций
</ol>
<p>
<b>Распространённые ошибки:</b>
<ol>
<li> TimeoutException - превышено время ожидания
<li> ElementNotInteractableException - элемент найден, но с ним нельзя взаимодействовать
<li> StaleElementReferenceException - элемент устарел (DOM изменился)
<li> NoSuchElementException - элемент не найден
</ol>
<pre>

</pre>
<a name="title"><h3 align=center>Ожидание заголовка .title_is(title) и  .title_contains(title)</h3>
Синтаксис:
<pre>
WebDriverWait(browser, poll_frequency=0.5, timeout=10).until(EC.<b>title_is(('STR'))</b>)
</pre>
EC.title_is(title: str) - ожидание проверки заголовка страницы.<br>
title - ожидаемый заголовок, который должен быть точным совпадением, <b>возвращает True, если заголовок совпадает, в противном случае - false</b>.
<p>
Зачем это нужно ?<br>
Заголовок страницы — это важный индикатор того, что вы находитесь на правильной странице или в правильном разделе сайта. Это особенно полезно при автоматизации навигации, когда вы переходите от одной страницы к другой и хотите удостовериться, что переход выполнен успешно.
<p>
Как это работает ?<br>
Когда вы вызываете это условие, Selenium сравнивает текущий заголовок страницы (то, что находится внутри тега &lt;title>) с предоставленной строкой. Если они совпадают, условие считается выполненным.
<pre>
# Ожидание, пока заголовок страницы станет "My Page Title"
WebDriverWait(browser, 10).until(EC.title_is("My Page Title"))
</pre>
<p>
<h4>.title_contains(title)</h4>
 Синтаксис:
<pre>
WebDriverWait(browser, 5).until(EC.<b>title_contains('tle')</b>)
</pre>
<p>
EC.title_contains(title: str) — Это ожидаемое условие, которое проверяет, содержит ли текущий заголовок веб-страницы заданное <b>подстроковое</b> значение.<br>
title- подстрока, которую должен содержать заголовок.
<p>
Зачем это нужно ?<br>
В некоторых случаях вам может не требоваться точное совпадение заголовка, а достаточно удостовериться, что заголовок содержит определенную фразу или слово. Это особенно полезно для сайтов, которые динамически обновляют свои заголовки или когда вам нужно проверить общую тему страницы, а не её конкретное название.
<p>
Как это работает ?<br>
Это условие проверяет, содержится ли предоставленная строка в текущем заголовке страницы (внутри тега &lt;title>). Если да, условие считается выполненным.
<pre>
# Ожидание, пока заголовок страницы будет содержать "Page"
WebDriverWait(browser, 10).until(EC.title_contains("Page"))
</pre>
вернёт true если title совпадает частично.
<p>
Лучшие практики:
<ol>
<li> Используйте title_is для проверки конкретных страниц с фиксированными заголовками
<li> Используйте title_contains для проверки динамических заголовков или общих тем страниц
<li> Комбинируйте с другими условиями для более надежной навигации
<li> Устанавливайте разумные таймауты (обычно 5-10 секунд)
</ol>
<pre>

</pre>
<h3 align=center>Неявные ожидания (Implicit Waits)</h3>
Неявное ожидание указывает WebDriver на необходимость опроса DOM в течение определённого времени при попытке найти элемент (или элементы), который не доступен сразу. По умолчанию значение равно 0, что означает, что если элемент не найден, он немедленно вернет ошибку. Если установлено неявное ожидание, драйвер будет ждать указанное время перед возвратом ошибки.
<p>
Это как бы глобальный таймер, который применяется для <b>каждой операции поиска элементов</b>. 
<pre>
from selenium import webdriver

driver = webdriver.Firefox()
driver.<b>implicitly_wait(10)</b> # seconds
driver.get("http://somedomain/url_that_delays_loading")
myDynamicElement = driver.find_element_by_id("myDynamicElement")
</pre>
<p>
Почему необходимо использовать Implicit Wait ?<br>
<ol>
<li> Простота: Это простой способ убедиться, что ваш код будет ждать достаточное количество времени перед тем как продолжить выполнение.
<li> Глобальность: Один раз установив, он применяется ко всем последующим операциям поиска.
</ol>
<p>
Важные замечания:
<ol>
<li> Не рекомендуется смешивать Implicit Waits и Explicit Waits в одном тесте, так как это может привести к непредсказуемым результатам.
<li> Implicit Wait не всегда является лучшим решением, особенно если на веб-странице много динамически загружаемого контента. В таких случаях лучше использовать Explicit Waits.
</ol>
<p>
Как это работает?
<ol>
<li> Задание времени ожидания: Когда вы устанавливаете Implicit Wait, вы фактически говорите Selenium: "Если я попытаюсь найти элемент и не найду его сразу, не выбрасывай ошибку. Вместо этого жди заданное мной время, пытаясь найти этот элемент".
<p>
<li> Поиск элемента: Когда вы пытаетесь найти элемент на странице (например, используя .find_element()), Selenium сначала проверяет, виден ли этот элемент сразу.
<p>
<li> Ожидание: Если элемент не найден сразу:
<p>
<li> Selenium будет периодически (каждые 0.2 сек, по умолчанию) проверять наличие элемента на странице. Это повторяется до тех пор, пока элемент не будет найден или пока не истечет установленное время Implicit Wait.
<p>
<li> Результат: Если элемент появляется на странице в течение заданного времени ожидания, код продолжает выполнение.
Если время истекло, и элемент так и не был найден, Selenium выбросит исключение NoSuchElementException.
</ol>
<p>
Лучшие практики:
<ol>
<li> Устанавливайте разумное время ожидания (обычно 2-5 секунд)
<li> Используйте Implicit Wait для простых сценариев с небольшим количеством динамического контента
<li> Для сложных сценариев предпочитайте Explicit Wait
<li> Не комбинируйте Implicit и Explicit Wait в одном тесте
<li> Учитывайте время загрузки страницы при установке значения ожидания
</ol>
<pre>

</pre>
<h4 align=center>Ожидание URL</h4>
Общий синтаксис:
<pre>
WebDriverWait(browser, poll_frequency=0.5, timeout=10).until(EC.УСЛОВИЕ(('STR')))
</pre>
Вместо "УСЛОВИЕ" ставим:
<ul>
<li> <b>.url_contains()</b><br>
EC.url_contains(url: str)— Это ожидаемое условие, которое проверяет, содержит ли текущий URL веб-страницы заданное <b>подстроковое</b> значение.<br>
url - подстрока, которую должен содержать URL.
<p>
Зачем это нужно ?<br>
При парсинге данных или автоматизации действий на сайтах часто требуется переходить по различным ссылкам или следить за редиректами. Проверка содержания URL может помочь удостовериться, что вы находитесь на правильной странице, особенно после выполнения каких-либо действий, которые могли бы изменить URL (например, после входа в аккаунт или перехода по категориям).
<p>
Как это работает ?<br>
Это условие анализирует текущий URL страницы и проверяет, содержит ли он заданное значение. Если условие выполняется, то это означает, что вы находитесь на ожидаемой или связанной с вашим запросом странице.
<pre>
# Допустим, у вас есть следующая ссылка (URL) на веб-сайт:
https://www.example.com/dashboard/

#Если вы используете метод EC.url_contains("dashboard"), он вернет True для этой ссылки, потому что строка "dashboard"
# содержится в URL.

# Ожидание, пока URL будет содержать "dashboard"
WebDriverWait(browser, 10).until(EC.url_contains("dashboard"))
</pre>
<p>
<li> <b>.url_matches()</b><br>
EC.url_matches(pattern: str)— Это ожидаемое условие, которое проверяет, соответствует ли текущий URL страницы заданному регулярному выражению.<br>
pattern- регулярное выражение для проверки URL.
<p>
Зачем это нужно ?<br>
При парсинге сайтов и автоматизации браузерных действий может возникнуть необходимость проверить структуру или точное соответствие URL определенному паттерну. В отличие от простой проверки на наличие подстроки (как в url_contains), url_matches позволяет выполнить более сложную и точную проверку URL с помощью регулярных выражений.
<p>
Как это работает ?<br>
Это условие сравнивает текущий URL страницы с регулярным выражением, предоставленным в качестве аргумента, и проверяет их соответствие.<br>
Пример:
<pre>
# Ожидание, пока URL соответствует шаблону
WebDriverWait(browser, 10).until(EC.<b>url_matches(r"https://www\.stepik\.org/[0-9]{4}/")</b>)
</pre>
Ещё пример:
<pre>
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import re

browser = webdriver.Chrome()
browser.get("https://www.stepik.org/articles")

# Ожидаем, пока URL будет соответствовать шаблону года (например, /2023/)
WebDriverWait(browser, 10).until(EC.url_matches(r".*/\d{4}/$"))

# Получаем текущий URL и извлекаем год с помощью регулярного выражения
current_url = browser.current_url
year_match = re.search(r'/(\d{4})/', current_url)
if year_match:
    year = year_match.group(1)
    print(f"Текущий год: {year}")
</pre>
<p>
<li> <b>.url_to_be()</b><br>
EC.url_to_be(url: str) — Это ожидаемое условие, которое убеждается, что текущий URL веб-страницы точно совпадает с предоставленным значением.<br>
url - ожидаемый URL страницы.
<p>
Зачем это нужно ?<br>
Когда вы автоматизируете веб-сайты с помощью Selenium, особенно динамические или сложные, точность URL может быть критичной. Например, различные страницы продуктов или категорий могут иметь очень похожие URL, и отличие может быть в одном символе или параметре. Убеждаясь, что вы находитесь на правильном URL, вы можете гарантировать, что выполняете действия на нужной странице и что ваша автоматизация работает корректно.
<p>
Как это работает ?<br>
Это условие сравнивает текущий URL страницы с предоставленным значением. Если они идентичны, условие считается выполненным.
<pre>
# Ожидание, пока URL станет "https://www.stepik.org/home"
WebDriverWait(browser, 10).until(EC.url_to_be("https://www.stepik.org/home"))
</pre>
<p>
<li> <b>.url_changes()</b><br>
EC.url_changes(url: str)— Это ожидаемое условие, которое проверяет, отличается ли текущий URL веб-страницы от предоставленного значения.<br>
url - исходный URL для сравнения.
<p>
Зачем это нужно ?<br>
При автоматизации с помощью Selenium часто бывают моменты, когда URL должен измениться после выполнения определенного действия, такого как нажатие кнопки, переход по ссылке или отправка формы. Подтверждение того, что URL действительно изменился, помогает удостовериться, что скрипт выполняется корректно и что браузер успешно перешел на новую страницу.
<p>
Как это работает ?<br>
Это условие сравнивает текущий URL страницы с предоставленным значением. Если они не совпадают, условие считается выполненным.
<pre>
# Ожидание, пока URL изменится относительно "https://www.stepik.org"
WebDriverWait(browser, 10).until(EC.url_changes("https://www.stepik.org"))
</pre>
</ul>
<p>
Лучшие практики:
<ol>
<li> Используйте url_contains для проверки общих разделов сайта
<li> Используйте url_matches для проверки структуры URL с помощью регулярных выражений
<li> Используйте url_to_be для проверки точного URL после редиректов
<li> Используйте url_changes для подтверждения успешного перехода по ссылке
<li> Комбинируйте проверки URL с другими условиями для более надежной навигации
</ol>
<p>
Распространённые ошибки:
<ol>
<li> TimeoutException - URL не изменился в течение указанного времени
<li> Неправильное написание URL (учтите регистр и протокол http/https)
<li> Использование url_to_be вместо url_contains для динамических URL
<li> Слишком короткий таймаут для медленно загружающихся страниц
<li> Неучет параметров запроса в URL при использовании url_to_be
</ol>
<p>
Для более надежной проверки URL можно комбинировать несколько условий:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# Ожидание, пока URL изменится И будет содержать определенную подстроку
WebDriverWait(browser, 10).until(
    EC.<b>all_of(
        EC.url_changes("https://stepik.org"),
        EC.url_contains("dashboard")</b>
    )
)
</pre></td></tr></table>
<a name="display"><h3 align=center>Проверка видимости и присутствия элементов в HTML</h3>
Общий синтаксис:
<pre>
WebDriverWait(browser, poll_frequency=0.5, timeout=10).until(EC.УСЛОВИЕ((locator)))
</pre>
Важно:  Результат зависит от типа метода. Если метод работает с одним элементом, он возвращает WebElement. Если метод работает с несколькими элементами, он возвращает list[WebElement]
<p>
УСЛОВИЯ:
<ol>
<li> <b>.presence_of_element_located()</b><br>
EC.presence_of_element_located(locator)— Это одно из ожидаемых условий , которое помогает нам убедиться, что элемент присутствует на веб-странице. Гарантирует, что элемент есть в DOM.<br>
locator— кортеж, содержащий два элемента: тип поиска (By.ID, By.XPATH и т. д.) и значение для поиска.
<p>
Что это проверяет?<br>
Этот метод проверяет наличие элемента на странице. Но важно понимать, что "присутствие" не означает "видимость". То есть элемент может быть на странице, но скрыт от пользователя (например, имеет стиль display: none).
<p>
Если элемент hidden (display: none; или visibility: hidden;), то Selenium не сможет с ним взаимодействовать стандартными методами (.click(), .send_keys(), .text и т. д.), так как он не видим для движка браузера.
<p>
Можно убрать стили при помощи .execute_script:
<pre>
# В зависимости от стиля
browser.execute_script("arguments[0].style.display = 'block';", element)
browser.execute_script("arguments[0].style.visibility = 'visible';", element)
browser.execute_script("arguments[0].classList.remove('hidden');", element)

# Полностью убрать все ограничения
browser.execute_script("""
    arguments[0].style.display = 'block';
    arguments[0].style.visibility = 'visible';
    arguments[0].style.opacity = '1';
    arguments[0].style.pointerEvents = 'auto';
    arguments[0].style.position = 'relative';
    arguments[0].style.zIndex = '9999';
""", element)
</pre>
<p>
Когда это НЕ сработает?<br>
<ol>
<li> Если элемент вообще не загружен в DOM<br>
Нужно подождать с WebDriverWait и presence_of_element_located().
<p>
<li> Если сайт использует display: flex/grid/inline-block<br>
Тогда вместо display = 'block' надо вернуть его оригинальное состояние:
<pre>
browser.execute_script("arguments[0].style.display = '';", element)
</pre>
<p>
<li> Если скрытие элемента завязано на JS-фреймворки (React, Vue, Angular) Тогда после изменения стиля, JS может снова скрыть элемент. Решение — имитировать пользовательское действие (клик, ввод), а не просто менять стили.
</ol>
<p>
Как использовать?<br>
Чтобы использовать это условие, вам нужно передать локатор - это способ указать Selenium, какой именно элемент вы ищете. Локатор - это кортеж из двух частей: способа поиска (например, By.ID или By.XPATH) и самого значения, по которому идет поиск.
<pre>
locator = (By.ID, 'some_element_id')
element = WebDriverWait(browser, 10).until(EC.presence_of_element_located(locator))
</pre>
<p>
<li> <b>.visibility_of_element_located()</b><br>
EC.visibility_of_element_located(locator)— Это одно из ожидаемых условий, позволяющее убедиться, что элемент не только присутствует на странице, но и видим пользователю.<br>
locator— такой же, как и выше
<p>
Чем отличается от простого "присутствия"?<br>
Есть элементы, которые могут быть на веб-странице, но при этом они скрыты от пользователя, например, из-за стиля display: none или visibility: hidden. Это условие учитывает не только наличие элемента в DOM-структуре страницы, но и его реальную видимость на экране.
<p>
Как использовать?<br>
Также как и для presence_of_element_located, вам нужно передать локатор, указывающий на интересующий вас элемент.
<pre>
locator = (By.XPATH, '//div[@class="visible_class"]')
element = WebDriverWait(browser, 10).until(EC.visibility_of_element_located(locator))
</pre>
<p>
<li> <b>.visibility_of()</b><br>
EC.visibility_of(element)— Это условие ожидания, которое проверяет, является ли конкретный элемент видимым на веб-странице.<br>
element— это уже найденный элемент Selenium.
<p>
В чем его особенность?<br>
В отличие от других условий, которые используют локаторы для указания на элемент, visibility_of принимает уже найденный элемент в качестве параметра. Это особенно удобно, когда у вас уже есть ссылка на объект элемента, и вы хотите убедиться в его видимости.
<p>
Как это работает?<br>
Это условие проверяет, что элемент не только присутствует в DOM-структуре страницы, но и виден пользователю (например, у него нет атрибутов display: none или visibility: hidden).
<pre>
element = browser.find_element(By.ID, 'visible_element_id')
visible_element = WebDriverWait(browser, 10).until(EC.visibility_of(element))
</pre>
<p>
<li> <b>presence_of_all_elements_located()</b><br>
EC.presence_of_all_elements_located(locator)— В некоторых ситуациях вам может потребоваться работать не с одним элементом, а с группой элементов, например, со списком или рядом кнопок. Используя это условие, вы можете удостовериться, что все эти элементы загрузились и присутствуют на странице перед тем, как начать с ними взаимодействие. Метод проверяет наличие всех элементов, указанных локатором, в DOM-структуре страницы. Однако стоит помнить, что "присутствие" не гарантирует "видимость" элемента.<br>
locator — такой же, как и выше.
<pre>
locator = (By.CLASS_NAME, 'some_class_name')
elements = WebDriverWait(browser, 10).until(EC.presence_of_all_elements_located(locator))
</pre>
<p>
<li> <b>visibility_of_any_elements_located()</b><br>
EC.visibility_of_any_elements_located(locator)— Это ожидаемое условие, которое проверяет видимость хотя бы одного элемента из группы элементов, соответствующих заданному локатору.<br>
locator — такой же, как и выше.
<p>
Зачем это нужно?<br>
Иногда на странице может быть несколько элементов с одинаковыми или похожими характеристиками (например, элементы списка). И вам может быть важно убедиться, что хотя бы один из этих элементов действительно виден пользователю, прежде чем продолжить выполнение вашего кода.
<p>
Как это работает?<br>
Это условие осуществляет поиск всех элементов по заданному локатору и возвращает список видимых элементов. Если этот список не пуст, условие считается выполненным.
<pre>
locator = (By.TAG_NAME, 'li')
visible_elements = WebDriverWait(browser, 10).until(EC.visibility_of_any_elements_located(locator))
</pre>
<p>
<li> <b>visibility_of_all_elements_located()</b><br>
EC.visibility_of_all_elements_located(locator)— Это ожидаемое условие в, которое убеждается в том, что абсолютно все элементы, соответствующие указанному локатору, являются видимыми на веб-странице.<br>
locator — такой же, как и выше.
<p>
Почему это важно?<br>
В определенных сценариях вам может потребоваться удостовериться, что каждый элемент из группы является доступным для пользователя. Например, если все пункты меню должны быть видимыми или все чекбоксы доступны для выбора.
<p>
Как это работает?<br>
Это условие выполняет поиск всех элементов по заданному локатору. Если все найденные элементы видимы, условие считается выполненным.
<pre>
locator = (By.CSS_SELECTOR, '.visible_elements')
all_visible_elements = WebDriverWait(browser, 10).until(EC.visibility_of_all_elements_located(locator))
</pre>
</ol>
<p>
Лучшие практики работы с проверкой элементов<br>
<ol>
<li> Используйте presence_of_element_located для быстрых проверок - этот метод работает быстрее, так как проверяет только DOM, а не видимость.
<li> Используйте visibility_of_element_located перед взаимодействием - перед кликом, вводом текста или другими действиями убедитесь, что элемент видим.
<li> Комбинируйте проверки - иногда полезно сначала проверить наличие, а затем видимость элемента.
<li> Устанавливайте разумные таймауты - не слишком короткие, чтобы избежать ложных срабатываний, и не слишком длинные, чтобы не замедлять тесты.
<li> Используйте специфичные локаторы - предпочитайте ID, name или уникальные CSS-селекторы для более надежного поиска элементов.
</ol>
<p>
Распространенные ошибки при проверке элементов
<ol>
<li> Использование presence_of_element_located вместо visibility_of_element_located - элемент может быть в DOM, но скрыт, что приведет к ошибкам при попытке взаимодействия.
<li> Слишком короткие таймауты - если страница загружается медленно, короткий таймаут может привести к ложным срабатываниям.
<li> Ненадежные локаторы - использование нестабильных локаторов (например, XPath, зависящих от текста) может привести к ошибкам при изменении страницы.
<li> Отсутствие обработки исключений - не обрабатывая исключения, вы можете пропустить важную информацию о причинах ошибок.
<li> Проверка видимости всех элементов, когда достаточно одного - это может замедлить выполнение тестов без необходимости.
</ol>
<p>
Жизненный цикл проверки элементов
<ol>
<li> Определите, что именно нужно проверить - наличие в DOM, видимость или и то, и другое.
<li> Выберите подходящий метод - на основе ваших требований выберите один из методов проверки.
<li> Создайте надежный локатор - используйте ID, name или уникальные CSS-селекторы.
<li> Установите разумный таймаут - обычно от 5 до 20 секунд, в зависимости от скорости загрузки страницы.
<li> Выполните проверку - используйте WebDriverWait с выбранным методом.
<li> Обработайте результат - сохраните элемент в переменную для дальнейшего использования или проверьте его свойства.
<li> Обработайте исключения - если элемент не найден или не видим, обработайте исключение и предоставьте полезную информацию для отладки.
</ol>
<p>
Про-совет: Комбинирование условий<br>
Для более надежной проверки элементов можно комбинировать несколько условий с помощью EC.all_of или EC.any_of:
<pre>
from selenium.webdriver.support import expected_conditions as EC

# Проверка, что элемент и присутствует, и видим
element = WebDriverWait(browser, 10).until(
    EC.all_of(
        EC.presence_of_element_located((By.ID, 'my_element')),
        EC.visibility_of_element_located((By.ID, 'my_element'))
    )
)

# Проверка, что элемент либо присутствует, либо видим
element = WebDriverWait(browser, 10).until(
    EC.any_of(
        EC.presence_of_element_located((By.ID, 'my_element')),
        EC.visibility_of_element_located((By.ID, 'my_element'))
    )
)
</pre>
<a name="check"><h3 align=center>Проверка текста и атрибутов элементов</h3>
<ol>
<li> <b>.text_to_be_present_in_element()</b><br>
EC.text_to_be_present_in_element(locator, text_)— Это ожидаемое условие, которое проверяет, содержит ли текст элемента, определенного локатором, заданное подстроковое значение.
<ol>
<li> locator: Кортеж, это может быть одно из значений из класса By, например, By.ID, By.CLASS_NAME, By.XPATH и так далее.
<li>text_: Этот параметр представляет собой текст или подстроку, который вы ожидаете найти внутри текста элемента. С помощью этого параметра вы указываете, какой конкретно текст или часть текста должен содержать элемент для успешного выполнения условия.
</ol>
<p>
Зачем это нужно ?<br>
В процессе автоматизации часто требуется удостовериться, что страница полностью загрузилась и содержит ожидаемую информацию. Это условие позволяет вам подтвердить, что определенный элемент на странице содержит нужный текст, что может служить индикатором успешной загрузки или наличия определенных данных.
<p>
Как это работает ?<br>
Это условие осуществляет поиск элемента на странице с использованием предоставленного локатора. После этого происходит проверка, содержит ли текст этого элемента заданное значение.
<pre>
#Определяем локатор и ожидаемый текст
locator = (By.ID, 'message')
expected_text = "Загрузка завершена"

# Используем явное ожидание, чтобы убедиться, что элемент содержит ожидаемый текст
WebDriverWait(browser, 10).until(<b>EC.text_to_be_present_in_element(locator, expected_text)</b>)
</pre>
<ul>
<li> Если текст появился → продолжаем выполнение кода.
<li> Если за 10 секунд текст не появился → выбрасывает ошибку TimeoutException.
<li> Важно помнить: этот метод возвращает булево значение (True/False), а не сам элемент! Если вам нужно взаимодействовать с элементом после проверки, его придется найти заново.
</ul>
<p>
<li> <b>.text_to_be_present_in_element_value()</b><br>
EC.text_to_be_present_in_element_value(locator, text_)— Это ожидаемое условие в Selenium, которое проверяет наличие определенного текста в значении атрибута value элемента, указанного локатором.
<ol>
<li> locator: Кортеж, содержащий два элемента — способ поиска (By.ID, By.XPATH, и т.д.) и значение для поиска.
<li> text_: Строка текста, который ожидается найти в значении атрибута value элемента.
</ol>
<p>
Зачем это нужно ?<br>
В процессе автоматизации действий на веб-сайтах часто встречаются элементы, такие как текстовые поля (например, поле для ввода пароля или поискового запроса). Это условие позволяет проверить, содержит ли такой элемент определенное значение. Это может быть полезно для проверки того, введено ли какое-то значение в поле ввода или для ожидания, пока значение элемента не обновится после каких-либо действий на странице.
<p>
Как это работает ?<br>
Условие осуществляет поиск элемента на основе предоставленного локатора. После нахождения элемента происходит проверка, содержит ли его атрибут value указанный текст.
<pre>
# Определяем локатор и ожидаемый текст
locator = (By.ID, 'search_field')
expected_text = "Query123"

# Используем явное ожидание, чтобы проверить наличие текста в элементе типа поле
WebDriverWait(browser, 10).until(EC.text_to_be_present_in_element_value(locator, expected_text))
</pre>
<p>
Важный момент:<br>
text_to_be_present_in_element_value() — сработает даже при частичном совпадении. Например ждем в поле ввода "авто",и если в поле ввода появиться надпись "Гайд по автоматизации" то условие выдаст True
<p>
Если в браузере открыть вкладку Elements и посмотреть на value у поля ввода (&lt;input>), то можно не увидеть текст, который там отображается. Это связано с тем, что:
<ol>
<li> Текст может быть динамически установлен через JavaScript и не обновлять сам атрибут value, а только свойство value в DOM.
<li> Некоторые фреймворки и библиотеки (React, Vue, Angular) работают именно со свойством value, а не с атрибутом.
<li> HTML-атрибут value показывает только значение, которое было установлено изначально (статически в коде), но не текущее, если оно изменилось через пользовательский ввод или скрипты.
</ol>
<p>
<li> <b>text_to_be_present_in_element_attribute()</b><br>
EC.text_to_be_present_in_element_attribute(locator, attribute_, text_) —это ожидаемое условие, которое проверяет, содержится ли указанный текст в определенном атрибуте элемента, определенного локатором.
<ul>
<li> locator: Кортеж, состоящий из двух элементов — способа поиска (By.ID, By.XPATH, и т.д.) и значения для поиска.
<li> attribute_: Название атрибута элемента, который вы хотите проверить (например, href, src, alt и т.д.).
<li> text_:Строка текста, который ожидается найти в значении указанного атрибута.
</ul>
<p>
Зачем это нужно ?<br>
В процессе автоматизации часто требуется не только извлекать текстовое содержимое элементов, но и атрибуты этих элементов, такие как href у ссылок, src у изображений и т. д. Это условие позволяет удостовериться, что атрибут элемента содержит определенное значение, что может быть ключевым критерием при выборе элементов для дальнейшей автоматизации.
<p>
Как это работает ?<br>
Это условие выполняет поиск элемента на основе предоставленного локатора. После нахождения элемента осуществляется проверка содержания определенного атрибута этого элемента на наличие заданного текста.
<pre>
# Определяем локатор, атрибут и ожидаемый текст
locator = (By.ID, 'image_id')
attribute_name = "alt"
expected_text = "Descriptive Image Text"

# Используем явное ожидание, чтобы удостовериться, что атрибут содержит нужный текст
WebDriverWait(browser, 10).until(EC.text_to_be_present_in_element_attribute(locator, attribute_name, expected_text))
</pre>
<p>
<li> <b>.element_attribute_to_include()</b><br>
EC.element_attribute_to_include(locator, attribute_)— это ожидаемое условие, которое проверяет наличие указанного атрибута у элемента, определенного локатором.
<ul>
<li> locator: Кортеж, состоящий из двух элементов — способа поиска (By.ID, By.XPATH, и т.д.) и значения для поиска.
<li> attribute_: Строка с названием атрибута, который нужно проверить.
</ul>
<p>
Возвращаемое значение:<br>
True: Если атрибут присутствует (даже если его значение пустое).<br>
False: Если атрибут отсутствует.
<p>
Зачем это нужно ?<br>
В процессе автоматизации иногда важно удостовериться, что элемент имеет определенный атрибут, независимо от его значения. Например, проверить наличие атрибута data-loaded у изображения, чтобы убедиться, что оно загружено, или наличие атрибута disabled у кнопки, чтобы определить её состояние.
<p>
Как это работает ?<br>
Это условие выполняет поиск элемента на основе предоставленного локатора. После нахождения элемента осуществляется проверка наличия указанного атрибута с помощью метода get_attribute(). Если метод возвращает значение, отличное от None, условие считается выполненным.
<pre>
# Определяем локатор и атрибут
locator = (By.ID, 'image_id')
attribute = "src"

# Используем явное ожидание, чтобы удостовериться, что у элемента есть атрибут "src"
WebDriverWait(browser, 10).until(EC.element_attribute_to_include(locator, attribute))
</pre>
</ol>
<p>
Лучшие практики использования
<ul>
<li> Выбирайте наиболее конкретный метод — для проверки текста используйте text_to_be_present_in_element, для атрибута value — специальный метод, и т.д.
<li> Устанавливайте разумные таймауты — для медленных операций (загрузка изображений) используйте более длительные ожидания
<li> Комбинируйте методы — иногда полезно сначала проверить наличие атрибута, а затем его содержимое
<li> Используйте частичное совпадение — все методы работают с подстроками, что дает большую гибкость при проверках
<li> Помните о типе возвращаемого значения — все эти методы возвращают bool, а не элемент! Для взаимодействия с элементом его нужно найти заново
</ul>
С помощью этих методов вы сможете создавать надежные парсеры и автоматизированные скрипты, которые корректно работают с динамическим контентом и дожидаются нужных состояний элементов перед взаимодействием с ними.
<pre>

</pre>
<a name="alert"><h3 align=center>Ожидание окон, элементов и алертов</h3>
<ul>
<li> <b>.frame_to_be_available_and_switch_to_it()</b><br>
EC.frame_to_be_available_and_switch_to_it(locator)— Это ожидаемое условие, которое проверяет доступность iframe на веб-странице и автоматически переключается на него.<br>
locator: Кортеж, содержащий способ поиска (например, By.ID или By.XPATH) и значение для поиска.
<p>
Зачем это нужно ?<br>
Многие сайты используют фреймы для разделения контента или вставки контента из других источников особенно капчи. Для взаимодействия внутри такого фрейма необходимо сначала переключиться на него.Это помогает избежать ошибок, связанных с попыткой взаимодействия с элементами фрейма до его полной загрузки.
<p>
Как это работает?<br>
Это условие осуществляет поиск фрейма по заданному локатору и, если фрейм доступен, осуществляет переключение на него.
<pre>
locator = (By.ID, 'iframe_id')
WebDriverWait(browser, 10).until(EC.frame_to_be_available_and_switch_to_it(locator))
</pre>
<p>
<li> <b>.invisibility_of_element_located()</b><br>
EC.invisibility_of_element_located(locator)— Этот метод используется, когда мы еще не нашли элемент, а просто хотим дождаться его невидимости.<br>
locator: Кортеж, содержащий способ поиска и значение для поиска.
<p>
Зачем это нужно ?<br>
Иногда перед извлечением данных необходимо удостовериться, что определенные элементы (например, всплывающие окна или баннеры) исчезли или стали невидимыми.
<p>
Как это работает ?<br>
Для понимания работы этого условия важно различать два состояния элемента: "не присутствует на странице" и "присутствует, но невидим". Элемент может быть частью DOM-структуры страницы, но при этом быть невидимым для пользователя из-за стилей CSS (например, из-за display: none или opacity: 0).
<p>
Предположим, у нас есть элемент с ID loading_spinner, который отображается, пока данные загружаются. Мы хотим подождать, пока этот элемент исчезнет (т.е. загрузка завершится).
<pre>
WebDriverWait(browser, 10).until(EC.invisibility_of_element_located((By.ID, 'loading_spinner')))
</pre>
Здесь мы не ищем сам элемент заранее, а сразу указываем локатор (By.ID, 'loading_spinner'), и Selenium будет ожидать, пока элемент исчезнет. Как только элемент исчезнет, WebDriverWait вернет True и код побежит дальше.
<p>
<li> <b>.invisibility_of_element()</b><br>
EC.invisibility_of_element(element) — Этот метод используется, когда элемент уже найден, и мы хотим проверить, стал ли он невидимым.<br>
element: Ссылка на уже найденный элемент.
<p>
Как это работает?<br>
Поиск Элемента: В отличие от многих других ожидаемых условий, EC.invisibility_of_element() не ищет элемент на странице. Вместо этого он ожидает, что вы уже нашли элемент и передадите его в качестве аргумента. Это означает, что элемент должен быть найден до вызова этого условия. Используйте этот метод, если вы уже нашли элемент и хотите дождаться, пока именно этот конкретный элемент станет невидимым.
<p>
Проверка Видимости: Условие проверяет, видим ли элемент на странице в данный момент. Элемент считается невидимым, если он отсутствует в DOM, его ширина и высота равны 0, или у него установлен стиль display: none.
<p>
Возврат Результата:<br>
Если элемент невидим, условие возвращает True.<br>
Если элемент видим, условие возвращает False.
<pre>
# Предположим, что element — это элемент всплывающего окна, который вы нашли ранее
element = browser.find_element(By.ID,'popup')

# Теперь вы хотите дождаться, пока всплывающее окно исчезнет
WebDriverWait(browser, 10).until(EC.invisibility_of_element(element))
</pre>
<p>
<li> <b>.element_to_be_clickable()</b><br>
EC.element_to_be_clickable(locator)— Это условие, предназначено для ожидания, пока элемент на веб-странице станет видимым и доступным для клика.<br>
locator: Кортеж, включающий в себя метод поиска элемента (ID, XPATH, CSS_SELECTOR и другие.) и значение, по которому осуществляется поиск.
<p>
Как это работает?<br>
Сначала Selenium пытается найти элемент на странице, используя предоставленный locator. После нахождения locator проверяется его видимость. locator считается видимым, если он присутствует в DOM (структуре документа), не скрыт CSS-стилями (например, свойством display: none; или visibility: hidden;), и имеет ненулевые размеры.<br>
Кроме проверки видимости, также проверяется, что locator активен и доступен для клика. Это означает, что он не перекрыт другими элементами и не заблокирован для взаимодействия. Важно не только то, что элемент виден, но и то, что он готов к взаимодействию.
<p>
Если locator не найден, не видим или не доступен для клика, Selenium будет ожидать в течение заданного времени (используя WebDriverWait(browser, 10) ) до тех пор, пока условия не будут выполнены.
<p>
Как только locator становится видимым и доступным для клика, он возвращается для дальнейших действий. Это может быть, например, клик по кнопке или другие взаимодействия.
<pre>
# Определение локатора для кнопки
button_locator = (By.ID, 'submit_button')

# Ожидание, пока кнопка станет доступна для клика
button = WebDriverWait(browser, 10).until(EC.<b>element_to_be_clickable</b>(button_locator))

# Теперь можно кликнуть по кнопке
button.click()
</pre>
<p>
<li> <b>.staleness_of()</b><br>
EC.staleness_of(element)— Это ожидаемое условие, которое проверяет, стал ли element устаревшим, то есть исчез ли он с DOM-структуры страницы или был ли он перезагружен. Это условие возвращает True, если element больше не присутствует в DOM или если его состояние стало устаревшим.<br>
element— Это элемент веб-страницы, который мы ожидаем станет устаревшим.
<p>
Как это работает?<br>
Когда вы взаимодействуете с веб-страницей, Selenium сохраняет ссылки на elements страницы.
Если страница обновляется, перезагружается или если какие-то elements исчезают, то ранее найденные ссылки на элементы могут стать устаревшими. staleness_of проверяет, действительна ли еще ссылка на element. Если element исчез из DOM или его состояние изменилось, условие возвращает True. Это полезно для ожидания завершения каких-либо асинхронных операций на странице, которые могут приводить к изменению DOM.
<pre>
# Находим элемент
element = browser.find_element(By.ID, 'some_element')

# Выполняем действие, которое приведет к обновлению элемента (например, клик по кнопке)
browser.find_element_by_id('update_button').click()

# Ожидаем, пока элемент станет устаревшим
WebDriverWait(browser, 10).until(EC.<b>staleness_of</b>(element))
</pre>
<p>
Важный момент: Что такое устаревание (staleness) в Selenium:<br>
Элемент считается устаревшим (stale), если он больше не привязан к текущему DOM или его ссылка в памяти Selenium становится недействительной. Это происходит в следующих случаях:
<ol>
<li> Элемент полностью удаляется из DOM (например, через remove()).
<li> Элемент заменяется другим элементом.
<li> Страница перезагружается, и весь DOM обновляется.
</ol>
EC.staleness_of(element) возвращает True, только если сохраненная ссылка на элемент (WebElement) перестает быть актуальной в текущем состоянии страницы.
<p>
<li> <b>element_to_be_selected()</b><br>
EC.element_to_be_selected(element)— Это ожидаемое условие в Selenium, которое проверяет, выбран ли предоставленный элемент на веб-странице. Это условие чаще всего используется для работы с элементами формы, такими как чекбоксы, радиокнопки или опции в выпадающем списке.<br>
element: Это сам элемент, который вы хотите проверить на то, выбран он или нет.
<p>
Как это работает?<br>
Когда вы передаете element в это условие, Selenium проверяет атрибут selected этого элемента. Если элемент выбран ✅ (то есть атрибут selected присутствует и установлен в true), условие считается выполненным.
<pre>
# Находим элемент (чекбокс) на странице
checkbox_element = browser.find_element(By.ID, "my_checkbox")

# Используем явное ожидание, чтобы убедиться, что чекбокс выбран
WebDriverWait(browser, 10).until(EC.<b>element_to_be_selected</b>(checkbox_element))
</pre>
<p>
<li> <b>.element_located_to_be_selected()</b><br>
.element_located_to_be_selected(locator)— Это ожидаемое условие проверяет, выбран ли элемент, определенный по локатору. Элемент может быть чекбоксом, радиокнопкой или опцией в выпадающем списке. Отличие от element_to_be_selected в том, что здесь вы передаете локатор, а не сам элемент.<br>
locator: Кортеж, содержащий два элемента: стратегию поиска элемента (By.ID, By.XPATH, и т.д.) и сам запрос для поиска.
<p>
Как это работает?<br>
Сначала Selenium выполняет поиск элемента на странице, используя предоставленный locator.
После того, как элемент найден, Selenium проверяет его атрибут selected. Если элемент выбран (чекбокс отмечен, радиокнопка активна, опция в выпадающем списке выбрана), то условие возвращает True. В противном случае возвращается False.
<p>
Ожидание: Если элемент не выбран, Selenium будет ожидать до истечения таймаута, периодически повторяя попытки проверки. Если время ожидания истекает, и элемент так и не становится выбранным, то будет выброшено исключение TimeoutException.
<pre>
# Определение локатора для чекбокса
checkbox_locator = (By.ID, 'accept_terms_checkbox')

# Ожидание, пока чекбокс станет выбранным
WebDriverWait(browser, 10).until(EC.element_located_to_be_selected(checkbox_locator))
</pre>
<p>
<li> <b>.element_selection_state_to_be()</b><br>
EC.element_selection_state_to_be(element, is_selected)— Это ожидаемое условие, которое проверяет, соответствует ли состояние выбора (выделения) элемента ожидаемому значению.
<ul>
<li> element: Это уже найденный элемент на веб-странице, состояние выбора которого вы хотите проверить. Элемент может быть чекбоксом, радио кнопкой или другим элементом формы, имеющим атрибут selected.
<li> is_selected: Булево значение (True или False), которое указывает, ожидаете ли вы, что элемент будет (✔️) или нет (❌).
</ul>
<p>
На пальцах<br>
Представьте, что вы на веб-странице с формой, и вам нужно убедиться, что определенный чекбокс отмечен, прежде чем вы продолжите выполнение вашего кода. Или наоборот, вам нужно удостовериться, что чекбокс не отмечен. Это условие как раз помогает в таких ситуациях.
<p>
Функция будет ожидать до тех пор, пока состояние выбора элемента не станет соответствовать значению is_selected или пока не истечет время ожидания. Позволяет дождаться как выбора элемента, так и снятия выбора.
<pre>
# Предположим, у нас есть чекбокс с ID "my_checkbox"
checkbox = browser.find_element(By.ID, 'my_checkbox')

# Мы хотим удостовериться, что чекбокс отмечен
WebDriverWait(browser, 10).until(EC.element_selection_state_to_be(checkbox, True))
</pre>
<p>
<li> <b>.element_located_selection_state_to_be()</b><br>
 EC.element_located_selection_state_to_be(locator, is_selected)— Это ожидаемое условие, которое проверяет, находится ли элемент, определенный локатором, в определенном состоянии выбора (выбран ✔️ или не выбран ❌).
<ul>
<li> locator: Кортеж, содержащий способ поиска и значение для поиска. Например, (By.ID, 'checkbox').
<li> is_selected: Булево значение, указывающее ожидаемое состояние выбора элемента. True означает, что элемент должен быть выбран, False — что не должен.
</ul>
<p>
Как это работает? Удобно, когда нужно проверить состояние элемента, не сохраняя предварительно ссылку на него.
<p>
Поиск Элемента: Сначала Selenium ищет locator на веб-странице, используя предоставленный локатор. 
<p>
Проверка Состояния Выбора: Затем ожидаемое условие проверяет, находится ли найденный locatorв ожидаемом состоянии выбора. Состояние выбора может быть True (элемент выбран) или False (элемент не выбран).
<p>
Возврат Результата: Если состояние элемента соответствует ожидаемому, условие возвращает True, и программа может продолжить выполнение. Если состояние не соответствует ожидаемому, то будет подождать до истечения времени ожидания, и в случае неудачи выбросится исключение TimeoutException.
<pre>
locator = (By.ID, 'my_checkbox')
expected_state = True  # Ожидаем, что чекбокс будет отмечен

# Ожидаем, пока чекбокс не окажется в ожидаемом состоянии
WebDriverWait(browser, 10).until(EC.element_located_selection_state_to_be(locator, True))
</pre>
<p>
<li> <b>.number_of_windows_to_be()</b><br>
EC.number_of_windows_to_be(num_windows)— Условие ожидания, которое проверяет, равно ли текущее количество открытых окон в браузере заданному числу.
<p>
Как это работает?
<ol>
<li> Подсчет Окон: Selenium поддерживает взаимодействие с несколькими окнами браузера. Когда вы взаимодействуете с веб-страницей, могут открываться новые вкладки или окна. Selenium может отслеживать все открытые окна и вкладки.
<p>
<li> Получение Списка Дескрипторов: Selenium предоставляет функцию для получения списка всех текущих дескрипторов окон. Дескриптор окна – это уникальный идентификатор, который представляет собой строку.
<p>
<li> Проверка Количества Окон: EC.number_of_windows_to_be берет это количество открытых окон (по сути, длину списка дескрипторов) и сравнивает его с числом, которое вы передали в качестве параметра num_windows.
<p>
<li> Ожидание Состояния: Если текущее количество открытых окон соответствует ожидаемому, условие возвращает True, что означает успешное выполнение ожидания. Если количество окон не соответствует ожидаемому, условие продолжает ждать до истечения тайм-аута, и только после этого возвращает False. Полезно для проверки того, что действие (например, клик) привело к открытию или закрытию ожидаемого количества окон/вкладок.
</ol>
<pre>
# Предполагаем, что изначально открыто одно окно
num_windows_before = len(browser.window_handles)

# Выполняем действие, которое должно открыть новое окно
browser.find_element(By.ID, 'some_link').click()

# Ожидаем, пока не откроется новое окно
WebDriverWait(browser, 10).until(EC.<b>number_of_windows_to_be</b>(num_windows_before + 1))

# Теперь можно безопасно переключиться на новое окно и продолжить тест
new_window_handle = [handle for handle in browser.window_handles if handle != browser.current_window_handle][0]
browser.switch_to.window(new_window_handle)
</pre>
<p>
<li> <b>.new_window_is_opened()</b><br>
EC.new_window_is_opened(current_handles)— Это ожидаемое условие, которое проверяет, было ли открыто новое окно или вкладка браузера.<br>
current_handles: список строк, представляющих собой уникальные идентификаторы уже открытых окон/вкладок браузера.
<p>
Зачем это нужно?<br>
При автоматизации тестирования или парсинга веб-страниц часто возникают сценарии, когда в результате какого-либо действия (например, клика по ссылке или кнопке) открывается новое окно или вкладка браузера. Для дальнейшей работы с этим новым окном необходимо убедиться, что оно действительно было открыто.
<p>
Как это работает?<br>
Когда вы вызываете это условие, Selenium сравнивает текущий список открытых окон/вкладок с предоставленным списком current_handles. Если количество окон/вкладок увеличилось, и появился хотя бы один новый уникальный идентификатор, условие считается выполненным.
<pre>
# Получаем список текущих открытых окон/вкладок
current_handles = browser.window_handles

# Выполняем действие, которое должно открыть новое окно/вкладку
browser.find_element(By.ID, 'open_new_window_button').click()

# Ждем открытия нового окна/вкладки
WebDriverWait(browser, 10).until(EC.new_window_is_opened(current_handles))

# Получаем новый список окон/вкладок
new_handles = browser.window_handles

# Находим идентификатор нового окна/вкладки
new_window = [handle for handle in new_handles if handle not in current_handles][0]

# Переключаемся на новое окно/вкладку
browser.switch_to.window(new_window)
</pre>
<p>
<li> <b>EC.alert_is_present()</b><br>
EC.alert_is_present()— Является ожидаемым условием и предназначена для проверки наличия всплывающего окна предупреждения (alert) на веб-странице.
<p>
Как это работает?<br>
Это условие проверяет, появилось ли всплывающее окно предупреждения на странице. Всплывающие окна предупреждений — это специальные диалоговые окна, которые не являются частью DOM-дерева страницы, и для их обработки требуются специальные методы WebDriver.
<p>
Когда вызывается EC.alert_is_present(), WebDriver пытается найти всплывающее окно предупреждения на текущей веб-странице.
Если всплывающее окно найдено, функция возвращает объект Alert, представляющий это всплывающее окно. Это позволяет вам взаимодействовать с всплывающим окном, например, принимать его, отклонять или извлекать из него текст. 
Если всплывающее окно не найдено, функция выбрасывает исключение NoAlertPresentException.
<pre>
# Используем явное ожидание для проверки наличия всплывающего окна предупреждения
alert = WebDriverWait(browser, 10).until(EC.<b>alert_is_present</b>())

# После этого можно взаимодействовать с всплывающим окном
text = alert.text
alert.accept()
</pre>
</ul>
<pre>

</pre>
<a name="drop"><h3 align=center>Drag and Drop (перетаскивание) в Selenium</h3>
Drag and Drop (перетаскивание) - это операция перетаскивания элемента из одной позиции в другую. Это может быть полезно, если вы хотите автоматизировать действия пользователя, такие как:
<ul>
<li> Загрузка файлов
<li> Перемещение элементов в различные области
<li> Установка элементов в определенный порядок
</ul>
<p>
Selenium предоставляет реализацию drag and drop с помощью класса ActionChains. Вы можете создать экземпляр ActionChains, используя экземпляр вашего веб-драйвера, а затем использовать методы, такие как:
<ol>
<li> drag_and_drop()
<li> move_by_offset()
<li> drag_and_drop_by_offset() 
<li> click_and_hold()
</ol> 
чтобы выполнить действие перетаскивания.
<p>
<ul>
<li> <b>.drag_and_drop()</b><br>
action.drag_and_drop(element, target) - это метод класса ActionChains. Он позволяет перетащить element  и поместить его в элемент target. 
<ul>
<li> element - элемент, который нужно перетаскивать.
<li> target -  целевой элемент, куда будем перемещать иcходный элемент
</ul>
<p>
Шаги работы метода .drag_and_drop():<br>
<ol>
<li> Найти Элемент для Перетаскивания: Сначала Selenium должен найти element на веб-странице, который вы хотите перетащить. Это может быть сделано с помощью различных методов поиска, таких как find_element(By.ID, 'ID_ELEM').
<pre>
# Находим исходный элемент, который будем перемещать
element = browser.find_element(By.ID,"source-element")
</pre>
<p>
<li> Найти целевой элемент: Затем Selenium должен найти место target, куда вы хотите перетащить выбранный element.
<pre>
# Находим целевой элемент, куда будем перемещать иcходный элемент
target = browser.find_element(By.ID,"target-element")
</pre>
<p>
<li> Инициализация действий: После того как элементы найдены, создается объект ActionChains, который используется для инициализации серии действий.
<pre>
# Создаём экземпляр класса ActionChains
<b>actions = ActionChains(browser)</b>
</pre>
<p>
<li> Выполнение перетаскивания: С помощью метода drag_and_drop объекта ActionChains Selenium "берет" element, "перетаскивает" его и "отпускает" на месте target. Весь этот процесс происходит виртуально в браузере, как если бы пользователь делал это вручную.
<pre>
# Выполняем действие перетаскивания
actions.drag_and_drop(element, target).<b>perform()</b>
</pre>
<p>
<li> Завершение действия: После того как действие перетаскивания инициировано, его нужно выполнить с помощью метода perform().
</ul>
<p>
<li> <b>.move_by_offset()</b><br>
action.move_by_offset(xoffset, yoffset) - используется для перемещения <b>указателя мыши</b> от текущего положения на определенное смещение по осям X и Y.
<p>
Основные применения move_by_offset():
<ul>
<li> Управление ползунками (слайдерами) на веб-страницах
<li> Работа с интерактивными картами и графиками
<li> Взаимодействие с элементами, которые реагируют на координаты мыши
<li> Решение капч, требующих точного позиционирования
<li> Имитация плавных движений мыши для более реалистичной автоматизации
</ul>
<p>
Как работает .move_by_offset(xoffset, yoffset):
<ul>
<li> xoffset - расстояние по оси x,
<li> yoffset - расстояние по оси y.
</ul>
<ol>
<li> Текущее положение мыши: Selenium учитывает текущее положение указателя мыши на странице.
<p>
<li> Смещение: Вы указываете, на сколько пикселей нужно сместить указатель мыши по горизонтали (ось X) и по вертикали (ось Y). Значения могут быть как положительными, так и отрицательными:
<ul>
<li> Положительное значение xoffset переместит указатель вправо.
<li> Отрицательное значение -xoffset переместит указатель влево.
<li> Положительное значение yoffset переместит указатель вниз.
<li> Отрицательное значение -yoffset переместит указатель вверх.
</ul>
<p>
<li> Выполнение действия: После того как смещение задано, метод .perform() вызывается для выполнения действия.
<p>
<li> Новое положение мыши: Указатель мыши перемещается на заданное смещение относительно его текущего положения.
</ul>
<p>
Обычно этот метод используется совместно с методом click(), чтобы симулировать действия пользователя с мышью.
</ol>
<p>
Примеры кода<br>
Код ниже демонстрирует использование Selenium для автоматизации взаимодействия с <b>ползунком (slider)</b> на веб-странице. Давайте разберем его построчно:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import time
from selenium import webdriver
<b>from selenium.webdriver.common.action_chains import ActionChains</b>
from selenium.webdriver.common.by import By

url = "https://parsinger.ru/selenium/5.10/5/index.html"

with webdriver.Chrome() as browser:
    browser.get(url)
    slider = browser.find_element(By.ID, "volume")
    time.sleep(3)

    <b>ActionChains(driver).click_and_hold(slider).move_by_offset(50, 0)</b>.release().perform()
</pre></td></tr></table>
<p>
 Разберём основную строку:
<pre>
ActionChains(browser).click_and_hold(slider).move_by_offset(50, 0).release().perform()
</pre>
<ol>
<li> Создается объект ActionChains, инициализированный текущим экземпляром браузера.<br>
<li> click_and_hold(slider): Нажимает и удерживает левую кнопку мыши на элементе slider.<br>
<li> move_by_offset(50, 0): Перемещает мышь на 50 пикселей вправо от текущего положения. Поскольку второй параметр равен 0, вертикальное смещение отсутствует.<br>
<li> release(): Отпускает левую кнопку мыши.<br>
<li> perform(): Выполняет все запланированные действия.
</ol>
<p>
В отличие от предыдущего примера кода, который осуществляет перемещение ползунка скачками на фиксированное количество пикселей, представленный ниже код реализует <b>плавное передвижение ползунка</b> на определённое смещение от его начального положения. Это может быть особенно полезно в ситуациях, когда требуется более точное и деликатное управление элементами интерфейса.<br>
Например, при взаимодействии с капчей, которая требует от пользователя точного позиционирования ползунка для совмещения определённых элементов изображения, важно иметь возможность мелкого и точного управления ползунком. В таком случае, передвигая ползунок на определённое смещение относительно его начального положения, пользователь может добиться более высокой степени точности, что, в свою очередь, повышает шансы на успешное прохождение капчи.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
import time
from selenium.webdriver.common.by import By

# Использование контекстного менеджера для управления драйвером
with webdriver.Chrome() as browser:
    # Загрузите локальный HTML-файл
    browser.get('https://parsinger.ru/selenium/5.10/5/index.html')

    slider = browser.find_element(By.ID,'volume')
    <font color=red>width = slider.size['width']</font>
    # Вычислите смещение для 1 единицы
    offset = width / 100

    actions = ActionChains(browser)

    # Нажмите на ползунок и удерживайте кнопку мыши
    actions.click_and_hold(slider).perform()

    # В цикле перемещайте ползунок на 1 единицу
    for _ in range(10):  # пример для 10 шагов
        actions.<b>move_by_offset</b>(offset, 0).perform()
        time.sleep(0.1)  # пауза для наглядности

    # Отпустите кнопку мыши
    actions.release().perform()
</pre></td></tr></table>
<p>
Разберём основные моменты в коде подробнее:<br>
<ol>
<li> Находим элемент ползунка по его идентификатору ('volume'). Затем получается ширина этого элемента, которая будет использоваться для вычисления смещения при перемещении ползунка.
<pre>
slider = browser.find_element(By.ID, 'volume')
width = slider.<font color=red>size</font>['width']
</pre>
<li> Для каждого шага вычисляется смещение (1% от ширины ползунка)
<pre>
# Вычислите смещение для 1 единицы
offset = width / 100
</pre>
<li> Выполняем нажатие и удержания кнопки мыши на элементе ползунка.
<pre>
actions.<b>click_and_hold(slider)</b>.perform()
</pre>
<li> В цикле ползунок перемещается на 10 шагов вправо. В качестве величины шага смещения используется offset, рассчитанный ранее. Между шагами делается пауза в 0.1 секунду для наглядности.
<pre>
for _ in range(10):  # пример для 10 шагов
    actions.move_by_offset(offset, 0).perform()
    time.sleep(0.1)  # пауза для наглядности
# Отпускаем кнопку мыши, завершая действие перетаскивания.
actions.release().perform()
</pre>
</ol>
<p>
<li> <b>.drag_and_drop_by_offset(element, xoffset, yoffset)</b><br>
 это метод класса ActionChains, который используется для перетаскивания <b>элемента</b> на определенное расстояние от его текущего положения. Вместо того чтобы указывать целевой элемент, как в методе .drag_and_drop(), вы указываете смещение по осям xoffset и yoffset, на которое элемент должен быть перемещен.
<ul>
<li> element - элемент, который нужно перетаскивать.
<li> xoffset - расстояние по оси X, на которое нужно переместить элемент.
<li> yoffset - расстояние по оси Y, на которое нужно переместить элемент.
</ul>
<p>
<i>
ActionChains(driver).drag_and_drop_by_offset(element_to_drag, 50, 25).release().perform()<br>
Смещение происходит относительно центра, а после смещения координаты элемента выставляются по левому верхнему углу, таким образом, на каждом шагу происходит уменьшение на 25 пикселей(половина высоты элемента). Чтобы квадратик ехал прямо, нужно это учесть</i>
<p>
Как это работает:<br>
<ol>
<li> Найти элемент для перетаскивания: Сначала Selenium должен найти element на веб-странице, который вы хотите перетащить. Это может быть сделано с помощью различных методов поиска, таких как find_element().
<pre>
# Находим элемент, который будем перемещать
element = driver.find_element(By.ID, "element-id")
</pre>
<p>
<li> Инициализация действий: После того как element найден, создается объект ActionChains, который используется для инициализации серии действий.
<pre>
# Создаём экземпляр класса ActionChains
actions = ActionChains(driver)
</pre>
<p>
<li> Выполнение перетаскивания: С помощью метода drag_and_drop_by_offset объекта ActionChains Selenium "берет" element, "перетаскивает" его на указанное смещение по осям xoffset и yoffset и "отпускает" его.
<pre>
# Выполняем перетаскивание по смещению
actions.drag_and_drop_by_offset(element, 200, 100).perform()
</pre>
<p>
<li> Завершение действия: После того как действие перетаскивания инициировано, его нужно выполнить с помощью метода perform.
</ol>
<p>
Пример с .drag_and_drop_by_offset() :
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import time  
from selenium import webdriver 
<b>from selenium.webdriver.common.action_chains import ActionChains</b>
from selenium.webdriver.common.by import By

with webdriver.Chrome() as driver:
    driver.get("https://parsinger.ru/selenium/5.10/7/index.html")  
    element_to_drag = driver.find_element(By.ID, "click_and_hold")  
    time.sleep(1) 
    # Создание объекта ActionChains, инициализация операции перетаскивания элемента на 500 пикселей вправо
    # и выполнение цепочки действий
    <b>ActionChains(driver).drag_and_drop_by_offset</b>(element_to_drag, 500, 0).release().perform()
</pre></td></tr></table>
<p>
Описание работы кода:<br>
<ol>
<li> element_to_drag = driver.find_element(By.ID, "click_and_hold")<br>
На странице ищется элемент с ID click_and_hold.<br>
<p> 
<li> time.sleep(1)<br>
Программа ожидает 1 секунду, чтобы все элементы страницы успели загрузиться.
<p>
<li> ActionChains(driver).drag_and_drop_by_offset(element_to_drag, 500, 0)<br>
Создается объект ActionChains, который инициирует операцию перетаскивания найденного элемента на 500 пикселей вправо от его текущего положения.
<p>
<li>  Метод release() вызывается для отпускания элемента после перетаскивания. Метод perform() выполняет всю цепочку заданных действий.
</ol>
<p>
<li> <b>.click_and_hold(element)</b><br>
это метод в классе ActionChains , который используется для захвата элемента и начала перетаскивания. Этот метод принимает в качестве аргумента элемент, который вы хотите захватить. После вызова click_and_hold(), вы можете вызвать методы, такие как move_to_element(), move_by_offset() или release() для выполнения перетаскивания элемента.
<p>
Как работает .click_and_hold(element):<br>
<ol>
<li> Найти элемент: Сначала необходимо найти element на веб-странице, на который вы хотите нажать и удерживать кнопку мыши. Это может быть сделано с помощью различных методов поиска, таких как find_element().
<pre>
# 1. Найти элемент
element = driver.find_element(By.ID, "ID_ЭЛЕМЕНТА")
</pre>
<p>
<li> Инициализация действий: Затем создается объект ActionChains, который используется для инициализации серии действий.
<pre>
# 2. Инициализация действий
actions = ActionChains(driver)
</pre>
<p>
<li> Нажать и удерживать: С помощью метода .click_and_hold() объекта ActionChains Selenium "нажимает" на выбранный element и "удерживает" кнопку мыши.
<pre>
# 3. Нажать и удерживать
actions.click_and_hold(element)
</pre>
<p>
<li> (Опционально) Выполнение дополнительных действий: После того как кнопка мыши нажата и удерживается, вы можете добавить дополнительные действия в цепочку, такие как перемещение к другому элементу с помощью .move_to_element().
<pre>
# 4. (Опционально) Выполнение дополнительных действий
# actions.move_to_element(ДРУГОЙ_ЭЛЕМЕНТ)
</pre>
<p>
<li> Завершение действия: После того как все необходимые действия добавлены в цепочку, их нужно выполнить с помощью метода .perform().
<pre>
# 5. Завершение действия
actions.perform()
</pre>
</ol>
Пример:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.by import By
import time

url = "https://parsinger.ru/selenium/5.10/7/index.html"

# Инициализация драйвера
with webdriver.Chrome() as driver:
    # Устанавливаем неявное ожидание для всех элементов
    driver.implicitly_wait(10)

    # Переход на страницу
    driver.get(url)
    time.sleep(1)
    # Поиск элемента для перетаскивания и контейнера
    click_and_hold_element = driver.find_element(By.ID, "click_and_hold")
    container = driver.find_element(By.CLASS_NAME, "container")

    # Выполнение операции перетаскивания
    actions = ActionChains(driver)
    actions.click_and_hold(click_and_hold_element).move_to_element(container).release().perform()

    # Даем время для визуальной проверки (по желанию)
    time.sleep(5)
</pre></td></tr></table>
<p>
Этот скрипт откроет Chrome, перейдет по указанной ссылке, найдет элемент с id='click_and_hold' и перетащит его в контейнер с class='container'.
</ul>
<pre>


</pre>
</div></body></html>
