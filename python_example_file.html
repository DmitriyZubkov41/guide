<html><head>
<style>
.menu {
       height: 100%;
       width: 130px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 140px; /* То же, что и ширина боковой панели */
           padding: 0px 0px 0px 0px;
         }
</style>
</head><body>
<title>Примеры по работе с файлами</title>
<div class="menu">
<a href="python_base.html">Основы python</a>
<a href="#file">Файлы</a>
<a href="#text">Работа с текстом</a>
<a href="#regularn">Регулярные выражения</a>
<a href="#table">Работа с таблицами</a>
<a href="#xml">Работа с XML</a>
<a href="#parsing">Парсинг файлов</a>
<a href="#plot">Построение графиков</a>
<a href="#api">API</a>
</div>
<div class="content">
<h3 align=center><a name="file">Файл, методы работы с файлами</h3>
Напишите программу, которая считывает из файла строку, соответствующую тексту, сжатому с помощью кодирования повторов, и
производит обратную операцию, получая исходный текст.
<pre>
with open('/home/dmitriy/Python/mypython/dataset_3363_2 (1).txt') as inf:
  for line in inf:
      line = line.strip()
      # print(line)
  simvol = ''
  num = ''
  str = ''
  for i in range(len(line)):
      ''' если символ является цифрой, тогда запоминаем ее в переменной num строкового типа
      если следующий символ снова цифра, тогда добавляем ее в num
      если же буква, тогда переменную символа simvol умножаем на int(num) и записывает эту строку в новый файл new_file.txt'''
      if '0' <= line[i] <= '9': # цифра
          num = num + line[i]
          if i == len(line) - 1: # последний символ
              str = str + simvol * int(num)
      else:  # буква
          # умножаем предыдущую букву на num и обнуляем num
          # print('simvol=',line[i], 'type(num)=',type(num),'num=',num)
          if i != 0:
              str = str + simvol * int(num)
          # print('stroka=', str)
          simvol = line[i]
          num = '0'
inf.close()
with open('/home/dmitriy/Python/mypython/dataset_3363_2_modify.txt', 'w') as ouf:
    ouf.write(str)</pre>
<b>Не моё:</b>
<pre>
with open('dataset_3363_2.txt', 'r') as f:
    s = f.readline().strip()
i = 0
while i < len(s):
    j = i + 1
    while j < len(s) and s[j].isdigit():
        j += 1
    print(s[i] * int(s[i+1:j]), end='')
    i = j</pre>
Первый символ - гарантированно буква.
Перебираем все последующие, пока они цифровые или пока не достигнут конец строки.<br>
После внутреннего цикла j либо указывает на следующую букву, либо на конец строки. В обоих случаях между s[i] и s[j] - цифры,
 составляющие нужное нам число повторов символа s[i].<br>
Печатаем символ нужное число раз, присваиваем i индекс следующей буквы для новой итерации цикла.    
<p>
<li> <b>Файл</b><br>
Напишите программу, которая считывает текст из файла (в файле может быть больше одной строки) и выводит самое частое слово в 
этом тексте и через пробел то, сколько раз оно встретилось. Если таких слов несколько, вывести лексикографически первое (можно 
использовать оператор < для строк).
<pre>
word = ''
d = {} 
maksimum = 0
spisok_max = {}
maks_word = ''
with open('/home/dmitriy/Python/mypython/dataset_3363_3.txt') as f:
  for line in f:
      line.strip() # удаляем служебные символы
      #print(line)
      for word in line.split():
          # заполняем словарь
          if word in d.keys():
              d[word] += 1
          else:
              d[word] =1 
# ищем максимальное количество слов
for key, value in d.items():
    if value > maksimum:
        spisok_max = {key:value}
        maksimum = value
    elif value == maksimum:
       spisok_max[key] = value
for key in spisok_max.keys():
    if key > maks_word:
        maks_word = key
print(maks_word, spisok_max[maks_word])
# Со строкой метод append не работает, чтобы добавить строку, используем оператор приращения.
# TypeError: can only concatenate str (not "list") to str: 
# TypeError: unsupported operand type(s) for +=: 'set' and 'list'
# for i in stroka переберет строку по буквам, чтобы по словам нужно использовать: for i in stroka.split()
</pre>
Ещё:
<pre>
<b>with open('dataset_3363_3.txt') as inf, open('MostPopularWord.txt','w') as ouf:
    maxc = 0
    s = inf.read().lower().strip().split()</b>
    s.sort()
    for word in s:
        counter = s.count(word)
        if counter > maxc:
            maxc = counter
            result_word = word
    ouf.write(result_word +' ' + str(maxc))</pre>
Без словаря, сразу читаем файл и сортируем список слов, чтобы потом первое найденное было лексиграфически впереди.
<br>
<b>Оказывается конструкция with является циклом.</b>
<pre>


--------------------------------------------------------------------------------------------------------------------


</pre>
<b>Чтение файла, импорт модуля, конструкция try/except/else</b>
<p>
Алиса зашифровала свою информацию с помощью библиотеки simple-crypt.<br>
Она представила информацию в виде строки, и затем записала в бинарный файл результат работы метода simplecrypt.encrypt.
Вам необходимо установить библиотеку simple-crypt, и с помощью метода simplecrypt.decrypt узнать, какой из паролей служит 
ключом для расшифровки файла с интересной информацией. Ответом для данной задачи служит расшифрованная интересная информация 
Алисы.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from simplecrypt import decrypt

with open('/home/dmitriy/Python/mypython/encrypted.bin', "rb") as inp:
    encrypted = inp.read()
    #print(encrypted)
with open('/home/dmitriy/Python/mypython/passwords.txt') as passw:
    for lst in passw:
        print(lst)
        try:
            s = decrypt(lst.strip(), encrypted)
        except Exception as e:
            print(f'Произошла ошибка: {e}')
            continue
        else:
            print('shifr=', s)</pre>
</td><td>
<pre>
import simplecrypt

encrypted = open("encrypted.bin", "rb").read()
passwords = open("passwords.txt").readlines()

for p in passwords:
    p = p.strip()
    try:
        s = simplecrypt.decrypt(p, encrypted)
    except simplecrypt.DecryptionException:
        continue

    print(s.decode("utf-8"))﻿</pre>
</td></tr></table>
<p>
Еще:
<pre>
import urllib
from simplecrypt import decrypt

ciphertext = <b>urllib.urlopen('https://stepik.org/media/attachments/lesson/24466/encrypted.bin').read()</b>
passwords = urllib.urlopen('https://stepik.org/media/attachments/lesson/24466/passwords.txt')

for password in passwords:
    try:
        plaintext = decrypt(password.strip(), ciphertext)
    except:
        pass
    else:
        print(plaintext)</pre>
<p>
1. Здесь в случае возникновения исключения (ошибка программы просто из-за плохого пароля) в блоке try выполнение программы 
переходит в блок except, там continue, то есть выполняется следующий итератор цикла. В случае, если пароль хороший, то 
выполняется блок else.
<p>
2. Функция strip() без аргументов удаляет в начале и в конце строки пробел. На этом примере, когда смотрел пароли, пробелы не 
видел, но был невидимый пернос строки. Возможно его также удаляет.
<p>
===========================================================================================
<p>
Вам дается текстовый файл, содержащий некоторое количество непустых строк.<br>
На основе него сгенерируйте новый текстовый файл, содержащий те же строки в обратном порядке.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
with open('/home/dmitriy/Python/mypython/1.txt') as f1:
    lst = f1.readlines() # вывели файл в список
    with open('/home/dmitriy/Python/mypython/2.txt', 'w') as f2:
        for i in range(-1, -len(lst) -1, -1):
            f2.write(lst[i].rstrip('\n') + "\n")
</pre>
</td></tr></table>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Не моё:
<pre>
with open('dataset_24465_4.txt', 'r') as fr, open('dataset_24465_4_w.txt', 'w') as fw:
    fw.writelines(fr.readlines()[::-1])</pre>
Ещё:
<pre>
lines = open("input.txt").readlines()
with open("output.txt", "w") as out:
    out.writelines(reversed(lines))
</pre>
</td></tr></table>
<pre>



========================================================================================================================



</pre>
<h3 align=center>Файл, методы, циклы, списки</h3>
19:50 - 21:30 (1 час и 40 минут)<br>
Имеется файл с данными по успеваемости абитуриентов. Он представляет из себя набор строк, где в каждой строке записана следующ
ая информация: <br>
Фамилия;Оценка_по_математике;Оценка_по_физике;Оценка_по_русскому_языку
<p>
Поля внутри строки разделены точкой с запятой, оценки — целые числа.
<p>
Напишите программу, которая считывает исходный файл с подобной структурой и для каждого абитуриента записывает его среднюю оце
нку по трём предметам на отдельной строке, соответствующей этому абитуриенту, в файл с ответом.
<p>
Также вычислите средние баллы по математике, физике и русскому языку по всем абитуриентам и добавьте полученные значения, разд
елённые пробелом, последней строкой в файл с ответом.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
d = {} # ключ - фамилия, значение - список из оценок
s = ''
num = 0
familia = []
ball = []
mathem = 0
phizik = 0
rus = 0
with open('/home/dmitriy/Python/mypython/dataset_3363_4.txt') as f:
    s = f.read().strip().split()
    for l in s:
        l = l.split(';')
        # print(l)
        for i in range(len(l)):
            if i % 4 == 0:
                familia.append(l[i])
                num = 0
            elif (i - 3) % 4 == 0:
                ball.append((num + int(l[i])) / 3)
                rus = rus + int(l[i])
            else:
                num = num + int(l[i])
                if (i - 1) % 4 == 0:
                    mathem = mathem + int(l[i])
                elif (i - 2) % 4 == 0:
                    phizik = phizik + int(l[i])
for i in ball:
    print(i)            
print(mathem/len(familia), phizik/len(familia), rus/len(familia))
</pre>
</td><td valign=top>
<b>Ещё:</b>
<pre>
koll, a1, b1, c1 = 0, 0, 0, 0
with open('dataset_3363_4.txt', 'r') as inf:
    for line in inf:
        line = line.strip().split(';')
        a, b, c = int(line[1]), int(line[2]), int(line[3])
        print((a+b+c)/3)
        koll += 1
        a1 += a
        b1 += b
        c1 += c
print((a1/koll), (b1/koll), (c1/koll))
</pre>
</td></tr></table>
<pre>


=========================================================================================================================

</pre>
<h3 align=center><a name="text">Работа с текстом</h3>
Вашей программе на вход подаются три строки s, a, b, состоящие из строчных латинских букв.
За одну операцию вы можете заменить все вхождения строки a в строку s на строку b.
<p>
Например, s = "abab", a = "ab", b = "ba", тогда после выполнения одной операции строка s перейдет в строку "baba", после 
выполнения двух и операций – в строку "bbaa", и дальнейшие операции не будут изменять строку s.
<p>
Необходимо узнать, после какого минимального количества операций в строке s не останется вхождений строки a. Если операций 
потребуется более 1000, выведите Impossible.
<p>
Выведите одно число – минимальное число операций, после применения которых в строке s не останется вхождений строки a, или 
Impossible, если операций потребуется более 1000.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td valign=top>
Моё:
<pre>
start_stroka = input()
enter_stroka = input()
shablon_stroka = input()
count = 0
if enter_stroka in start_stroka and enter_stroka in shablon_stroka:
        print('Impossible')
else:
    <font color=red>while count < 1001:</font> # лучше <b>while enter_stroka in start_stroka:</b>
        if enter_stroka in start_stroka:
            start_stroka = start_stroka.replace(enter_stroka, shablon_stroka)
            count += 1
        else:
            break
    if count < 1001:
        print(count)
    else:
        print('Impossible')
</pre>
</td><td valign=top>
Другое:
<pre>
s = input()
a = input()
b = input()

if a not in s:
    print(0)
elif a in b:
    print("Impossible")
else:
    ans = 0
    <font color=green>while a in s:</font>
        s = s.replace(a, b)
        ans += 1

    print(ans)</pre>
</td></tr></table>
<p>
Сначала хотел выполнить через рекурсивную функцию, но поскольку значение имел только последний вызов функции (хвостатая 
рекурсия), то выполнил итеративным способом.<br>
<b>Решения с рекурсией у других:</b>
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
№1
<pre>
def repl(s, a, b):
	if s.count(a) == 0:
		return 0
	return 1 + repl(s.replace(a, b), a, b)


s = input()
a = input()
b = input()
try:
	print(repl(s, a, b))
except RecursionError:
	print('Impossible')</pre>
</td>
<td v align=top>
№2
<pre>
def replacer(s: str, a: str, b: str, cnt: int) -> int:
    try:
        if a in s:
            new_s = s.replace(a, b)
            return replacer(new_s, a, b, cnt + 1)
        else:
            return cnt
    except RecursionError:
        return -1


s, a, b = [input() for _ in range(3)]
ans = replacer(s, a, b, 0)
print(ans if ans != -1 else 'Impossible')</pre>
</td></tr></table>
<p>
В первом примере базовым случаем является условие, когда нечего будет менять. Возврат функции равен счетчику. Когда достигли 
базового (конечного) условия, во всех вызванных функциях будут возврашать себя (счетчик), увеличивающийся на 1.
<p>
2 пример мне больще нравится. Здесь также базовое (конечное) условие, когда нечего менять. Но за счет того что count 
передается через аргумент функции, на базовом условии сразу получаем итоговый результат и через return его возвращаем. Внешние 
return также возвращают count. <b>Получается, что функция возвращает то, что возвращает конечный return.</b>
<pre>


-----------------------------------------------------------------------------------------------------------------------------


</pre>
Вашей программе на вход подаются две строки s и t, состоящие из строчных латинских букв.
<p>
Выведите одно число – количество вхождений строки t в строку s.
<pre>
s = input()
t = input()
count = 0
for i in range(0,len(s)):
    if t in s[i : i + len(t)]:
        count += 1
print(count)</pre>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
Выведите строки, содержащие "cat" в качестве подстроки хотя бы два раза.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

lines = []
for line in stdin:
    if len(re.findall('cat', line)) >= 2:
        lines.append(line.rstrip('\n'))
for _ in lines:
    print(_)</pre>
</td><td valign=top>
Другое:
<pre>
import re
import sys

for line in sys.stdin:
    line = line.strip()
    if re.search(r"cat.*cat", line):
        print(line)</pre>
</td></tr></table>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Другое:
<pre>
import sys

print(*(s for s in sys.stdin if s.count('cat') > 1), sep='')
</pre>
</td></tr></table>
<pre>


-------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
Выведите строки, содержащие "cat" в качестве слова.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    if re.findall(r'\bcat\b', line.rstrip().lstrip()):
        print(line.rstrip('\n'))</pre>
</td><td valign=top>
Другое:
<pre>
import re
import sys

for line in sys.stdin:
    line = line.rstrip()
    if re.search(r"\bcat\b", line):
        print(line)</pre>
</td></tr></table>
<pre>


===========================================================================================================================


</pre>
<a name="regularn"><h3 align=center>Регулярные выражения</h3>
Вам дана последовательность строк.<br>
Выведите строки, содержащие две буквы "z﻿", между которыми ровно три символа.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    if re.search(r'z\D\D\Dz', line.rstrip()):
        print(line.rstrip())</pre>
</td><td valign=top>
Другое:
<pre>
import re
import sys

for line in sys.stdin:
    line = line.strip()
    if re.search(r"z...z", line):
        print(line)</pre>
</td></tr></table>
<pre>


-------------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
Выведите строки, содержащие обратный слеш "\﻿".
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    line = line.strip()
    if re.search(r'\\', line):
        print(line)</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
Выведите строки, содержащие слово, состоящее из двух одинаковых частей (тандемный повтор).
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    line = line.strip()
    if re.search(r'\b(.+)\1\b', line):
        print(line)</pre>
</td>
<td>
Другое:
<pre>
import re
import sys

for line in sys.stdin:
    line = line.strip()
    if re.search(r"\b(\w+)\1\b", line):
        print(line)
</pre></td></tr></table>
<pre>


-------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
В каждой строке замените все вхождения подстроки "human" на подстроку "computer"﻿ и выведите полученные строки.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    line = line.strip()
    print(re.sub('human', 'computer', line))</pre>
</td>
<td>
Другое:
<pre>
import re
import sys

print(re.sub(r'human', 'computer', sys.stdin.read()), end='')
</pre></td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
В каждой строке замените первое вхождение слова, состоящего только из латинских букв "a" (регистр не важен), на слово "argh".
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    print(re.sub(r'\ba+\b', 'argh', line.strip(), count = 1, flags=re.IGNORECASE))</pre>
</td></tr>
<tr><td>
Другое:
<pre>
import sys
import re

[print(re.sub(r'\b[<b>aA]</b>+\b', 'argh', line.rstrip(), 1)) for line in sys.stdin]</pre></td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
В каждой строке поменяйте местами две первых буквы в каждом слове, состоящем хотя бы из двух букв.<br>
Буквой считается символ из группы \w.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    print(re.sub(r'\b(\w)(\w)', r'\2\1', line.strip()))</pre>
</td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
В каждой строке замените все вхождения нескольких одинаковых букв на одну букву.<br>
Буквой считается символ из группы \w.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    print(re.sub(r'(\w)\1+', r'\1', line.strip()))</pre>
</td></tr></table>
<pre>


------------------------------------------------------------------------------------------------------------------------


</pre>
Вашей программе на вход подаются две строки, содержащие url двух документов A и B.<br>
Выведите Yes, если из A в B можно перейти за два перехода, иначе выведите No.
<p>
Обратите внимание на то, что не все ссылки внутри HTML документа могут вести на существующие HTML документы.
<pre>
Sample Input 1:
<p>
https://stepik.org/media/attachments/lesson/24472/sample0.html
https://stepik.org/media/attachments/lesson/24472/sample2.html
Sample Output 1:

Yes</pre>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
import requests
import re

url1 = input()
url2 = input().replace('stepik.org', 'stepic.org')

r = requests.get(url1).text
pattern = r'href="(\S*)"'
lst = re.findall(pattern, r.strip())
s = []
for i in lst:
    r = requests.get(i).text
    s +=re.findall(pattern, r.strip())
if url2 in s:
    print('Yes')
else:
    print('No')</pre>
</td><td>
Другое:
<pre>
import re
import requests

start_url = input()
end_url = input()

found = False

link_pattern = re.compile(r'<a[^>]*?href="(.*?)"[^>]*?>')

resp = requests.get(start_url).text
for url in link_pattern.findall(resp):
    cur_resp = requests.get(url).text
    if end_url in link_pattern.findall(cur_resp):
        found = True
        break

print("Yes" if found else "No")</pre>
</td></tr></table>
<p>
<i>Кто-нибудь, объясните мне, пожалуйста, почему link_pattern.findall(resp) выдает очищенный от метатегов &lt;a href= &lt;/
a&gt; URL адрес? Т.е. полным совпадением (Full match) для данного регулярного выражения считается адрес, окруженный метатегами 
&lt;a href= &lt;/a&gt;, а "очищенный" от метатегов адрес является группой (Group 1).<br>
Почему link_pattern.findall(resp)выдает группы (т.е. только то, что в регулярном выражении заключено в круглые 
скобки), а не полное совпадение шаблона (Full match)?
<p>
"Если в шаблоне есть группирующие скобки, то вместо списка найденных подстрок будет возвращён список кортежей, в каждом из 
которых только соответствие каждой группе." https://habr.com/ru/post/349860/#Gruppy_i_refindall</i>
<pre>


-----------------------------------------------------------------------------------------------------------------------


</pre>
Вашей программе на вход подается ссылка на HTML файл.<br>
Вам необходимо скачать этот файл, затем найти в нем все ссылки вида &lt;a ... href="..." ... &gt; и вывести список сайтов, на 
которые есть ссылка.
<br>Сайтом в данной задаче будем называть имя домена вместе с именами поддоменов. То есть, это последовательность символов, 
которая следует сразу после символов протокола, если он есть, до символов порта или пути, если они есть, за исключением 
случаев с относительными ссылками вида &lt;a href="../some_path/index.html"&gt;.
<p>
Сайты следует выводить в алфавитном порядке.
<pre>
Пример HTML файла:

&lt;a href="http://stepik.org/courses"&gt;
&lt;a href='https://stepik.org'&gt;
&lt;a href='http://neerc.ifmo.ru:1345'&gt;
&lt;a href="ftp://mail.ru/distib" &gt;
&lt;a href="ya.ru"&gt;
&lt;a href="www.ya.ru"&gt;
&lt;a href="../skip_relative_links"&gt;

Пример ответа:
mail.ru
neerc.ifmo.ru
stepik.org
www.ya.ru
ya.ru</pre>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
import requests
import re

url = input()
f = requests.get(url).text
pattern = r'&lt;a(?:.+?)href=[\'\"](?:[a-z]+:\/\/)?([a-z][\w\-\.]+)'
lst = set(re.findall(pattern, f))
st = sorted(lst)
for i in st:
    print(i)
</pre>
</td></tr></table>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Другое:
<pre>
import requests
import re

page = requests.get(input())

url_pattern = re.compile(r'&lt;a.*?href=["|\'](.*?:\/\/)?(\w.*?)([/|:].*)?["|\'].*')
links = sorted(set([link[1] for link in url_pattern.findall(page.text)]))
print(*links, sep='\n')
</pre>
</td></tr></table>
<pre>

-------------------------------------------------------------------------------------------------------------------

</pre>
<b>Модуль re, функция findal для поиска по паттерну в строке, join - преобразование списка в строку</b><br>
В этой задаче мы реализуем алгоритм дешифровки строк, закодированных с помощью одного из самых простых  вариантов кодирования длин серий.<br>
На вход алгоритму подаётся строка, содержащая цифры и символы латинского алфавита. Эта строка разбивается на так называемые "серии", которые кодируются парой число-символ или просто символ (в таком случае число считается равным единице). Результат должен содержать эти серии в том же порядке, что они и встречаются в исходной строке, при этом каждая серия раскрывается в последовательность символов соответствующей длины.<br>
Например, рассмотрим строку:<br>
3ab4c2CaB<br>
Разобъём её на серии:<br>
3a b 4c 2C a B<br>
После чего преобразуем серии и получим исходную закодированную строку:<br>
aaabccccCCaB
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<pre>
import re

shifr_str = input()

pattern = <b>r'\d*[A-Za-z]{1}</b>'  # d* - любое количество цифр, [A-Za-z]{1} - любой символ из класса (множества A-Za-z) в коли-ве 1
lst = <b>re.findall(pattern, shifr_str)</b>
# print(lst)

for simvols in lst:
    letter = re.findall(r'[A-Za-z]{1}', simvols)
    if re.findall(r'\d*', simvols)[0] != '':
        print(''.join(letter) * int(re.findall(r'\d*', simvols)[0]), end='')
    else:
        print(''.join(letter) * 1, end='')
</pre></td></tr>
<tr><td valign=top>
<pre>
n = ''
for i in input():  # 3ab4c2CaB
    if i.isdigit():
        n += i
        continue
    print(i * int(n or 1), end = '')
    n = ''
</pre></td></tr></table>
<pre>



=======================================================================================================================



</pre>
<a name="table"><h3 align=center>Работа с таблицами</h3>
Вам дана частичная выборка из датасета зафиксированных преступлений, совершенных в городе Чикаго с 2001 года по настоящее 
время.
<br>Одним из атрибутов преступления является его тип – Primary Type.
<br>Вам необходимо узнать тип преступления, которое было зафиксировано максимальное число раз в 2015 году.
<br>Файл с данными: Crimes.csv
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
import csv
import re
from collections import Counter

d = {}
lst = []
with open('/home/dmitriy/Python/mypython/Crimes.csv') as f:
    reader = csv.reader(f)
    for row in reader:
        if re.search(r'\d\d/\d\d/2015', row[2]):
            lst.append(row[5])
print(Counter(lst))
</pre>
</td><td valign=top>
Другое:
<pre>
from collections import Counter as c

with open('Crimes.csv') as f:
 data = csv.reader(f)
 print(c( row[5] for row in data <b>if '2015' in row[2]</b> ))
</pre>
Ошибка: нет import csv
<br>
------------------------------------------------------------
<br>
Другое:
<pre>
import csv

with open("Crimes.csv") as f:
     reader = csv.reader(f)
     crimes = []
     for row in reader:
         if "2015" in row[2]:
             crimes.append(row[5])
     print(max(crimes, key=crimes.count))</pre>
</td></tr></table>
<pre>



==================================================================================================================



</pre>
<a name="xml"><h3 align=center>Работа с данными XML-формата</h3>
Вам дано описание пирамиды из кубиков в формате XML.<br>
Кубики могут быть трех цветов: красный (red), зеленый (green) и синий (blue﻿).<br>
Для каждого кубика известны его цвет, и известны кубики, расположенные прямо под ним.<br>
Пример:
<pre>
&lt;cube color="blue"&gt;
  &lt;cube color="red"&gt;
    &lt;cube color="green"&gt;
    &lt;/cube&gt;
  &lt;/cube&gt;
  &lt;cube color="red"&gt;
  &lt;/cube&gt;
&lt;/cube&gt;
</pre> 
Введем понятие ценности для кубиков. Самый верхний кубик, соответствующий корню XML документа имеет ценность 1. Кубики, 
расположенные прямо под ним, имеют ценность 2. Кубики, расположенные прямо под нижележащими кубиками, имеют ценность 3. И т. д.
<br>Ценность цвета равна сумме ценностей всех кубиков этого цвета.
<br>Выведите через пробел три числа: ценности красного, зеленого и синего цветов.
<pre>
Sample Input:
&lt;cube color="blue"&gt;&lt;cube color="red"&gt;&lt;cube color="green"&gt;&lt;/cube&gt;&lt;/cube&gt;&lt;cube 
color="red"&gt;&lt;/cube&gt;&lt;/cube&gt;
Sample Output:
4 3 1
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<b>Моё:</b>
<pre>
import xml.etree.ElementTree as ET
 
<font color=red>red_box = 0
green_box = 0
blue_box = 0</font>
root = ET.fromstring(input())

def search_cube(element, level):
    global red_box
    global blue_box
    global green_box
    for subelement in element.findall('cube'):
        if subelement.attrib['color'] == 'red':
            red_box += level
        elif subelement.attrib['color'] == 'green':
            green_box += level
        else:
            blue_box += level
    level += 1    
    for subelement in element.findall('cube'):
        search_cube(subelement, level)
        

if root.attrib['color'] == 'red':
    red_box = 1
elif root.attrib['color'] == 'green':
    green_box = 1
else:
    blue_box = 1
search_cube(root, 2)
print(red_box, green_box, blue_box)
</pre>
</td><td valign=top>
Другое:
<pre>
from xml.etree import ElementTree

root = ElementTree.fromstring(input())
<font color=green>colors = {"red": 0, "green": 0, "blue": 0}</font>

def getcubes(root, value):
    colors[root.attrib['color']] += value
    for child in root:
        getcubes(child, value+1)

getcubes(root,1)
print(colors["red"], colors["green"], colors["blue"])
</pre>
<p>
В отличии от моего:<br>
1. Вместо 3 переменных создал словарь. Это позволило заменить блок условий одной строчкой <i>colors[root.attrib['color']] += 
value</i>
<p>
2. Корневой узел разбирается в функции. Создает целостность кода.
</td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>etree.ElementTree</b><br>
В OpenStreetMap XML встречаются теги node, которые соответствуют некоторым точкам на карте. Ноды могут не только обозначать какой-то точечный объект, но и входить в состав way (некоторой линии, возможно замкнутой) и не иметь собственных тегов. Для доступного по ссылке https://stepik.org/media/attachments/lesson/245678/map1.osm фрагмента карты посчитайте, сколько node имеет хотя бы один вложенный тэг tag, а сколько - не имеют. В качестве ответа введите два числа, разделённых пробелом.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import xml.etree.ElementTree as ET

tree = ET.parse('map1 .osm')
root = tree.getroot()

not_tag = 0
yes_tag = 0
for i in root.findall('node'):  # находит все теги node
    tag = i.find('tag')  # внутри node находит тег tag, если не находит, то возвращает None
    if tag != None:
        yes_tag +=1
    else:
        not_tag +=1

print(yes_tag, not_tag)
</pre></td></tr></table>
<pre>

-----------------------------------------------------------------------------------------------------------------------

</pre>
<b>Чтение url-адреса, urllib.request, xml.etree.ElementTree, поиск атрибутов</b><br>
Вася решил открыть АЗС (заправку). Чтобы оценить уровень конкуренции он хочет изучить количество заправок в интересующем его районе. Вася скачал интересующий его кусок карты OSM https://stepik.org/media/attachments/lesson/245681/map2.osm и хочет посчитать, сколько на нём отмечено точечных объектов (node), являющихся заправкой. В качестве ответа вам необходимо вывести одно число - количество АЗС.<br>
Заправки аходятся внутри тега tag и имеют атрибуты k=amenity и v=fuel
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import urllib.request
import xml.etree.ElementTree as ET

url = "https://stepik.org/media/attachments/lesson/245681/map2.osm"

with urllib.request.urlopen(url) as response:
    xml_data = response.read()

#print(type(xml_data))  # &lt;class 'bytes'>
root = ET.fromstring(xml_data)

#print(root)  # &lt;Element 'osm' at 0x7f3189bd4ae0>

count = 0
for node in root.findall('node'):
    tag = node.find('tag') 
    if tag != None:
        if <b>tag.get('k') == 'amenity' and tag.get('v') == 'fuel':</b>
            count += 1

print(count)
</pre></td>
<td valign=top>
<pre>
import xml.etree.ElementTree as ET

root = ET.parse('map2.osm').getroot()
nodes = <b>root.findall("./node/tag[@k='amenity'][@v='fuel']")</b>
print(len(nodes))
</pre>
root.findall("./node/tag[@k='amenity'][@v='fuel']") возвращает список объектов tag
</td></tr></table>
<p>
Атрибуты ищем через метод get
<pre>

-------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Создание xml-файла с внутренними тегами</b><br>
Задача через питоновский скрипт создать html страницу с выводом таблицы умножения.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from xml.etree import ElementTree

root = ElementTree.Element("html")

body_teg = ElementTree.SubElement(root, "body")

table_teg = ElementTree.SubElement(body_teg, "table")
for strk in range(1, 11):
    tr_teg = ElementTree.SubElement(table_teg, "tr")
    for stlb in range(1, 11):
        td_teg = ElementTree.SubElement(tr_teg, "td")
        td_teg.text = str(strk * stlb)

tree = ElementTree.ElementTree(root)
tree.write("test.html")  # записываем дерево в файл
</pre></td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Добавление атрибутов</b><br>
Предыдущее задание, но числа в виде ссылок:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from xml.etree import ElementTree

root = ElementTree.Element("html")

body_teg = ElementTree.SubElement(root, "body")

table_teg = ElementTree.SubElement(body_teg, "table")
for strk in range(1, 11):
    tr_teg = ElementTree.SubElement(table_teg, "tr")
    for stlb in range(1, 11):
        td_teg = ElementTree.SubElement(tr_teg, "td")
        a_teg = ElementTree.SubElement(td_teg, "a")
        a_teg.set('href','http://' + str(strk * stlb) + '.ru')
        a_teg.text = str(strk * stlb)

tree = ElementTree.ElementTree(root)
tree.write("test.html")
</pre></td></tr></table>
<pre>

===========================================================================================================================

</pre>
<a name="parsing"><h3 align=center>Парсинг файлов (Selenium, Beautiful Soup, pandas, xlrd)</h3>
<b>Написание веб-скрапера с использованием BeautifulSoup и requests:</b><br>
– Выберите веб-сайт с данными, которые вы хотели бы собрать.<br>
– Напишите веб-скрапер с использованием библиотеки BeautifulSoup для извлечения данных.<br>
– Сохраните извлеченные данные в удобном формате (например, CSV).<br>
Решение: Для этой задачи давайте рассмотрим пример веб-скрапинга данных о книгах с веб-сайта Books to Scrape(http://books.toscrape.com/).<br>
Пример кода для веб-скрапинга данных о книгах и сохранения их в формате CSV:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import requests
from bs4 import BeautifulSoup
import pandas as pd
# URL веб-сайта для скрапинга
url = 'http://books.toscrape.com/'
# Отправка GET-запроса
response = requests.get(url)
# Проверка успешности запроса
if response.status_code == 200:
    # Использование BeautifulSoup для парсинга HTML-страницы
    soup = BeautifulSoup(response.text, 'html.parser')
    # Нахождение блоков с информацией о книгах
    book_blocks = soup.find_all('article', class_='product_pod')
    # Списки для хранения данных
    titles = []
    prices = []
    ratings = []
    # Итерация по блокам и извлечение данных
    for book_block in book_blocks:
        title = book_block.h3.a['title']
        price = book_block.select('div p.price_color')[0].text
        rating = book_block.select('p[class^="star-rating"]')[0]['class'][1]
        titles.append(title)
        prices.append(price)
        ratings.append(rating)
    # Создание Pandas DataFrame
    df = pd.DataFrame({
    'Title': titles,
    'Price': prices,
    'Rating': ratings,
    })
   # Сохранение данных в CSV-файл
   df.to_csv('books_data.csv', index=False)
   print("Данные успешно скрапированы и сохранены в 'books_data.csv'.")
else:
    print(f"Ошибка {response.status_code}: Невозможно получить данные с веб-сайта.")
<pre></td></tr></table>
<p>
Этот код пройдет по страницам веб-сайта с книгами, извлечет информацию о названии, цене и рейтинге книг, создаст Pandas
DataFrame и сохранит данные в CSV-файл "books_data.csv". Пожалуйста, учтите, что использование веб-скрапинга должно
соответствовать политике использования веб-сайта.
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>xlrd, pandas, statistics</b><br>
Вася планирует карьеру и переезд. Для это составил таблицу, в которой для каждого региона записал зарплаты для разных интересные ему профессий. Таблица доступна по ссылке https://stepik.org/media/attachments/lesson/245267/salaries.xlsx. Выведите название региона с самой высокой медианной зарплатой (медианой называется элемент, стоящий в середине массива после его упорядочивания) и, через пробел, название профессии с самой высокой средней зарплатой по всем регионам.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import xlrd3

d = {}
d1 = {}
wb = xlrd3.open_workbook('salaries.xlsx')  # возвращает &lt;xlrd3.xlsx.BetterBook object at 0x7f878694bfd0>
<font color=red>sheet_names = wb.sheet_names()</font>  # ['Лист1'], возвращает список листов файла, не нужен
sh = wb.sheet_by_name(sheet_names[0])      # Sheet  0:&lt;Лист1>

for stroka_sh in range(1, sh.nrows):
    #print(sh.row_values(stroka_sh))
    d[sh.row_values(stroka_sh)[0]] = sorted(sh.row_values(stroka_sh)[1:])
    #print(sh.row_values(stroka_sh)[0], d[sh.row_values(stroka_sh)[0]])

max_salary = 0
region =''
for key, val in d.items():
    if d[key][3] > max_salary:
        max_salary = d[key][3]
        region = key

print(region, max_salary)

for stolb_sh in range(1, sh.ncols):
    #print(sh.col_values(stolb_sh))
    d1[sh.col_values(stolb_sh)[0]] = sum(sh.col_values(stolb_sh)[1:]) / len(sh.col_values(stolb_sh)[1:])
#print(d1)

profy_salary = 0
profy = ''
for i in d1:
    if d1[i] > profy_salary:
       profy_salary = d1[i] 
       profy = i

print(profy, profy_salary)
print(region, profy)
</pre></td></tr>
<tr><td>
Через библиотеку statistics:
<pre>
import xlrd

from statistics import median, mean

wb = xlrd.open_workbook('salaries.xlsx')
sh = wb.sheet_by_index(0)
d = {sh.cell_value(row,0): median(sh.row_values(row)[1:]) for row in range(1,9)}
e = {sh.cell_value(0,col): mean(sh.col_values(col)[1:]) for col in range(1,8)}
print(max(d, key=lambda k: d[k]), max(e, key=lambda k: e[k]))
</pre></td></tr>
<tr><td>
Через модуль pandas
<pre>
import pandas as pd


data = pd.read_excel('salaries.xlsx', index_col=0)
print(data.median(axis=1).idxmax(), data.mean(axis=0).idxmax())
<pre></td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>xlrd, pandas, сортировка словаря сначала по убыванию значения, а потом если значения равны, то в алфавитном порядке по ключу</b><br>
Васю назначили завхозом в туристической группе и он подошёл к подготовке ответственно, составив справочник продуктов с указанием калорийности на 100 грамм, а также содержание белков, жиров и углеводов на 100 грамм продукта. Ему не удалось найти всю информацию, поэтому некоторые ячейки остались незаполненными (можно считать их значение равным нулю). Также он использовал какой-то странный офисный пакет и разделял целую и дробную часть чисел запятой. Таблица доступна по ссылке https://stepik.org/media/attachments/lesson/245290/trekking1.xlsx<br>
Вася хочет минимизировать вес продуктов и для этого брать самые калорийные продукты. Помогите ему и упорядочите продукты по убыванию калорийности. В случае, если продукты имеют одинаковую калорийность - упорядочите их по названию. В качестве ответа необходимо сдать названия продуктов, по одному в строке.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
XLRD:
<pre>
import xlrd3

wb = xlrd3.open_workbook('trekking1.xlsx')
sheet_names = wb.sheet_names()
sh = wb.sheet_by_name(sheet_names[0]) 

d = {}
for stroka_sh in range(1, sh.nrows):
    #print(sh.row_values(stroka_sh))
    d[sh.row_values(stroka_sh)[0]] = sh.row_values(stroka_sh)[1]

sort_obj = <b>sorted(d, key=lambda k: (-d[k], k))</b>  # возвращает список ключей словаря d
for i in sort_obj:
    print(i)
</pre></td></tr></table>
<p>
sorted(d, key=lambda k: (-d[k], k)): (-1 * d[k]) разворачиваем список по убыванию калорийности, и при совпадении оставляем правильный порядок сортировки по алфавиту.
<p>
Можно использовать еще itemgetter.
<p>
Решение на pandas:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import pandas as pd

tabpd = pd.read_excel("trekking1.xlsx")

tabpd_sorted = tabpd.<b>sort_values(by=['ККал на 100', 'Unnamed: 0']</b>, ascending=[False, True]) # сортируем по двум столбцам

#print(tabpd_sorted['Unnamed: 0'])  # выводит вместе с индексом строк, не то что мне нужно

#print(tabpd_sorted[['Unnamed: 0']].values)  # выводит как список списков, также не то что мне нужно

for i in tabpd_sorted['Unnamed: 0']:  # вот так правильно.
    print(i)
</pre></td></tr></table>
<pre>

----------------------------------------------------------------------------------------------------------------------------

</pre>
Откатил на более старую версию xlrd, поэтому теперь: import xlrd<br>
<b>xldr, pandas, объединение датафреймов (merge()</b><br>
Васю назначили завхозом в туристической группе и он подошёл к подготовке ответственно, составив справочник продуктов с указанием калорийности на 100 грамм, а также содержание белков, жиров и углеводов на 100 грамм продукта. Ему не удалось найти всю информацию, поэтому некоторые ячейки остались незаполненными (можно считать их значение равным нулю). Также он использовал какой-то странный офисный пакет и разделял целую и дробную часть чисел запятой. Таблица доступна по ссылке https://stepik.org/media/attachments/lesson/245290/trekking2.xlsx<br>
Вася составил раскладку по продуктам на один день (она на листе "Раскладка") с указанием названия продукта и его количества в граммах. Посчитайте 4 числа: суммарную калорийность и граммы белков, жиров и углеводов. Числа округлите до целых вниз и введите через пробел.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
XLRD:
<pre>
import xlrd

wb = xlrd.open_workbook('trekking2.xlsx')
sheet_names = wb.sheet_names()
sh0 = wb.sheet_by_name(sheet_names[0]) 
spravka = {sh0.row_values(i)[0] : sh0.row_values(i)[1:] for i in range(1, sh0.nrows)}

sh1 = wb.sheet_by_name(sheet_names[1])
summarn_kal = 0
belok = 0
uglevod = 0
fat = 0

for i in range(1, sh1.nrows):
    food = sh1.row_values(i)[0]
    massa = sh1.row_values(i)[1]
    summarn_kal += massa * spravka[food][0] / 100
    if spravka[food][1] == '':
        spravka[food][1] = 0
    if spravka[food][2] == '':
        spravka[food][2] = 0
    if spravka[food][3] == '':
        spravka[food][3] = 0
    belok += massa * spravka[food][1] / 100
    uglevod += massa * spravka[food][3] / 100
    fat += massa * spravka[food][2] / 100

print(int(summarn_kal), int(belok), int(fat), int(uglevod))
</pre></td></tr>
<tr><td>
Не моё:
<pre>
import xlrd, requests
res = requests.get('https://stepik.org/media/attachments/lesson/245290/trekking2.xlsx')
wb = xlrd.open_workbook(file_contents=res.content)
sh_spr = wb.sheet_by_name(wb.sheet_names()[0])
sh_ras = wb.sheet_by_name(wb.sheet_names()[1])
res = [0,0,0,0]
for i in range(1, sh_ras.nrows):
    n, p = sh_ras.row_values(i)
    for j in range(1, sh_spr.nrows):
        if n == sh_spr.row_values(j)[0]:
            s = [x*p/100 if x else 0 for x in sh_spr.row_values(j,1)]   
            res = [x+y for x,y in zip(res, s)]
print(*map(int, res))
</pre></td></tr>
<tr><td>
pandas
<pre>
import pandas as pd

sh1 = pd.read_excel("trekking2.xlsx", sheet_name=0).fillna(0)
sh2 = pd.read_excel("trekking2.xlsx", sheet_name=1).fillna(0)

#df1 = pd.merge(sh1, sh2,  left_on='Unnamed: 0', right_on='Продукт') 

df1 = sh1.rename(columns={"Unnamed: 0": "Продукт"})

#df1 = pd.merge(df1, sh2, on='Продукт')
df2 = df1.merge(sh2, on='Продукт')

df2.iloc[:, 1:5] = df2.iloc[:, 1:5].mul(df2['Вес в граммах']/100, axis=0)
print(df2)
print(*[int(x) for x in df2.iloc[:,1:5].sum()])
</pre></td></tr></table>
<pre>

-----------------------------------------------------------------------------------------------------------------------

</pre>
<b>xlrd pandas</b><br>
Васю назначили завхозом в туристической группе и он подошёл к подготовке ответственно, составив справочник продуктов с указанием калорийности на 100 грамм, а также содержание белков, жиров и углеводов на 100 грамм продукта. Ему не удалось найти всю информацию, поэтому некоторые ячейки остались незаполненными (можно считать их значение равным нулю). Также он использовал какой-то странный офисный пакет и разделял целую и дробную часть чисел запятой. Таблица доступна по ссылке https://stepik.org/media/attachments/lesson/245290/trekking3.xlsx<br>
Вася составил <b>раскладку по продуктам на весь поход</b> (она на листе "Раскладка") с указанием номера дня, названия продукта и его количества в граммах. Для каждого дня посчитайте 4 числа: суммарную калорийность и граммы белков, жиров и углеводов. Числа округлите до целых вниз и введите через пробел. Информация о каждом дне должна выводиться в отдельной строке.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
XLRD:
<pre>
import xlrd

wb = xlrd.open_workbook('trekking3.xlsx')
sh0 = wb.sheet_by_name(wb.sheet_names()[0]) 
sh1 = wb.sheet_by_name(wb.sheet_names()[1])

summarn_kal = 0
belok = 0
uglevod = 0
fat = 0

spravka = {sh0.row_values(i)[0] : sh0.row_values(i)[1:] for i in range(1, sh0.nrows)}

d = {}
d1 = {}
for i in range(1, sh1.nrows):
    line = sh1.row_values(i)
    day = int(line[0])
    if day not in d:  # если в словаре нет такого ключа
        d[day] = [line[1:]]
    else:  # если такой ключ уже есть
        d[day].append(line[1:])  # добавляем значение в конец списка
    
print(d)
print("kal bel fat uglev")
for day in d.keys():
    kalor = 0
    belok = 0
    uglevod = 0
    fat = 0
    for i in range(len(d[day])):
        food = d[day][i][0]
        massa = d[day][i][1] / 100
        kalor += massa * spravka[food][0]
        if spravka[food][1] == '': spravka[food][1] = 0
        belok += massa * spravka[food][1]
        if spravka[food][3] == '': spravka[food][3] = 0
        uglevod += massa * spravka[food][3]
        if spravka[food][2] == '': spravka[food][2] = 0
        fat += massa * spravka[food][2]
    print(int(kalor), int(belok), int(fat), int(uglevod))
</pre></td></tr>
<tr><td>
Не моё:
<pre>
import urllib.request
import xlrd
proxy_support = urllib.request.<font color=red>ProxyHandler({'http' : 'http://192.168.50.107:3130',
                                             'https': 'http://192.168.50.107:3130'})
opener = urllib.request.build_opener(proxy_support)
urllib.request.install_opener(opener)</font>
bt = urllib.request.urlopen("https://stepik.org/media/attachments/lesson/245290/trekking3.xlsx").read()

wb = xlrd.open_workbook(file_contents=bt)
sh = wb.sheet_by_name("Справочник")
m_inf = {sh.row_values(i)[0]: list(map(lambda x: float(x if x!='' else 0),sh.row_values(i)[1:5])) for i in range(1,sh.nrows)}

sh = wb.sheet_by_name("Раскладка")

ans = {}
for i in range(1, sh.nrows):
    day = int(sh.row_values(i)[0])
    if sh.row_values(i)[0] in ans:
        ans[day][0] += m_inf[sh.row_values(i)[1]][0] * sh.row_values(i)[2] / 100
        ans[day][1] += m_inf[sh.row_values(i)[1]][1] * sh.row_values(i)[2] / 100
        ans[day][2] += m_inf[sh.row_values(i)[1]][2] * sh.row_values(i)[2] / 100
        ans[day][3] += m_inf[sh.row_values(i)[1]][3] * sh.row_values(i)[2] / 100
    else:
        ans[day]  = [m_inf[sh.row_values(i)[1]][0] * sh.row_values(i)[2] / 100,
                                     m_inf[sh.row_values(i)[1]][1] * sh.row_values(i)[2] / 100,
                                     m_inf[sh.row_values(i)[1]][2] * sh.row_values(i)[2] / 100,
                                     m_inf[sh.row_values(i)[1]][3] * sh.row_values(i)[2] / 100]

for x in [(x[0],list(map(int,x[1]))) for x in ans.items()]:
    print(*x[1])
</pre></td></tr>
<tr><td>
pandas:
<pre>
import pandas as pd

url = 'https://stepik.org/media/attachments/lesson/245290/trekking3.xlsx'
sheet_1 = pd.read_excel(url, sheet_name=0, index_col=0).fillna(0)
sheet_2 = pd.read_excel(url,	sheet_name=1, index_col=[0])  # параметр index_col=[0] назначает нулевой столбец 'День' индексным
for day in sheet_2.index.unique():  # атрибут index выдает индекс меток, а функция unique() сокращает его до уникальных 
  ration = pd.concat([sheet_2.loc[day].groupby('Продукт').sum(), sheet_1], axis=1, join='inner')
  
  print(*ration.apply(lambda x: x.iloc[1:] * x.iloc[0] / 100, axis=1).sum(axis=0).astype('int'))
</pre></td></tr>
<tr><td>
Пример умножения столбцов без всяких mul
<pre>
import pandas as pd

kall = pd.read_excel('trekking3.xlsx', sheet_name=0)
menu = pd.read_excel('trekking3.xlsx', sheet_name=1)

kall.rename(columns={'Unnamed: 0': 'Продукт'}, inplace=True)
ration = pd.merge(menu, kall, on='Продукт')
ration['total kal'] = ration['Вес в граммах'] / 100 * ration['ККал на 100']
ration['total bel'] = ration['Вес в граммах'] / 100 * ration['Б на 100']
ration['total j'] = ration['Вес в граммах'] / 100 * ration['Ж на 100']
ration['total ug'] = ration['Вес в граммах'] / 100 * ration['У на 100']
result = ration.groupby('День').agg('sum')
res = result.iloc[:, 5:12].values.tolist()
for i in res:
    print(*[int(j) for j in i], sep=' ')
</pre></td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>pandas, чтение всех файлов с каталога, добавление датафрейма в виде строки к датафрейму через concat, запись в файл</b><br>
Главный бухгалтер компании "Рога и копыта" случайно удалил ведомость с начисленной зарплатой. К счастью, у него сохранились расчётные листки всех сотрудников. Помогите по этим расчётным листкам восстановить зарплатную ведомость. Архив с расчётными листками доступен по ссылке https://stepik.org/media/attachments/lesson/245299/rogaikopyta.zip (вы можете скачать и распаковать его вручную или самостоятельно научиться делать это с помощью скрипта на Питоне).<br>
Ведомость должна содержать 1000 строк, в каждой строке должно быть указано ФИО сотрудника и, через пробел, его зарплата. Сотрудники должны быть упорядочены по алфавиту.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import os
import pandas as pd
 
vedomost = pd.DataFrame({'ФИО': [], 'Начисление': []})

for file in <b>os.listdir</b>("./rogaikopyta/"): # метод чтения файлов из каталога
    #print(file)
    if not file.startswith("~") and file.endswith(".xlsx"): # чтобы не возникало ошибки из-за временного файла ~tmp.xlsx
        df = pd.read_excel('./rogaikopyta/'+file)
        new_row = pd.DataFrame({'ФИО' : [df.at[0, 'Unnamed: 1']], 'Начисление' : [int(df.at[0, 'Unnamed: 3'])]})
        vedomost = pd.concat([vedomost, new_row], ignore_index=True)

v = vedomost.sort_values(by="ФИО")

#v.to_excel('1vedomost.xlsx', index=False)
v.to_csv('v1.txt', index=None, sep=' ')
</pre></td></tr></table>
<p>
new_row - создаём датафрейм из нужных данных файла
<p>
vedomost = pd.concat([vedomost, new_row], ignore_index=True) - присоединяем new_row к итоговому датафрейму vedomost</td></tr>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
Не мои решения:<br>
pandas
<pre>
import pandas as pd
import zipfile
import requests
import io


sheet = pd.Series()
url = 'https://stepik.org/media/attachments/lesson/245299/rogaikopyta.zip'
r = requests.get(url)

with r, zipfile.ZipFile(io.BytesIO(r.content)) as archive:
	for member in archive.infolist():
		slip = pd.read_excel(io.BytesIO(archive.read(member)))
		sheet.loc[slip.iloc[0, 1]] = int(slip.iloc[0, 3])

with open('salaries.txt', 'w') as salaries:
	salaries.write('\n'.join(sheet.sort_index().reset_index(). \
		apply(lambda x: f'{x.iloc[0]} {x.iloc[1]}', axis=1)))
</pre></td></tr>
<tr><td>
XLRD
<pre>
import xlrd, xlwt, requests, zipfile, io
res = requests.get(' https://stepik.org/media/attachments/lesson/245299/rogaikopyta.zip')
zfile = zipfile.ZipFile(io.BytesIO(res.content), 'r')
ww = xlwt.Workbook() 
ws = ww.add_sheet('zp')
l = []
for x in zfile.infolist():
    wb = xlrd.open_workbook(file_contents=zfile.read(x))
    sh = wb.sheet_by_name(wb.sheet_names()[0])
    l += [(sh.row_values(1)[1], sh.row_values(1)[3])]
for i, s in enumerate(sorted(l)):
    ws.write(i, 0, s[0])
    ws.write(i, 1, s[1])
ww.save('zp.xlsx')
</pre></td></tr></table>
<pre>


=========================================================================================================================

</pre>
<a name="plot"><h3 align=center>Построение графиков</h3>
<b>Модуль matplotlib.pyplot</b><br>
Если вам нужно нарисовать всего один график для ваших данных, то самым простым решением может оказаться вывод результатов вашей программы с разделением отдельных значений в строке с помощью табуляции (символа \t), их копирование в Excel или его аналог и построение графика.<br>
Однако, в случае если вам нужно строить очень много графиков, то такой способ не годится и нужно научиться строить их непосредственно с помощью Python. Одной из самых популярных библиотек для построения графиков является matplotlib, возможности которой во многом даже превосходят возможности редакторов электронных таблиц.<br>
Большинство нужных нам функций находятся в matplotlib.pyplot<br>
Посмотрим на простой пример, который сохраняет в файл sin.png график функции sin(x) на отрезке от 0 до 10:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import matplotlib.pyplot as plt # подключаем библиотеку с коротким названием, чтобы не писать каждый раз много букв
import math

fig = plt.figure() # создаем график

plt.axis([0, 10, -1.5, 1.5]) # на оси x будет изображаться участок от 0 до 10, а на оси y от -1.5 до 1.5

plt.xlabel('x') # подпись оси x
plt.ylabel('sin(x)') # подпись оси y

xs = [] # здесь будут параметры функции (x координаты изображаемых точек)
sin_vals = [] # здесь будут значения функции (y координаты изображаемых точек)

x = 0.0
while x < 10.0: # заполняем списки
    sin_vals.append(math.sin(x))
    xs.append(x)
    x += 0.01

plt.plot(xs, sin_vals) # создаем график: первый аргумент - список x-координат, второй - соответствующие y-координаты

fig.savefig('sin.png') # сохраняем график в файл
</pre></td></tr></table>
<pre>

============================================================================================================================

</pre>
<a name="api"><h3 align=center>Интеграция данных с API:</h3>
Задача: Интеграция данных с API:<br>
– Выберите публичное API (например, OpenWeatherMap, GitHub API, Twitter API).<br>
– Используйте библиотеку `requests` для получения данных из API.<br>
– Преобразуйте полученные данные в удобный формат (например, Pandas DataFrame) и выполните простой анализ.<br>
Решение: Для этой задачи давайте воспользуемся OpenWeatherMap API для получения текущей погоды (https://pogrommist.ru/openweathermap/).<br>
Пример кода для интеграции с OpenWeatherMap API, получения данных о погоде и выполнения простого анализа с использованием
Pandas:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import requests
import pandas as pd
# Ваш API ключ OpenWeatherMap (зарегистрируйтесь на сайте, чтобы получить ключ)
api_key = 'your_api_key'
# Город для получения погоды (замените на интересующий вас город)
city = 'London'
# Формирование URL для запроса к OpenWeatherMap API
url = f'http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}'
# Получение данных с API
response = requests.get(url)
# Проверка успешности запроса
if response.status_code == 200:
    # Преобразование данных в формат JSON
    weather_data = response.json()
    # Создание Pandas DataFrame
    df = pd.DataFrame({
    'City': [weather_data['name']],
    'Temperature (Celsius)': [weather_data['main']['temp'] – 273.15], #
    Конвертация в градусы Цельсия
    'Weather Condition': [weather_data['weather'][0]['description']], 'Humidity': [weather_data['main']['humidity']],
    'Wind Speed (m/s)': [weather_data['wind']['speed']],
   })
# Вывод данных и выполнение простого анализа
print("Данные о погоде в", city)
print(df)
# Пример анализа: вывод предупреждения о низкой температуре
if df['Temperature (Celsius)'].iloc[0] < 5:
    print("\nПредупреждение: Низкая температура. Рекомендуется надеть теплую одежду.")
else:
    print(f"Ошибка {response.status_code}: Невозможно получить данные о погоде.")
</pre></td></tr></table>
<p>
Не забудьте заменить `'your_api_key'` на ваш API ключ
OpenWeatherMap. Этот код получает данные о текущей погоде для заданного города, преобразует их в DataFrame и выполняет простой
анализ.
<pre>







</pre></body></html>
