<html><head></head><body>
<title>ROS для среднего уровня знаний</title>
<h2 align="center">Создание пакетов ros вручную</h2>
Ссылки: <a href="https://wiki.ros.org/ROS/Tutorials/Creating%20a%20Package%20by%20Hand">Creating a ROS package by hand.</a>
<p>
Существует инструмент для создания ROS-пакетов (catkin_create_pkg), но, как вы увидите, на самом деле здесь нет ничего сложного. catkin_create_pkg предотвращает ошибки и экономит усилия, но пакеты - это всего лишь каталог и простой XML-файл.
<p>
    Теперь мы создадим новый пакет <b>foobar</b>. В этом руководстве предполагается, что мы работаем с вашим рабочим пространством catkin и что поиск установочного файла уже выполнен.
<p>
В каталоге catkin_ws:<br>
<b>mkdir -p src/foobar<br>
cd src/foobar</b>
<p>
В данный момент src/foobar пустой. Самое первое, что мы сделаем, это добавим наш файл манифеста. Файл package.xml позволяет таким инструментам, как rospack, определять информацию о том, от чего зависит ваш пакет.<br>
<b>nano src/foobar/package.xml</b><br>
Внутри foobar/package.xml поместите следующее:<br>
<img src="./images/package.xml1.png">
<p>
Теперь, когда у вашего пакета есть манифест, ROS может найти его. Попробуйте выполнить команду:<br>
<b>rospack find foobar</b><br>
Если все верно, то выдаст путь к пакету.<br>
Обратите внимание, что этот пакет теперь также имеет зависимости от roscpp и std_msgs. Такие зависимости используются catkin для настройки пакетов в правильном порядке.
<p>
Теперь нам нужен файл CMakeLists.txt, чтобы catkin_make, который использует CMake для большей гибкости при сборке на нескольких платформах, собрал пакет.<br>
В данный момент его нет. Создадим и редактируем в моём любимом редакторе из каталога catkin_ws:<br>
<b>nano src/foobar/CMakeLists.txt</b><br>
<pre>
cmake_minimum_required(VERSION 2.8.3)
project(foobar)
find_package(catkin REQUIRED roscpp std_msgs)
catkin_package()
</pre>
<p>
Это все, что вам нужно, чтобы начать создавать пакет в ROS с помощью catkin. Конечно, если вы хотите, чтобы он действительно начал что-то создавать, вам нужно будет изучить еще пару макросов CMake. Дополнительную информацию смотрите в нашем руководстве <a href="https://wiki.ros.org/CMakeLists">CMakeLists.txt</a>. Также всегда возвращайтесь к руководству для начинающих (<a href="https://wiki.ros.org/ROS/Tutorials/CreatingPackage">создание пакета</a> и т.д.), чтобы настроить свои package.xml и CMakeLists.txt.
<h2 align=center>Управление системными зависимостями</h2>
Ссылки: <a href="https://wiki.ros.org/ROS/Tutorials/rosdep">Managing System dependencies</a>
<p>
Пакетам ROS иногда требуются внешние библиотеки и инструменты, которые должны предоставляться операционной системой. Эти необходимые библиотеки и инструменты обычно называются <b>системными зависимостями</b>. В некоторых случаях эти системные зависимости не устанавливаются по умолчанию. ROS предоставляет простой инструмент rosdep, который используется для загрузки и установки системных зависимостей.
<p>
Пакеты ROS должны указывать, что им нужны эти системные зависимости, в манифесте пакета. Давайте посмотрим на манифест для пакета turtlesim:
<br>
Сначало:<br>
<b>roscd turtlesim<br>
cat package.xml</b><br>
<img src="./images/package.xml2.png">
<p>
Внутри тегов build_depend можно видеть требуемые библиотеки пакеты для ноды (пакета) turtlesim.
<p>
<b>rosdep</b> - это инструмент, который вы можете использовать для установки системных зависимостей, требуемых пакетами ROS.<br>
Общий синтаксис:<br>
<font color=green>rosdep install [package]</font>
<p>
Загрузим и установим системные зависимости для turtlesim:<br>
<b>rosdep install turtlesim</b><br>
<img src="./images/rosdep_install.png">
<p>
Хотя rosdep является клиентским инструментом, ссылка предоставляется правилами rosdep, которые хранятся онлайн в ros/rosdistro/rosdep на github.
<p>
Когда выполняем:<br>
<b>rosdep update</b>
<br>rosdep фактически извлекает правила из репозитория rosdistro на github.<br>
начиная с версии 0.14.0, обновление rosdep будет извлекать имена пакетов ROS только для дистрибутивов ROS, отличных от EOL. Если вы все еще используете дистрибутив EOL ROS (чего, вероятно, не следует делать), вы можете передать аргумент --include-eol-distros, чтобы также получить имена этих пакетов ROS.
<p>
Эти правила используются, когда в списке указана зависимость, которая не соответствует имени пакета ROS, созданного в buildfarm. Затем rosdep проверяет, существует ли правило для ее устранения для соответствующей платформы и используемого менеджера пакетов.
<p>
При создании нового пакета вам может потребоваться объявить новые системные зависимости в соответствии с правилами rosdep, если их там еще нет. Просто отредактируйте файл, добавьте необходимую зависимость (строго в алфавитном порядке и по структуре, аналогичной другим уже зарегистрированным зависимостям) и отправьте запрос на извлечение.
<p>
После того, как этот запрос на извлечение был объединен, вам нужно запустить :<br>
<b>rosdep update</b><br>
и теперь эта зависимость будет устранена rosdep.
<p>
Можно протестировать это:<br>
<b>rosdep resolve my_dependency_name</b>


<h2 align=center>Советы по запуску крупных проектов</h2>
Ссылки: <a href="https://wiki.ros.org/ROS/Tutorials/Roslaunch%20tips%20for%20larger%20projects">Roslaunch tips for large projects</a>
<p>
В этом руководстве описаны некоторые советы по написанию файлов roslaunch для крупных проектов. Основное внимание уделяется тому, как структурировать файлы запуска, чтобы их можно было максимально часто использовать повторно в различных ситуациях. В качестве примера мы будем использовать пакет 2d nav_pr2.
<p>
Большие приложения на роботе обычно включают в себя несколько взаимосвязанных узлов, каждый из которых имеет множество параметров. Хорошим примером является 2d-навигация. Приложение 2dnav_pr2 состоит из самого узла move_base, локализации, фильтрации на плоскости, базового контроллера и картографического сервера. В совокупности существует также несколько сотен параметров ROS, которые влияют на работу этих узлов. И, наконец, существуют ограничения, такие как тот факт, что для повышения эффективности фильтрация в плоскости заземления должна выполняться на том же оборудовании, что и наклонный лазер.
<p>
Файл roslaunch позволяет нам сказать все это. При запущенном роботе запуск файла 2dnav_pr2.launch в пакете 2dnav_pr2 откроет все, что требуется роботу для навигации. В этом руководстве мы рассмотрим этот файл запуска и различные используемые функции.
<p>
Мы также хотели бы, чтобы файлы roslaunch можно было использовать повторно, насколько это возможно. В этом случае перемещение между физически идентичными роботами можно выполнять вообще без изменения файлов запуска. Даже такое изменение, как переход от робота к симулятору, может быть выполнено всего с несколькими изменениями. Мы рассмотрим, как структурирован файл запуска, чтобы сделать это возможным.
<p>
Файл запуска верхнего уровня:
<b>rospack find 2dnav_pr2/move_base/2dnav_pr2.launch</b>
<p>
<font color=red size=5>У меня не установлен пакет 2dnav_pr2и вообще согласно https://robotics.stackexchange.com/questions/64212/rospack-2dnav-pr2 пакет называется pr2_2dnav, но поддерживается, последняя версия indigo</font>
<p>
Этот файл содержит набор других файлов. Каждый из этих включенных файлов содержит узлы и параметры (и, возможно, вложенные включения), относящиеся к одной части системы, такой как локализация, обработка данных с датчиков и планирование траектории.
<p><i>
Совет по дизайну: Файлы запуска верхнего уровня должны быть короткими и состоять из ссылок на другие файлы, соответствующие подкомпонентам приложения, и часто изменяемых параметров ROS.</i>
<p>
Как мы увидим позже, это упрощает замену одной части системы.
<p>
Чтобы запустить это на роботе PR2, требуется запустить ядро, затем запустить файл запуска для конкретного робота, такой как pre.launch в пакете pr2_alpha, а затем запустить 2dnav_pr2.launch. Мы могли бы включить сюда файл запуска робота, а не требовать, чтобы он запускался отдельно. Это привело бы к следующим компромиссам:
<p>
ПЛЮСЫ: Нам пришлось бы сделать на один шаг меньше "открыть новый терминал, запустить заново".
Минусы: запуск файла запуска робота инициирует фазу калибровки, которая длится около минуты. Если бы файл запуска 2dnav_pr2 включал файл запуска робота, каждый раз, когда мы отключали roslaunch (с помощью control-c) и запускали его снова, калибровка происходила бы снова.<br>
МИНУСЫ: Некоторые навигационные узлы 2d требуют, чтобы калибровка была завершена до их запуска. Roslaunch намеренно не обеспечивает никакого контроля за порядком или временем запуска узлов. Идеальным решением было бы обеспечить корректную работу узлов, дождавшись завершения калибровки, но в ожидании этого, поместив данные в два файла запуска, мы можем запустить робота, дождаться завершения калибровки, а затем запустить 2dnav.
Таким образом, не существует универсального ответа на вопрос, следует ли разбивать содержимое на несколько файлов запуска. В данном случае было решено использовать два разных файла запуска.
<p><i>
Совет по дизайну: Помните о компромиссах при принятии решения о том, сколько файлов запуска верхнего уровня требуется вашему приложению.</i>

<h3>Машинные теги и переменные среды</h3>
Мы хотели бы контролировать, какие узлы работают на каких компьютерах, для балансировки нагрузки и управления полосой пропускания. Например, мы хотели бы, чтобы узел amcl работал на том же компьютере, что и базовый лазер. В то же время, для удобства повторного использования, мы не хотим жестко кодировать имена компьютеров в файлах roslaunch. Roslaunch обрабатывает это с помощью тегов компьютеров.
<p>
Сперва ключить тег:<br>
<b>&lt;include file="$(find pr2_alpha)/$(env ROBOT).machine" /&gt;</b>
<p>
Первое, на что следует обратить внимание в этом файле, - это использование аргумента подстановки env для использования значения переменной среды ROBOT. Например, выполнение:<br>
<b>export ROBOT=pre</b><br>
до запуска roslaunch это привело бы к включению файла pre.machine.
<p>
<i>Совет по разработке: Используйте аргумент подстановки env, чтобы части файла запуска зависели от переменных среды.</i>
<p>
Далее давайте рассмотрим пример файла machine: pre.machine в пакете pr2_alpha.<br>
<img src="./images/launch.png">
<p>
Этот файл устанавливает соответствие между логическими именами компьютеров, в данном случае "c1" и "c2", и фактическими именами хостов, такими как "pre 2". Он даже позволяет управлять пользователем, от имени которого вы входите в систему (при условии, что у вас есть соответствующие учетные данные ssh).
<p>
Как только сопоставление определено, его можно использовать при запуске узлов. Например, включенный файл config/new_amcl_node.xml в пакете 2d nav_pr2 содержит строку:<br>
<i>&lt;node pkg="amcl" type="amcl" name="amcl" machine="c1"&gt;</i>
<p>
Это приводит к запуску узла amcl на компьютере с логическим именем c1 (просмотрев другие файлы запуска, вы увидите, что большая часть обработки лазерного датчика была выполнена на этом компьютере).
<p>
При запуске нового робота, скажем, известного как prf, нам просто нужно изменить переменную среды ROBOT. Затем будет загружен соответствующий машинный файл (prf.machine в пакете pr2_alpha). Мы даже можем использовать это для запуска в симуляторе, установив для ROBOT значение sim. Посмотрев на файл sim.machine в пакете pr2_alpha, мы видим, что он просто сопоставляет все логические имена машин с localhost.
<p><i>
Совет по проектированию: Используйте теги компьютера, чтобы сбалансировать нагрузку и контролировать, какие узлы выполняются на одном компьютере, и подумайте о том, чтобы имя файла компьютера зависело от переменной среды для возможности повторного использования.</i>

<h3>Параметры, пространства имен (namespaces) и файлы yaml</h3>
Давайте посмотрим на прилагаемый файл move_base.xml. Вот фрагмент этого файла:<br>
<img src="./images/move_base.xml.png">
<p>
Этот фрагмент запускает узел move_base. Первым включенным элементом является переназначение. Move_base предназначен для получения одометрии по теме "odom". В случае с pr2 odometry публикуется в разделе pr2_base_odometry, поэтому мы переназначаем его.
<p>
<i>Совет по дизайну: Используйте переназначение раздела, когда информация определенного типа публикуется по разным темам в разных ситуациях.</i>
<p>
За этим следует набор тегов &lt;param&gt;. Обратите внимание, что эти параметры находятся внутри элемента node (поскольку они находятся перед &lt;/node&gt; в конце), поэтому они будут частными параметрами. Например, в первом из них для параметра move_base/controller_frequency устанавливается значение 10,0.
<p>
После элементов &lt;param&gt; есть несколько элементов &lt;rosparam&gt;. Они считывают данные параметров в формате yaml, который удобен для чтения человеком и позволяет создавать сложные структуры данных. Вот часть файла costmap_common_params.yaml, загруженного первым элементом &lt;rosparam&gt;:
<img src="./images/rosparam.png">
<p>
Мы видим, что yaml допускает такие вещи, как векторы (для параметра footprint). Он также позволяет помещать некоторые параметры во вложенное пространство имен. Например, для параметра base_scan_marking/sensor_frame установлено значение base_laser. Обратите внимание, что эти пространства имен относятся к собственному пространству имен файла yaml, которое было объявлено как global_costmap с помощью атрибута ns элемента including rosparam. В свою очередь, поскольку этот параметр rosparam был включен элементом node, полное имя параметра будет /move_base/global_costmap/base_scan_marking/sensor_frame.
<p>
Следующая строка в move_base.xml это:<br>
<i>&lt;rosparam file="$(find 2dnav_pr2)/config/costmap_common_params.yaml" command="load" ns="local_costmap" /&gt;</i>
<p>
На самом деле это тот же yaml-файл, что и в строке перед ним. Просто он находится в другом пространстве имен (пространство имен local_costmap предназначено для контроллера траектории, в то время как пространство имен global_costmap влияет на глобальный навигационный планировщик). Это намного удобнее, чем вводить все значения заново.
<p>
Следующая строка:<br>
<i>&lt;rosparam file="$(find 2dnav_pr2)/move_base/local_costmap_params.yaml" command="load"/&gt;</i>
<p>
В отличие от предыдущих, этот элемент не имеет атрибута ns. Таким образом, пространство имен файла yaml является родительским пространством имен /move_base. Но взгляните на первые несколько строк самого файла yaml:<br>
<img src="./images/local_costman.png">
<p>
Таким образом, мы видим, что параметры все-таки находятся в пространстве имен /move_base/local_costmap.
<p>
<i>Совет по дизайну: файлы Yaml допускают параметры сложных типов, вложенные пространства имен параметров и повторное использование одних и тех же значений параметров в нескольких местах.</i>

<h3>Повторное использование файлов запуска</h3>
Многие из приведенных выше советов были даны для того, чтобы упростить повторное использование файлов запуска в различных ситуациях. Мы уже видели один пример, в котором использование аргумента подстановки env может позволить изменять поведение без изменения каких-либо файлов запуска. Однако в некоторых ситуациях это неудобно или невозможно. Давайте взглянем на пакет pr2_2d nav_gazebo. Он содержит версию приложения для 2d-навигации, но для использования в симуляторе Gazebo. Что касается навигации, единственное, что изменилось, - это то, что используемая нами среда Gazebo основана на другой статической карте, поэтому узел map_server должен быть загружен с другим аргументом. Мы могли бы использовать здесь другую замену env. Но это потребовало бы от пользователя установки множества переменных среды только для того, чтобы иметь возможность повторно запускать. Вместо этого 2dnav gazebo содержит свой собственный файл запуска верхнего уровня под названием "2d nav-stack-amcl.launch", показанный здесь (слегка измененный для наглядности).:<br>
<img src="./images/launch1.png">
<p>
Первое отличие заключается в том, что, поскольку мы знаем, что находимся в симуляторе, мы просто используем файл sim.machine, а не используем аргумент подстановки. Во-вторых, строка:<br>
<i>&lt;include file="$(find 2dnav_pr2)/config/map_server.xml" /&gt;</i><br>
была заменена на<br>
<i>&lt;node name="map_server" pkg="map_server" type="map_server" args="$(find gazebo_worlds)/Media/materials/textures/map3.png 0.1" respawn="true" machine="c1" /&gt;</i>
<p>
Включенный файл в первом случае просто содержал объявление узла, как и во втором, но с другим файлом карты.
<p><i>
Совет по дизайну: Чтобы изменить "высокоуровневый" аспект приложения, скопируйте файл запуска верхнего уровня и измените нужные части.</i>
<h3>Переопределение параметров</h3>
Описанный выше метод иногда становится неудобным. Предположим, мы хотим использовать 2dnav_pr2, но просто изменим параметр разрешения локальной карты затрат на 0,5. Мы могли бы просто локально изменить local_costmap_params.yaml. Это самый простой способ для временных изменений, но это означает, что мы не сможем вернуть измененный файл обратно. Вместо этого мы могли бы создать копию файла local_costmap_params.yaml и изменить его. Тогда нам пришлось бы изменить move_base.xml, чтобы включить измененный файл yaml. И тогда нам пришлось бы изменить 2dnav_pr2.launch, чтобы включить измененный move_base.xml. Это может занять много времени, и при использовании системы управления версиями мы больше не увидим изменений в исходных файлах. Альтернативой является реструктуризация файлов запуска таким образом, чтобы параметр move_base/local_costmap/resolution был определен в файле верхнего уровня 2dnav_pr2.launch, и создание модифицированной версии только этого файла. Это хороший вариант, если мы заранее знаем, какие параметры, скорее всего, будут изменены.
<p>
Другой вариант - использовать переопределяющее поведение roslaunch: параметры устанавливаются по порядку (после обработки включений). Таким образом, мы могли бы создать дополнительный файл верхнего уровня, который переопределяет<br>
 <img src="./images/launch2.png">
 <p>
 Основным недостатком этого метода является то, что он может усложнить понимание: для определения фактического значения, которое roslaunch устанавливает для параметра, требуется поиск по файлам, включающим roslaunch. Но это позволяет избежать необходимости создавать копии нескольких файлов.
<p><i>
Совет по дизайну: Чтобы изменить глубоко вложенный параметр в дереве файлов запуска, который вы не можете изменить, используйте параметр roslaunch, переопределяющий семантику.</i>

<h3>Аргументы Roslaunch</h3>
Начиная с CTurtle, в roslaunch есть функция замены аргументов вместе с тегами, которые позволяют настраивать части файла запуска в зависимости от значения аргументов. Это может быть более общим и понятным способом структурирования, чем механизм переопределения параметров или методы повторного использования файлов запуска, описанные выше, за счет необходимости изменять исходный файл запуска, чтобы указать, какие аргументы могут быть изменены. Смотрите документацию roslaunch XML.
<p><i>
Совет по дизайну: Если вы можете изменить исходный файл запуска, часто предпочтительнее использовать аргументы roslaunch, а не переопределять параметры или копировать файлы roslaunch.</i>

<h3>Конфигурационные файлы и roslaunch</h3>
Файл .launch - это тип конфигурационного файла. С точки зрения файловой системы, нет разницы между файлами .launch и любыми другими файлами в формате xml (поэтому подходит любое расширение файла. Для простоты .В этом разделе используется launch). Он не может запускать какой-либо процесс сам по себе. Вместо этого он работает только тогда, когда передается определенным исполняемым файлам, которые используют файл .launch в качестве входных данных. Наиболее известным таким исполняемым файлом является roslaunch.
<p>
<b>Файлы конфигурации упаковки (включая файлы .launch)</b><br>
Конфигурационные файлы, пригодные для повторного использования, обычно включаются в пакеты. Затем пользовательское программное обеспечение таких конфигурационных файлов может получить доступ к этим конфигурациям, просмотрев путь, по которому находятся конфигурации, или, что более распространено, используя механизм поиска ресурсов ROS ("rospack find"), так что пользователю не нужно знать путь к конфигурациям. Преимущество последнего заключается в упаковке конфигурационных файлов в "пакет", о котором мы говорим (пакет, совместимый с rosmake/Catkin/Colcon).
<p>
В контексте roslaunch значение конфигурационных файлов различно: * .файл запуска: он находится в исполняемом файле roslaunch (или его внутреннем процессе, запущенном через его API), напрямую передается в него и анализируется. * YAML: Путь к файлу может быть передан тегу rosparam, который считывает файл и загружает содержимое на сервер параметров ROS. * Нет встроенной поддержки файлов других типов.
<p>
Внутри .launch одна из примечательных функций заключается в том, что путь к другому ресурсу может быть заменен на $(найти pkg).
<p>
<b>Practice-A. Отдельные пакеты для .launch и других конфигурационных файлов</b><br>
В сочетании с этим хорошей практикой упаковки конфигураций является создание отдельных пакетов для .запуска и других типов конфигурационных файлов. Скажем, пакетов YOURPRJ_config и YOURPRJ_launch. Потому что * Есть большая вероятность, что некоторые конфигурации в вашем PRJ_CONFIG pkg содержат ссылки .файлы запуска в вашем PRJ_LAUNCH. Т.е. ваш prj_launch зависит от вашего PRJ_CONFIG. * Допустим, в вашем проекте есть другой пакет, YOURPRJ_calibration package, который предоставляет узлы, использующие конфигурации, хранящиеся в вашем PRJ_CONFIG. У вас также есть файлы запуска для запуска этих узлов.
<p>
Если бы и launch, и другие конфигурации были упакованы в один и тот же пакет, скажем, у вашего PRJ_CONFIG_SINGLE возникла бы циклическая зависимость.
<p>
запускайте файлы в ссылочных узлах вашего PRJ_CONFIG_SINGLE в вашем PRJ_CALIBRATION.
<p>
узлы в вашем Prj_calibration ссылаются на файлы конфигурации в вашем PRJ_CONFIG_SINGLE.
<p>
Благодаря тому, что launch и другие конфигурации хранятся в отдельных пакетах, можно избежать циклической зависимости.
узлы в вашем Prj_calibration ссылаются на файлы конфигурации в вашем PRJ_CONFIG.
<p>
файлы запуска в вашем PRJ_LAUNCH ссылаются на узлы в вашем prj_calibration.
<p>
<b>Практика-B. Сгруппируйте множество конфигураций в один пакет или меньшее количество пакетов</b><br>
В ROS-промышленном фреймворке, где работа с большим количеством, но схожего оборудования является одной из мотиваций, группировка множества конфигураций, включая. .запускать файлы оказалось удобнее. Смотрите соответствующее обсуждение (discourse.ros.org#18443).

<h3 align=center>Запуск ROS на нескольких компьютерах</h3>
Ссылки: <a href="https://wiki.ros.org/ROS/Tutorials/MultipleMachines">Running ROS across multiple machines</a>
<p>
В этом руководстве объясняется, как запустить систему ROS с использованием двух компьютеров. В нем объясняется использование ROS_MASTER_URI для настройки нескольких компьютеров на использование одного мастера.
<p>
ROS разработан с учетом распределенных вычислений. Хорошо написанный узел не делает никаких предположений о том, в какой части сети он выполняется, позволяя перемещать вычисления во время выполнения в соответствии с доступными ресурсами (существуют исключения; например, узел драйвера, который взаимодействует с частью аппаратного обеспечения, должен выполняться на компьютере, к которому физически подключено оборудование). Развернуть систему ROS на нескольких компьютерах несложно. Помните о следующих моментах:
<ul>
<li>Вам нужен только один ведущий сервер. Выберите один компьютер для запуска.
<li>Все узлы должны быть настроены на использование одного и того же ведущего сервера с помощью ROS_MASTER_URI.
<li> Между всеми парами компьютеров должно быть полное двустороннее подключение по всем портам (см. ROS/NetworkSetup).
<li> Каждая машина должна указывать свое имя, доступное для всех других компьютеров (см. ROS/NetworkSetup).
<h3>Talker / listener внутри двух машин</h3>
Допустим, мы хотим запустить систему общения / прослушивания на двух компьютерах с именами marvin и hal. Это имена хостов этих машин, что означает, что это имена, по которым вы будете обращаться к ним, когда. Например, для входа в marvin вам нужно выполнить следующие действия:<br>
<i>ssh marvin</i>
<br>То же самое приходит и в <b>hal</b>.
<ol>
<li> Старт мастера<br>
Нам нужно выбрать одну машину для запуска мастера; мы выберем hal. Первый шаг - запустить мастер
<p>
<i>ssh hal<br>
roscore</i>
<li> Старт listener
Теперь мы запустим прослушиватель на hal, настроив ROS_MASTER_URI таким образом, чтобы использовать только что запущенный мастер:
<p>
<i>ssh hal<br>
export ROS_MASTER_URI=http://hal:11311<br>
rosrun rospy_tutorials listener.py</i>
<li>Старт talker
Далее мы запустим talker на marvin, также настроив ROS_MASTER_URI так, чтобы использовался мастер на hal:
<p>
<i>ssh marvin<br>
export ROS_MASTER_URI=http://hal:11311<br>
rosrun rospy_tutorials talker.py</i>
<p>
Вуаля: теперь вы должны увидеть, что прослушиватель в hal получает сообщения от talker в marvin.
<p>
Обратите внимание, что последовательность запуска talker / listener не имеет значения; узлы могут запускаться в любом порядке. Единственное требование - перед запуском любых узлов запустить мастер.
<li> Вариант: подключение в другом направлени<br>
Теперь давайте попробуем в другом направлении. Оставив мастер запущенным на hal, убейте talker и listener, затем запустите их на противоположных машинах.
<p>
Сначала listener на marvin:
<br>
<i>ssh marvin<br>
export ROS_MASTER_URI=http://hal:11311<br>
rosrun rospy_tutorials listener.py</i>
<p>
Теперь talker на hal:<br>
<i>ssh hal<br>
export ROS_MASTER_URI=http://hal:11311<br>
rosrun rospy_tutorials talker.py</i><p>
</ol>
<p>
<b>rostopic</b>
<p>
Для тестирования вы можете использовать инструмент rostopic на всех компьютерах, подключенных к ядру.
<p>
Вы получите список всех доступных тем. Если вы не подключены к ядру, появится сообщение об ошибке.
<p>
<font color=green>rostopic list</font>
<p>
В беспроводных сетях иногда возникает необходимость проверить, есть ли соединение и продолжают ли приходить сообщения. Для коротких тестов удобно распечатывать сообщения.
<p>
<b>rostopic echo /topic_name</b>
<h3>Когда что-то идет не так</h3>
Если что-то из приведенной выше последовательности действий не сработало, причина, скорее всего, кроется в конфигурации вашей сети. Требования к конфигурации и советы по устранению неполадок приведены в разделах ROS/NetworkSetup и ROS/Troubleshooting.
<p>
Одной из распространенных проблем является отсутствие определения ROS_IP на компьютере, на котором запущен talker.py.
<p>
проверьте это с помощью: echo $ROS_IP
<p>
Если вы не зададите ROS_IP, то rostopic info действительно покажет правильные соединения издателя и слушателя, но rostopic echo будет пустым. Вы не увидите TX-трафика в локальной сети, на компьютере с talker. Во-первых, после определения ROS_IP с соответствующим IP-адресом (экспортировать ROS_IP=machine_ip_addr) вы увидите трафик по локальной сети, а listener.py отобразит полученные данные.

<h3 align=center>Определение пользовательских сообщений</h3>
Ссылка: <a href="https://wiki.ros.org/ROS/Tutorials/DefiningCustomMessages">Defining Custom Messages</a>
<ol>
<li> Создание сообщений
<p>
Создать сообщение очень просто. Просто поместите msg-файл в каталог msg в пакете. Пожалуйста, следуйте предыдущему руководству по созданию msg-файлов (не забудьте выбрать тип системы сборки вверху страницы
<li> Включение или импорт сообщений
<p>
Для C++<br>
Сообщения помещаются в пространство имен, которое соответствует имени пакета. т.е.<br>
<img src="./images/include.png">
<p>
Для python:<br>
<img src="./images/python.png">
<li> Зависимости
<p>
Если вы используете новое пользовательское сообщение, определенное в другом пакете, не забудьте добавить:
<p>
в package.xml:<br>
<img src="./images/build_depend.png">
<p>
и вам нужно будет добавить это в свой CMakeList.txt:<br>
<i>add_dependencies(your_program ${catkin_EXPORTED_TARGETS})</i>
<p>
Если вы создаете узлы на C++, которые используют ваши новые сообщения, вам также нужно будет объявить зависимость между вашим узлом и вашим сообщением, как описано в документации по сборке catkin msg/srv
<p>
В руководстве ROS Node Tutorial по Python показан пример ранее описанных руководств по работе с talker и listener, использующих пользовательское сообщение, с реализациями на C++ и Python.

<h3 align=center><a href="https://wiki.ros.org/ROS/Tutorials/Using%20a%20C%2B%2B%20class%20in%20Python">Using a C++ class in Python</a></h3>

<h3 align=center><a href="https://wiki.ros.org/ROS/Tutorials/Packaging%20your%20ROS%20project%20as%20a%20snap">Packaging your ROS project as a snap</a></h3>

<h3 align=center><a href="https://wiki.ros.org/WritingTutorials">How to Write a Tutorial</a></h3>

<h3 align=center><a href="https://wiki.ros.org/urdf/Tutorials">Создайте свой собственный URDF файл</a></h3>

<br><br><br><br><br><br><br><br></body></html>

