<html><head>
<style>
.menu {
       height: 100%;
       width: 170px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 10px;
           margin-left: 170px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Функции в Cи++</title>
<div class="menu">
<a href="./index.html">Главная</a>
----------------------
<a href="./c++.html">Основы С++</a>
<a href="./c++_massiv.html">Массивы</a>
<a href="./c++file.html">Работа с файлами</a>
<a href="./c++_example.html">Решения</a>
--------------------------
Основы функций в C++:
<a href="#reload">Перегрузка функций. Директива extern C</a>
<a href="#inline">Ключевое слово inline</a>
<table border=2 style="border-collapse:collapse;"><tr><td>
<a href="#lambda">Лямбда-функции</a>
<a href="#lambda_in_parametr">Лямбда в аргументах функций</a>
<a href="#occup">Захват значений</a>
</td></tr></table>
<table border=2 style="border-collapse:collapse;"><tr><td>
<a href="#struct">Структуры</a>
<a href="#this">&nbsp;&nbsp; Указатель this</a>
<a href="#mode_struct">&nbsp;&nbsp; Режимы доступа</a>
<a href="#konstruktor">&nbsp;&nbsp; Конструкторы</a>
<a href="#sev_konstr">&nbsp;&nbsp;&nbsp;&nbsp; Определение нескольких конструкторов</a>
<a href="#destrukt">&nbsp;&nbsp; Деструкторы</a>
<a href="#static">Ключевое слово static</a>
</td></tr></table>
<a href="#new">Операторы new / delete</a>
<a href="#smart_ptr">указатели unique_ptr</a>
<a href="#share">указатели shared_ptr</a>
</div>

<div class="content">

Ссылки на учебники: <a href="https://metanit.com/cpp/tutorial/">Руководство по языку программирования C++</a>
<p>
<a name="reload"><h3 align=center>Перегрузка функций. Директива extern C</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-peregruzka-funkciy-direktiva-extern-c">Перегрузка функций. Директива extern C</a><br>
<a href="https://metanit.com/cpp/tutorial/4.14.php">Перегрузка функций</a>
<p>
Язык С++ позволяет определять функции с одним и тем же именем, но разным набором параметров. Подобная возможность называется <b>перегрузкой функций</b> (function overloading). Компилятор же на этапе компиляции на основании параметров выберет нужный тип функции.
<p>
Чтобы определить несколько различных версий функции с одним и тем же именем, все эти версии должны отличаться как минимум по одному из следующих признаков:
<ul>
<li> имеют разное количество параметров
<p>
<li>соответствующие параметры имеют разный тип
</ul>
<p>
При этом различные версии функции могут также отличаться по возвращаемому типу. Однако компилятор, когда выбирает, какую версию функции использовать, ориентируется именно на количество параметров и их тип.
<p>
Рассмотрим простейший пример:
<pre>
#include &lt;iostream>
 
<font color=green>int sum(int, int);</font>
<font color=blue>double sum(double, double);</font>
 
int main()
{
    int result1 {sum(3, 6)}; // выбирается версия int sum(int, int)
    std::cout << result1 << std::endl; // 9
 
     
    double result2 {sum(3.3, 6.6)}; // выбирается версия double sum(double, double)
    std::cout << result2 << std::endl; // 9.9
}
int sum(int a, int b)
{
    return a + b;
}
double sum(double a, double b)
{
    return a + b;
}
</pre>
Здесь определены две версии функция sum, которая складывает два числа. В одном случае она складывает два числа типа int, в другом - числа типа double. При вызове функций компилятор на основании переданных аргументов определяет, какую версию использовать. Например, при первом вызове передаются числа int:
<p>
int result1 {sum(3, 6)};<br>
Соответственно для этого вызова выбирается версия
<p>
int sum(int, int);
<p>
Во втором вызове в функцию передаются числа с плавающей точкой:
<p>
double result2 {sum(3.3, 6.6)};<br>
Поэтому выбирается версия, которая принимает числа double:<br>
double sum(double, double);
<p>
Аналогично перегруженные версии функции могут отличаться по количеству параметров:
<pre>
#include &lt;iostream>
 
<font color=green>int sum(int, int);</font>
<font color=blue>int sum(int, int, int);</font>
 
int main()
{
    int result1 {sum(3, 6)}; // выбирается версия int sum(int, int)
    std::cout << result1 << std::endl; // 9
 
     
    int result2 {sum(3, 6, 2) }; // выбирается версия int sum(int, int, int)
    std::cout << result2 << std::endl; // 11
}
int sum(int a, int b)
{
    return a + b;
}
int sum(int a, int b, int c)
{
    return a + b + c;
}
</pre>
<pre>

</pre>
<h4 align=center>Директива extern "C"</h4>
Надо сказать, что механизм перегрузки функций в С++ повлек за собой некоторые особенности при сборке проектов в исполняемый файл. Ранее, когда создавался язык Си, то функции имели уникальные имена. Соответственно, компоновщик, встречая имя функции в объектном файле, подставлял вместо него соответствующий код вызова. Например, имя функция modul_int() в Си внутри объектного файла имела метку modul_int. Все просто. Но с перегрузкой имен функций все изменилось. Теперь мало просто указать ее имя, нужно дополнительно закодировать в объектном файле набор ее параметров, так как именно эта связка:
<pre>
имя функции + параметры
</pre>
дает уникальную метку. Проблема в том, что разные компиляторы языка С++ по разному выполняют это кодирование. Например, компилятор g++ для функции:
<p>
int modul(int x);<br>
сформирует метку вида:
<pre>
_Z5moduli
</pre>
Здесь _Z – это специальный префикс, означающий начало метки функции; число 5 – количество символов в имени функции; i – внутреннее обозначение стандартного типа int.
<p>
Повторюсь, другие компиляторы языка С++ и даже разные версии одного и того же компилятора, могут по разному строить эти метки. К чему это в итоге приводит? Все верно. Если у нас есть только объектные файлы какого-либо проекта, то не всегда нам удастся его собрать и получить конечный результат, например, в виде исполняемого файла. Мало того, если объектные файлы были созданы компилятором языка Си, в котором не подразумевается перегрузка функций, то кодирование меток точно будет неверным для компилятора С++.
<p>
Но вот эта последняя проблема все же решаема. Если мы пишем программу на языке Си и предполагаем использовать ее, в том числе, и на С++, то объявление функций следует поместить в тело директивы extern "C" следующим образом:
<pre>
extern "C" {
 
void show_msg(const char* msg)
{
    puts("-----------------------");
    puts(msg);
    puts("-----------------------");
}
 
}
Или, если в блоке одна функция, то можно просто указать:

extern "C"
void show_msg(const char* msg)
{
    puts("-----------------------");
    puts(msg);
    puts("-----------------------");
}
</pre>
Разумеется, внутри директивы extern "C" не допускается определять перегруженные функции, т.к. метки будут формироваться и восприниматься компоновщиком в стиле языка Си.
<p>
В результате, мы имеем функцию show_msg(), которая в объектном файле будет представлена своим именем show_msg и успешно обрабатываться различными компиляторами языка С++. Однако директива extern "C" доступна в языке С++ и не существует в языке Си. Поэтому для полной универсальности кода, следует добавить следующие директивы условной компиляции:
<pre>
#ifdef __cplusplus
extern "C" {
#endif
void show_msg(const char* msg)
{
    puts("-----------------------");
    puts(msg);
    puts("-----------------------");
}
 
#ifdef __cplusplus
}
#endif
</pre>
Здесь макросимвол __cplusplus всегда существует для компилятора С++ и изначально отсутствует в компиляторе языка Си. Поэтому язык Си «не увидит» директиву extern "C", а С++ успешно ее обработает. В итоге, получаем универсальное объявление функции show_msg() для компиляторов обоих языков.
<p>
Конечно, это следует делать только в том случае, если мы, например, пишем библиотеку общую для Си и С++ или модуль, который предполагается использовать в этих языках. Тогда нужно добавлять директиву extern "C". Если же программа пишется исключительно для Си или С++, то функции объявляются обычным образом.
<pre>


========================================================================================================================


</pre>
<a name="inline"><h3 align=center>Ключевое слово inline перед функциями</h3>
Современные компиляторы языков Си и С++ довольно умело оптимизируют программу и на уровне машинного кода вместо вызова простых функций сразу подставляют внутри main() код тела функции. Поэтому, просматривая машинный код можем не увидеть вызов простой функции, а сразу обнаружить код функции внутри main(). Подобный подход компилятор пытается применить для всех простых в реализации функций. Часто это приводит к некоторому повышению производительности программы в целом. Однако если такая подстановка невозможна (например, для рекурсивных функций) или тело функции содержит довольно большой объем операторов, то компилятор формирует их обычный вызов с использованием стекового фрейма. Тем не менее, если программист понимает, что тело функции было бы разумно подставлять в местах ее формального вызова, то он может сообщить об этом компилятору, прописав перед заголовком функции <b>ключевое слово inline</b> следующим образом:
<pre>
<b>inline</b> name_func(...)
{
...
}
</pre>
Благодаря наличию ключевого слова inline, <b>возможно</b>, ее тело просто будет подставлено в место формального вызова. Хотя, это не гарантируется. Компилятор сам примет решение, исходя из формируемой программы на уровне машинных кодов. Тем не менее, ключевое слово inline может сыграть здесь значимую роль в выборе компилятором способа выполнения этой функции.
<p>
На самом деле, довольно часто функции, прописанные в заголовочных файлах, или внутри структур и классов, рассматриваются, как inline-функции, так как в заголовках, обычно, размещаются или прототипы функций или функции с короткими реализациями, а значит, они вполне могут быть преобразованы в inline-функции. То же самое и функции внутри классов и структур. Если их реализации прописаны непосредственно там, то это повод для компилятора рассматривать их как inline. И часто они именно так переводятся в машинный код, то есть, без реального вызова.
<p>
<b>Правильное объявление inline функций:</b>
<pre>
<font color=red>//inline set_y(int y);</font> //не указан тип функции

<font color=red>//double abs_d(double x) inline;</font> //слово inlline идет первым при объявлении либо послу указания типа функции
<font color=green>
inline int get_min(int a, int b);

void inline set_x(int x);

int inline get_max(int a, int b);</font>
</pre>
<pre>


===========================================================================================================================



</pre>
<a name="lambda"><h3 align=center>Лямбда-функции</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-lyambda-vyrazheniya-obyavlenie-i-vyzov">>Лямбда-выражения. Объявление и вызов</a><br>
<a href="https://metanit.com/cpp/tutorial/15.2.php">Лямбда-выражения</a>
<p>
<b><a href="https://metanit.com/cpp/tutorial/15.1.php">Объект-функция</a></b><br>
<b>Объект-функция</b> (function object) или функтор (functor) представляет объект, который может вызываться как функция. Для этого применяется оператор (). Примером объекта функции является лямбда-функция.
<p>
В стандарте компилятора С++11 появились, так называемые, лямбда-функции (еще говорят лямбда-выражения или анонимные функции). Лямбда-выражение позволяет создавать простой объект-функцию в любом допустимом месте программы. И одно из таких допустимых мест и чаще всего применяемый – аргумент обычной функции. 
<p>
Общий синтаксис их определения следующий:
<pre>
[] ([параметры]) { <операторы тела функции>}
</pre>
Обратите внимание, что здесь отсутствует имя функции. Поэтому их иногда и называют анонимными. Лямбда-выражение <b>начинается с квадратных скобок</b>. Затем, как в обычной функции, в круглых скобках идет перечисление параметров - типы и их имена. Также начиная со стандарта C++14 для параметров можно указывать <b>значения по умолчанию</b>. За списком параметров, как и в обычной функции, в фигурных скобках помещаются действия, выполняемые лямбда-выражением. 
<p>
Для лямбда-функций без параметров вы можете опустить пустой список параметров (). То есть лямбда-выражение формы []() {...} может быть дополнительно сокращено до [] {...}:
<pre>
[]{ std::cout << "Hello" << std::endl; }
</pre>
<h4>Вызов лямбда-выражения</h4>
Как вызывать функцию, у которой нет имени? В самом простом варианте можно добавить вызов сразу после ее определения, например, так:
<pre>
    [](int a) {
        cout << "Lambda-function: " << a << endl;
    } <b>(10)</b>;
</pre>
или если лямбда-функция не имеет параметров, то например:
<pre>
[](){std::cout << "Hello" << std::endl;} ();
    // или так
[]{std::cout << "Hello" << std::endl;} ();
</pre>
Но смысла от такой операции большого не будет. Поэтому обычно созданный объект-функцию присваивают какой-либо переменной.Лямбда-выражение можно определить как переменную:
<pre>
int main()
{
    // переменная hello представляет лямбда-выражение 
    auto <b>hello</b> { [](){std::cout << "Hello" << std::endl;} };
 
    // через переменную вызываем лямбда-выражение
    hello();    // Hello
    hello();    // Hello
}
</pre>
Здесь переменная hello в качестве значения хранит лямбда-выражение. Чтобы компилятор автоматически определил тип переменной, она определена с ключевым словом auto
<p>
Далее через имя переменной мы можем вызвать лямбда-выражение как обычную функцию:
<pre>
hello();
</pre>
Другой пример с не пустым параметром:
<pre>
int main()
{
    <b>auto print { [](const std::string& text){std::cout << text << std::endl;} };</b>
 
    // вызываем лямбда-выражение
    print("Hello World!");          // вызов функции со строкой "Hello World!"
    print("Good bye, World...");    // Good bye, World...
}
</pre>
Здесь лямбда-выражение принимает один параметр типа const std::string&, то есть строку, которая выводится на консоль. И это лямбда-выражение присвоено переменной print.
<p>
Также можно сразу же при определении вызвать лямбда-выражение, передав в него строку
<pre>
[](const std::string& text){std::cout << text << std::endl;} ("Hell");
</pre>
<h4>Возвращение значения</h4>
Лямбда-выражение может возвращать произвольное значение. В этом случае, как и в обычной функции, применяется оператор return:
<pre>
int main()
{
    <b>auto sum { [](int a, int b){return a + b;} };</b> //инициализация лямбда-функции
 
    // вызываем лямбда-выражение
    std::cout << sum(10, 23) << std::endl;  // 33
 
    // присваиваем его результат переменной
    int result { sum(1, 4)};
    std::cout << result << std::endl;       // 5
}
</pre>
В данном случае лямбда-выражение возвращает сумму параметров в виде значения int. Соответственно результат выражения мы можем использовать как значение типа int.
БзЮ
Стоит отметить, что по умолчанию компилятор сам определяет, значение какого именно типа будет возвращаться из лямбды. Однако мы также можем явным образом указать возвращаемый тип:
<pre>
int main()
{
    auto sum { [](int a, int b) <b>-> double</b> {return a + b;} };
 
    // вызываем лямбда-выражение
    std::cout << sum(10, 23) << std::endl;  // 33
}
</pre>
Для установки возвращаемого типа <b>после списка параметров указывается стрелка и собственно возвращаемый тип</b>. Так, в данном случае возвращается значение типа double:<br>
[](int a, int b) -> double {return a + b;}
<p>
То есть сумма чисел, которая по умолчанию представляет тип int, будет преобразована в значение типа double.>
<pre>


</pre>
<a name="lambda_in_parametr"><h3 align=center>Лямбда-выражения в аргументах функций</h3>
Теперь, когда мы в целом познакомились с идеей лямбда-выражений, ответим на следующий вопрос, зачем все это нужно? Давайте, я приведу простой пример, где лямбда-функции могут быть удобнее обычных функций.
<p>
Объявим функцию с именем show_ar, которая выводит целочисленные значения переданного ей массива ar длиной length:
<pre>
void show_ar(const int* ar, size_t length, bool (*filter_func)(int) = nullptr)
{
    for(int i = 0;i < length; ++i) {
        if(filter_func != nullptr) {
            if(filter_func(ar[i]))
                cout << ar[i] << " ";
        }
        else
            cout << ar[i] << " ";
    }
}
</pre>
Последний параметр представляет собой указатель на функцию со значением по умолчанию nullptr. В этом случае в консоль выводится весь массив от начала до конца. Например, так:
<pre>
int main()
{
    int data[] {1, 2, 3, 4, 5, 6, 7, 8};
    show_ar(data, sizeof(data)/sizeof(*data));
 
    return 0;
}
</pre>
Но третьим аргументом можно передать функцию, которая позволит нам фильтровать данные и отображать только нужные значения массива, например, только четные. Для этого воспользуемся лямбда-выражением и пропишем его следующим образом прямо в момент вызова функции show_ar():
<pre>
show_ar(data, sizeof(data)/sizeof(*data), <b>[](int x) {return x % 2 == 0;}</b>);
</pre>
Анонимная функция возвращает истину для четных значений и ложь для нечетных. В итоге видим в консоли только четные значения элементов массива.
<p>
Видите, как удобно определять произвольные критерии выбора числовых значений с помощью лямбда-функций? В результате, функция show_ar() стала в некотором смысле универсальной. Ее можно вызвать для отображения массива целых чисел с любым критерием отбора. Например, всех чисел кратных трем:<br>
show_ar(data, sizeof(data)/sizeof(*data), [](int x) {return x % 3 == 0;});
<p>
Преимущество лямбда-выражения в этом примере перед обычной функцией еще и в том, что это выражение для функции существует лишь при вызове show_ar() и автоматически пропадает после вызова. То есть, имеем экономию памяти и не нагромождаем программу лишними объявлениями функций.
<pre>

</pre>
<h4>Универсальные лямбда-выражения</h4>
Универсальное лямбда-выражение (generic lambda) — это лямбда-выражение, в котором <b>как минимум для одного параметра в качестве типа указано слово auto или выражения auto& или const auto&</b>. Это позволяет уйти от жесткой привязки параметров к определенному типу. Например:
<pre>
int main()
{
    auto add = [](auto a, auto b) {return a + b;};
    //auto print = [](const auto& value) {std::cout << value << std::endl; };
 
    std::cout << add(2, 3) << std::endl;        // 5 - складываем числа int
    std::cout << add(2.2, 3.4) << std::endl;    // 5.6 - складываем числа double
 
    std::string hello{"hello "};
    std::string world{"world"};
    std::cout << add(hello, world) << std::endl;    // hello world - складываем строки
}
</pre>
В данном случае определено лямбда-выражение, которое принимает два параметра и возвращает их сумму. Оно присвоено переменной add:<br>1
auto add = [](auto a, auto b) {return a + b;};
<p>
То есть на момент написания мы не знаем, какие типы будут представлять параметры. Конкретные типы будет выводить компилятор при вызове лямбда-выражения исходя из переданных в него значений:<br>
std::cout << add(2, 3) << std::endl;<br>
Так, в данном случае передаются два числа типа int, соответственно результат будет сумма этих чисел в виде значения int.
<p>
Другой пример - определим универсальное лямбда-выражение, которое выводит произвольное значение на консоль:
<pre>
int main()
{
    auto print = [](const auto& value) {std::cout << value << std::endl; };
 
    print("Hello");
    print(4);
    print(45.6789);
}
</pre>
<pre>



</pre>
<a name="occup"><h3 align=center>Захват внешних значений в лямбда выражениях</h3>
Ссылки: <a href="">Захват внешних значений в лямбда выражениях</a><br>
<a href="https://metanit.com/cpp/tutorial/15.3.php">Захват внешних значений в лямбда-выражениях</a>
<p>
Для чего нужны и как используются квадратные скобки, стоящие вначале каждого лямбда-выражения. Во всех предыдущих примерах они у нас с вами были пустыми. Но, в действительности, через них можно передавать различные переменные из внешней области видимости, то есть, переменные, находящиеся за пределами тела лямбда-функции. Этот процесс в С++ называется <b>захват переменных</b>.
<p>
Первое, что вытекает из необходимости захвата внешних значений, это недоступность локальных переменных, объявленных за пределами лямбда-выражения. Действительно, компиляция следующего текста программы приведет к ошибке:
<pre>
#include &lt;iostream>
 
using std::cout;
using std::cin;
using std::endl;
 
<b>const int max_size = 1000;</b>
 
int main()
{
    <b>int data[] {1, 2, 3, 4, 5, 6, 7, 8};
    size_t sz = sizeof(data)/sizeof(*data);</b>
                                               
    auto r = []() { 
        <font color=red>cout << sz << endl;</font>         // ошибка, sz - локальная переменная, лямбда функция не видит их
        <font color=green>cout << max_size << endl;</font>  // max_size - глобальная переменная, лямбда функция видит их
        };
 
    r();
 
    return 0;
}
</pre>
Внутри тела лямбда-функции локальные внешние переменные оказываются недоступными. Но не глобальные. Их по-прежнему можно использовать в любом месте текущего модуля, в том числе, и внутри лямбда-выражений.
<p>
Для того чтобы иметь доступ к локальным переменным в лямбда, используют различные операторы в квадратных скобках и ключевые слова.
<h4>Получение данных по значению (оператор =)</h4>
Если надо получить все внешние переменные из области, где определено лямбда-выражение, по значению, то в квадратных скобках указывается символ '='.
<pre>
auto r = [<font size=4 color=brown><b>=</b></font>]() { 
        <font color=green>cout << sz << endl;</font>         // ok, теперь ошибок нет
        cout << max_size << endl; 
        };
</pre>
Этот оператор означает, что
<ol>
<li> мы создаём в лямбда-функции новые переменные с такими же именами, как у переменных в main() (за пределами лямбда-функции)
<li> и инициализируем их теми же значениями
<li> и эти новые переменные являются константами.
</ol>
В частности, sz – это новая константная переменная с копией значения переменной sz из функции main(). Поэтому, при выводе ее значения, мы видим число 8 и изменить ее уже нельзя. Следующий код не скомпилируется:
<pre>
    auto r = [=]() {
        <font color=red>sz++;</font> // ошибка, sz – константа, значение менять нельзя
        cout << sz << endl;         
        cout << max_size << endl; 
        };
</pre>
<h4>Ключевое слово mutable</h4>
Однако это поведение можно изменить, если после круглых скобок лямбда-выражения прописать ключевое слово mutable следующим образом:
<pre>
    auto r = [=]() <b>mutable</b> {
        <font color=green>sz++;</font>  // ok
        cout << sz << endl;         // ok
        cout << max_size << endl; 
        };
</pre>
Теперь мы имеем копии всех внешних переменных внутри объекта r с возможностью их изменения. Это же касается и более сложных данных, например, массивов:
<pre>
    auto r = [=]() <b>mutable</b> {
        <font color=green>for(int& x : data) {
            x += 2;
            cout << x << " ";
        }</font>
        cout << endl; 
    };
</pre>
<font size=5>С помощью слова mutable мы можем менять переменную - копию переменной из main(), но не саму оригинальную переменную. Просто без этого слова mutable мы бы не смогли менять и копию внутри лямбда - функции.</font>
<h4>Захват определённых переменных</h4>
Если нам нужно передавать <b>не все переменные, а лишь некоторые</b>, то вместо символа ‘=’ в квадратных скобках просто прописываются захватываемые переменные, например, так:
<pre>
    auto r = [<b>sz</b>]() mutable {
        cout << sz << endl; 
    };
</pre>
В результате в лямбда-функции из всех локальных переменных из main() будет доступна копия переменной sz, а копия переменной data нет.<br>
Чтобы была также доступна data, следует ее записать:
<pre>
auto r = [<b>sz, data</b>]() mutable {
 ...}
</pre>
<h4>Захват переменных по ссылке и указателю (знак &)</h4>
Если же нам нужно внутри лямбда-выражения оперировать непосредственно внешними локальными переменными, то их следует передавать либо по ссылке, либо через указатели. Начнем с захвата внешних переменных по ссылкам. Для этого в квадратных скобках вместо символа ‘=’ прописывается символ ссылки ‘<b>&</b>’ следующим образом:
<pre>
    auto r = [<b>&</b>]() {
        cout << sz++ << endl; 
        for(int& x : data)
            cout << ++x << " ";
        cout << endl; 
    };
</pre>
Переменные sz и data представляют собой ссылки на соответствующие переменные. Мы можем совершенно спокойно менять их внутри лямбда-функции, меняя и внешние переменные.
<p>
Также вместо символа ‘&’ можно указывать отдельные захватываемые переменные. Например:
<pre>
    auto r = [<b>&sz, &data</b>]() { //<font color=blue>это вроде как ссылки, не адреса этих переменных</font>
        cout << sz++ << endl; 
        for(int& x : data)
            cout << ++x << " ";
        cout << endl; 
    };
</pre>
Здесь работа ведется только с двумя внешними переменными sz и data через соответствующие ссылки.
<p>
Наконец, похожего эффекта можно добиться, используя <b>указатели на переменные</b>. Например, так:
<pre>
int main()
{
    int data[] {1, 2, 3, 4, 5, 6, 7, 8};
    size_t sz = sizeof(data)/sizeof(*data);
    <b>size_t *ptr_sz = &sz;</b>
 
    auto r = [<b>ptr_sz</b>, <font color=red>&data</font>]() {
        (*ptr_sz)++;
        cout << *ptr_sz << endl; 
        for(int& x : data)
            cout << ++x << " ";
        cout << endl; 
    };
 
    r();
 
    cout << sz << endl;
    for(int x : data)
        cout << x << " ";
    cout << endl;
 
    return 0;
}
</pre>
<i><b>Перед указателем знак амперсанда ставить не надо</b><br>
<font color=red>И непонятно, data является массивом, то есть его имя также указатель, вроде как также не нужен амперсанд при захвате массива, надо проверить.</font><br>
при захвате массива int d[10]; [d] ([параметры]) mutable {[операторы]} изменение значений его элементов в лямбда-функции не приведет к изменению внешнего массива d - верно</i><br>
В результате мы захватываем указатель ptr_sz и внутри тела лямбда-функции формируется константный указатель с тем же именем ptr_sz. Через этот указатель мы совершенно спокойно можем читать и менять значение переменной sz, но <b>не можем менять адрес указателя ptr_sz, т.к. он константный</b>.
<p>
Этот пример также показывает, что в квадратных скобках мы можем комбинировать запись через присваивание и через ссылки. Мало того, можно даже использовать и такие виды записей:
<pre>
[&a, b, &m, n]   // a и m – по ссылке; b и n – по значению
[=, &m, &n]      // все по значению; m и n – по ссылке
[&, m, n]        // все по ссылке; m и n – по значению
</pre>
Вот так, относительно просто, можно объявлять, вызывать и использовать лямбда-выражения в языке С++.
<p>
<b>Примеры:</b>
<pre>
int count = 1;
int& lnk = count;
char* ptr = msg;

<font color=red>//auto lmd_7 = [lnk] (int step) { lnk += step; };</font> //неверно

<font color=red>//auto lmd_6 = [*ptr] (int step) { *ptr += step; };</font> //неверно
</pre>
<i><b>При захвате ссылки lnk в теле лямбда-выражения формируется переменная (не ссылка) lnk со значением 1</b></i>
<pre>


===========================================================================================================================


</pre>
<a name="struct"><h3 align=center>Структуры</h3>
Структуры в языке С++ преобразились и стали, фактически, классами. Но обо всем по порядку.<br>
Понятие структур нам уже известно по языку Си. В С++ они формально объявляются похожим образом. Например, так:
<pre>
struct point {
    int x, y;
};
</pre>
То есть, пишется ключевое слово struct, затем, имя типа структуры – point, в фигурных скобках прописываются поля (переменные) структуры и в конце ставится точка с запятой.
<p>
Первое важное отличие такой структуры в С++ от аналогичной в языке Си, заключается в том, что имя point здесь является полноценным типом, а не просто тегом структуры, как это было в Си. То есть, далее по программе мы можем объявить переменную типа point следующим образом:
<pre>
    point pt;
</pre>
Тогда как в Си нам необходимо было прописывать:<br>
struct point pt;
<p>
Кстати, в языке С++ допустимы обе формы записи типа структуры. Сделано это было для обратной совместимости с языком Си. Однако, если мы пишем программу исключительно для компилятора С++, то слово struct при объявлении переменных опускают.
<p>
Далее, мы можем инициализировать поля этой структуры следующим образом:
<pre>
struct point pt {};  // инициализация нулями
struct point pt {1}; // инициализация x=1, y=0
struct point pt {1, 2};  // инициализация x=1, y=2
</pre>
<h4>Функции-члены (методы)</h4>
Следующее ключевое отличие структур языка С++ - это возможность объявление функций непосредственно внутри структуры. Например, так:
<pre>
struct point {
    int x, y;
 
    double length() { return sqrt(x*x + y*y); }
};
</pre>
Функция length() вычисляет длину радиус-вектора и возвращает вычисленное значение. Такие функции получили название <b>функции-члены</b> или, чаще всего говорят, <b>методы</b>.
<p>
Особенностью методов является прямой доступ к переменным объекта, для которого этот метод был вызван. Например, следующий фрагмент программы вычисляет с помощью метода length() длины двух разных объектов point:
<pre>
int main()
{
    struct point pt {1, 2};
    struct point pt_2 {3, 4};
 
    cout << pt.length() << endl;
    cout << pt_2.length() << endl;
    return 0;
}
</pre>
<a name="this"><h3 align=center>Неявный указатель this</h3>
Ссылка: <a href="https://metanit.com/cpp/tutorial/5.6.php">Ключевое слово this</a>
<p>
При объявлении метода length() мы просто записали имена переменных x и y, объявленных внутри структуры. Но у каждого объекта pt и pt_2 свои локальные переменные x и y со своими значениями. Так откуда же метод length() «знает» какие переменные использовать и как получает к ним доступ? В действительности, каждому методу автоматически и неявно передается специальный <b>указатель с именем this</b>. Его так и называют – неявный указатель на объект. А раз так, то мы, по идее, можем обратиться из метода к локальным переменным текущего объекта, следующим образом:
<pre>
struct point {
    int x, y;
 
    double length() { return sqrt(<b>this->x*this->x + this->y*this->y</b>); }
};
</pre>
И, действительно, это будет эквивалентом предыдущей записи. На самом деле, когда явно не прописывается параметр this, то он <b>подразумевается при обращении к полям структуры</b>. Именно так метод length() получает доступ к нужным переменным для вычисления длины радиус-вектора. Как видите, все просто.
<p>
<font color=red>Конечно, неявный указатель this имеет тот же тип, что и текущая структура. В нашем примере – это тип point*. Он доступен практически в любом методе структуры, за исключением статических методов. Например, если мы попробуем записать такой метод и обратиться через указатель this к полю структуры, то получим ошибку:</font>
<pre>
struct point {
    int x, y;
 
    double length() { return sqrt(this->x*this->x + this->y*this->y); }
    static void show_coords() {cout << this->x; }  // ошибка, this не существует
};
</pre>
<font color=red>И это логично, так как статические методы не связаны с конкретным объектом, а просто являются функцией внутри области видимости структуры.</font>
<p>
Вообще через указатель this мы можем обращаться к любым полям структуры, даже если это другие методы. Например, так:
<pre>
struct point {
    int x, y;
 
    double length() { return sqrt(this->get_x()*this->get_x() + this->get_y()*this->get_y()); }
    int get_x() { return x; }
    int get_y() { return y; }
};
</pre>
Или, без ключевого слова this:
<pre>
struct point {
    int x, y;
 
    double length() { return sqrt(get_x()*get_x() + get_y()*get_y()); }
    int get_x() { return x; }
    int get_y() { return y; }
};
</pre>
Но тогда оно подразумевается.
<p>
Конечно, это несколько искусственный пример. В данном случае было бы правильнее обращаться напрямую к переменным x и y. Это лишь демонстрация возможности указателя this.
<h4>Для чего нужен this</h4>
Часто параметры функции (метода) и имена полей имеют одинаковые имена и чтобы различать их, то к полям обращаются с добавлением слова this, а к параметрам только через их имена.
<pre>

==========================================================================================================================

</pre>
<a name="mode_struct"><h3 align=center>Структуры. Режимы доступа. Сеттеры и геттеры</h3>
Ссылки: <a href="">Структуры. Режимы доступа. Сеттеры и геттеры</a>
<p>
В структурах и классах языка С++ дополнительно можно определять режимы доступа к тем или иным полям структуры (класса). На данный момент мы рассмотрим два таких режима:
<ul>
<li> public – публичный доступ к переменным и методам;
<p>
<li> private – частный (закрытый) доступ к переменным и методам.
</ul>
Например, если нам нужно закрыть прямой доступ извне для каких-либо полей структуры, то достаточно объявить их как private следующим образом:
<pre>
struct point {
<b>private:</b>
    int x, y;
<b>public:</b>
    double length() { return sqrt(x*x + y*y); }
};
</pre>
То есть, пишется ключевое слово private и ставится двоеточие. Все, что следует ниже, попадает в раздел private до тех пор, пока не встретится какой-либо другой режим доступа. Так как мы хотим, чтобы метод length() был общедоступным, то необходимо явно прописать режим public после private.
<p>
Теперь мы не можем выполнять инициализацию объекта pt, так как инициализируемые поля x и y скрыты от внешнего доступа. Также мы не можем изменять значения этих полей, обращаясь к ним напрямую через объект pt:<br>
pt.x = 153;  // ошибка
<p>
А вот вызывать метод length() по-прежнему можно:<br>
double res = pt.length(); // ok
<p>
Причем, внутри метода length() обращение к приватным переменным x и y разрешено. То есть, режим доступа private запрещает работать с переменными x и y напрямую извне структуры point, но не запрещает делать это <b>изнутри структуры</b>. А режим public позволяет прямое обращение как извне структуры, так и внутри нее. По умолчанию все поля структуры помечаются как public. Именно поэтому на прошлом занятии мы даже не подозревали о существовании каких-то режимов доступа.
<p>
Конечно, защита на уровне private отдельных полей структуры – это защита для программиста от своих собственных случайных ошибок. Если что-либо помечено как private, значит, напрямую к этим переменным или методам обращаться не следует. Хотя, конечно, обойти эту защиту достаточно просто. Поэтому мы здесь закрывает поля не от злоумышленников, а для корректного написания кода, уменьшая собственные возможные ошибки.
<p>
И еще одно важное замечание. <b>Защита private определяется на уровне типа данных – структуры целиком, а не на уровне отдельных объектов.</b> О чем здесь речь? Смотрите, если в нашей структуре point объявить еще один метод, например, sum() для сложения одного вектора с другим:
<pre>
struct point {
private:
    int x, y;
public:
    double length() { return sqrt(x*x + y*y); }
    <b>void sum(const point& pt)</b>
    {
        this->x += pt.x;
        this->y += pt.y;
    }
};
</pre>
<b>То внутри метода sum мы можем совершенно спокойно обращаться к переменным x и y через переданный объект pt. И все благодаря тому, что функция-член sum() принадлежит типу данных point. Она находится, как бы, внутри него. А раз, так, то автоматически получает доступ ко всем приватным полям этой структуры, даже если они берутся из другого объекта. Поэтому и говорят, что защита действует на уровне типа данных, а не на уровне объектов.</b>
<p>
Конечно, полученная структура point, на данный момент не пригодна для практического использования. Мы не можем задавать нужные нам координаты и читать их. Самый очевидный шаг, как это можно было бы поправить – это определить соответствующие публичные методы. Например, следующим образом:
<pre>
struct point {
<b>private:</b>
    int x, y;
<b>public:</b>
    double length() { return sqrt(x*x + y*y); }
    void sum(const point& pt)
    {
        this->x += pt.x;
        this->y += pt.y;
    }
 
    <b>void set_coords(int x, int y)</b>
    { 
        if(x < -100 || x > 100 || y < -100 || y > 100)
            return;
 
        <b>this->x</b> = x; //слово this обязательно, мы тем самым говорим что обращаемся к полю, а не одноименному параметру функции x
        this->y = y; 
    }
 
    void get_coords(int& x, int& y) {x = this->x; y = this->y; }
    int get_x() { return this->x; }
    int get_y() { return this->y; }
};
</pre>
Обратите внимание, что в методах set_coords() и get_coords() для обращения к переменным x и y текущего объекта необходимо использовать неявный указатель this. Если бы мы прописали просто x, то это соответствовало бы локальному параметру x функции, а не переменной объекта. Поэтому в таких случаях, когда локальные переменные внутри метода совпадают по именам с полями структуры, для обращения к полям необходимо использовать указатель this на текущий объект.
<p>
Теперь мы можем передавать координаты и читать их, используя публичные методы:
<pre>
int main()
{
    struct point pt;
    
    pt.set_coords(1, 2);
    cout << pt.get_x() << " " << pt.get_y() << endl;
 
    double res = pt.length();
    cout << res << endl;
    
    return 0;
}
</pre>
В ООП методы, которые служат для установки значений переменных объекта, получили название <b>сеттеры</b> (от префикса set, который часто записывается вначале таких методов), а методы, с помощью которых читаются значения переменных объекта – <b>геттерами</b> (от префикса get).
<p>
Однако и в такой реализации структура point все еще остается недоработанной. Это связано с тем, что когда мы создаем объект pt, то его начальное состояние оказывается неопределенным из-за неизвестных значений координат x и y.
<pre>





</pre>
<a name="konstruktor"><h3 align=center>Структуры. Конструкторы и деструкторы</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-struktury-konstruktory-i-destruktory">Структуры. Конструкторы и деструкторы</a><br>
<a href="https://metanit.com/cpp/tutorial/5.2.php">Конструкторы и инициализация объектов</a>
<p>
В языке С++ предусмотрены специальные функции структур и классов, которые называются конструкторами:
<ul>
<li> имя конструктора всегда должно совпадать с именем типа данных, классов;
<li> конструктор никогда не возвращает никаких значений, поэтому возвращаемый тип не прописывается вовсе;
<li> конструктор может иметь произвольное число параметров;
<li> конструктор всегда вызывается при создании каждого нового объекта.
<li> конструкторы позволяют инициалилизировать объект класса во время его создания и таким образом гарантировать, что поля класса будут иметь определенные значения.
</ul>
<p>
Объявим конструктор в структуре point следующим образом:
<pre>
struct point {
private:
    int x, y;
public:
    <b>point()</b>  // конструктор объекта
        <b>{ x = 0; y = 0; }</b>
    ...
};
</pre>
Теперь, при создании нового объекта, его локальные переменные x и y будут принимать предсказуемое нулевое значение:
<pre>
int main()
{
    struct point pt;
    cout << pt.get_x() << " " << pt.get_y() << endl;
    return 0;
}
</pre>
<h4>Инициализация объекта с помощью конструктора</h4>
Таким образом, мы с вами устранили неопределенность в состоянии объекта pt. Однако выполнять его инициализацию в момент создания произвольными значениями по-прежнему нельзя:
<pre>
<font color=red>struct point pt(1, 2);</font> // ошибка
</pre>
Очевидно, для добавления такой возможности нам нужен еще один конструктор с двумя параметрами. Объявим его следующим образом:
<pre>
struct point {
private:
    int x, y;
public:
    point() { x = 0; y = 0; }                //первый конструктор
    <b>point(int x, int y) { this->x = x; this->y = y; }</b> //второй конструктор
    ...
};
</pre>
Это называется <b>перегрузкой конструкторов</b>. Компилятор выбирает тот или иной в зависимости от набора и типов аргументов, указанных при создании объектов. Теперь мы совершенно спокойно можем выполнять команды вида:
<pre>
struct point pt(1, 2); // ok
</pre>
Или даже делать так:
<pre>
double res = point(10, 20).length();
</pre>
Здесь создается временный объект типа point с координатами (10; 20) и вычисляется длина радиус-вектора. После вычислений временный объект автоматически уничтожается (освобождается память, которую он занимал).
<h4 align=center>Создание объекта конструктором на примере пользовательского класса Person</h4>
В пользовательском классе Person определен конструктор:
<pre>
Person(std::string p_name, unsigned p_age)
{
    name = p_name;
    age = p_age;
    std::cout << "Person has been created" << std::endl;
}
</pre>
По сути конструктор представляет функцию, которая может принимать параметры и которая должна называться по имени класса. В данном случае конструктор принимает два параметра и передает их значения полям name и age, а затем выводит сообщение о создании объекта.
<p>
Если мы определяем свой конструктор, то компилятор больше не создает конструктор по умолчанию. И при создании объекта нам надо обязательно вызвать определенный нами конструктор.
<p>
Вызов конструктора получает значения для параметров и возвращает объект класса:
<pre>
Person tom("Tom", 38); //вызов конструктора для инициализации объекта tom
</pre>
После этого вызова для поля name будет определено значение "Tom", а для поля age - значение 38. Вполедствии мы также сможем обращаться к этим полям и переустанавливать их значения.
<p>
Второй способ создания объекта можно использовать инициализатор в фигурных скобках:
<pre>
Person tom{"Tom", 38};
</pre>
Тажке можно присвоить объекту результат вызова конструктора:
<pre>
Person tom = Person("Tom", 38);
</pre>
По сути она будет эквивалетна предыдущей.
<h4>Параметры по умолчанию</h4>
Как и другие функции, конструкторы могут иметь параметры по умолчанию:
<pre>
#include &lt;iostream>
 
class Person 
{
    std::string name;
    unsigned age;
public:
    // передаем значения по умолчанию
    Person(std::string <b>p_name = "Undefined", unsigned p_age = 18</b>)
    { 
        name = p_name; 
        age = p_age;
    }
    void print() 
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
};
int main()
{
    Person tom{"Tom", 38};
    Person bob{"Bob"};
    Person sam;
    tom.print();    // Name: Tom   Age: 38
    bob.print();    // Name: Bob   Age: 18
    sam.print();    // Name: Undefined   Age: 18
}
</pre><pre>

</pre>
<a name="sev_konstr"><h3 align=center>Определение нескольких конструкторов</h3>
Подобным образом мы можем определить несколько конструкторов и затем их использовать:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
 
class Person 
{
    std::string name{};
    unsigned age{};
public:
    void print() 
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
    Person(std::string p_name, unsigned p_age)
    {
        name = p_name;
        age = p_age;
    }
    Person(std::string p_name)
    {
        name = p_name;
        age = 18;
    }
    Person()
    {
        name = "Undefined";
        age = 18;
    }
};
int main()
{
    Person tom{"Tom", 38};  // вызываем конструктор Person(std::string p_name, unsigned p_age)
    Person bob{"Bob"};      // вызываем конструктор Person(std::string p_name)
    Person sam;             // вызываем конструктор Person()
    tom.print();
    bob.print();
    sam.print();
}
</pre>
</td></tr></table>
<p>
В классе Person определено три конструктора, и в функции все эти конструкторы используются для создания объектов:
<pre>
Name: Tom       Age: 38
Name: Bob       Age: 18
Name: Undefined Age: 18
</pre>
Хотя пример выше прекрасно работает, однако мы можем заметить, что все три конструктора выполняют фактически одни и те же действия - устанавливают значения переменных name и age. И в C++ можем сократить их определения, вызова из одного конструктора другой и тем самым уменьшить объем кода:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
 
class Person 
{
    std::string name{};
    unsigned age{};
public:
    void print() 
    {
        std::cout << "Name: " << name << "\tAge: " << age << std::endl;
    }
    Person(std::string p_name, unsigned p_age)
    {
        name = p_name;
        age = p_age;
        std::cout << "First constructor" << std::endl;
    }
    Person(std::string p_name)<b>: Person(p_name, 18)</b> // вызов первого конструктора
    {
        std::cout << "Second constructor" << std::endl;
    }
    Person()<b>: Person(std::string("Undefined"))</b> // вызов второго конструктора
    { 
        std::cout << "Third constructor" << std::endl;
    }
};
int main()
{
    Person sam;     // вызываем конструктор Person()
    sam.print();
}
</pre>
</td></tr></table>
<p>
Запись Person(string p_name): Person(p_name, 18) представляет вызов конструктора, которому передается значение параметра p_name и число 18. То есть второй конструктор делегирует действия по инициализации переменных первому конструктору. При этом второй конструктор может дополнительно определять какие-то свои действия.
<p>
Таким образом, следующее создание объекта<br>
Person sam;<br>
будет использовать третий конструктор, который в свою очередь вызывает второй конструктор, а тот обращается к первому конструктору.
<p>
Данная техника еще называется <b>делегированием конструктора</b>, поскольку мы делегируем инициализацию другому конструктору.
<pre>


</pre>
<a name="destrukt"><h3 align=center>Деструкторы</h3>
Ссылки: <a href="https://metanit.com/cpp/tutorial/5.13.php">Деструктор</a>
<p>
<b>Деструктор</b> выполняет освобождение использованных объектом ресурсов и удаление нестатических переменных объекта. Деструктор автоматически вызывается, когда удаляется объект. Удаление объекта происходит в следующих случаях:
<ul>
<li> когда завершается выполнение области видимости, внутри которой определены объекты
<p>
когда удаляется контейнер (например, массив), который содержит объекты

<li> когда удаляется объект, в котором определены переменные, представляющие другие объекты
<p>
<li> динамически созданные объекты удаляются при применении к указателю на объект оператора <b>delete</b>
</ul>
По сути деструктор - это функция, которая называется по имени класса (как и конструктор) и перед которой стоит тильда (~)
<p>
Деструктор обладает следующим свойствами:
<ul>
<li> имя метода называется также, как и тип данных с тильдой (‘~’) вначале;
<li> деструктор ничего не возвращает;
<li> деструктор не имеет параметров.
</ul>
Например, мы можем объявить следующий деструктор в структуре point:
<pre>
struct point {
private:
    int x, y;
public:
    point() { x = 0; y = 0; }
    point(int x, int y) { this->x = x; this->y = y; }
 
    ~point()  // деструктор
        { cout << "вызов деструктора объекта" << endl; }
    ...
};
</pre>
При выполнении программы мы увидим вызовы деструкторов для временного объекта и для объекта pt.
<p>
Обычно деструктор не так часто требуется и в основном используется для освобождения связанных ресурсов. Например, объект класса использует некоторый файл, и в деструкторе можно определить код закрытия файла. Или если в классе выделяется память с помощью оператора new или malloc, то в деструкторе можно освободить подобную память.
<pre>
struct point {
private:
    int x, y;
    short* coords;
public:
    <b>point() { x = 0; y = 0; coords = (short *)malloc(2 * sizeof(short)); }
    point(int x, int y) { this->x = x; this->y = y; coords = (short *)malloc(2 * sizeof(short)); }</b>
 
    <b>~point()</b>  // деструктор
    { 
        cout << "вызов деструктора объекта" << endl; 
        free(coords);
    }
    ...
};
</pre>
Иначе, при каждом новом объекте point память под массив будет постоянно выделяться, но не освобождаться при уничтожении объекта структуры. Это привело бы к утечке памяти. Как раз эту проблему решает деструктор, освобождая все захваченные текущим объектом ресурсы. Причем, деструктор гарантированно вызывается всегда при уничтожении объекта. Компиляторы это очень хорошо отслеживают и в нужный момент добавляют вызов деструктора. В результате, при создании объекта один раз срабатывает конструктор, а при уничтожении этого объекта – один раз срабатывает деструктор. В этом мы можем быть уверены.
<pre>

===========================================================================================================================

</pre>
<a name="static"><h3 align=center>Ключевое слово static</h3>
Ссылки: <a href="https://metanit.com/cpp/tutorial/5.7.php">Статические члены класса</a><br>
<a href="https://www.guru99.com/ru/static-function-in-cpp.html">Статическая функция-член в C++ (Примеры)</a>
<p>
Кроме переменных и методов, которые относятся непосредственно к объекту, C++ позволяет определять переменные и методы, которые относятся непосредственно к классу или иначе говоря статические члены класса. Статические переменные и методы относят в целом ко всему классу. Для их определения используется ключевое слово <b>static</b>.
<h4>Статические поля</h4>
Статические переменные обычно применяются для хранения значений, специфичных для класса, для всех объектов класса в целом. То есть статические поля хранят состояние всего класса. Статическая переменная определяется только один раз и будет существовать, даже если объекты класса не были созданы.
<p>
Показательным примером статических переменных являются различные счетчики. Например, нам надо хранить количество созданных объектов. Такое количество относится классу, однако не зависит от конкретного объекта. Посмотрим на примере:
<pre>
#include &lt;iostream>
 
class Person
{
public:
    Person(std::string p_name, unsigned p_age)
    {
        ++count;    // при создании нового объекта увеличиваем счетчик
        name = p_name;
        age = p_age;
    }
    void print_count()
    {
        std::cout << "Created " << count << " objects" << std::endl;
    }
private:
    std::string name;
    unsigned age;
    <b>static inline unsigned count{};</b>  // статическое поле - счетчик объектов Person
};
 
int main()
{
    Person tom{"Tom", 38};
    Person bob{"Bob", 42};
    Person sam{"Sam", 25};
    tom.print_count();
    bob.print_count();
    sam.print_count();
}
</pre>
Здесь в классе Person определена статическая переменная count с помощью ключевого слова static:
<pre>
static inline unsigned count{}; // инициализируем нулем
</pre>
Обратите внимание, после static идет ключевое слово inline. Это ключевое слово в принципе необязательно для статических переменных и необходимо конкретно в данном случае для инициализации переменной count. В данном случае нулем.
<p>
При создании каждого нового объекта в конструкторе увеличиваем счетчик на единицу:
<pre>
Person(std::string p_name, unsigned p_age)
{
    ++count;    // при создании нового объекта увеличиваем счетчик
</pre>
В функциях класса Person мы можем обращаться к этой статической переменной. Например, в функции print_count выводим ее значение на консоль.
<p>
Для теста в функции main создаем три объекта Person и затем у каждого вызываем функцию print_count.<br>
Поскольку переменная count статическая и относится ко всему классу в целом и не зависит от конкретного объекта, во всех трех случаях будет выведено число 3.
<h4>Статические функции</h4>
Статические функции также принадлежат классу в целом и не зависят от любого отдельного объекта класса. Обычно статические функции-члены используются для работы со статическими переменными. Например, в примере выше функция print_count() выводит значение статической переменной count и никак не зависит от конкретного объекта, не использует и не изменяет переменные и функции объектов. Поэтому такую функцию можно и даже лучше сделать статической:
<pre>
#include &lt;iostream>
 
class Person
{
public:
    Person(std::string p_name, unsigned p_age)
    {
        ++count;    // при создании нового объекта увеличиваем счетчик
        name = p_name;
        age = p_age;
    }
    // статическая функция
    <b>static void print_count()</b>
    {
        std::cout << "Created " << count << " objects" << std::endl;
    }
private:
    std::string name;
    unsigned age;
    static inline unsigned count{};  // статическое поле - счетчик объектов Person
};
 
int main()
{
    Person tom{"Tom", 38};
    Person bob{"Bob", 42};
    Person sam{"Sam", 25};
    tom.print_count();  // Created 3 objects
}
</pre>
Для определения статической функции перед ней также указывается ключевое слово static:<br>
<b>static</b> void print_count()<br> 
К подобным функциям также можно обращаться через имя объекта:
<pre>
tom.print_count();
</pre>
<h4>Обращение к статическим членам класса</h4>
Как выше было продемонстрировано, для обращения к статическим членам можно использовать имя любого объекта. Однако C++ также поддерживает и другой синтаксис:
<pre>
класс::член_класса
</pre>
После имени класса идет оператор :: и имя статического компонента класса. Например:
<pre>
#include &lt;iostream>
 
class Person
{
public:
    <b>static</b> inline unsigned maxAge{120};     // статическая публичная переменная
    Person(std::string p_name, unsigned p_age)
    {
        ++count;
        name = p_name;
        if(p_age < maxAge)  // если значение не больше максимального
            age = p_age;
    }
    // статическая функция
    <b>static</b> void print_count()
    {
        std::cout << "Created " << count << " objects" << std::endl;
    }
private:
    std::string name;
    unsigned age{1};
    <b>static</b> inline unsigned count{};  // статическая приватная переменная
};
 
int main()
{
    Person tom{"Tom", 38};
    Person bob{"Bob", 42};
    Person sam{"Sam", 25};
     
    // обращаемся к статической функции print_count
    <b>Person::print_count();</b>
    // обращаемся к статической переменной maxAge
    std::cout << "Max age: " << <b>Person::maxAge</b> << std::endl;
    // изменяем статическую переменную maxAge
    <b>Person::maxAge = 110;</b>
    std::cout << "Max age: " << <b>Person::maxAge</b> << std::endl;
}
</pre>
Здесь добавлена публичная статическая переменная maxAge, которая представляет максимальный возраст. Поскольку этот показатель не зависит от определенного объекта и относится в целом к классу объектов Person (справедливо для всех людей), то определяем такую переменную как статическую. В конструкторе используем эту переменную для верификации переданного в конструктор возраста. Если он больше максимального, то возраст получает значение по умолчанию - 1.
<h4>Статические константы</h4>
Также можно определять статические константы. Так, в примере выше маловероятно, что значение maxAge будет меняться. Поэтому мы можем определить ее как константу. Ее значения нельзя будет изменить, а во остальном работа с ней идет также как и со статическими переменными:
<pre>
static inline const unsigned maxAge{120};     // статическая константа
</pre>
<pre>

=================================================================================================================


</pre>
<a name="new"><h3 align=center>Операторы new / delete и new [] / delete []</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-operatory-new-delete">Операторы new / delete и new [] / delete []</a><br>
<a href="https://proproprogs.ru/c_base/cpp-osobennosti-raboty-new-i-delete">Особенности работы new и delete</a>
<p>
В языке С++ в дополнение к глобальным и локальным переменным можно создавать <b>динамические объекты</b>. В отличии от глобальных и локальных объектов продолжительность жизни динамических объектов не зависит от того, где они созданы. <b>Динамические объекты существуют, пока не будут удалены явным образом</b>. Динамические объекты размещаются в <b>динамической памяти</b> (free store). Это область памяти, не занятая операционной системой или другими загруженными в данный момент программами.
<p>
Использование динамических объектов имеет ряд преимуществ. Во-первых, более эффективное использование памяти - выделяется имеенно столько места, сколько необходимо, а <font color=red>после использования сразу освобождается</font> (непонятно разве они не существуют пока их не удалят вручную?).<br>
Во-вторых, мы можем использовать гораздо больший объем памяти, который в ином случае был бы не доступен. Но это и накладывает ограничения: мы должны следить, чтобы все динамические объекты были удалены.
<p>
Для управления динамическими объектами применяются операторы new и delete.
<p>
<b>Оператор new</b> выделяет место в динамической памяти для объекта и возвращает указатель на этот объект.
<p>
<b>Оператор delete</b> получает указатель на динамический объект и удаляет его из памяти.
<p>
Функции malloc() и free() также выделяют нужное число байт для хранения объекта структуры и, затем, освобождают эту память. Более никаких дополнительных действий не выполняется. В языке Си этого достаточно для размещения объекта структуры в памяти. Но не в С++. Здесь дополнительно в отличии от malloc() и free() в языке С следует <b>вызвать конструктор непосредственно после создания объекта и деструктор – непосредственно перед удалением объекта</b>. В этом отличие new/delete от malloc/free.
<p>
Пример:
<pre>
int main()
{
    struct point* pt;
 
    pt = <b>new point</b>;
    // что то делаем
    <b>delete pt;</b>
 
    return 0;
}
</pre>
Обратите внимание, что нам не требуется прописывать приведение типов у оператора new, так как он <font color=red>возвращает указатель на тип данных</font>, для которого выполняется выделение памяти.
<p>
Вообще, в С++ рекомендуется (по возможности) использовать эти новые операторы new и delete вместо прежних malloc() и free(). Мало того, крайне не рекомендуется их смешивать. Например, выделить память с помощью new, а освободить с помощью free(). Это плохая практика, которая может привести к непредсказуемым результатам работы программы.
<p>
Но вернемся к нашему примеру. При выполнении команды:
<p>
pt = new point;<br>
вызывается конструктор без параметров (конструктор по умолчанию). И если вывести координаты x и y в консоль:
<p>
cout << pt->get_x() << " " << pt->get_y() << endl;<br>
то увидим нули. А что если в момент создания нового объекта мы хотим сразу передать ему некоторые координаты? Для этого после типа point ставятся круглые скобки и прописываются параметры, например, так:
<pre>
pt = new point(10, 20);
</pre>
Интересно, что операторы new и delete в С++ можно использовать и с базовыми типами. Например, так:
<pre>
int *ptr_int = new int;
delete ptr_int;
</pre>
Будет создан, а затем, удален целочисленный объект int в памяти устройства с неопределенным значением. Но у этого объекта есть конструктор, через который можно инициализировать переменную int следующим образом:
<p>
int *ptr_int = new int(-123);<br>
Тогда начальное значение будет равно -123. И так можно делать с любыми другими базовыми типами языка С++.
<p>
Примеры создания объектов через new, объявим простую структуру volume:
<pre>
#include &lt;iostream>
 
using std::cout;
using std::endl;
 
struct volume {
    int width, height, depth;
};
</pre>
А, затем, в функции main создадим объекты этой структуры следующим образом:
<pre>
int main(void)
{
    <b>volume* v_1 = new volume;</b> //стандартный способ, указатель на объект (область памяти), который создали через new volume
    <b>volume* v_2 {new volume};</b> //через инициализатор
    <b>volume* v_3 = new volume();</b> //через конструктор по умолчанию и значения в нем по умолчанию равны 0
    <b>volume* v_4 {new volume{1, 2, 3}};</b> //сначала инициализируем структуру с значениями
 
    cout << v_1->width << " " << v_1->height << " " << v_1->depth << endl;
    cout << v_3->width << " " << v_3->height << " " << v_3->depth << endl;
    cout << v_4->width << " " << v_4->height << " " << v_4->depth << endl;
 
    delete v_1;
    delete v_2;
    delete v_3;
    delete v_4;
 
    return 0;
}
</pre>
После запуска этой программы в консоли увидим строчки:
<pre>
17635152 17629376 1601069417
0 0 0
1 2 3
</pre>
Смотрите, как это сработало. Во-первых, объект структуры volume был успешно создан в памяти с помощью оператора new. Но мы знаем, что new предполагает автоматический вызов конструктора, которого в структуре volume прописано не было. Откуда же он взялся? В действительности, при объявлении любой структуры в С++ компилятор автоматически добавляет несколько конструкторов, в том числе и тот, который необходим для создания нового объекта. Параметров у такого конструктора по умолчанию нет. И то же самое с деструктором. Если он явно не описан, то добавляется деструктор по умолчанию.
<p>
Но, обратите внимание, если мы явно пропишем хоть один конструктор внутри структуры, то компилятор не станет добавлять ни одного по умолчанию. Подробнее об этом, конечно, следует говорить в курсе по ООП языка С++.
<p>
Вернемся к нашей программе создания объектов структуры volume. Мы видим, если после оператора new прописать тип данных volume без круглых скобок, то никакой инициализации полей не происходит. Переменные width, height, depth принимают произвольные (неопределенные) значения. Если же круглые скобки указаны, то все поля структуры инициализируются нулями. Наконец, допустимо создавать объект (v_4) и прописывать инициализатор для полей этой структуры:<br>
volume* v_4 {new volume {1, 2, 3}};
<p>
Однако если мы в структуре volume пропишем хотя бы один свой конструктор, например:
<pre>
struct volume {
    volume() { cout << "constructor" << endl; }
 
    int width, height, depth;
};
</pre>
то компилятор не станет автоматически добавлять какие-либо другие. В частности, это приведет к тому, что команда:<br>
volume* v_4 {new volume {1, 2, 3}};<br>
не скомпилируется, т.к. теперь в структуре volume нет подходящего конструктора для такой операции.
<p>
Сейчас мы не станет углубляться в тему конструкторов, их видов, способов определения и так далее. Главное, что сейчас важно запомнить – это то, что любой тип данных языка С++ подразумевает использование этих специальных методов: конструкторов и деструктора. В частности, это означает, что с любым примитивным типом данных мы можем выполнять все те же самые действия, что и со структурами. Например:
<pre>
int main(void)
{
    <b>int* p1 = new int;
    double* p2 {new double()};
    short* p3 {new short{-5}};
    unsigned* p4 {new unsigned(11)};</b>
 
    cout << *p1 << " " << *p2 << " " << *p3 << " " << *p4 << endl;
 
    delete p1;
    delete p2;
    delete p3;
    delete p4;
 
    return 0;
}
</pre>
<h4 align=center>Создание динамические массивов через new[]</h4>
Ссылки: <a href="https://metanit.com/cpp/tutorial/4.12.php">Динамические массивы</a>
<p>
Кроме отдельных динамических объектов в языке C++ мы можем использовать динамические массивы. Для выделения памяти под динамический массив также используется оператор new, после которого в квадратных скобках указывается, сколько массив будет содержать объектов:
<pre>
int *numbers {new int[4]}; // динамический массив из 4 чисел
// или так
// int *numbers = new int[4];
</pre>
Причем в этом случае оператор new также возвращает указатель на объект типа int - первый элемент в созданном массиве.
<p>
В данном случае определяется массив из четырех элементов типа int, но каждый из них имеет неопределенное значение. Однако мы также можем инициализировать массив значениями:
<pre>
int *numbers1 {new int[4]{}};               // массив состоит из чисел 0, 0, 0, 0

int *numbers2 {new int[4]{ 1, 2, 3, 4 }}; // массив состоит из чисел 1, 2, 3, 4

int *numbers3 {new int[4]{ 1, 2 }};       // массив состоит из чисел 1, 2, 0, 0

// аналогичные определения массивов
// int *numbers1 = new int[4]{};             // массив состоит из чисел 0, 0, 0, 0

// int *numbers1 = new int[4]();             // массив состоит из чисел 0, 0, 0, 0

// int *numbers2 = new int[4]{ 1, 2, 3, 4 }; // массив состоит из чисел 1, 2, 3, 4

// int *numbers3 = new int[4]{ 1, 2 };       // массив состоит из чисел 1, 2, 0, 0

//short* ar_3 {new short[11] { 1, 2 }};  // 1, 2, 0, 0, ... всего 11 элементов
</pre>
При инициализации массива конкретными значениями следует учитывать, что если значений в фигурных скобках больше чем длина массива, то оператор new потерпит неудачу и не сможет создать массив. Если переданных значений, наоборот, меньше, то элементы, для которых не предоставлены значения, инициализируются значением по умолчанию.
<p>
Стоит отметить, что в стандарт С++20 добавлена возможность выведения размера массива, поэтому, если применяется стандарт С++20, то можно не указывать длину массива:
<pre>
int *numbers {new int[]{ 1, 2, 3, 4 }}; // массив состоит из чисел 1, 2, 3, 4
</pre>
После создания динамического массива мы сможем с ним работать по полученному указателю, получать и изменять его элементы:
<pre>
int *numbers {new int[4]{ 1, 2, 3, 4 }}; 
 
// получение элементов через синтаксис массивов
std::cout << numbers[0] << std::endl;       // 1
std::cout << numbers[1] << std::endl;       // 2
 
// получение элементов через операцию разыменования
std::cout << *numbers << std::endl;         // 1
std::cout << *(numbers+1) << std::endl;     // 2
</pre>
Причем для доступа к элементам динамического массива можно использовать как синтаксис массивов (numbers[0]), так и операцию разыменования (*numbers)
<p>
Соответственно для перебора такого массива можно использовать различные способы:
<pre>
unsigned n{ 5 };  // размер массива
int* p{ new int[n] { 1, 2, 3, 4, 5 } };
 
// используем индексы
for (unsigned i{}; i < n; i++)
{
    std::cout << p[i] << "\t";
}
std::cout << std::endl;
 
// добавляем к адресу в указателе смещение
for (unsigned i{}; i < n; i++)
{
    std::cout << *(p+i)<< "\t";
}
std::cout << std::endl;
 
// проходим по массиву с помощью вспомогательного указателя
for (int* q{ p }; q != p + n; q++)
{
    std::cout << *q << "\t";
}
std::cout << std::endl;
</pre>
Обратите внимание, что для задания размера динамического массива мы можем применять обычную переменную, а не константу, как в случае со стандартными массивами.
<p>
Для удаления динамического массива и освобождения его памяти применяется специальная форма оператора delete:
<pre>
delete [] указатель_на_динамический_массив;
</pre>
Например:
<pre>
#include &lt;iostream>
 
int main()
{
    unsigned n{ 5 };  // размер массива
    int* p{ new int[n] { 1, 2, 3, 4, 5 } };
 
    // используем индексы
    for (unsigned i{}; i < n; i++)
    {
        std::cout << p[i] << "\t";
    }
    std::cout << std::endl;
 
    delete [] p;
}
</pre>
Чтобы после освобождения памяти указатель не хранил старый адрес, также рекомендуется обнулить его:
<pre>
delete [] p;
p = nullptr;    // обнуляем указатель
</pre>
<pre>

</pre>
<h4 align=center>Особенности работы оператора delete</h4>
Как мы с вами уже знаем, он освобождает ранее выделенную память, и автоматически прописывает вызов деструктора объекта. Это так же может быть деструктор по умолчанию или деструктор, прописанный явным образом. Единственно на что следует обращать пристальное внимание – это однократное освобождение занятой памяти. Например, если мы дважды освободим память для одной и той же области памяти:
<pre>
delete p1;
delete p1;
</pre>
то программа может завершиться аварийно из-за нарушения целостности динамической памяти.
<p>
Чтобы этого избежать, хорошей практикой считается присвоение значения нулевого указателя nullptr, когда какой-либо указатель не ссылается на выделенную область. Например:
<pre>
delete p1;
<b>p1 = nullptr;</b>
delete p1;
</pre>
В этом случае повторный вызов оператора delete не приведет к каким-либо последствиям, т.к. для нулевого указателя он не выполняет никаких действий.
<pre>

============================================================================================================================

</pre>
<a name="smart_ptr"><h3 align=center>Smart-указатели</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-smart-ukazateli-tipa-unique-ptr">Smart-указатели типа unique_ptr</a><br>
<a href="https://metanit.com/cpp/tutorial/11.1.php">Smart-указатели. unique_ptr&lt;T></a>
<p>
Для сведения к минимуму ошибок с выделением / освобождением памяти в языках высокого уровня, таких как Java, Python, C#, предусмотрен механизм <b>«сборки мусора»</b>, который отслеживает неиспользуемую память и автоматически ее освобождает. Но в языке C++ нет такого сборщика мусора, т.к. это низкоуровневый язык программирования и сами сборщики пишутся зачастую на нем. Однако некоторые решения все же есть. Это использование, так называемых, <b>умных (smart) указателей</b>. Они на примитивном уровне подобны сборщику мусора и сами контролируют процесс освобождения памяти. <b>То есть, вручную освобождать память уже не требуется, она освободится сама (автоматически), когда станет ненужной и операторы delete или delete [] не нужны.</b>.
<p>
Познакомимся с двумя видами smart-указателей:
<ul>
<li> <b>unique_ptr</b> – «уникальный» (в единственном числе) smart-указатель, ссылающийся на выделенную область памяти (или принимающий значение nullptr);
<p>
<li> <b>shared_ptr</b> – smart-указатель, допускающий множественные адресации на одну и ту же выделенную область памяти.
</ul>
<h4>Указатель unique_ptr</h4>
Для использования в программе на языке C++ «умных» указателей необходимо вначале подключить заголовок:
<pre>
<font color=green size=4><b>#include &lt;memory></b></font>
</pre>
После этого в пространстве имен std появится класс unique_ptr. Теперь мы можем объявлять smart-указатели этого типа следующим образом:
<pre>
std::unique_ptr&lt;int> ptr;
std::unique_ptr&lt;int> ptr_2 {};
</pre>
В угловых скобках мы пишем тип данных, с которым будет работать указатель. В данном случае – это примитивный тип int. Вообще, забегая вперед, отмечу, что угловые скобки, стоящие после имени класса, – это пример использования шаблонного класса. То есть, класс unique_ptr определен так, чтобы его можно было использовать с произвольными типами данных. И благодаря этому достигается универсальность объявления smart-указателей типа unique_ptr. На данный момент достаточно просто запомнить, что после имени класса нужно прописать угловые скобки с типом данных, с которым в дальнейшем будет работать smart-указатель.
<p>
<b>Во всех трех приведенных вариантах объявления указателей, их значения равны nullptr, то есть, не ссылаются ни на какую выделенную область памяти</b>.<br>
Поэтому, если сейчас попытаться вывести значение данных, на которые ссылается указатель ptr:<br>
std::cout << *ptr << std::endl;<br>
то программа завершится аварийно. Нельзя в языке С++ читать данные через указатель со значением nullptr. Правильнее вначале было бы проверить, что значение указателя не равно nullptr, то есть, он ссылается на выделенную область памяти. Это можно сделать следующим образом:
<pre>
if(ptr)
    std::cout << *ptr << std::endl;
</pre>
Обратите внимание, как записана проверка: <b>nullptr – это эквивалент false</b>, а не nullptr – это эквивалент true. Также обратите внимание, что чтение данных из памяти, на которую ссылается smart-указатель, синтаксически осуществляется так же, как и для обычного указателя.
<h4>Функция make_unique</h4>
Ссылки: <a href="https://www.geeksforgeeks.org/cpp-14-make_unique/">std::make_unique в C++ 14</a>
<p>
std::make_unique — это вспомогательная функция в C++, которая была введена в C++14, пространство имен для неё std. Она  выделяет память <b>для создаваемого объекта unique_ptr</b> и возвращает интеллектуальный указатель на эту память.
<p>
Синтаксис:
<pre>
std::make_unique <тип_объекта> ( аргументы );
</pre>
Параметры:<br>
object_type: Это тип объекта, который вы хотите создать.<br>
аргументы: Это список аргументов для конструктора object_type.
<p>
Тип возврата<br>
Эта функция возвращает unique_ptr типа object_type.
<p>
Это предпочтительный способ создания std::unique_ptr, так как он безопаснее, чем использование оператора new напрямую, поскольку объект автоматически уничтожается, когда выходит из области видимости.
<p>
Пример: пропишем обратную проверку и если указатель ptr равен nullptr, то <b>выделим для него область памяти</b>.<br> Начиная со стандарта C++14, делается это следующим образом:
<pre>
    if(!ptr)
        ptr = std::<b>make_unique</b>&lt;int>(10);
 
    std::cout << *ptr << std::endl;
</pre>
То есть, вызывается специальная шаблонная функция <b>make_unique</b>, которая выделяет область памяти. В угловых скобках указали тип данных, под который выделяется память, а в качестве аргумента передается начальное значение 10. Теперь программа отработает без каких-либо проблем и в консоль будет выведено число 10.<br>
Эта выделенная область памяти не имеет имени (переменной), о ней мы знаем только благодаря ссылающему указателю ptr.
<p>
Что будет, если мы попробуем еще раз для этого же указателя выделить память с помощью функции make_unique:
<pre>
ptr = std::make_unique&lt;int>(10);
ptr = std::make_unique&lt;int>(11);
</pre>
Возникнет ли здесь «утечка памяти»? В действительности, нет, не возникнет. В классе unique_ptr операция присваивания переопределена и в момент присвоения нового адреса, прежняя область автоматически освобождается. Поэтому указатель ptr будет вести на новую область со значением 11.
<p>
Вообще, в практике программирования на C++, «умные» указатели довольно часто инициализируются сразу в момент объявления. Например:
<pre>
<b>std::unique_ptr&lt;int> ptr {std::make_unique&lt;int>()};</b>
</pre>
Здесь создали умный указатель, указали его на созданную область памяти типа int со значением 0.
<p>
До стандарта C++14 эта инициализация прописывалась с помощью стандартного оператора new следующим образом:<br>
std::unique_ptr&lt;int> ptr_2 {<font color=red>new</font> int {-6}}; //так не рекомендуется
<p>
Но теперь так делать не рекомендуется, хотя синтаксически и допустимо. Как минимум, по двум причинам:
<p>
1. Во-первых, области памяти, выделяемые под сам указатель ptr_2 и объект данных (int), могут располагаться независимо друг от друга. Тогда как по стандарту функции make_unique() рекомендуется располагать область данных smart-указателя и область данных, на которые он ссылается, непосредственно друг за другом. Это несколько ускоряет работу smart-указателя.
<p>
2. Во-вторых, при создании smart-указателя в аргументах какой-либо функции, оператор new и создание самого указателя могут происходить в разные моменты времени. В некоторых случаях такое рассогласование может приводить к непредвиденным ошибкам.
<p>
Итак, запомним, что <b>выделение памяти для smart-указателей типа unique_ptr следует выполнять с помощью функции make_unique()</b>.
<p>
<b>Далее, если у нас имеется два указателя типа unique_ptr, то мы не можем присваивать один другому.</b> Например, команда:<br>
<font color=red>ptr_3 = ptr_2;</font><br>
приведет к ошибке на этапе компиляции. Это связано с тем, что указатель типа unique_ptr может ссылаться на ту или иную область памяти только в единственном числе. И никакой другой smart-указатель ссылаться на эту область уже не получится. Обычный можно. <b>В этом смысл «уникальности» smart-указателей этого типа и отличия от обычных указателей</b>. Хотя, «обмануть» компилятор все же возможно, если использовать такую конструкцию:
<pre>
int* p = new int(5);
std::unique_ptr&lt;int> ptr_2{ p };
std::unique_ptr&lt;int> ptr_3{ p };
</pre>
Программа скомпилируется, но может завершиться аварийно, так как оба smart-указателя ведут на одну и ту же область и дважды освобождают ее, что, в общем случае, недопустимо. Поэтому smart-указатели все же не панацея от всех возможных программных вариаций и программист должен грамотно и ответственно подходить к их использованию.
<p>
<b>Smart-указатели типа unique_ptr имеют ряд полезных методов</b>:
<ul>
<li> <b>get()</b> – возвращает «сырой» указатель на выделенную область памяти;
<p>
<li> <b>release()</b> – возвращает указатель на выделенную область памяти и «отвязывает» smart-указатель от нее;
<p>
<li> <b>reset()</b> – меняет значение указателя на другую область памяти, либо на значение nullptr, если ничего не указано;
<p>
<li> <b>swap()</b> – выполняет обмен адресами smart-указателей между собой.
</ul>
<p>
<h4>get()</h4>
Первый метод get() достаточно прост. Он возвращает обычный (сырой) указатель, если в программе он требуется по каким-либо причинам:
<pre>
int* p = ptr.get();
std::cout << p << " " << *p << std::endl;
</pre>
ptr - smart указатель<br>
p - обычный указатель
<h4>release()</h4>
Следующий метод release также возвращает сырой указатель на выделенную область, но сам smart-указатель «отвязывает» от этой области:
<pre>
int* p = ptr.release();
std::cout << ptr.get() << " " << p << " " << *p << std::endl;
</pre>
<h4>reseat()</h4>
Если нам нужно изменить ресурс, на который ссылается «умный» указатель, то это делается с помощью метода reset:
<pre>
ptr.reset(); // меняем на значение nullptr
</pre>
или
<pre>
ptr.reset(new int {143}); // меняем на новую область памяти
std::cout << ptr.get() << " " << *ptr << std::endl;
</pre>
Обратите внимание, что здесь допустимо использовать оператор new, но не функцию make_unique() в чистом виде.
<h4>swap()</h4>
Наконец, последний метод swap() просто меняет адреса двух smart-указателей:
<pre>
ptr.swap(ptr_2);
std::cout << *ptr << " " << *ptr_2 << std::endl;
</pre>
<h4 align=center>Указатели типа unique_ptr на массивы</h4>
В заключение этого занятия отмечу, что указатели unique_ptr можно определять и на массивы. Например:
<pre>
#include &lt;iostream>
#include &lt;memory>
 
using std::cout;
using std::endl;
 
int main(void)
{
    unsigned total {10};
    <b>std::unique_ptr&lt;int[]> ar {std::make_unique<int[]>(total)};</b>
    auto ar_2 {std::make_unique&lt;int[]>(7)};
    <b>std::unique_ptr&lt;int[]> ar_3 {nullptr};</b>
 
    return 0;
}
</pre>
Затем, через ar, ar_2, ar_3 мы можем обращаться к элементам соответствующих массивов привычным нам образом:
<pre>
    for(int i = 0; i < total; ++i)
        cout << ar[i] << " ";
</pre>
Увидим все нули. Это говорит о том, что при создании массивов с помощью функции make_unique() значения всех элементов автоматически инициализируются нулями.
<p>
Соответственно, можем записать какие-либо другие значения в массив следующим образом:
<pre>
    for(int i = 0; i < total; ++i)
        ar[i] = i*i;
</pre>
То есть, работа выполняется абсолютно так же, как и с обычными массивами языка С++.
<pre>



</pre>
<a name="share"><h3 align=center>Smart-указатели типа shared_ptr</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-smart-ukazateli-tipa-shared-ptr">Smart-указатели типа shared_ptr</a><br>
<a href="https://metanit.com/cpp/tutorial/11.2.php">shared_ptr&lt;T></a>
<p>
В практике программирования чаще используются указатели вида shared_ptr, которые также автоматически освобождают неиспользуемую память, но в отличие от unique_ptr могут ссылаться на нее во множественном числе.
<p>
Для данных указателей применяется механизм подсчета ссылок (reference counting). Каждый раз, когда создается объект shared_ptr&lt;T>, увеличивается счетчик объектов shared_ptr&lt;T>, которые содержат определенный адрес. Когда объект shared_ptr&lt;T> удаляется или ему присваивается другой адрес, счетчик ссылок уменьшается на единицу. Когда больше нет объектов shared_ptr&lt;T>, которые ссылаются на определенный адрес, счетчик ссылок сбрасывается в ноль.
<p>
Указатели типа shared_ptr объявляются в программе по аналогии с указателями unique_ptr. Вначале также нужно подключить заголовок:
<pre>
#include &lt;memory>
</pre>
После чего в пространстве имен std появится класс shared_ptr
<p>
При определении указателя без явной инициализации по умолчанию он инициализируется значением nullptr
<pre>
std::shared_ptr&lt;int> ptr;   // ptr = nullptr
std::shared_ptr&lt;int> ptr_2 {};
std::shared_ptr&lt;int> ptr_3 {nullptr};
std::shared_ptr&lt;int> ptr_4 {ptr};
</pre>
Во всех случаях объявляются указатели со значением nullptr. Причем, последний указатель ptr_4 инициализирован адресом указателя ptr. Как мы помним, с типом unique_ptr такая конструкция приводила к ошибке на этапе компиляции. Здесь же никаких ошибок нет, т.к. shared_ptr предполагает множество разных smart-указателей на одну и ту же область памяти.
<p>
Если нам нужно сразу в инициализаторе указателя типа shared_ptr выделить некоторую область памяти, то это следует делать с помощью функции <b>make_shared()</b>:
<pre>
std::shared_ptr&lt;int> ptr {<b>std::make_shared&lt;int>(3)</b>};
</pre>
В результате ptr будет ссылаться на область памяти для хранения целочисленного значения 3 типа int.
<p>
Еще пример:
<pre><font color=red>
std::shared_ptr<float> p_3 {new float()};</font> //работает.

<font color=red>std::shared_ptr<float> p_2 = new float();</font> //не работает.
</pre>
<font color=red>В первом случае инициализируется смарт-поинтер, в конструктор которого передаётся сырой поинтер, а во втором умный указатель инициализируется непосредственно сырым поинтером, так делать нельзя.</font>
<p>
Пользоваться указателем ptr можно абсолютно так же, как и обычным указателем на тип int. Например:
<pre>
ptr_2 = ptr; // присвоение адреса указателя ptr указателю ptr_2
*ptr = 10;  // запись числа 10 по адресу указателя ptr
cout << ptr_2 << *ptr_2 << endl;  // чтение и вывод в консоль значения по указателю ptr_2
</pre>
Обратите внимание, что <b>операция взятия адреса указателя shared_ptr делается просто по его имени (без вызова метода get)</b>.
<p>
А вот <b>выполнять операции адресной арифметики с такими указателями не получится</b>. При выполнении следующих команд получим ошибки на этапе компиляции:
<pre>
<font color=red>ptr_3 += 10;</font> //ошибка
<font color=red>auto res = ptr_3 - ptr_4;</font> //ошибка
<font color=red>p_1 = (char *)p_2;</font> // утверждение "присваивает адрес указателя p_2 указателю p_1" неверно
</pre>
Это их отличает от обычных (классических) указателей языка C/C++.
<h4>Контроль памяти указателей типа shared_ptr</h4>
Давайте теперь детальнее посмотрим, как указатели типа shared_ptr осуществляют контроль за памятью. Предположим, указатель ptr инициализируется на некоторую область памяти:<br>
std::shared_ptr<int> ptr_1 {std::make_shared<int>(3)};
<p>
В результате формируется объект самого указателя ptr_1, область памяти для хранения целочисленного значения типа int, а также специальный счетчик counter указателей на выделенную область памяти.
<p>
Если объявить еще один указатель на эту же область:<br>
std::shared_ptr&lt;int> ptr_2 {ptr_1};
<p>
то счетчик counter автоматически увеличивается до двух.<br>
И так далее. С увеличением числа указателей типа shared_ptr на эту область памяти, счетчик counter будет все время увеличиваться.
<p>
Предположим теперь, что указатель ptr_2 меняет свой адрес. Например, в результате выполнения такой команды:<br>
ptr_2 = std::make_shared&lt;int>(10);
<p>
Тогда счетчик для предыдущей области памяти (с int(3)) уменьшится на единицу, а указатель ptr_2 будет ссылаться на другую область памяти со своим счетчиком, у которого значение также будет равно единице.<br>
Далее, если указатель ptr_1 «отвязать» от текущей области памяти:<br>
ptr_1 = ptr_2;<br>
то счетчик на первую область будет равен нулю, а на вторую – два.
<p>
И как только для какой-либо выделенной области счетчик counter устанавливается в ноль, эта область памяти автоматически освобождается. Так реализован контроль за памятью для указателей shared_ptr. Кроме того, <b>смешивать разные типы smart-указателей между собой также запрещено</b>. Например, следующая конструкция приведет к ошибке на этапе компиляции:
<pre>
std::unique_ptr&lt;int> ptr_u {std::make_unique&lt;int>(-1)};
std::shared_ptr&lt;int> ptr_1 {ptr_u};  // ошибка
</pre>
Или конструкция вида:<br>
ptr_1 = ptr_u; // ошибка<br>
также приведет к ошибке. То есть, мы можем работать либо с указателями unique_ptr, либо с указателями shared_ptr, не смешивая их.
<h4 align=center>Методы указателей shared_ptr</h4>
Следующим шагом рассмотрим методы, которые имеются у smart-указателей типа shared_ptr. Основные из них следующие:
<ul>
<li> <b>get()</b> – получение «сырого» указателя на выделенную область памяти;
<p>
<li> <b>reset()</b> – меняет значение указателя на другую область памяти, либо на значение nullptr, если ничего не указано;
<p>
<li> <b>swap()</b> – меняет адреса двух указателей между собой;
<p>
<li> <b>unique()</b> – возвращает true (1), если на выделенную область ссылается только один указатель, и false (0) – в противном случае;
<p>
<li> <b>use_count()</b> – возвращает текущее значение счетчика conter для текущей области памяти.
</ul>
<h4>get()</h4>
Давайте посмотрим, как работают эти методы. С первым get() мы уже знакомы по предыдущему smart-указателю. Здесь все то же самое:
<pre>
std::shared_ptr&lt;int> ptr_1 {std::make_shared&lt;int>(3)};
std::shared_ptr&lt;int> ptr_2 {ptr_1};
 
int* p = <b>ptr_1.get()</b>;
</pre>
<h4>reset()</h4>
Следующий метод reset позволяет заменять одну область памяти на другую. Например:
<pre>
    <b>ptr_2.reset(new int[5] {1, 2, 3});</b>
    int* ar = ptr_2.get();
 
    for(int i = 0;i < 5;++i)
        cout << ar[i] << " ";
</pre>
Обратите внимание, мы выделили новую область памяти с помощью оператора new для массива в 5 элементов. После этого получили стандартный указатель на начало этого массива и с его помощью прочитали и вывели значения в консоль.
<p>
К сожалению, указатели типа shared_ptr могут работать с массивами, только начиная с версии языка C++20. До этого придется использовать оператор new.
<p>
Оставшиеся методы работают очевидным образом. Например:
<pre>
    <b>ptr_2.reset(new int[5] {1, 2, 3});</b>
    <b>ptr_2.swap(ptr_1);</b>
 
    cout << *ptr_2 << " " << <b>ptr_1.use_count()</b> << endl;
    cout << <b>ptr_1.unique()</b> << endl;
</pre>
В консоли увидим:
<pre>
3 1
1
</pre>
А если убрать строчку с reset, то вывод будет таким:
<pre>
3 2
0
</pre>
<h4>Работа smart-указателей типа shared_ptr с массивами в стандарте C++20</h4>
Начиная со стандарта C++20 указатели shared_ptr можно инициализировать и использовать с динамическими массивами. Делается это по аналогии с указателями unique_ptr следующим образом:
<pre>
unsigned total = 10;
std::shared_ptr&lt;int> ar_1 {std::make_shared&lt;int[]>(total)};
</pre>
Здесь ar_1 - массив, ему с помощью функции make_shared выделили памяти на total элементов типа int<br>
total - это длина массива. Указывается не в квадратных скобках, а в круглых, как аргумент функции.
<p>
Через указатель ar_1 можно работать как с массивом привычным нам образом:
<pre>
    ar_1[0] = 10;
    
    for(unsigned i = 0;i < total; ++i)
        cout << ar_1[i] << " ";
</pre>
Вот основные возможности «умных» указателей unique_ptr и shared_ptr. Сейчас в практике программирования на C/C++ они крайне рекомендуются при написании программ различного уровня сложности, так как существенно уменьшают проблемы, связанные с утечкой памяти, ее повторным освобождением, доступом к невыделенной памяти и так далее. Поэтому вместо применения операторов new/delete по возможности следует применять тот или иной вид smart-указателей.
<pre>





</pre>
</div></body></html>
