<html><head>
<style>
.menu {
       height: 100%;
       width: 170px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 5px;
           margin-left: 180px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Функциональное программирование</title>
<div class="menu">
<a href="index.html">Начальная</a>
<a href="python_base.html">Основы языка python</a>
<a href="python_collection.html">Коллекции</a>
<a href="python_funk.html">Функции</a>
<a href="python_oop.html">ООП</a>
<a href="python_library.html">Библиотеки</a>
<a href="python_example.html">Примеры</a>
Функциональное программирование:
<a href="#internal_funk">Встроенные функции:</a>
<a href="#map">&nbsp;&nbsp;&nbsp; Функция map()</a>
<a href="#filter">&nbsp;&nbsp;&nbsp; Функция filter()</a>
<a href="#zip">&nbsp;&nbsp;&nbsp;Функция zip()</a>
<a href="#range">&nbsp;&nbsp;&nbsp; Функция range</a>
<a href="#enumerate">&nbsp;&nbsp;&nbsp; enumerate()</a>
</div>
<div class="content">
<h2 align=center>Функциональное программирование</h2>
<a name="internal_funk"><h3 align=center>Встроенные функции</h3>
Ссылки: <a href="https://docs.python.org/3/library/functions.html">Документация по Built-in Functions</a><br>
<a href="https://intuit.ru/studies/courses/49/49/lecture/27060?page=">Встроенные функции</a>
<p>
В среде Python без дополнительных операций импорта доступно более сотни встроенных объектов, в основном, функций и исключений. 
Для удобства функции условно разделены по категориям:
<p>
<h3><a href="https://pythonworld.ru/osnovy/vstroennye-funkcii.html">Функции преобразования типов и классы</a>: coerce, str, 
repr, int, list, tuple, long, float, complex, dict, super, file, bool, object</h3>
<p>
<h3>Числовые и строковые функции: abs, divmod, ord, pow, len, chr, unichr, hex, oct, cmp, round, unicode</h3>
abs(x)	Модуль числа x. Результат: |x|.
<p>
divmod(x, y)	Частное и остаток от деления. Результат: (частное, остаток).
<p>
pow(x, y[, m])	Возведение x в степень y по модулю m. Результат: x**y % m.
<p>
round(n[, z])	Округление чисел до заданного знака после (или до) точки.
<p>
ord(s)	Функция возвращает код (или Unicode) заданного ей символа в односимвольной строке.
<p>
chr(n)	Возвращает строку с символом с заданным кодом.
<p>
len(s)	Возвращает число элементов последовательности или отображения.
<p>
oct(n), hex(n)	Функции возвращают строку с восьмеричным или шестнадцатеричным представлением целого числа n.
<p>
cmp(x, y)	Сравнение двух значений. Результат: отрицательный, ноль или положительный, в зависимости от результата 
сравнения.
<p>
unichr(n)	Возвращает односимвольную Unicode-строку с символом с кодом n.
<h3><a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=4">Функции обработки данных: apply, map, filter, 
reduce, zip, range, xrange, max, min, iter, enumerate, sum</a></h3>
<h3 align=center><a name="map">Функция map()</h3>
Синтаксис:
<pre>map(func, iterables)</pre>
map вытаскивает каждый элемент из итерируемого объекта iterables и к этому элементу применяет функцию func.<br>
Пример:<br>
a = [1, -2, -3, 4]<br>
b = list(map(abs, a)) # вернет список из модулей элементов списка a
<p>
b = map(abs, a) вернёт map объект, чтобы увидеть значение этого объекта, нужно применить к нему функцию преобразования типов 
объекта.
<p>
<b>Скобки после func не пишутся</b>
<pre>

</pre>
<h3 align=center><a name="filter">Функция filter()</h3>
Осуществляет отбор элементов из указанного итерируемого объекта.
<p>
Синтаксис:
<pre>filter(func, iterables)</pre>
Работает следующим образом. Если функция func возвращает True для текущего элемента итерируемого объекта iterables, то этот 
элемент входит в filter. Если же func возвращает False, то текущий элемент игнорируется.
<p>
<b>Скобки после func не пишутся</b>
<p>
В качестве первого аргумента могут применяться встроенные или собственные функции, lambda функции а также методы итерируемого 
объекта.
<pre>

</pre>
<a name="zip"><h3 align=center>Функция zip()</h3>
Ссылки: <a href="https://docs.python.org/3/library/functions.html#zip">Из официальной документации</a>
<p>
Синтаксис:
<pre>
zip(*iterables, strict=False)
</pre>
Эта функция возвращает zip-объект кортежей, в котором i -й кортеж содержит i -е элементы параллельных итерируемых последовательностей (список, кортеж, множество или словарь). Длина результирующей последовательности равна длине самой короткой из последовательностей-аргументов. По существу она преобразует информацию из несколько итерируемых объектов в один список.
<p>
Чтобы вытащить список из этого zip-объекта, его нужно преобразовать в список: list(zip(iterable1, iterable2, iterable3, ...)) .
<p>
Пример:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
fruits = ['apple', 'banana', 'lime']
numbers = [1, 2, 3]
zip_fruits_numbers = zip(fruits, numbers)
print(type(zip_fruits_numbers))  # &lt;class 'zip'>
print(zip_fruits_numbers)        # &lt;zip object at 0x7f3b0d39c1c0>
print(zip(fruits, numbers))      # &lt;zip object at 0x7f3b0d39c200>

# <b>вывод кортежей из zip-объекта</b>
print('вывод кортежей из zip-объекта')
for kortej in zip_fruits_numbers:
    print(kortej)

# <b>вывод списка из zip-объекта</b>
print('вывод списка из zip-объекта')
list_fruits_numbers = list(zip_fruits_numbers)
print(list_fruits_numbers)        # <font color=red><b>[]</b></font>
print(list(zip(fruits, numbers))) # [('apple', 1), ('banana', 2), ('lime', 3)]
list_fruits_numbers = list(zip(fruits, numbers))
print(list_fruits_numbers)        # [('apple', 1), ('banana', 2), ('lime', 3)]

# <b>вывод словаря из zip-объекта</b>
print('вывод словаря из zip-объекта')
dict_fruits_numbers = dict(zip_fruits_numbers)
print(dict_fruits_numbers)        # <font color=red><b>{}</b></font>

print(dict(zip(fruits, numbers))) # {'apple': 1, 'banana': 2, 'lime': 3}
</pre></td></tr></table>
<p>
Вывод:
<pre>
&lt;class 'zip'>
&lt;zip object at 0x7f3b0d39c1c0>
&lt;zip object at 0x7f3b0d39c200>
вывод кортежей из zip-объекта
('apple', 1)
('banana', 2)
('lime', 3)
вывод списка из zip-объекта
[]
[('apple', 1), ('banana', 2), ('lime', 3)]
[('apple', 1), ('banana', 2), ('lime', 3)]
вывод словаря из zip-объекта
{}
{'apple': 1, 'banana': 2, 'lime': 3}
{'apple': 1, 'banana': 2, 'lime': 3}
</pre>
<font size=5>Неожиданно, что когда сохраняю результат zip-функции в переменную zip_fruits_numbers, потом при попытке получить список или словарь от этой переменной получаю пустоту, а кортежи через цикл получить можно.</font> Связано это с тем что zip-объект является итератором.<br>
<i>Итераторы предназначены для генерации данных "на лету" ровно один раз, не более. Если вы хотите получить данные из него во второй раз, вам нужно либо сохранить все итерированные данные в другом списке, либо запустить итератор заново. В тех случаях, когда вам нужно считывать данные из файлов или выполнять другие неприятные действия, чтобы повторно получить этот итератор, вероятно, лучше всего просто сохранить эти данные в списке, когда они будут сгенерированы.</i>
<p>
<b>Транспонирование матрицы</b><br>
Другой подход к zip() заключается в том, что он преобразует строки в столбцы, а столбцы - в строки. Это похоже на транспонирование матрицы.
<p>
Следует учитывать, что iterables (последовательности), передаваемые в zip(), могут иметь разную длину; иногда по замыслу, а иногда из-за ошибки в коде, который подготовил эти повторяющиеся значения. Python предлагает три разных подхода к решению этой проблемы:
<ul>
<li> По умолчанию функция zip() останавливается, когда заканчивается самая короткая итерируемая последовательность. Она игнорирует оставшиеся элементы в более длинных итерируемых таблицах, сокращая результат до длины самой короткой итерируемой таблицы:
<pre>
list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))
[(0, 'fee'), (1, 'fi'), (2, 'fo')]
</pre>
<li> функция zip() часто используется в тех случаях, когда предполагается, что повторяющиеся значения имеют одинаковую длину. В таких случаях рекомендуется использовать параметр strict=True. Результат такой же, как у обычной функции zip():
<pre>
list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))
[('a', 1), ('b', 2), ('c', 3)]
</pre>
В отличие от поведения по умолчанию, оно вызывает ValueError, если один итерируемый объект исчерпывается раньше других:
<pre>
for item in zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True):  
    print(item)

(0, 'fee')
(1, 'fi')
(2, 'fo')
Traceback (most recent call last):
  ...
ValueError: zip() argument 2 is longer than argument 1
</pre>
Без аргумента strict=True любая ошибка, приводящая к появлению итераций разной длины, будет устранена, что, возможно, проявится как труднодоступная ошибка в другой части программы.
<li> Более короткие повторяющиеся элементы можно дополнить постоянным значением, чтобы все повторяющиеся элементы имели одинаковую длину. Это делается с помощью itertools.zip_longest().
</ul>
<p>
Крайние случаи: при использовании единственного итерационного аргумента функция zip() возвращает итератор из 1 кортежа. При отсутствии аргументов она возвращает пустой итератор.
<p>
Советы:
<ul>
<li> Порядок вычисления итераций слева направо гарантирован. Это позволяет использовать идиому для кластеризации ряда данных в группы длиной n с использованием zip(*[iter(s)]*n, strict=True). При этом один и тот же итератор повторяется n раз, так что каждый выходной кортеж содержит результат n обращений к итератору. В результате входные данные делятся на n фрагментов длиной.
<p>
<li> zip() в сочетании с оператором * можно использовать для распаковки списка:
<pre>
x = [1, 2, 3]
y = [4, 5, 6]
list(zip(x, y))
[(1, 4), (2, 5), (3, 6)]
x2, y2 = zip(*zip(x, y))
x == list(x2) and y == list(y2)
True
</pre>
</ul>
<pre>

</pre>
<h3><a name="range">Функция range</a></h3>
Функция range обычно применяется в цикле и позволяет перебрать какой-нибудь объект типа список по его индексу.
<pre>
for index range(len(spisok):
    print spisok(index)</pre>
функция range принимает от одного до трех аргументов. Если аргумент всего один, она генерирует список чисел от 0 
(включительно) <b>до заданного числа (исключительно).</b><br>
Если аргументов два, то список начинается с числа, указанного первым аргументом.<br>
Если аргументов три - третий аргумент задает шаг
<pre>
>>> print range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10, 3)
[1, 4, 7]</pre>
Третий аргумент может быть и отрицательным, служит для вывода элементов справа налево:
<pre>
>>> for i in range(10, 5, -1):
...     print(i)</pre>
Получим 10, 9, 8, 7, 6
<p>
Функция <b>xrange()</b> - аналог range(), более предпочтительный для использования при последовательном доступе, например, в 
цикле for или с итераторами. Она возвращает специальный xrange -объект, который ведет себя почти как список, порождаемый 
range(), но не хранит в памяти все выдаваемые элементы.
<pre>

</pre>
<a name="enumerate"><h4>Функция enumerate()</h4>
Возвращает объект enumerate. iterable должен быть последовательностью, итератором или каким-либо другим объектом, поддерживающим итерацию. Метод __next__() итератора, возвращаемый функцией enumerate(), возвращает кортеж, содержащий число (начиная с start, которое по умолчанию равно 0) и значения, полученные в результате итерации по iterable.
<pre>
enumerate(iterable[, start=0]) -> enumerate-object
</pre>
Где sequence - любой итерируемый объект.
<p>
start=0 : int Начальное значение счётчика.
<pre>
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
</pre>
<p>
Функция в частности применяется в случаях, когда необходим счётчик количества элементов в последовательности.<br>
Позволяет избавиться от необходимости инициализировать и обновлять отдельную переменную-счётчик:
<pre>
sequence = [1, 2, 7, 19]

# Сравните:
idx = 0
for item in sequence:
    print(idx)
    idx += 1
Вывод:
0
1
2
3

# и
for idx, item in enumerate(sequence):
    print(idx)

Вывод:
0
1
2
3
</pre>
<a name="any"><h3 align=center>Функция any()</h3>
Синтаксис:<br>
any(iterable)
<p>
Возвращает True, если существует хотя бы один элемент в iterable в условии if element вернёт True. Если iterable пустой, то False. Эквивалентно:
<pre>
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
</pre>
<a name="round"><h3 align=center>Функция round()</h3>
Синтаксис:<br>
round(number, ndigits)
<p>
number — обязательный параметр, который указывает число для округления.<br>
ndigits — необязательный аргумент, определяющий, до какого количества знаков нужно округлить. Если его не указывать, число будет округлено до ближайшего целого.
<pre>

</pre>
<h3>Функции определения свойств: hash, id, callable, issubclass, isinstance, type</h3><p>
<h3>Функции для доступа к внутренним структурам: locals, globals, vars, intern, dir</h3>
<h3>Функции компиляции и исполнения: eval, execfile, reload, __import__, compile</h3>
<h3>Функции ввода-вывода: input, raw_input, open</h3>
<h3>Функции для работы с атрибутами: getattr, setattr, delattr, hasattr</h3>
<h3>Функции-"украшатели" методов классов: staticmethod, classmethod, property</h3>
<h3>Прочие функции: buffer, slice</h3>

</div><pre>







</pre></body</html>
