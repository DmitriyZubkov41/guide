<html><head>
<style>
.menu {
       height: 100%;
       width: 155px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 5px;
           margin-left: 160px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Функциональное программирование</title>
<div class="menu">
<a href="index.html">Начальная</a>
<a href="python_base.html">Основы языка python</a>
<a href="python_collection.html">Коллекции</a>
<a href="python_funk.html">Функции</a>
<a href="python_oop.html">ООП</a>
<a href="python_gui.html">Графика</a>
<a href="python_bot.html">Боты</a>
<a href="python_library.html">Библиотеки</a>
<a href="python_example.html">Примеры</a>
<p>
<b>Функциональное программирование:</b>
<a href="#internal_funk">Встроенные функции:</a>
<a href="#map">&nbsp;&nbsp;&nbsp; Функция map()</a>
<a href="#filter">&nbsp;&nbsp;&nbsp; Функция filter()</a>
<a href="#zip">&nbsp;&nbsp;&nbsp;Функция zip()</a>
<a href="#range">&nbsp;&nbsp;&nbsp; Функция range</a>
<a href="#enumerate">&nbsp;&nbsp;&nbsp; enumerate()</a>
<a href="#algoritm">Алгоритмы:</a>
<a href="#graf">ДЕРЕВЬЯ И ГРАФЫ</a>
</div>

<div class="content">
<h2 align=center>Функциональное программирование</h2>
<a name="internal_funk"><h3 align=center>Встроенные функции</h3>
Ссылки: <a href="https://docs.python.org/3/library/functions.html">Документация по Built-in Functions</a><br>
<a href="https://intuit.ru/studies/courses/49/49/lecture/27060?page=">Встроенные функции</a>
<p>
В среде Python без дополнительных операций импорта доступно более сотни встроенных объектов, в основном, функций и исключений. 
Для удобства функции условно разделены по категориям:
<p>
<h3><a href="https://pythonworld.ru/osnovy/vstroennye-funkcii.html">Функции преобразования типов и классы</a>: coerce, str, 
repr, int, list, tuple, long, float, complex, dict, super, file, bool, object</h3>
<p>
<h3>Числовые и строковые функции: abs, divmod, ord, pow, len, chr, unichr, hex, oct, cmp, round, unicode</h3>
abs(x)	Модуль числа x. Результат: |x|.
<p>
divmod(x, y)	Частное и остаток от деления. Результат: (частное, остаток).
<p>
pow(x, y[, m])	Возведение x в степень y по модулю m. Результат: x**y % m.
<p>
round(n[, z])	Округление чисел до заданного знака после (или до) точки.
<p>
ord(s)	Функция возвращает код (или Unicode) заданного ей символа в односимвольной строке.
<p>
chr(n)	Возвращает строку с символом с заданным кодом.
<p>
len(s)	Возвращает число элементов последовательности или отображения.
<p>
oct(n), hex(n)	Функции возвращают строку с восьмеричным или шестнадцатеричным представлением целого числа n.
<p>
cmp(x, y)	Сравнение двух значений. Результат: отрицательный, ноль или положительный, в зависимости от результата 
сравнения.
<p>
unichr(n)	Возвращает односимвольную Unicode-строку с символом с кодом n.
<h3><a href="https://intuit.ru/studies/courses/49/49/lecture/27062?page=4">Функции обработки данных: apply, map, filter, 
reduce, zip, range, xrange, max, min, iter, enumerate, sum</a></h3>
<h4><a name="map">Функция map()</h4>
Синтаксис:
<pre>map(func, iterables)</pre>
map вытаскивает каждый элемент из итерируемого объекта iterables и к этому элементу применяет функцию func.<br>
Пример:<br>
a = [1, -2, -3, 4]<br>
b = list(map(abs, a)) # вернет список из модулей элементов списка a
<p>
b = map(abs, a) вернёт map объект, чтобы увидеть значение этого объекта, нужно применить к нему функцию преобразования типов 
объекта.
<p>
<b>Скобки после func не пишутся</b>
<pre>

</pre>
<h43><a name="filter">Функция filter()</h3>
Осуществляет отбор элементов из указанного итерируемого объекта.
<p>
Синтаксис:
<pre>filter(func, iterables)</pre>
Работает следующим образом. Если функция func возвращает True для текущего элемента итерируемого объекта iterables, то этот 
элемент входит в filter. Если же func возвращает False, то текущий элемент игнорируется.
<p>
<b>Скобки после func не пишутся</b>
<p>
В качестве первого аргумента могут применяться встроенные или собственные функции, lambda функции а также методы итерируемого 
объекта.
<pre>

</pre>
<a name="zip"><h3 align=center>Функция zip()</h3>
Ссылки: <a href="https://docs.python.org/3/library/functions.html#zip">Из официальной документации</a>
<p>
Синтаксис:
<pre>
zip(*iterables, strict=False)
</pre>
Эта функция возвращает zip-объект кортежей, в котором i -й кортеж содержит i -е элементы параллельных итерируемых последовательностей (список, кортеж, множество или словарь). Длина результирующей последовательности равна длине самой короткой из последовательностей-аргументов. По существу она преобразует информацию из несколько итерируемых объектов в один список.
<p>
Чтобы вытащить список из этого zip-объекта, его нужно преобразовать в список: list(zip(iterable1, iterable2, iterable3, ...)) .
<p>
Пример:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
fruits = ['apple', 'banana', 'lime']
numbers = [1, 2, 3]
zip_fruits_numbers = zip(fruits, numbers)
print(type(zip_fruits_numbers))  # &lt;class 'zip'>
print(zip_fruits_numbers)        # &lt;zip object at 0x7f3b0d39c1c0>
print(zip(fruits, numbers))      # &lt;zip object at 0x7f3b0d39c200>

# <b>вывод кортежей из zip-объекта</b>
print('вывод кортежей из zip-объекта')
for kortej in zip_fruits_numbers:
    print(kortej)

# <b>вывод списка из zip-объекта</b>
print('вывод списка из zip-объекта')
list_fruits_numbers = list(zip_fruits_numbers)
print(list_fruits_numbers)        # <font color=red><b>[]</b></font>
print(list(zip(fruits, numbers))) # [('apple', 1), ('banana', 2), ('lime', 3)]
list_fruits_numbers = list(zip(fruits, numbers))
print(list_fruits_numbers)        # [('apple', 1), ('banana', 2), ('lime', 3)]

# <b>вывод словаря из zip-объекта</b>
print('вывод словаря из zip-объекта')
dict_fruits_numbers = dict(zip_fruits_numbers)
print(dict_fruits_numbers)        # <font color=red><b>{}</b></font>

print(dict(zip(fruits, numbers))) # {'apple': 1, 'banana': 2, 'lime': 3}
</pre></td></tr></table>
<p>
Вывод:
<pre>
&lt;class 'zip'>
&lt;zip object at 0x7f3b0d39c1c0>
&lt;zip object at 0x7f3b0d39c200>
вывод кортежей из zip-объекта
('apple', 1)
('banana', 2)
('lime', 3)
вывод списка из zip-объекта
[]
[('apple', 1), ('banana', 2), ('lime', 3)]
[('apple', 1), ('banana', 2), ('lime', 3)]
вывод словаря из zip-объекта
{}
{'apple': 1, 'banana': 2, 'lime': 3}
{'apple': 1, 'banana': 2, 'lime': 3}
</pre>
<font size=5>Неожиданно, что когда сохраняю результат zip-функции в переменную zip_fruits_numbers, потом при попытке получить список или словарь от этой переменной получаю пустоту, а кортежи через цикл получить можно.</font> Связано это с тем что zip-объект является итератором.<br>
<i>Итераторы предназначены для генерации данных "на лету" ровно один раз, не более. Если вы хотите получить данные из него во второй раз, вам нужно либо сохранить все итерированные данные в другом списке, либо запустить итератор заново. В тех случаях, когда вам нужно считывать данные из файлов или выполнять другие неприятные действия, чтобы повторно получить этот итератор, вероятно, лучше всего просто сохранить эти данные в списке, когда они будут сгенерированы.</i>
<p>
<b>Транспонирование матрицы</b><br>
Другой подход к zip() заключается в том, что он преобразует строки в столбцы, а столбцы - в строки. Это похоже на транспонирование матрицы.
<p>
Следует учитывать, что iterables (последовательности), передаваемые в zip(), могут иметь разную длину; иногда по замыслу, а иногда из-за ошибки в коде, который подготовил эти повторяющиеся значения. Python предлагает три разных подхода к решению этой проблемы:
<ul>
<li> По умолчанию функция zip() останавливается, когда заканчивается самая короткая итерируемая последовательность. Она игнорирует оставшиеся элементы в более длинных итерируемых таблицах, сокращая результат до длины самой короткой итерируемой таблицы:
<pre>
list(zip(range(3), ['fee', 'fi', 'fo', 'fum']))
[(0, 'fee'), (1, 'fi'), (2, 'fo')]
</pre>
<li> функция zip() часто используется в тех случаях, когда предполагается, что повторяющиеся значения имеют одинаковую длину. В таких случаях рекомендуется использовать параметр strict=True. Результат такой же, как у обычной функции zip():
<pre>
list(zip(('a', 'b', 'c'), (1, 2, 3), strict=True))
[('a', 1), ('b', 2), ('c', 3)]
</pre>
В отличие от поведения по умолчанию, оно вызывает ValueError, если один итерируемый объект исчерпывается раньше других:
<pre>
for item in zip(range(3), ['fee', 'fi', 'fo', 'fum'], strict=True):  
    print(item)

(0, 'fee')
(1, 'fi')
(2, 'fo')
Traceback (most recent call last):
  ...
ValueError: zip() argument 2 is longer than argument 1
</pre>
Без аргумента strict=True любая ошибка, приводящая к появлению итераций разной длины, будет устранена, что, возможно, проявится как труднодоступная ошибка в другой части программы.
<li> Более короткие повторяющиеся элементы можно дополнить постоянным значением, чтобы все повторяющиеся элементы имели одинаковую длину. Это делается с помощью itertools.zip_longest().
</ul>
<p>
Крайние случаи: при использовании единственного итерационного аргумента функция zip() возвращает итератор из 1 кортежа. При отсутствии аргументов она возвращает пустой итератор.
<p>
Советы:
<ul>
<li> Порядок вычисления итераций слева направо гарантирован. Это позволяет использовать идиому для кластеризации ряда данных в группы длиной n с использованием zip(*[iter(s)]*n, strict=True). При этом один и тот же итератор повторяется n раз, так что каждый выходной кортеж содержит результат n обращений к итератору. В результате входные данные делятся на n фрагментов длиной.
<p>
<li> zip() в сочетании с оператором * можно использовать для распаковки списка:
<pre>
x = [1, 2, 3]
y = [4, 5, 6]
list(zip(x, y))
[(1, 4), (2, 5), (3, 6)]
x2, y2 = zip(*zip(x, y))
x == list(x2) and y == list(y2)
True
</pre>
</ul>
<pre>

</pre>
<h3><a name="range">Функция range</a></h3>
Функция range обычно применяется в цикле и позволяет перебрать какой-нибудь объект типа список по его индексу.
<pre>
for index range(len(spisok):
    print spisok(index)</pre>
функция range принимает от одного до трех аргументов. Если аргумент всего один, она генерирует список чисел от 0 
(включительно) <b>до заданного числа (исключительно).</b><br>
Если аргументов два, то список начинается с числа, указанного первым аргументом.<br>
Если аргументов три - третий аргумент задает шаг
<pre>
>>> print range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> print range(1, 10, 3)
[1, 4, 7]</pre>
Третий аргумент может быть и отрицательным, служит для вывода элементов справа налево:
<pre>
>>> for i in range(10, 5, -1):
...     print(i)</pre>
Получим 10, 9, 8, 7, 6
<p>
Функция <b>xrange()</b> - аналог range(), более предпочтительный для использования при последовательном доступе, например, в 
цикле for или с итераторами. Она возвращает специальный xrange -объект, который ведет себя почти как список, порождаемый 
range(), но не хранит в памяти все выдаваемые элементы.
<pre>

</pre>
<a name="enumerate"><h4>Функция enumerate()</h4>
Возвращает объект enumerate. iterable должен быть последовательностью, итератором или каким-либо другим объектом, поддерживающим итерацию. Метод __next__() итератора, возвращаемый функцией enumerate(), возвращает кортеж, содержащий число (начиная с start, которое по умолчанию равно 0) и значения, полученные в результате итерации по iterable.
<pre>
enumerate(iterable[, start=0]) -> enumerate-object
</pre>
Где sequence - любой итерируемый объект.
<p>
start=0 : int Начальное значение счётчика.
<pre>
>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
</pre>
<p>
Функция в частности применяется в случаях, когда необходим счётчик количества элементов в последовательности.<br>
Позволяет избавиться от необходимости инициализировать и обновлять отдельную переменную-счётчик:
<pre>
sequence = [1, 2, 7, 19]

# Сравните:
idx = 0
for item in sequence:
    print(idx)
    idx += 1
Вывод:
0
1
2
3

# и
for idx, item in enumerate(sequence):
    print(idx)

Вывод:
0
1
2
3
</pre>
<p>
<h3>Функции определения свойств: hash, id, callable, issubclass, isinstance, type</h3><p>
<h3>Функции для доступа к внутренним структурам: locals, globals, vars, intern, dir</h3>
<h3>Функции компиляции и исполнения: eval, execfile, reload, __import__, compile</h3>
<h3>Функции ввода-вывода: input, raw_input, open</h3>
<h3>Функции для работы с атрибутами: getattr, setattr, delattr, hasattr</h3>
<h3>Функции-"украшатели" методов классов: staticmethod, classmethod, property</h3>
<h3>Прочие функции: buffer, slice</h3>
<pre>

</pre>
<a name="algoritm"><h3 align=center>Алгоритмы:</h3>
Ссылки: <a href="https://teletype.in/@pythontalk/data_structures_algorithms">Структуры данных и алгоритмы в Python</a>
<p>
Алгоритмы — это пошаговые инструкции для выполнения задач. Они могут быть простыми, как сортировка списка чисел, или сложными, как алгоритмы машинного обучения.
<h3 align=center>Алгоритмы поиска:</h3>
Ссылка: книга Cuantum Алгоритмы и структуры данных на Python 2024 год стр. 149
<h4>Линейный поиск</h4>
<h4>Бинарный поиск</h4>
Бинарный поиск — это эффективный алгоритм поиска, который работает только с отсортированными списками. Выполните поиск в отсортированном массиве, многократно деля интервал поиска пополам. Начните с интервала, охватывающего весь массив. Если значение ключа поиска меньше, чем элемент в середине интервала, сузьте интервал до нижней половины. В противном случае сузьте его до верхней половины. Повторяйте проверку до тех пор, пока значение не будет найдено или интервал не окажется пустым.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
def binary_search(arr, x):
    low = 0
    high = len(arr) – 1
    mid = 0

    while low <= high:
        mid = (high + low) // 2

        if arr[mid] < x:
            low = mid + 1
        elif arr[mid] > x:
            high = mid – 1
        else:
            return mid
    return -1

# Пример использования
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
result = binary_search(my_list, 4)
print(f'Элемент найден на индексе {result}')
</pre></td></tr></table>
<pre>

</pre>
<h3 align=center>Алгоритмы сортировки</h3>
Ссылка: книга Cuantum Алгоритмы и структуры данных на Python 2024 год стр. 128
<p>
<h4>Сортировка пузырьком</h4>
Сортировка пузырьком — это простой алгоритм сортировки, который многократно проходит по списку, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Этот алгоритм не является самым эффективным, но он прост в реализации и понимании.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
    return arr

# Пример использования
my_list = [64, 34, 25, 12, 22, 11, 90]
sorted_list = bubble_sort(my_list)
print(sorted_list)
</pre></td></tr></table>
<h4>Сортировка по выбору</h4>
Этот алгоритм сортирует массив, многократно находя минимальный элемент (в порядке возрастания) из неотсортированной части и помещая его в начало. На каждой итерации выбирается минимальный элемент (в порядке возрастания) из неотсортированного подмассива и перемещается в отсортированный подмассив.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import sys

A = [64, 25, 12, 90, 22, 11]

# перебор всех элементов массива
for i in range(len(A)):
    # нахождение минимального элемента
    # в несортированном списке
    min_idx = i
    for j in range(i+1, len(A)):
        if A[min_idx] > A[j]:
            min_idx = j
			
    # замена элемента с минимальным значением на первый элемент
    A[i], A[min_idx] = A[min_idx], A[i]


print("Отсортированный список:")
for i in range(len(A)):
    print(f"{A[i]}")
</pre></td></tr></table>
<pre>
Отсортированный список:
11
12
22
25
64
90
</pre>
Временная сложность — O (n**2), так как имеется два вложенных цикла. Алгоритм хорошо сортирует списки малого и среднего размера.
Помимо эффективности, сортировка выбором проста и легка в реализации. Он особенно эффективен для небольших списков или ситуаций, когда размер входных данных ограничен. Однако у сортировки выбором есть определенные недостатки. По сравнению
с более сложными методами сортировки, такими как быстрая сортировка или сортировка слиянием, она медленнее, поэтому не очень хорошо под­ходит для сортировки больших объемов данных или сценариев, в которых скорость имеет решающее значение.
<h4>Пузырьковая сортировка</h4>
Это простейший алгоритм сортировки, который работает путем многократной перемены мест соседних элементов, если они расположены в неправильном порядке.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def bubble_sort(arr):
    n = len(arr)

    # перебор всех элементов списка
    for i in range(n):
        # последние i элементов на месте
        for j in range(0, n-i-1):
            # обход элементов от 0 до n-i-1
	    # поменять местами, если найденный элемент
	    # больше следующего
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]

arr = [64, 34, 25, 12, 22, 11, 90]

bubble_sort(arr)

print("Отсортированный список:")
#for i in range(len(arr)):
for i in arr:
    #print(f"{arr[i]}")
    print(i)
</pre></td></tr></table>
<pre>	
# Отсортированный список:
# 11
# 12
# 22
# 25
# 34
# 64
# 90
</pre>
<h4>Сортировка вставкой</h4>
Чтобы отсортировать массив размера n по возрастанию, используйте сортировку вставкой:
<ul>
<li> Переберите список от arr[1] до arr[n].
<li> Сравните текущий элемент с его предыдущим.
<li> Если ключевой элемент меньше своего предшественника, сравните его с предыдущими элементами. Переместите больший элемент на одну позицию вверх, чтобы освободить место для поменявшегося элемента.
</ul>
<p>
<img src="images/python_funk_progr.png">
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def insertion_sort(arr):
    # перебор от 1 до len(arr)
    for i in range(1, len(arr)):
        key = arr[i]
        # Переместить элементы arr[0..i-1], которые больше ключа,
        # на одну позицию вперед от их текущей позиции
        j = i-1
        while j >= 0 and key < arr[j] :
            arr[j + 1] = arr[j]
            arr[j] = key
            j -= 1

arr = [12, 11, 60, 13, 20, 5, 6]
insertion_sort(arr)
for i in range(len(arr)):
    print(f"{arr[i]}")
</pre></td></tr></table>
<pre>
5
6
11
12
13
20
60
</pre>
Данный алгоритм способен эффективно сортировать списки небольшого и среднего размера. Его средняя и наихудшая временная сложность со­ ставляет О(п**2). Сортировка вставками может показаться неэффективной, однако в сценариях, когда список частично отсортирован, она превосходит все остальные алгоритмы. В лучшем случае, когда список уже отсортирован, временная сложность данного алгоритма достигает О(n). Это связано с тем, что сортировка вставками обрабатывает каждый элемент списка только раз, не требуя никаких перестановок. Таким образом, произ­водительность данного алгоритма зависит от начального состояния списка
и в определенных ситуациях может быть весьма высокой.
<h4>Сортировка слиянием</h4>
Этот алгоритм делит входной массив на две половины, вызывает себя для двух половин, а затем объединяет две отсортированные половины. Для слияния двух половин используется функция merge(). Merge(arr, l, m, r) — это ключевой процесс, который предполагает, что arr[l..m] и arr[m+1..r] отсортированы, и объединяет два отсортированных подмассива в один. 
<pre>
MergeSort(arr[], l, r)
Если r > l
     1. Найдите среднюю точку, чтобы разделить массив на две половины:  
             середина m = l+ (r-l)/2
     2. Вызовите mergeSort для первой половины:   
             вызов mergeSort(arr, l, m)
     3. Вызовите mergeSort для второй половины:
             вызов mergeSort(arr, m+1, r).
     4. Объедините две половины, отсортированные на шаге 2 и 3:
             вызов merge(arr, l, m, r)
</pre>
<p>
<img src="images/python_funk_progr1.png">
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def merge_sort(arr):
    if len(arr) > 1:
        # находим середину списка
        mid = len(arr)//2

	# делим список
        L = arr[:mid]
        
	# на две половины
        R = arr[mid:]

	# сортируем первую
        merge_sort(L)

	# сортируем вторую
        merge_sort(R)

        i = j = k = 0

	# копируем данные во временные списки L[] и R[]
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1

	# проверяем, что ничего не потеряли
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1

        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1


def print_list(arr):
    for i in range(len(arr)):
        print(arr[i], end=" ")
    print()

if __name__ == '__main__':
    arr = [12, 11, 40, 20, 13, 5, 6, 7]
    print("Изначальный список:", end="\n")
    print_list(arr)
    merge_sort(arr)
</pre></td></tr></table>
<pre>
Изначальный список:
12 11 40 20 13 5 6 7 
Отсортированный список: 
5 6 7 11 12 13 20 40
</pre>
<h4>Алгоритм быстрой сортировки или "разделяй и властвуй"</h4>
Он выбирает элемент за основу и разбивает заданный массив вокруг него. Существует много различных версий этого алгоритма, которые выбирают основу разными способами:
<ul>
<li> Всегда выбирать последний элемент в качестве основы (реализовано ниже).
<li> Выбирать случайный элемент в качестве основы.
<li> Выбрать медиану в качестве основы.
</ul>
Ключевым процессом в алгоритме является partition(). Его задача состоит в том, чтобы, учитывая массив и элемент x из массива в качестве основы, поместить x на его правильную позицию в отсортированном массиве и поместить все меньшие элементы перед x, а все большие элементы — после x. Всё это должно быть выполнено за линейное время.
<p>
<img src="images/python_funk_progr2.png">
<h4>ShellSort</h4>
Является разновидностью сортировки вставкой. 
<h4>Концепция временной сложности</h4>
Временная сложность — это показатель, который позволяет получить общее представление о взаимосвязи между количеством входных данных (обычно обозначаемых как п) и количеством шагов, выполняемых алгоритмом. Почему важно разбираться во временной сложности? Представьте, что при­ сутствуете на магическом шоу, где два фокусника утверждают, что умеют сортировать колоду карт. Один говорит, что использует линейный алгоритм сортировки, а это значит, что время, необходимое для сортировки карт,
увеличивается пропорционально их количеству. Время работы алгоритма сортировки, который использует второй фокусник, судя по всему, при уве­личении количества карт растет экспоненциально. Если бы вам предложили доверить одному из этих фокусников сортировку колоды из миллиона карт, то кого бы вы выбрали? Временная сложность может помочь вам принять обоснованное решение
в подобных ситуациях, позволяя понимать, как эффективность алгоритма зависит от размера входных данных.
<h4>Нотация «О большое»</h4>
Нотация «О большое» — математическое представление временной слож­ности. Это ценный инструмент для анализа эффективности алгоритмов, дающий представление о скорости их выполнения. Используя эту нотацию, вы можете принимать обоснованные решения о том, какие алгоритмы ис­пользовать для различных сценариев. Выбор правильного алгоритма для конкретной задачи может оказать значительное влияние на эффективность и производительность ваших решений. Ниже представлены некоторые распространенные обозначения нотации 
«О большое» и соответствующие им описания.
<ul>
<li> 0(1) — постоянное время. Время работы алгоритма остается неизменным независимо от размера входных данных. Это очень эффективно и жела­тельно во многих случаях.
<li> О(1о§ п) — логарифмическое время. Алгоритмы с такой временной сложностью уменьшают размер входных данных с каждой итерацией. Классический пример такого алгоритма — двоичный поиск.
<li> О(п) — линейное время. В алгоритмах с линейной временной сложностью время выполнения линейно увеличивается по мере увеличения размера входных данных. Это общий сценарий для многих алгоритмов.
<li> О(п log и) — линейно-арифметическое время. Эта временная сложность часто встречается в алгоритмах сортировки, таких как сортировка слия­нием и быстрая сортировка. В этих алгоритмах соблюдается баланс между временной и пространственной сложностью, позволяющий достичь оптимальной производительности.
<li> О(и2), О^пР) и т. д. — полиномиальное время. Алгоритмы с полиноми­альной временной сложностью имеют вложенные циклы, что приводит к значительному увеличению времени выполнения при увеличении раз­
мера входных данных.
</ul>
Сравним алгоритмы сортировки по их средней временной сложности.<br>
Простые алгоритмы — пузырьковая сортировка, сортировка выбором и сортировка вставками — имеют временную сложность О(и2), вследствие этого не очень эффективны при работе с большими наборами данных. Однако они могут хорошо работать с маленькими наборами.
<p>
Расширенные алгоритмы — быстрая сортировка, сортировка слиянием и пирамидальная сортировка — имеют временную сложность O(n log п), поэтому часто используются при работе с большими наборами данных.
<pre>

</pre>
<h3 align=center>Хеширование</h3>
Ссылка: книга Cuantum Алгоритмы и структуры данных на Python 2024 год стр. 156
<pre>

</pre>
<a name="graf"><h3 align=center>ДЕРЕВЬЯ И ГРАФЫ: ИЕРАРХИЧЕСКИЕ СТРУКТУРЫ ДАННЫХ</h3>
Ссылка: книга Cuantum Алгоритмы и структуры данных на Python 2024 год стр. 185 Глава 6
<p>
Изучив эти иерархические структуры, вы сможете использовать сложные алгоритмы, что даст вам возможность эффективно решать самые разные задачи во множестве областей.
<h4 align=center>Деревья: типы и методы обхода</h4>
Деревья представляют собой тип структуры данных, которая повторяет структуру иерархического дерева. Они начинаются с корневого значения, которое выступает в качестве начальной точки, и разветвляются на под­ деревья, связанные с корнем родительскими узлами.
<p>
<b>Методы обхода:</b><br>
Когда говорят о <b>поиске в ширину</b> (Breadth First Search, BFS) и <b>глубину</b> (Depth First Search, DFS), имеется в виду порядок обхода узлов двоичного дерева. При обходе в глубину вы сначала опускаетесь к низу дерева, а потом идете в сторону, а при обходе в ширину — наоборот, начинаете с корня и спускаетесь сначала к его узлам-потомкам, обходите их, потом спускаетесь к потомкам потомков, обходите их, и так далее.
<p>
<img src="images/python_funk_progr3.png">
<p>
Если взять в качестве примера двоичное дерево на этом рисунке, при BFS-подходе порядок обхода узлов будет следующим: 1, 2, 3, 4, 5.<br>
В случае с DFS возможны разные варианты последовательности посещения узлов. Все зависит от того, будет это прямой, обратный или центрированный обход. Например, прямой обход выдаст 1, 2, 4, 5, 3.
<p>
<b>Виды деревьев</b><br>
Двоичные деревья<br>
Каждый узел в этой структуре может иметь до двух дочерних элементов, обычно называемых левым и правым. Двоичные деревья являются одной из основных структур данных в информатике и находят широкое применение в различных приложениях. Они позволяют эффективно взаимодействовать с данными, поэтому актив­но используются в таких операциях, как поиск, сортировка и организация
информации. Кроме того, двоичные деревья лежат в основе более сложных типов деревьев, таких как двоичные деревья поиска и AVL-деревья, что по­вышает их полезность и производительность.
<p>
<b>Двоичные деревья поиска</b><br>
Двоичные деревья поиска (Binary Search Tree, BST) — структура данных, используемая для представления данных с иерархической организацией, в которой все узлы соответствуют следующему свойству: левый дочерний узел меньше родительского, а правый дочерний — больше. Это свойство по­ зволяет выполнять поиск, вставку и удаление за время O(log п), что делает двоичные деревья весьма эффективными. BST высоко ценятся в области информатики и структур данных. Они пред­лагают метод иерархического хранения и организации данных, позволяя быстро получать доступ к ним и взаимодействовать с ними. Соблюдение принципов BST помогает поддерживать баланс и оптимизацию, делая работу по созданию и анализу алгоритмов эффективной.
<p>
<b>Сбалансированные деревья</b><br>
Деревья AVL и красно-черные деревья — два популярных примера само­балансирующихся деревьев двоичного поиска. Они специально разработаны для поддержания баланса путем автоматической корректировки своей структуры. Благодаря этой регулировке высота дерева всегда находится под контролем, позволяя предотвращать снижение производительности и обеспечивать эф­фективность поисковых операций. Способность к самобалансировке делает деревья АѴЬ и красно-черные деревья надежным и эффективным решением
для хранения и поиска данных.
<p>
<b>N-арные деревья</b><br>
Это тип дерева, в котором каждый узел может иметь несколько дочерних. Эта характеристика делает такое дерево менее строгим, чем двоичное, и по­зволяет более гибко представлять иерархические структуры данных. Такие деревья универсальны и особенно полезны в сценариях, где данные естественным образом образуют сложную иерархию с множеством ветвей, позволяя эффективно организовывать и извлекать данные и управлять ими, а также анализировать данные в различных областях, таких как информатика, биология и сетевые системы.
<p>
<b>В-деревья</b><br>
В-деревья — структура данных, используемая в базах данных и файловых системах. Они дают возможность хранить огромные объемы данных и управ­лять ими. Благодаря своим уникальным свойствам В-деревья позволяют эффективно выполнять операции вставки, удаления и поиска, что делает их очень ценным компонентом различных приложений. В базах данных В-деревья отвечают за быстрый доступ и поиск данных, по­вышая общую производительность. В файловых системах они способству­ют беспрепятственной организации файлов и управлению ими, повышая эффективность операций.

<h3 align=center>Графы</h3>
Ссылка: книга Cuantum Алгоритмы и структуры данных на Python 2024 год стр. 193
<h3 align=center>Динамическое программирование</h3>
Алгоритмы поиска пути в робототехнике<br>
Динамическое программирование — ключевой подход в робототехнике, особенно в алгоритмах поиска пути. Оно позволяет роботам ориентиро­ваться в сложных условиях, разбивая задачу перемещения на более мелкие и управляемые подзадачи. При поиске пути алгоритмы динамического программирования использу­ют ранее определенные оптимальные решения, чтобы проложить лучший
маршрут для робота, учитывая препятствия, изменчивость рельефа и другие важные факторы. Эта методология позволяет роботам двигаться эффективно и безопасно, оптимизируя маршруты и сокращая ненужные затраты энергии. Такой подход не только повышает общие показатели эффективности робо­тов, но и улучшает их способность адаптироваться к различным ситуациям и препятствиям, с которыми они могут столкнуться.
<p>
<b>Сравнение динамического программирования и стратегии «разделяй и властвуй»</b><br>
К этому моменту вы могли заметить, что стратегия «разделяй и властвуй» и динамическое программирование чем-то похожи. В этом подразделе мы обсудим, чем они отличаются друг от друга. В обоих подходах задачи разбиваются на более мелкие, однако в динами­
ческом программировании результаты этих подзадач сохраняются, чтобы не пришлось проводить повторные вычисления. Это различие важно при решении задач, в которых подзадачи перекрываются, как это часто бывает в задачах оптимизации. В методе «разделяй и властвуй» подзадачи решаются независимо друг от друга, а их решения объединяются, чтобы можно было получить оконча­тельное решение. В динамическом программировании используется подход «снизу вверх», при котором подзадачи решаются систематическим образом и сохраненные результаты используются для эффективного решения более крупных задач. Таким образом, несмотря на то что оба метода направлены на решение сложных задач, динамическое программирование — более эффективный и оптимизированный подход, поскольку позволяет использовать данные, полученные при решении небольших подзадач.
</div><pre>







</pre></body</html>
