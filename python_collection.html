<html><head>
<style>
.menu {
       height: 100%;
       width: 140px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 150px; /* То же, что и ширина боковой панели */
           padding: 0px 0px 0px 16px;
         }
</style>
</head><body>
<title>Коллекции</title>
<div class="menu">
<a href="index.html">Начальная</a>
<a href="python_base.html">Основы</a>
<a href="python_funk.html">Функции</a>
<a href="python_funk_progr.html">Функциональное программирование</a>
<a href="python_oop.html">ООП в python</a>
<a href="python_library.html">Библиотеки</a>
<a href="python_parsing">Парсинг страниц</a>
<a href="python_gui.html">Графика</a>
<a href="python_bot.html">Боты</a>
<a href="python_example.html">Примеры</a>
<p>
Коллекции:
<a href="#string">Строки:</a>
<a href="#metod_str">&nbsp;&nbsp; Методы строки:</a>
<a href="#split">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; split()</a>
<a href="#unicode">&nbsp;&nbsp; Unicode, что это</a>
<a href="#list">Список:</a>
<a href="#join">&nbsp;&nbsp;&nbsp;&nbsp; Метод join</a>
<a href="#set">Множество</a>
<a href="#typle">Кортежи</a>
<a href="#diction">Словарь</a>
<a href="#collections">Коллекции (обобчающая)</a>
<a href="#generator">Все о генераторах</a>
<a href="#gener">Генератор коллекций</a>
<a href="#table">Прямоугольная матрица</a>
<a href="#user_struct">Пользовательские структуры данных</a>
</div>
<div class="content">
<b>Структуры данных</b> представляют собой различные типы данных. Основные (встроенные) структуры данных: список, кортеж, словарь, множество, строки.<br>
И <a href="#user_struct">пользовательские структуры данных</a>.
<h3 align=center><a name="string">Строки</h3>
Ссылки: <a href="https://metanit.com/python/tutorial/5.1.php">Строки</a>
<p>
Строка представляет последовательность символов в кодировке Unicode, заключенных в кавычки. Причем для определения строк Python позволяет использовать как одинарные, так и двойные кавычики:
<pre>
message = "Hello World!"
print(message)  # Hello World!
 
name = 'Tom'
print(name)  # Tom
</pre>
Если строка длинная, ее можно разбить на части и разместить их на разных строках кода. В этом случае вся строка заключается в круглые скобки, а ее отдельные части - в кавычки:
<pre>
text = ("Laudate omnes gentes laudate "
        "Magnificat in secula ")
print(text)
</pre>
Если же мы хотим определить многострочный текст, то такой текст заключается в тройные двойные или одинарные кавычки:
<pre>
'''
Это комментарий
'''
text = '''Laudate omnes gentes laudate
Magnificat in secula
Et anima mea laudate
Magnificat in secula 
'''
print(text)
</pre>
При использовани тройных одинарных кавычек не стоит путать их с комментариями: если текст в тройных одинарных кавычках присваивается переменной, то это строка, а не комментарий.
<h4>Управляющие последовательности в строке</h4>
Строка может содержать ряд специальных символов - управляющих последовательностей или escape-последовательности. Некоторые из них:
<p>
\ : позволяет добавить внутрь строки слеш
<p>
\' : позволяет добавить внутрь строки одинарную кавычку
<p>
\" : позволяет добавить внутрь строки двойную кавычку
<p>
\n : осуществляет переход на новую строку
<p>
\t : добавляет табуляцию (4 отступа)
<p>
Используем некоторые последовательностей:
<pre>
text = "Message:\n\"Hello World\""
print(text)
</pre>
Консольный вывод программы:
<pre>
Message:
"Hello World"
</pre>
Хотя подобные последовательности могут нам помочь в некоторых делах, например, поместить в строку кавычку, сделать табуляцию, перенос на другую строку. Но они также могут и мешать. Например:
<pre>
path = "C:\python\name.txt"
print(path)
</pre>
Здесь переменная path содержит некоторый путь к файлу. Однако внутри строки встречаются символы "\n", которые будут интерпретированы как управляющая последовательность. Так, мы получим следующий консольный вывод:
<pre>
C:\python
ame.txt
</pre>
Чтобы избежать подобной ситуации, перед строкой ставится символ r
<pre>
path = r"C:\python\name.txt"
print(path)
</pre>
<h4>Вставка значений в строку</h4>
Python позволяет встравивать в строку значения других переменных. Для этого внутри строки переменные размещаются в фигурных скобках {}, а перед всей строкой ставится символ f:
<pre>
userName = "Tom"
userAge = 37
user = f"name: {userName}  age: {userAge}"
print(user)   # name: Tom  age: 37
</pre>
В данном случае на место {userName} будет вставляться значение переменной userName. Аналогично на вместо {userAge} будет вставляться значение переменной userAge.
<h4>Обращение к символам строки</h4>
И мы можем обратиться к отдельным символам строки по индексу в квадратных скобках:
<pre>
string = "hello world"
c0 = string[0]  # h
print(c0)
c6 = string[6]  # w
print(c6)
 
c11 = string[11]  # ошибка IndexError: string index out of range
print(c11)
</pre>
Индексация начинается с нуля, поэтому первый символ строки будет иметь индекс 0. А если мы попытаемся обратиться к индексу, которого нет в строке, то мы получим исключение IndexError. Например, в случае выше длина строки 11 символов, поэтому ее символы будут иметь индексы от 0 до 10.
<p>
<b>Чтобы получить доступ к символам, начиная с конца строки</b>, можно использовать отрицательные индексы. Так, индекс -1 будет представлять последний символ, а -2 - предпоследний символ и так далее:
<pre>
string = "hello world"
c1 = string[-1]  # d
print(c1)
c5 = string[-5]  # w
print(c5)
</pre>
При работе с символами следует учитывать, что строка - это неизменяемый (immutable) тип, поэтому если мы попробуем изменить какой-то отдельный символ строки, то мы получим ошибку, как в следующем случае:
<pre>
string = "hello world"
string[1] = "R"
</pre>
Мы можем только полностью переустановить значение строки, присвоив ей другое значение.
<h4>Перебор строки</h4>
С помощью цикла for можно перебрать все символы строки:
<pre>
string = "hello world"
for char in string:
    print(char)
</pre>
<h4>Получение подстроки</h4>
При необходимости мы можем получить из строки не только отдельные символы, но и подстроку. Для этого используется следующий синтаксис:
<pre>
string[:end]: извлекается последовательность символов начиная с 0-го индекса по индекс end (не включая)

string[start:end]: извлекается последовательность символов начиная с индекса start по индекс end (не включая)

string[start:end:step]: извлекается последовательность символов начиная с индекса start по индекс end (не включая) через шаг step
</pre>
Здесь start, end, step - это не ключевые слова, а индексы символов в строке и шаг.
<p>
Используем все варианты получения подстроки:
<pre>
string = "hello world"
 
# с 0 до 5 индекса
sub_string1 = string[:5]
print(sub_string1)      # hello
 
# со 2 до 5 индекса
sub_string2 = string[2:5]
print(sub_string2)      # llo
 
# с 2 по 9 индекса через один символ
sub_string3 = string[2:9:2]
print(sub_string3)      # lowr
</pre>
<h4>Объединение строк</h4>
Одной из самых распространенных операций со строками является их объединение или конкатенация. Для объединения строк применяется операция сложения:
<pre>
name = "Tom"
surname = "Smith"
fullname = name + " " + surname
print(fullname)  # Tom Smith
</pre>
С объединением двух строк все просто, но что, если нам надо сложить строку и число? В этом случае необходимо привести число к строке с помощью функции str():
<pre>
name = "Tom"
age = 33
info = "Name: " + name + " Age: " + str(age)
print(info)  # Name: Tom Age: 33
</pre>
<h4>Повторение строки</h4>
Для повторения строки определенное количество раз применяется операция умножения:
<pre>
print("a" * 3)  # aaa
print("he" * 4)  # hehehehe
</pre>
<h4>Сравнение строк</h4>
Особо следует сказать о сравнении строк. Сравнение производится в лексикографическом порядке. При сравнении строк принимается во внимание символы и их регистр. Так, цифровой символ условно меньше, чем любой алфавитный символ. Алфавитный символ в верхнем регистре условно меньше, чем алфавитные символы в нижнем регистре. Например:
<pre>
str1 = "1a"
str2 = "aa"
str3 = "Aa"
print(str1 > str2)  # False, так как первый символ в str1 - цифра
print(str2 > str3)  # True, так как первый символ в str2 - в нижнем регистре
</pre>
Поэтому строка "1a" условно меньше, чем строка "aa". Вначале сравнение идет по первому символу. Если начальные символы обоих строк представляют цифры, то меньшей считается меньшая цифра, например, "1a" меньше, чем "2a".
<p>
Если начальные символы представляют алфавитные символы в одном и том же регистре, то смотрят по алфавиту. Так, "aa" меньше, чем "ba", а "ba" меньше, чем "ca".
<p>
Если первые символы одинаковые, в расчет берутся вторые символы при их наличии.
<p>
Зависимость от регистра не всегда желательна, так как по сути мы имеем дело с одинаковыми строками. В этом случае перед сравнением мы можем привести обе строки к одному из регистров.
<p>
Функция lower() приводит строку к нижнему регистру, а функция upper() - к верхнему.
<pre>
str1 = "Tom"
str2 = "tom"
print(str1 == str2)  # False - строки не равны
 
print(str1.lower() == str2.lower())  # True
</pre>
<h4>Поиск в строке</h4>
С помощью выражения term in string можно найти подстроку term в строке string. Если подстрока найдена, то выражение вернет значение True, иначе возвращается значение False:
<pre>
text = "hello world"
exist = "hello" in text
print(exist)    # True
 
exist = "sword" in text
print(exist)    # False
</pre>
Соответственно с помощью операторов not in можно проверить отсутствие подстроки в строке:
<pre>
text = "hello world"
print("hello" not in text)    # False
print("sword" not in text)    # True
</pre>
<a name="metod_str"><h3 align=center>Методы строки</h3>
Полный список строковых методов есть в <a href="https://pyplanet.ru/article/string-methods.html">нашем справочнике</a>.
<p>
<ol>

<li> <b>replace()</b><br>
Метод replace() в Python используется для замены всех вхождений указанной подстроки в строке, на другую подстроку. Возвращает 
другую измененную строку.
<p>
Синтаксис
<br><b>str.replace(old, new[, count])</b>
<p>
где:
<br>str — строка, в которой нужно выполнить замену;<br>
old — подстрока, которую нужно заменить;<br>
new — новая подстрока, которой нужно заменить все вхождения old;<br>
count — необязательный параметр, который указывает, сколько раз нужно выполнить замену. По умолчанию заменятся все вхождения 
old.
<p>
Примеры использования метода replace():<br>
Ваша задача - написать функцию, которая принимает строку и возвращает новую строку с удаленными гласными. Например, строка "This website is for losers LOL!" станет "Ths wbst s fr lsrs LL!".
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def disemvowel(string_):
    vowels = 'aeiouAEIOU'
    for vowel in vowels:
        string_ = <b>string_.replace(vowel, '')</b>

    return string_

print(disemvowel("This website is for losers LOL!"))
</pre></td></tr></table>
<p>
<li> <b>count(arg)</b><br>
считает сколько раз в строке встречается символ(ы) arg
<pre>
s = input()
n = s.count('g') + s.count('G') + s.count('c') + s.count('C')
print(n * 100 / len(s))</pre>
<p>
<li> <b>upper()</b><br>
переводит строку в верхний регистр
<p>
<li> <b>lower()</b><br>
наоборот в нижний регистр
<p>
<li> <b>find(arg)</b><br>
выдает индекс arg в строке. Если arg не будет в строке, то результат будет -1<br>
более рекомендуется конструкция: <b>if 'arg' in s:</b><br>
Нужно иметь в виду, что метод создает новый объект, как результат выполнения метода, но оригинальный объект не меняется.
<p>
Синтаксис:
<pre>S.find(sub[, start[, end]]) -> int</pre>
Возвращает наименьший индекс в S, где находится подстрока sub, так что sub содержится в S[start:end].  Необязательные
аргументы start и end интерпретируются как в нотации slice.<br>
Возвращает значение -1 в случае сбоя.
<p>
<b>Задача: вывести все индексы вхождения субстроки в строку.</b><br>
В Python есть несколько способов поиска подстроки в строке. Например, можно использовать методы find() и rfind(), которые возвращают индекс первого вхождения подстроки и индекс последнего вхождения подстроки соответственно.<br>
Однако, эти методы не предоставляют информации обо всех вхождениях подстроки в строку. Например, если необходимо найти все вхождения слова «мир» в предложении «Привет, мир! Мир — прекрасен», то find() и rfind() не смогут с этим справиться.<br>
В этом случае можно использовать регулярные выражения или цикл для прохождения по строке и поиска всех вхождений подстроки.
<p>
<b>Использование регулярных выражений</b><br>
Модуль re в Python предоставляет <b>функцию finditer()</b>, которая возвращает итератор, содержащий все вхождения подстроки в строке:
<pre>
import re
 
s = "Привет, мир! Мир - прекрасен"
matches = re.finditer('мир', s)
indices = [match.start() for match in matches]
 
print(indices)  # [8, 13]
</pre>
<b>Использование цикла</b>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Мой способ:
<pre>
s = input()
sub_s = input()

lst_ind = []
index = -1  # начинаем поиск с начала строки
 
while True:
    # находим следующее вхождение подстроки
    index = s.find(sub_s, index + 1)
    
    # если вхождение не найдено, выходим из цикла
    if index == -1:
        break

    lst_ind.append(index)

print(len(lst_ind)) 
if len(lst_ind) != 0:
    print(*lst_ind)
else:
    print(-1)
</pre>
</td>
<td valign=top>
Получше решение:
<pre>
input_str = input()
req_str = input()
pos = 0

if req_str not in input_str:
    print(-1)
else:
    while True:
        pos = input_str.find(req_str, pos)
        if pos == -1:
            break
        else:
            print(pos, end=' ')
            pos += 1
</pre></td></tr></table>
<p>
<li> <b>strip()</b><br>
Функция strip() – это предопределенная библиотечная функция Python. Она используется для возврата копии исходной строки путем 
удаления начальных и конечных пробелов, символов, переданных в функцию strip().
<br>Другими словами, это функция строки, которая удаляет символы как с левого, так и с правого конца строки, указывая набор 
символов для функции strip() в качестве аргумента. По умолчанию она удаляет пробелы из начальной и конечной строки, если в 
функцию strip() в Python не передается аргумент.
<p>
Синтаксис<br>
<b>объект строки.strip('parametr')</b>
<p> 
Параметр strip() является необязательным. Если программист не передает какой-либо параметр функции strip(), она удаляет 
начальные и конечные пробелы из строк.<br>
Если набор заданного параметра передается в функцию strip(), она удаляет символы из исходной строки.<br>
Возвращаемое значение: возвращает другой объект строки, равной исходной минус удаленный набор символов (параметр) или пробелов 
в конце и начале исходной строки.
<pre>
>>> a = ' abcd e '
>>> b = a.strip()
>>> b
'abcd e'
>>> b = b.strip('e')
>>> b
'abcd '
</pre>
<li> <b>Метод ljust() и rjust()</b><br>
Источник: <a href="https://pythonstart.ru/string/ljust-rjust">Метод ljust() и rjust() в Python</a>
<p>
Метод ljust() возвращает выровненную по левому краю строку заданной минимальной ширины. Синтаксис метода:
<pre>
string.ljust(width[, fillchar])
</pre>
Здесь fillchar ‒ необязательный параметр.
<p>
Параметры:<br>
Команда принимает два параметра:<br>
width ‒ ширина данной строки. Если ширина меньше или равна длине строки, возвращается исходная строка. 
<br>fillchar (необязательно) ‒ символ для заполнения оставшегося места по ширине
<p>
Возвращаемое значение<br>
Метод в Python возвращает выровненную по левому краю строку в пределах заданной минимальной ширины. Если fillchar определен, он также заполняет оставшееся пространство определенным символом.
Пример:
<pre>
string = 'cat'
width = 5

print(string.ljust(width, '!'))
</pre>
Вывод:<br>
cat!!
<p>
Если вы хотите выровнять строку по правому краю, используйте rjust().<br>
В первом параметре метода передаётся число для определения длины строки, во втором необязательном параметре — символ-заполнитель, по умолчанию это пробел.
<pre>
txt = 'abc'
print(txt.rjust(6, '!'))
</pre>
Результат выполнения кода: "!!!abc"
<li> <b><a name="split">Метод split() - преобразование строки в список слов</b><br>
Синтаксис:
<pre>
str.split(sep=None, maxsplit=-1)
</pre>
Возвращает список слов в строке, используя sep в качестве строки-разделителя. Если задан параметр maxsplit, выполняется разбиение не более чем на maxsplit (таким образом, в списке будет не более maxsplit+1 элементов). Если значение maxsplit не указано или равно -1, то количество разбиений не ограничено (выполняются все возможные разбиения).
<p>
Примеры:
<pre>
>>> lst = 'a b c d'
>>> lst.split() # без аргумента, разделение будет по умолчанию по пробелу
['a', 'b', 'c', 'd']
>>> lst = 'a : b : c : d'
>>> lst.split(':')
['a ', ' b ', ' c ', ' d']
>>> lst.split(' : ')
['a', 'b', 'c', 'd']
ещё:
>>> 'a, b, c, d'.split(',')
['a', ' b', ' c', ' d']
>>> 'a, b, c, d'.split(', ')
['a', 'b', 'c', 'd']
>>> '1,2,3'.split(',')
['1', '2', '3']
>>> '1,2,3'.split(',', maxsplit=1)
['1', '2,3']
>>> '1,2,,3,'.split(',')
['1', '2', '', '3', '']
>>> '1<>2<>3<4'.split('&lt;>')
['1', '2', '3<4']

# <b>Отличие между list() и split()</b>
str = 'string     with        multi spaces'

print(lst.split())  # ['string', 'with', 'multi', 'spaces']
print(list(str))  # ['s', 't', 'r', 'i', 'n', 'g', ' ', ' ', ' ', ' ', ' ', 'w', 'i', 't', 'h', ' ', ' ', ' ', ' ', ' ', ' ',
 ' ', ' ', 'm', 'u', 'l', 't', 'i', ' ', 's', 'p', 'a', 'c', 'e', 's']
</pre>
<p>
<li> <b>Метод index()</b><br>
Метод index() возвращает индекс указанного элемента в списке.<br>
 Синтаксис метода в Python:
<pre>
list.index(element, start, end)
</pre>
element – элемент для поиска;<br>
start (необязательно) – начать поиск с этого индекса;<br>
end (необязательно) – искать элемент до этого индекса.<br>
Метод возвращает индекс данного элемента в списке. Если элемент не найден, возникает исключение ValueError.<br>
Примечание: Команда возвращает только первое вхождение соответствующего элемента.
<p>
<li> <b>Метод capitalize():</b><br>
Метод capitalize() преобразует первый символ строки в верхний регистр и переводит в нижний регистр все остальные символы, если таковые имеются.<br>
Синтаксис:
<pre>
string.capitalize()
</pre>
Функция не принимает никаких параметров. Возвращает строку, в которой первая буква заглавная, а все остальные символы ‒ строчные. Это не изменяет исходную строку.
<p>
В Python часто возникает <b>задача преобразования первой буквы каждого слова в строке в заглавную</b>. Например, есть строка ‘hello world’, и необходимо преобразовать ее в ‘Hello World’. Это можно сделать несколькими способами.<br>
Использование встроенного метода title()
Самый простой способ заключается в использовании <b>встроенного метода title()</b>, который делает первую букву каждого слова в строке заглавной.<br>
Пример:
<pre>
s = 'hello world'
s = s.title()
print(s)  # Вывод: 'Hello World'
</pre>
Использование метода capitalize() с разделением строки<br>
Если нужно больше контроля над процессом, можно использовать комбинацию методов split(), capitalize() и join().<br>
Метод split() разделяет строку на список слов, capitalize() делает первую букву слова заглавной, а join() объединяет слова обратно в строку.<br>
Пример:
<pre>
s = 'hello world'
s = ' '.join(word.capitalize() for word in s.split())
print(s)  # Вывод: 'Hello World'
</pre>
Важно отметить, что <b>метод title() делает все остальные буквы в слове строчными, в то время как capitalize() не изменяет остальные буквы в слове</b>.
<p>
<li> <h4>Метод isdigit()</h4>
Метод isdigit() возвращает True, если все символы в строке являются цифрами. Если нет, возвращается False.
<p>
Синтаксис:
<pre>
 string.isdigit()
</pre>
Команда возвращает:<br>
Истинно(True), если все символы в строке являются цифрами.<br>
Ложь(False), если хотя бы один символ не является цифрой.<br>
Пример:
<pre>
s = "28212" 
print(s.isdigit()) # Ответ True

s = "Mo3 nicaG el l22er" 
print(s.isdigit()) # Ответ False
</pre>
В Python надстрочные и подстрочные индексы (обычно записываемые с использованием Unicode) также считаются цифровыми символами. Следовательно, если строка содержит эти символы вместе с десятичными символами, isdigit() возвращает True.
<p>
Римские цифры, числители валют и дроби (обычно записываемые в кодировке Unicode) считаются числовыми символами, но не цифрами. Isdigit() возвращает False, если строка содержит эти символы. Чтобы проверить, является ли символ числовым или нет, вы можете использовать метод isnumeric().
<p>
<li> <b>Методы startswith() и endswith()</b><br>
Метод startswith используется для определения того, начинается ли строка с указанных символов или нет. Метод endswith используется для определения того, заканчивается ли строка указанными символами или нет. Эти две функции возвращают True или False.
<p>
Синтаксис:
<pre>
yourstring.endswith("end_string")
</pre>
Этот метод возвращает True, если end_string совпадает с концом yourstring, иначе False.
<p>
<li> <b>Метод isalpha()</b><br>
Синтаксис:
<pre>
<font color=brown size=4>string.isalpha()</font>
</pre>
Метод isalpha() возвращает True, если все символы в строке являются алфавитными. Если нет, возвращается False.
</ol>
<pre>


</pre>
<h3 align=center>Функции строки</h3>
<h4>Функции ord и len</h4>
Поскольку строка содержит символы Unicode, то с помощью функции ord() мы можем получить числовое значение для символа в кодировке Unicode:
<pre>
print(ord("A"))     # 65
</pre>
Для получения длины строки можно использовать функцию len():
<pre>
string = "hello world"
length = len(string)
print(length)   # 11
</pre>
<h4>str()</h4>
Преобразует объект в скобках в строку.<br>
Параметры<br>
Функция str() принимает три параметра:
<p>
object — чье строковое представление должно быть возвращено<br>
encoding — в которую необходимо декодировать данный байтовый объект (может быть UTF-8, ASCII и т. д.)<br>
errors — ответ при сбое декодирования (может быть строгим, игнорировать, заменять и т. д.)<br>
Функция str() возвращает:
<p>
печатное строковое представление данного объекта<br>
строковое представление данного байтового объекта в предоставленной кодировке<br>
Примеры
<pre>
# строковое представление 
name = str('Коля')
print(name)

# строковое представление целого числа
age = str(24)
print(age)

# строковое представление числовой строки
height = str('175см')
print(height)

# Результат

Коля
24
175см
</pre>
<p>
2. <b>Функция sorted()</b><br>
Служит для сортировки итерируемых объектов и в частности может применяться для сортировки строк.<br>
Синтаксис:
<pre>
sorted(iterable, key=None, reverse=False)
</pre>
Параметры функции:<br>
`iterable` — строка, список, кортеж, множество, словарь.
<p>
`key` — необязательный параметр. Если указать ключ, то сортировка будет выполнена по функции этого ключа.
<p>
`reverse` — необязательный параметр. По умолчанию сортировка выполняется по возрастанию. Если указать `reverse=True`, то можно отсортировать по убыванию.
<p>
Функция возвращает список отсортированных элементов.
<p>
Пример:<br>
print(sorted(input().lower()) == sorted(input().lower()))
<p>
Здесь input() возвращает строку. Метод lower() переводит эту строку полностью в нижний регистр.
<pre>

</pre>
<h4>Срез (диапазон строки)</h4>
Общий шаблон:
<pre>
s = 'stroka'
print(s[x1:x2:x3]</pre>
Здесь напечатается строка из символов, где x1 - это индекс первого нужного символа в строке. Если не указан, то по умолчанию 
равен 0 Может иметь отрицательное значение, тогда индекс считается с првой стороны, <b>но все равно далее символы смотрятся в 
правую сторону.</b><br>
x2 -  индекс последнего нужного символа. Может иметь отрицательное значение, то есть отсчет с правой стороны.<br>
x3 - шаг приращения индекса, если не указан, то по умолчанию 1. Может иметь отрицательное значение. s[::-1] просто перевернёт 
строку.
</ul>
<h4>Поиск строк между определенными строками</h4>
Пример: файл https://stepik.org/media/attachments/lesson/209719/2.html содержит статью с Википедии про язык Python. В этой статье есть теги code, которыми выделяются конструкции на языке Python. Вам нужно найти все строки, содержащиеся между тегами %lt;code> и &lt;/code> и найти те строки, которые встречаются чаще всего и вывести их в алфавитном порядке, разделяя пробелами.<br>
Решение:
<pre>
from urllib.request import urlopen
import re
from collections import Counter

html = urlopen("https://stepik.org/media/attachments/lesson/209719/2.html").read().decode('utf-8')

pattern = '&lt;code>(.*?)&lt;/code>'
elements_count = Counter(sorted(re.findall(pattern, html)))
print(elements_count)
</pre>
Здесь с помощью urlopen открываем веб-страницу.<br>
Далее используем регулярные выражения. В pattern = '&lt;code>(.*?)&lt;/code>' точка означает любой символ кроме перевода строки. Звездочка означает от нуля и более символов. ? убирает жадность.<br>
Функция re.findall выдает список всех вхождений pattern в строку html. Непонятно только почему в содержимое элемента списка не входят открывающий и закрывающий теги code.<br>
Функция sorted() сортирует список в алфавитном порядке.<br>
Функция Counter создает на основе списка словарь, ключ = элементу, а значение = сколько раз этот элемент входит в список.
<pre>



</pre>
<a name="unicode"><h3 align=center>Unicode, что это и как использовать</h3>
Ссылки: <a href="https://timeweb.cloud/tutorials/python/kak-rabotat-s-unicode-v-python">Как работать с Unicode в Python: руководство</a><br>
<a href="https://www.8host.com/blog/kak-rabotat-s-unicode-v-python/">Как работать с Unicode в Python</a><br>
<a href="https://otus.ru/journal/kodirovki-v-python-i-unicode/">Кодировки в Python и Unicode</a>
<h4>Кодировки: общая информация</h4>
В общем виде кодировка предполагает перевод любого символа в понятный компьютеру вид, когда каждая буква, число или иной знак (например, !, %, ?) записывается в двоичном виде, как последовательность нулей и единиц.
<p>
Unicode (Юникод)  — это стандарт кодирования символов для большинства компьютеров. Он гарантирует, что текст — включая буквы, символы, эмодзи и даже управляющие символы — будет выглядеть одинаково на разных устройствах, платформах и в цифровых документах, независимо от операционной системы или программного обеспечения. Это важная составляющая интернета и компьютерной индустрии в целом. Без него всё было бы сложно и хаотично.
<p>
Unicode сам по себе не является кодировкой, а больше похож на базу данных почти всех возможных символов. В нём есть кодовая точка (идентификатор для каждого символа в базе данных), которая может иметь значение от 0 до 1,1 миллиона – как видите, скорее всего в ближайшее время эти уникальные кодовые точки не закончатся.<br>
Каждая кодовая точка в Unicode обозначается <b>U+n</b>, где U+ — кодовая точка Unicode, а n — это набор для символа из четырех-шести шестнадцатеричных цифр. Unicode намного надежнее ASCII, в котором только 128 символов. Обмен цифровым текстом с помощью ASCII сложнее, так как он основан на американском английском и не поддерживает символы с диакритическими знаками. А в Unicode почти 150 000 символов и он охватывает символы всех языков мира.
<p>
Здесь стоит немного остановиться на системах счисления, поскольку компьютеры не используют привычную нам десятичную, а работают преимущественно с двоичными, восьмеричными и шестнадцатеричными значениями. Это важно, поскольку, в отличие от ASCII с его восьмеричной системой счисления, Юникод использует шестнадцатеричную систему счисления, <font color=red>которая содержит 216 возможных символов</font>.
<h4>Системы счисления и работа с ними в Python</h4>
Если мы попробуем представить, допустим, число 12 в шестнадцатеричном виде в Python, то получим следующее (введите в интерпретаторе первую строку из примера ниже и вы увидите, что Python выдаст вам 18):
<pre>
>>> int('12', base=16)
18
</pre>
Здесь 12 - это число в системе счисления на которую указывает аргумент base. base=16 - это шестнадцатиричная система счисления. 18 - число в десятичной системе, равное 12 в шестнадцатиричной системе.<br>
Почему так получилось? Дело в том, что первые 16 символов в такой кодировке — это значения от 0 до 9 плюс латинские буквы A-F:
<pre>
десят. - 16-тер.
   0 = 0
   1 = 1
   2 = 2
   3 = 3
   4 = 4
   5 = 5
   6 = 6
   7 = 7
   8 = 8
   9 = 9
   10 = A
   11 = B
   12 = C
   13 = D
   14 = E
   15 = F
</pre>
Проверить это несложно, введите, например:
<pre> 
>>> int('F', base=16)
15
</pre>
A занимает 10-е место после 0-9. 16-м символом, соответственно, будет F, далее после F нет букв, идет 11, а затем 12, то есть значение 12 занимает 18-е место в шестнадцатеричной системе счисления, потому Python и выдал нам такой результат. С помощью аргумента base мы можем запросить нужное нам число и в любой другой системе счисления. Допустим, в привычной десятичной или восьмеричной, а далее укажем и шестнадцатеричную:
<pre> 
>>> int('25', base=10)
25
  
>>> int('25', base=8)
21

>>> int('25', base=16)
37
</pre>
Но будьте осторожны, поскольку функция int() принимает только целочисленные значения и значения ряда букв (от A до F), которые также выступают в качестве чисел в шестнадцатеричной системе. Понять такуют концепцию не сложно, просто вспомните, что в латыни все числа тоже передавались буквами: III, V, VII, X, LIV и т. д. Поэтому следующая запись вызовет ошибку, так как символу L числовое значение не присвоено ни в одной из систем:
<pre>
>>> int('L', base=16)
Traceback (most recent call last):
  File "&lt;pyshell#6>", line 1, in &lt;module>
    int('L', base=16)
ValueError: invalid literal for int() with base 16: 'L'
</pre>
Как видим, Python нам указал и причину ошибки: недопустимый литерал для функции int() с базовой системой счисления 16. А вот с F всё будет в порядке в шестнадцатеричной системе счисления:
<pre>  
>>> int('F', base=16)
15
</pre>
Но не во всех остальных, где эта буква не используется в качестве числового значения, например:
<pre> 
>>> int('F', base=8)
Traceback (most recent call last):
  File "&lt;pyshell#12>", line 1, in &lt;module>
    int('F', base=8)
ValueError: invalid literal for int() with base 8: 'F'
</pre>
Кроме того, в Python существует и более удобное представление числовых значений в машинных системах счисления: двоичной, восьмеричной и шестнадцатеричной. Взгляните на следующие примеры:
<pre>
>>> 10
10

>>> 0b10
2

>>> 0o10
8

>>> 0x10
16
</pre>
В первом случае мы не использовали никакого префикса для числа, поэтому интерпретатор нам выдал значение числа 10 в привычной для нас десятичной системе счисления. <b>0b</b> — это префикс для представления числа в двоичном виде, <b>0o</b> — в восьмеричном и, наконец, <b>0x</b> — в шестнадцатеричном. Таким образом, если мы хотим узнать, какое место занимает числовой символ F в шестнадцатеричной системе счисления (чему равен в 10-тичной системе), то нам нужно ввести в интерпретаторе следующее:
<pre> 
>>> 0xF
15
</pre>
С остальными же префиксами (и без них) мы получим предсказуемую ошибку. Теперь мы готовы изучать Юникод.
<h4 align=center>основы работы Unicode в Python</h4>
Собственно, называть Юникод кодировкой не совсем корректно, поскольку он не извлекает биты, а только использует <b>кодовые точки</b>. Поэтому более правильно считать Юникод базовым набором символов. Наиболее же распространенным стандартом кодировки, использующим Unicode в качестве такого набора символов, является UTF-8, с которым вы наверняка сталкивались, если занимались конверсией текстов: например, в редакторе Notepad++. UTF-8 как раз и предназначен для конверсии символов Юникода в понятный компьютеру вид.
<h4>Конвертирование кодовых точек Unicode в Python</h4>
Кодирование — это процесс представления данных в читаемой компьютером форме. Существуют разные способы кодирования данных — ASCII, Latin-1 и т. д. У каждой кодировки свои сильные и слабые стороны, но пожалуй, самой распространенной является UTF-8 —  тип кодирования, который отображает символы со всего мира в одном наборе. То есть, UTF-8 это незаменимый инструмент для всех, кто работает с интернационализированными данными. В целом, UTF-8 справляется с многими задачами. Он относительно эффективен и может работать в разных программах. UTF-8 конвертирует кодовую точку Unicode в понятные компьютеру шестнадцатеричные байты. Другими словами, Unicode – это маппинг, а UTF-8 позволяет компьютеру понять этот маппинг.
<p>
В Python 3 кодировка строк по умолчанию – UTF-8, значит, любая кодовая точка Unicode в строке Python автоматически конвертируется в соответствующий символ.
<p>
Сейчас мы создадим символ авторского права (©) с помощью его кодовой точки Unicode в Python. Сначала запустите интерактивную консоль Python в терминале, а затем введите:
<pre>
>>> s =  '\u00A9'
>>> s
</pre>
В этом коде мы создали строку s с кодовой точкой Unicode \u00A9. Как упоминалось ранее, поскольку строка Python по умолчанию использует кодировку UTF-8, вывод значения s автоматически заменяет его на соответствующий символ Unicode. Обратите внимание, что \u в начале кода обязателен. Без него Python не сможет конвертировать кодовую точку. В выводе получим соответствующий символ Unicode:<br>
'©'<br>
В Python есть встроенные функции для кодирования и декодирования строк. Функция encode() конвертирует строку в байтовую строку.
<p>
Для этого откройте интерактивную консоль Python и введите код:
<pre>
>>> ''.encode('utf-8')
</pre>
В результате получим байтовую строку символа:
<pre>
b'\xf0\x9f\x85\xa5'
</pre>
Обратите внимание, что перед каждым байтом стоит \x, значит, это шестнадцатеричное число.
<p>
Далее с помощью функции decode() конвертируем байтовую строку в обычную. Функция decode() принимает в качестве аргумента тип кодировки. Отметим, что функция decode() может декодировать только байтовую строку, которая задается с помощью буквы b в начале строки. Удаление b приведет к ошибке AttributeError.
<p>
В консоли введите:
<pre>
>>> b'\xf0\x9f\x85\xa5'.decode('utf-8')
</pre>
Получим следующий вывод:
<pre>
''
</pre>
Другие примеры:
<pre>  
>>> "таймвеб".encode("utf-8")
b'\xd1\x82\xd0\xb0\xd0\xb9\xd0\xbc\xd0\xb2\xd0\xb5\xd0\xb1'

>>> b'\xd1\x82\xd0\xb0\xd0\xb9\xd0\xbc\xd0\xb2\xd0\xb5\xd0\xb1'.decode("utf-8")
'таймвеб'
</pre>
Мы получили набор из 14 двухбайтовых значений. Дело в том, что каждый кириллический символ кодируется в виде двух таких значений. А вот если мы попробуем записать название латиницей и закодируем его, то получим следующее:
<pre>
>>> "timeweb".encode("utf-8")
b'timeweb'

>>> b'timeweb'.decode("utf-8")
'timeweb'
</pre>
Для латинских символов без диакритических знаков кодировка максимально простая и понятная. А теперь давайте попробуем написать что-нибудь по-французски с их «фирменными» значками:
<pre>
>>> "répéter".encode("utf-8")
b'r\xc3\xa9p\xc3\xa9ter'

>>> b'r\xc3\xa9p\xc3\xa9ter'.decode("utf-8")
'répéter'
</pre>
Здесь хорошо видно, что для буквы é тоже используется свой двухбайтовый набор символов, как и для кириллицы. В результате латинские буквы без диакритических знаков в кодировке UTF-8 остались как есть, а символ é был преобразован в двухбайтовое значение.
<h4>Как подключить метод Unicode в Python</h4>
Python 3 имеет полную поддержку Юникода и даже реализован с его помощью, поэтому явного указания в начале файла .py на UTF-8 не требуется. И это значит, что, например, присвоение répéter = "~/myworks/répéter.pdf" Python воспримет без каких-либо проблем (однако оно всё равно не рекомендуется, поскольку с этими символами могут возникнуть проблемы при работе в самой системе и других программах). А еще это значит, что кодировать и декодировать значения в Python 3 можно без явного указания кодировки, то есть так:
<pre>
>>> "timeweb".encode()
b'timeweb'

>>> b'timeweb'.decode()
'timeweb'

>>> "répéter".encode()
b'r\xc3\xa9p\xc3\xa9ter'

>>> b'r\xc3\xa9p\xc3\xa9ter'.decode()
'répéter'
</pre>
Как видим, интерпретатор обработал все значения корректно, никаких ошибок. Однако указывать кодировку всё же рекомендуется, поскольку UTF-8 хоть и наиболее распространена, но всё же не универсальна и поддерживается пока не везде.
<p>
Теперь у вас есть базовое понимание интерпретации Unicode в Python. Далее мы разберем встроенный в Python модуль unicodedata, чтобы применить расширенные методы Unicode для строк.
<h4>Функция list()</h4>
Полезным может оказаться побайтовый вызов значений закодированных символов. Делается это при помощи функции list():
<pre>
>>> "таймвеб".encode("utf-8")
b'\xd1\x82\xd0\xb0\xd0\xb9\xd0\xbc\xd0\xb2\xd0\xb5\xd0\xb1'

>>> list(b'\xd1\x82\xd0\xb0\xd0\xb9\xd0\xbc\xd0\xb2\xd0\xb5\xd0\xb1')
[209, 130, 208, 176, 208, 185, 208, 188, 208, 178, 208, 181, 208, 177]
</pre>
<h4>Другие кодировки в Unicode</h4>
Таблица символов Python Unicode objects поистине огромна: только основная ее часть включает 65535 символов, куда входят все латинские, кириллические, греческие, арабские и некоторые другие с различными диакритическими знаками. Остальная часть символов зарезервирована для языков с иероглифической письменностью и разнообразных значков (например, эмодзи). Но UTF-8 не единственная из используемых кодировок. Также определенную популярность имеют UTF-16 и UTF-32. И отношения между ними такие же сложные, как и между расширениями ASCII. Давайте сравним:
<pre>
>>> word = "τφχψ"
>>> codedata = word.encode("utf-8")
>>> codedata.decode("utf-8")
'τφχψ'
>>> codedata.decode("utf-16")
'蓏蛏蟏裏'
>>> codedata.decode("utf-32")
Traceback (most recent call last):
  File "&lt;pyshell#55>", line 1, in &lt;module>
    codedata.decode("utf-32")
UnicodeDecodeError: 'utf-32-le' codec can't decode bytes in position 0-3: code point not in range(0x110000)
</pre>
Как видим, греческие символы в кодировке UTF-16 преобразовались в… японские, а попытка их представления в кодировке UTF-32 и вовсе привела к ошибке. И это серьезный повод стараться использовать только общепринятую, которой является UTF-8, иначе в работе ваших программ в разных окружениях могут случаться сбои.
<h4>Встроенные функции Python</h4>
Эти полезные функции расширят ваши возможности при работе с кодировками и помогут выполнять следующее:
<p>
ascii() — служит для перевода значения в кодировку ASCII;
<p>
bin() — дает двоичное значение целого числа;
<p>
oct() — дает восьмеричное значение целого числа;
<p>
hex() — дает шестнадцатеричное значение целого числа;
<p>
bytes() — представляет значение в побайтовом виде;
<p>
str() — представляет значение в строковом виде;
<p>
int() — представляет значение в целочисленном виде.
<p>
Чтобы узнать десятичное значение числа в шестнадцатеричной системе используется синтаксис:
<pre>
>>> int('1F600', 16)
128512
>>> int('1F64F', 16)
128591
>>> 
</pre>
<p>
Теперь конкретные примеры:
<pre>  
>>> ascii('répéter')
"'r\\xe9p\\xe9ter'"

>>> ascii(32)
'32'

>>> bin(32)
'0b100000'

>>> oct(32)
'0o40'

>>> hex(32)
'0x20'

>>> bytes(18)
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'

>>> str(32)
'32'

>>> int('32')
32
</pre>
<h4>Прямой ввод строковых значений</h4>
Благодаря тому, что Python имеет полную поддержку UTF-8, мы можем ввести в качестве строкового значения практически любой набор символов, который будет корректно обработан:
<pre> 
>>> japanese = '蓏蛏蟏裏'
>>> print(japanese)
蓏蛏蟏裏
</pre>
Как видим, интерпретатор не выдал ошибку и в переменной japanese у нас теперь хранятся иероглифы. Еще один экзотический пример:
<pre> 
>>> arabic = 'سامثعبان كبير غير'
>>> print(arabic)
ثعبان كبير غير سام
>>> 
</pre>
Мы скопировали Python по-арабски и сохранили в переменной arabic. И интерпретатор тоже обработал это корректно, с учетом даже направления письма, что нетрудно проверить, попросив Python вывести эти символы в кодировке UTF-8:
<pre>
>>> arabic.encode("utf-8")
b'\xd8\xab\xd8\xb9\xd8\xa8\xd8\xa7\xd9\x86 \xd9\x83\xd8\xa8\xd9\x8a\xd8\xb1 \xd8\xba\xd9\x8a\xd8\xb1 \xd8\xb3\xd8\xa7\xd9\x85'
</pre>
И затем декодируем первый по счету блок:
<pre>
>>> b'\xd8\xab\xd8\xb9\xd8\xa8\xd8\xa7\xd9\x86'.decode("utf-8")
'ثعب
</pre>
Мы получили крайнее правое слово.
<p>
Таким образом, благодаря полной поддержке Юникода и встроенным функциям Python предлагает самые широкие возможности для работы с кодировкой UTF-8 и любыми другими.
<h4>Основные методы</h4>
Decode и incode - Методы, отвечающие за кодирование и декодирование строки в нужном формате.
<p>
ASCII - Функция, которая приводит string to ASCII.
<p>
<b>Chr, ord</b> - Взаимообратные операции. Первая демонстрирует Unicode-символ соответствующий to введенному числовому значению. Вторая вернет числовой аналог конкретной символьной записи.
<p>
Hex, bin, int, oct - Функции, позволяющие переводить числа to различные системы счисления.
<p>
Bytes - Работает так же, как и метод encode. Отличается расширенными возможностями.
<p>
Str - Перевод байтовых строк в обычные с использованием указанной ранее кодировки.
<p>
Unicodedata - Модуль, умеющий работать с базами данных всех Unicode-элементов.
<pre>





</pre>
<h3 align=center><a name="list" href="https://pyplanet.ru/article/array-list.html">Список</a></h3>
<b>Список</b> - переменная, содержащая список данных (элементов), внутри квадратных скобок идущих через запятую. Элементы списка можно в отличии от строки изменять.
<pre>
list = [] # пустой список
array = [1, 2, 3, 4, 5, 6, 7] # список из целых чисел int
print(type(array)) # класс list
ar = [2, 4.6, 'str', [1, 2, 3]] # список, состоящий из целого числа, из числа с плавающей точкой, из строки и из списка
</pre>

<h4>Индексация списков:</h4>
Индексация элементов списка имеет 2 способа, традиционная с 0 и с конца списка с -1.
Например есть список a = [1, 2, 3, 4]<br>
Тогда по обычной индексации элемент 1 имеет индекс 0 (a[0] = 1, a[1] = 2, a[2] = 3, a[3] = 4)<br>
По индексации с конца последний элемент имеет индекс -1 и далее левее на -1 индекс растет: a[-1] = 4, a[-2] = 3, a[-3] = 2, a[-4] = 1
<br>Индекс, в общем случае, не обязан быть числом. К элементам хеш-таблиц (которые мы рассмотрим позже) можно обращаться по строковому индексу.<br>
Также, поскольку списки - изменяемый тип данных, то по индексу возможно присвоение:
<pre>
>>> array = [1, 2, 3, 0, 1.4, -2]
>>> array[1] = 42
>>> array
[1, 42, 3, 0, 1.4, -2]</pre>
<p>
<b>Сложение списков:</b>
<pre>
array2 = [9, 10]
new_array = array + array2
new_array = [0, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</pre>
<p>
<b>Умножение на список:</b>:
<pre>
>>> list=['f',4,5,'r']
>>> list
['f', 4, 5, 'r']
>>> list*5
['f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r', 'f', 4, 5, 'r']
>>>
</pre>
<p>
<b>Как узнать входит ли 'stroka' в список list</b>
<pre>
if 'stroka' in list:
    # true, входит
else:
    # false, не входит</pre>
Можно для этой цели использовать модуль index(var):
<pre>
>>> students.index('Sasha')
2</pre>
Здесь если строка Sasha входит в список, то вернется индекс этого элемента, иначе вернет ошибку.
<p>
<b>Присвоение списков</b><br>
В питоне:
<pre>
>>> a = [1, 2, 3, 4]
>>> b = a
>>> b
[1, 2, 3, 4]
>>> a[3] = 10
>>> a
[1, 2, 3, 10]
>>> b
[1, 2, 3, 10]</pre>
Видно, что если изменили значение элемента в списке a, то изменится и список b, хотя обычно в других языках так не должно 
быть.<br>
<i>Когда вы пишите  a = [1, 2, 3], то а лишь указывает на список  [1, 2, 3], это как ярлык, который вы прикрепили к данному 
списку.
Затем, делая b=a, вы не копируете список, вы просто создаете новый ярлык к списку, на который указывает а.
Изменяя a, вы меняете также b. Потому﻿ что они указывают на один и тот же список.</i><br>
Чтобы a и b открепить друг от друга, нужно одному из них присвоить новый список (или любой объект другого типа).
<h4>Копирование списка</h4>
Чтобы скопировать список, создайте срез, содержащий весь исходный список без указания первого и второго индексов ( [:] ). Эта конструкция создает срез, который начинается с первого элемента и завершается последним; в результате создается копия всего списка.
<p>
Представьте, что вы создали список своих любимых блюд и теперь хотите создать отдельный список блюд, которые нравятся вашему другу. Пока вашему другу нравятся все блюда из нашего списка, поэтому вы можете создать другой список, просто скопировав наш:
<pre>
my_foods = ['pizza', 'falafel', 'carrot cake']
<b>friend_foods = my_foods[:]</b>

print("My favorite foods are:")
print(my_foods)
print("\nMy friend's favorite foods are:")
print(friend_foods)
</pre>
Сначала создается список блюд my_foods . Затем создается другой список friend_foods . Чтобы создать копию my_foods , программа запрашивает срез my_foods без указания индексов и сохраняет копию в friend_foods . При выводе обоих списков становится видно, что они содержат одинаковые данные.
<p>
Добавим новое блюдо в каждый список и покажем, что каждый из них отслеживает любимые блюда человека:
<pre>
my_foods.append('cannoli')
friend_foods.append('ice cream')

print("My favorite foods are:")
print(my_foods)

print("\nMy friend's favorite foods are:")
print(friend_foods)
</pre>
вот что происходит при попытке копирования списка без использования среза:
<pre>
my_foods = ['pizza', 'falafel', 'carrot cake']

# Не работает:
friend_foods = my_foods
my_foods.append('cannoli')
friend_foods.append('ice cream')
print("My favorite foods are:")
print(my_foods)

print("\nMy friend's favorite foods are:")
print(friend_foods)
</pre>
Вместо того чтобы сохранять копию my_foods в friend_foods , мы присваиваем переменной friend_foods значение переменной my_foods . На самом деле этот синтаксис сообщает Python, что новая переменная friend_foods должна быть связана со списком, уже хранящимся в my_foods , поэтому теперь обе переменные связаны с одним списком. В результате при добавлении элемента 'cannoli' в my_foods этот элемент также появляется в friend_foods . Аналогичным образом элемент 'ice cream' оказывается в обоих списках, хотя на первый взгляд был добавлен только в friend_foods.<br>
Вывод показывает, что оба списка содержат одинаковые элементы, а это совсем не то, что требовалось.
<p>
<i>Если не ошибаюсь, то копия будет создаваться, если список не содержит внутри себя другой список.</i>
<pre>

</pre>    
<h3>Методы списка</h3>
<p>
<ul>
<li> <h4>Добавление элемента в список</h4>
1. <b>append()</b><br>
Метод добавляет в конец списка новый элемент.
<pre>array.append(8)</pre>
В конец списка array добавили элемент 8.
<p>
Другой способ добавления в конец списка нового элемента - оператор приращения:
<pre>array +=[8]</pre>
Интересный пример по этому случаю:
<pre>
>>> students = ['Ivan', 'Masha', 'Sasha']
>>> students += ['Olga']
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga']
>>> students += 'Olga'
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a']</pre>
Видна разница между добавлением элемента с помощью модуля append и оператором +=.<br>
И списки, и строки - это последовательности (см. https://docs.python.org/3/library/stdtypes.html?highlight=mutable%20sequence#) . 
<br>+= складывает список с элементами последовательности ﻿по отдельности.
<br>А append прибавляет к списку новый элемент списка, сколько бы вложенных элементов в этом добавляемом элементе ни было.
<pre>
Продолжение:

>>> students += ['Dmitriy', 'Alexei']
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei']
>>> students.append(['Anna', 'Elena'])
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei', ['Anna', 'Elena']]
</pre>
<p>
Другие методы добавления элемента в список<br>
2. <b>extend(iterable)</b><br>
вставляет весь iterable в конец списка.
<p>
3. <b>insert(i, x)</b><br>
вставляет элемент x на позицию c индексом i, обеспечивая таким образом точную точку вставки.<br>
Пример:
<pre>
list1 = [1, 2, 5]
list2 = [3, 4]
list1.insert(2, list2)
print(list1)  # Получим: [1, 2, [3, 4], 5]
</pre>
<p>
<b>Используйте срезы для аккуратной вставки list2 в list1 без создания дополнительных уровней вложенности</b>:
<pre>
# Вставляем аккуратно и точно!
list1[start:end] = list2

list1 = [1, 2, 5]
list2 = [3, 4]
list1[2:2] = list2
print(list1)  # Выведет: [1, 2, 3, 4, 5]
</pre>
<b>Если вы предпочитаете уникальные значения</b>, примените вычитание множеств, чтобы добавить в список только те элементы, которых в нем еще нет:
<pre>
# Добавляем только неповторяющиеся элементы
list1.extend(set(list2) – set(list1))
</pre>
<li> <b><a href="https://skillbox.ru/media/code/kak-udalit-element-iz-spiska-v-python/">Методы удаления элементов из списка:
</a></b>
<p>
<ol>
<li> <b>remove() - удаление <b>одного</b> элемента из списка по имени</b><br>
Применяется этот метод, если не известен индекс удаляемого элемента.<br>
Параметров может быть только один, то есть можно удалить за раз только один элемент:
<pre>
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei', ['Anna', 'Elena']]
>>> students.remove('o', 'l', 'g', 'a', ['Anna', 'Elena'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: remove() takes exactly one argument (5 given)
>>> students.remove(['Anna', 'Elena'])
>>> students
['Ivan', 'Masha', 'Sasha', 'Olga', 'O', 'l', 'g', 'a', 'Dmitriy', 'Alexei']</pre>
<p>
Метод remove() удаляет только первое вхождение заданного значения. Если существует вероятность того, что значение встречается в списке несколько раз, то используйте цикл, чтобы определить, были ли удалены все вхождения данного значения.
<p>
<li> <b>Метод pop(): удаление по индексу</b><br>
Иногда значение, удаляемое из списка, должно как-то использоваться. В этом случае, если еще известен индекс удаляемого элемента используется метод pop().<br>
В качестве аргумента pop() получает индекс, а возвращает удалённое значение:
<pre>
>>> lst = [1, 2, 3, 5]
>>> lst.pop(3)
5
>>> print(lst)
[1, 2, 3]</pre>
Если передать отрицательное значение, то pop() будет считать индексы не с нуля, а с -1
<p>
Если оставить pop() без аргумента, то удалится последний элемент — потому что -1 является аргументом по умолчанию.
<p>
При попытке обратиться в методе pop() к несуществующему индексу, интерпретатор выбросит исключение IndexError.
<p>
<li> <b>Метод clear(): очищение списка</b>
clear() удаляет из списка всё, то есть буквально очищает его. Он не принимает аргументов и не возвращает никаких значений:
<pre>
print(lst)
[1, 2, 3]
>>> lst.clear()
>>> print(lst)
[]</pre>
<p>
<li> <b>Ключевое слово del</b><br>
Если вам известна позиция элемента, который должен быть удален из списка, воспользуйтесь оператором del:
<pre>
motorcycles = ['honda', 'yamaha', 'suzuki']
print(motorcycles)
del motorcycles[0]
print(motorcycles)
</pre>
Оператор del удаляет первый элемент, 'honda' , из списка motorcycles:
<pre>
['honda', 'yamaha', 'suzuki']
['yamaha', 'suzuki']
</pre>
Можно удалить срез элементов при  этом элемент с правым индексом не удалится. В примере ниже это строка 'IV':
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[1:4]
print(new_list)

>>> ['ноль', 'IV']</pre>
Чтобы очистить список, достаточно передать полный срез [:]:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[:]
print(new_list)

>>> []
</pre>
Также del можно использовать с отрицательными индексами:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[-4]
print(new_list)

>>> ['ноль', [2.1, 'два и два'], 3, 'IV']</pre>
Со срезами это тоже работает:
<pre>
new_list = ['ноль', 1, [2.1, 'два и два'], 3, 'IV']
del new_list[-3:-1]
print(new_list)

>>> ['ноль', 1, 'IV']
</pre>
Если при удалении единичного элемента указать несуществующий индекс, то Python выдаст ошибку IndexError.
<p>
Если выбирать: оператор del или метод pop() , — вам поможет простое правило: если вы собираетесь просто удалить элемент из списка, никак не используя его после удаления, то выбирайте оператор del ; в противном случае выбирайте метод pop() .
</ol>
<p>
<li> <b>Сортировка списка</b><br>
1. <b>sort()</b> - сортировка элементов по возрастанию
<pre>
>>> students.sort()
>>> students
['Alexei', 'Dmitriy', 'Ivan', 'Masha', 'Olga', 'Sasha', 'a', 'g', 'l']</pre>
Здесь строки отсортировались по алфавитному порядку, буквы также по алфавиту, но после строк.
<p>
Список также можно отсортировать <b>в обратном алфавитном порядке</b>; для этого методу sort() следует передать аргумент reverse=True :
<pre>
cars = ['bmw', 'audi', 'toyota', 'subaru']
cars.<b>sort(reverse=True)</b>
print(cars)  # ['toyota', 'subaru', 'bmw', 'audi']
</pre>
<p>
2. <b>Функция sorted()</b><br>
Второй способ, использовать функцию sorted():<br>
Синтаксис:
<pre>
sorted(iterable, key=None, reverse=False)
</pre>
<ul>
<li> iterable — обязательный. В него передаётся итерируемый объект, который вы хотите отсортировать (список, кортеж, строка, множество, замороженное множество).
<p>
<li> key — необязательный. Указывает на функцию (или другой вызываемый объект), которая должна быть вызвана для каждого элемента iterable перед выполнением сравнений. По умолчанию None.<br>
Значением параметра key должна быть функция (или другой вызываемый объект), которая принимает единственный аргумент и возвращает key для использования в целях сортировки. Этот метод быстр, поскольку функция key вызывается ровно один раз для каждой входной записи.
<p>
Распространенным способом является сортировка сложных объектов с использованием некоторых индексов объекта в качестве ключей. Например:
<pre>
student_tuples = [
    ('john', 'A', 15),
    ('jane', 'B', 12),
    ('dave', 'B', 10),
]
sorted(student_tuples, <b>key=lambda student: student[2]</b>)   # sort by age
[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
</pre>
<p>
<li> reverse — необязательный. По умолчанию sorted() сортирует объект по возрастанию — но если поставить reverse=True, можно расположить элементы в обратном порядке.
</ul>
<p>
Функция не меняет оригинальный iterable, поскольку возвращает новый отсортированный объект.
<p>
<b>Чтобы отсортировать словарь по значению</b>:
<pre>
<font size=4 color=brown>sorted_tuple = sorted(d.items(), key=lambda item: item[1], reverse=True)</font>
</pre>
Возвращает список кортежей, отсортированный по значению словаря по убыванию из-за reverse=True. Чтобы получить словарь, то применить функцию dict() к списку, тогда список кортежей преобразуется в словарь..
<p>
<b>Сортировка ключей по обратному значению, а затем если ключи совпадают, то по их значениям по возрастанию</b>:
<pre>
<font size=4 color=brown>sorted(dct, key=lambda k: (-dct[k], k))</font>
</pre>
Если преобразовать значение в отрицательное число, то сортировка по значению будет происходить в обратном порядке, а ключи будут сортироваться в порядке возрастания.<br>
Возвращает только кортеж ключей словаря.
<p>
<b>Разница между sort() и sorted() в том, что первый - сортирует список на месте, возвращая None (нет нового списка, а 
пероначальный меняется). Второй - возвращает новый отсортированный список.</b>
<p>
Так же, можно сортировать словари.
<pre>
x = {1: 'a', 3: 'ab', 2: 'abc'}
 По ключам:

x = dict(sorted(x.items()))
print(x)
{1: 'a', 2: 'abc', 3: 'ab'}
По значениям:

x = dict(sorted(x.items(), key=lambda e:e[1]))
print(x)
{1: 'a', 3: 'ab', 2: 'abc'}</pre>
<p>
<b>Чтобы переставить элементы списка в обратном порядке, используйте метод reverse()</b>.<br>
Например, если список машин первоначально хранился в хронологическом порядке, соответствующем дате приобретения, то элементы можно переставить в обратном хронологическом порядке:
<pre>
cars = ['bmw', 'audi', 'toyota', 'subaru']
print(cars)
cars.reverse()
print(cars)
</pre>
Метод reverse() не сортирует элементы в обратном алфавитном порядке, а просто меняет порядок списка на обратный:
<pre>
['bmw', 'audi', 'toyota', 'subaru']
['subaru', 'toyota', 'audi', 'bmw'] 
</pre>
Метод возвращает этот же объект, но изменённый.
<p>
Функция reversed() делает тоже самое.
<p>
<li> <b><a name="join">Метод join - преобразование списка в строку</b><br>
Метод join преобразует список из строк в одну строку, элементы списка будут разделены символом - делимитером между ' '.
<p>
Метод принимает итерируемый объект в качестве аргумента, а поскольку список отвечает этим условиям, то его вполне можно 
использовать. Также список должен состоять из строк. Если попробовать использовать функцию для списка с другим содержимым, то 
результатом будет такое сообщение: <font color=red>TypeError: sequence item 0: expected str instance, int found</font>.
<p>
Примеры:
<pre>
>>> lst = ["a", "e", "i", "o", "u"]
>>> ','.join(lst)
'a,e,i,o,u'
</pre>
ещё:
<pre>
>>> lst = ['a', 'b', 'c']
>>> ' '.join(lst)
'a b c'
</pre>
<p>
<li> <b>index()</b><br>
Метод index() возвращает индекс указанного элемента в списке. Синтаксис метода в Python:
<pre>list.index(element, start, end)</pre>
element – элемент для поиска;<br>
start (необязательно) – начать поиск с этого индекса;<br>
end (необязательно) – искать элемент до этого индекса.
<p>
Метод возвращает индекс данного элемента в списке. Если элемент не найден, возникает исключение ValueError.<br>
<i>Примечание: Команда возвращает только первое вхождение соответствующего элемента.</i>
<p>
<li> Метод count()<br>
Синтаксис:
<pre>
<font size=5 color=brown>list.count(element)</font>
</pre>
Где list — это список, в котором вы хотите подсчитать элементы, а element — это элемент, количество вхождений которого вы хотите узнать. Метод возвращает целое число, которое представляет количество вхождений указанного элемента в списке.<br>
Метод count() может быть использован не только для списков, но и для других итерируемых объектов, таких как строки и кортежи. 
</ul>
<h4>Функции:</h4>
<ul>
<li> <b>Функции числовых списков:</b><br>
Некоторые функции Python предназначены для работы с числовыми списками. Например, вы можете легко узнать минимум, максимум и сумму числового списка:
<pre>
>>> digits = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
>>> min(digits)
0
>>> max(digits)
9
>>> sum(digits)
</pre>
</ul>
<a name="raspak"><h4>Распаковка списков, кортежей</h4>
Есть список из трех элементов. Необходимо со­здать три новых переменных и каждой из них присвоить соответствующий эле­мент этого списка apple, banana и lime. Это можем сделать, используя квадратные скобки и указывая индекс определенного элемента в этом списке. После таких трех строк кода со значениями переменных my_apple, my_banana и my_lime бу­дут соответствующие элементы этого списка. Но так делать не совсем удобно, потому что сейчас имеются три элемента, а их может быть несколько десятков.
Для таких случаев и существует распаковка в Python.
<pre>
my_fruits = ['apple', 'banana', 'lime']

<b>my_apple, my_banana, my_lime = my_fruits</b>

print(my_apple)
print(my_banana)
print(my_lime)
</pre>
<b>Теперь об операторе * при распаковке</b>. Допустим есть список из 3 элементов, нужно создать одну переменную my_apple и ей присвоить значение apple, а оставшие элементы внести в другой список:
<pre>
my_fruits = ['apple', 'banana', 'lime']

<b>my_apple, *other_lst = my_fruits</b>

print(my_apple)
print(other_lst)
</pre>
<h4>Создание одинаковых, но независимых списков</h4>
<pre>
list1 = []
list2 = list1.copy()
</pre>
Теперь если добавляем элемент в список, другой список не меняется. Это правило верно, если список не содержит вложенные списки.
<pre>


==========================================================================================================================


</pre>
<h3 align=center><a name="set" href="https://pythonworld.ru/tipy-dannyx-v-python/mnozhestva-set-i-frozenset.html">Множества (set и frozenset)</a></h3>
Множество - объект, который содержит неповторяющие элементы. Оформляется с помощью фигурных скобок.<br>
some_set = {1, 2, 3...}<br>
Но если попробуем так:<br>
test = {}<br>
то создадим не множество, а словарь.
<p>
Пустое множество создается с помощью функции set():<br>
some_set = set()
<p>
<h4>Операции с множествами:</h4>
<ul>
<li> Объединение - с помощью вертикальной черты (|) объединяются два или более множеств
<p>
<li> Пересечение - с помощью знака & находятся общие элементы для двух или более множеств.
<li> Различие - с помощью знака минус (-) определяются элементы, уникальные элементы для одного множества по сравнению с другим.
<p>
<li> Дополнение - определяются элементы, отсутствующие в множестве по сравнению с универсальным множеством.
<p>
<li> Декартово произведение - генерируется новое множество, состоящее из всех возможных упорядоченных пар из двух множеств.
</ul>
<p>
из stackoverflow:<br>
<pre>
>>> d1 = {"a": 0, "b": 1, "c": 2}
>>> d2 = {"c": 20, "d": 30}

>>> # Merge, | 
>>> d1 | d2
{"a": 0, "b": 1, "c": 20, "d": 30}
>>> d1 
{"a": 0, "b": 1, "c": 2}

>>> # Update, |=
>>> d1 |= d2
>>> d1 
{"a": 0, "b": 1, "c": 20, "d": 30}</pre>

<h4>Особенности set</h4>
Может содержать только неизменяемые элементы (числа, строки, кортежи - может; списки, другие множества - не может)<br>
Порядок элементов не определён<br>
<b>Индексация элементов отсутствует</b><br>
Особенности связаны с тем, что внутри множества в Python реализованы хеш-таблицей. Если кратко, то от каждого элемента мы 
вычисляем хеш-функцию, и её значение - это индекс в каком-то большом заранее выделенном массиве.
<p>
Отсюда также следует, что для поиска элемента в большом массиве выгоднее (по скорости) использовать множества, а не списки.
<p>
Перебрать элементы множества можно обычным способом с помощью цикла:<br>
<b>for element in some_set:</b>
<p>
<b>Методы множества:</b><br>
<b>Метод add</b><br>
Метод add добавляет элементы в множество. Если элемент уже есть в множестве, то он не дублируется и множество остается в 
исходном состоянии. Элемент добавляется в произвольном порядке, его позиция для множества четко не определяется. В параметре 
метода передаем элемент, который хотим добавить.
<p>
Синтаксис<br>
множество.add(что добавляем)<br>
Пример <br>
Давайте добавим к нашему множеству новый элемент:
<pre>
st = {'a', 'b', 'c'}
st.add('e')
print(st)</pre>
Результат выполнения кода:
<p>
{'e', 'b', 'c', 'a'}
<p>
Пример<br>
А теперь давайте добавим уже существующий элемент:
<pre>
st = {'a', 'b', 'c'}
st.add('b')
print(st)</pre>
После выполнения кода нам вернется наше множество:
<br>{'b', 'a', 'c'}


<li> <h4>Frozenset</h4>
frozenset - это неизменяемое множество. Создано по аналогии с парой список - кортеж, имеет те же самые особенности по сравнению с множеством, что и кортежи по сравнению со списками. Создаётся только с помощью функции frozenset(), своего литерала (как кортеж) не имеет.
<p>
frozenset может использоваться в качестве элементов set.

<h4>Методы множества</h4>
<ol>
<li> name_set.add(element)<br>
Добавляем element в name_set. Если element уже есть, то не добавится.
<p>
<li> name_set.remove(element)<br>
Удаляет element из множества. Если этого элемента нет в множестве, то возникнет ошибка.
<p>
<li> name_set.discard(element)<br>
Аналогично методу remove, только при удалении несуществующего элемента, ошибки не возникнет. 
<p>
<li> name_set.clear(element)<br>
Удалит все элементы множества.
</ol>
<pre>


==========================================================================================================================



</pre>
<h3 align=center><a name="typle" href="https://pyplanet.ru/article/tuple.html">Кортежи</a></h3>
Кортежи - почти как изученные нами ранее списки, за исключением того, что они неизменяемы.
<p>
Как создаётся кортеж?<br>
Кортеж создаётся способом, походим на то, каким создаются списки, только вместо квадратных скобок - круглые.
<pre>a = (1, 2, 3, 0, -1, 2)</pre>
Скобок может вообще не быть:
<pre>a = 1, 2, 3, 0, -1, 2</pre>
Пустой кортеж:
<pre>a = ()</pre>
А вот кортеж из одного элемента выглядит иначе:
<pre>a = (1, )</pre>
Здесь обязательна запятая, иначе Python не сможет отличить одноэлементный кортеж от просто числа.
<p>
Зачем нужен кортеж, если есть списки?
<ul>
<li> Кортежи занимают немного меньше памяти и работают чуть быстрее до тех пор, пока вы не собираетесь изменять его содержимое
<li> Кортежи лучше защищены от ненамеренного изменения данных
<li> Кортежи могут быть использованы в местах, требующих неизменяемый тип данных
<li> Некоторые функции работают только с кортежами
</ul>
С кортежами можно работать так же, как и со списками, кроме методов, изменяющих список (таких, как append, extend, pop, sort и 
др.). Также есть доступ по индексу, есть срезы (только срез кортежа вернёт кортеж, а не список). 
<pre>


============================================================================================================================


</pre>
<h3 align=center><a name="diction" href="https://pythonworld.ru/tipy-dannyx-v-python/slovari-dict-funkcii-i-metody-slovarej.html">Словарь</a></h3>

<b>Словарь</b> (хэш, ассоциативный массив) - это изменчивая структура данных для хранения пар key-value, где value однозначно 
определяется ключом.<br>
В качестве ключа может выступать неизменчивый тип данных (число, строка, кортеж и т.п.).<br>
Порядок пар ключ-значение произволен (словарь не имеет индекса, вместо индекса ключ).<br>
value может быть строкой, числом, списком.<br>
Задается с помощью фигурных скобок (как множество):
<pre>
       var_dictionary={
                       key1:value1,
                       key2:value2,
                       key3:value3
                      }</pre>
Пример:
<pre>dictionary = {'dog' : 'собака', 'table' : 'стол', 'computer': 'компьютер'}</pre>
<b>Мы можем обращаться к значениям словаря по ключу</b>:
<pre>
print(dictionary['dog'])  # печатаем строку 'собака'
dictionary['dog'] = 'пес' # изменяем значение 'собака' на 'пес'
dictionary['laptop'] = 'ноутбук' # добавляем новый элемент с ключом 'laptop' и значением 'ноутбук' в словарь
del dictionary[dog]       # удаляется пара ключ-значение с данным ключом
</pre>

<b><a href="https://pythonist.ru/kak-dobavit-element-v-slovar/">Как добавить элемент в словарь</a></b><br>
В отличие от списков и кортежей, в работе со словарями методы add(), insert() и append() вам не помощники. Тут необходимо 
создать новый ключ. Позже он будет использоваться для хранения значения.
<p>
Добавляются элементы в словарь так:
<pre>dictionary_name[key] = value</pre>
Рассмотрим пример, чтобы разобраться. В нашем словаре было четыре пары ключ-значение. Этот словарь отражает количество 
булочек, которые продаются в кафе.
<p>
Допустим, мы испекли 10 вишневых булочек. Теперь нам нужно внести их в словарь. Сделать это можно так:
<pre>
scones = {
    "Фрукты": 22,
    "Пустая": 14,
    "Корица": 4,
    "Сыр": 21
}
scones["Вишня"] = 10
print(scones)</pre>
Вывод: 
<pre>
 {'Фрукты': 22, 'Овощи': 14, 'Корица': 4, 'Сыр': 21, 'Вишня': 10}</pre>
Как видите, мы добавили в словарь ключ Вишня и присвоили ему значение 10.
<p>
Сперва мы объявили словарь scones, хранящий информацию о булочках, которые доступны к заказу в нашем кафе. Потом мы добавили в 
наш словарь ключ Вишня и присвоили ему значение 10:
<br> scones["Вишня"] = 10<br>
И, наконец, мы вывели в консоль обновленную версию словаря. 
<p>
добавление и обновление происходит одинаково
Тем же способом мы можем обновить значение ключа. Допустим, мы испекли еще 10 булочек с корицей. Обновить значение этого ключа 
можно так:
<pre>
scones = {
    "Фрукты": 22,
    "Пустая": 14,
    "Корица": 4,
    "Сыр": 21
}
scones["Корица"] = 14
print(scones)</pre>
Вывод: 
<pre>
 {'Фрукты': 22, 'Пустая': 14, 'Корица': 14, 'Сыр': 21}</pre>
То есть, тем же способом мы можем установить новое значение какому-либо ключу. В нашем случае мы присвоили Корица значение 14.
<p>
<b>Как добавлять элемент в словарь в цикле:</b>
<pre>
# input data for dict
keys = ['Name', 'Website', 'Topic', 'Founded']
values = ['GeeksforGeeks', 'https://www.geeksforgeeks.org/', 'Programming', 2009]

# creating  an empty dictionary
output = {}

# adding items to the dictionary using a loop
for i in range(len(keys)):
    output.update({keys[i]: values[i]})</pre>
<br>Словарь:
<pre>
dictionary = {
            'dog': 'собака', 'table': 'стол', 'computer': 'компьютер', 'apple': 'яблоко', 1: 'yyy', 0: ['qq', 'ww']}
</pre>
<p>
<b>Цикл по всему словарю:</b>
<pre>
<b>for key, val in dictionary.items():</b>   
    print(key, val)
</pre>
Выполнит:
<pre>
dog собака
table стол
computer компьютер
apple яблоко
1 yyy
0 ['qq', 'ww']
</pre>
<p>
Вместо key и val можно написать другие имена, хоть k и v:
<pre>
for k, v in dictionary.items():
</pre>
Метод items() возвращает список пар «ключ — значение». Цикл for сохраняет компоненты пары в двух указанных переменных.
<p>
<b>Цикл по ключам словаря:</b><pre>
for key in dictionary.keys():
   print(key, dictionary[key])
</pre>
Выполнит:
<pre>
dog собака
table стол
computer компьютер
apple яблоко
1 yyy
0 ['qq', 'ww']
</pre>
Метод keys() возвращает список всех ключей словаря.
<p>
Перебрать ключи можно и так:<br>
<b>for key in some_dict:</b><br>
поскольку по-умолчанию перебираются ключи словаря.
<p>
<b>Цикл по значениям словаря:</b><br>
Используется метод values():
<pre>
for val in dictionary.values():
    print(val)

собака
стол
компьютер
яблоко
yyy
['qq', 'ww']
</pre>
<p>
<b>Пополняется словарь dictionary из другого diction2:</b><pre>
diction2={'orange':'мандарин'}
dictionary.update(diction2)
print(dictionary)</pre>
{'dog': 'собака', 'table': 'стол', 'computer': 'компьютер', 'apple': 'яблоко', 1: 'yyy', 0: ['qq', 'ww'], 'orange': 'мандарин'}<p>
<b>Получить одновременно и ключ и значение:</b>
<pre>
for key, value in some_d.items():
</pre>
<p>
<b>Сортировка словаря</b><br>
Сортировка по значению:<br>
Часто возникает ситуация, когда необходимо отсортировать словарь по значению.<br>
Рассмотрим пример. Есть словарь, где ключами являются имена, а значениями — возраст:<br>
people = {"Вася": 25, "Петя": 30, "Маша": 20}
<p>
Предположим, что требуется отсортировать этот словарь по возрасту в порядке возрастания.<br>
В Python для этого можно использовать встроенную функцию sorted(). Однако, стандартное применение этой функции к словарю приведет к сортировке по ключам, а не по значениям. Чтобы сортировать по значениям, необходимо указать аргумент key в функции sorted(). В качестве этого аргумента можно передать функцию, которая будет применена к каждому элементу перед сравнением. Для доступа к значениям словаря в Python используется метод get().<br>
Итак, для сортировки словаря по значению в порядке возрастания можно использовать следующий код:
<pre>
sorted_people = sorted(people.items(), key=lambda item: item[1])
</pre>
В этом коде people.items() возвращает пары (ключ, значение), key=lambda item: item[1] указывает, что сортировка происходит по значению (второму элементу пары), а не по ключу.<br>
Результатом выполнения этого кода будет список кортежей:<br>
[('Маша', 20), ('Вася', 25), ('Петя', 30)]
<p>
Если же требуется отсортировать словарь по значению в порядке убывания, нужно добавить аргумент reverse=True в функцию sorted():<br>
sorted_people = sorted(people.items(), key=lambda item: item[1], reverse=True)
<p>
Результатом будет:<br>
[('Петя', 30), ('Вася', 25), ('Маша', 20)]
<h4 align=center>Методы словаря</h4>
<ul>
<li> <b>update()</b><br>
Функция добавляет элемент(ы) в словарь, если ключ отсутствует в словаре. Если ключ находится в словаре, он обновляет ключ новым значением.
<br>Синтаксис: dict.update([other])
<p>
Если update() в Python вызывается без передачи параметров, словарь остается без изменений.
<br>Команда обновляет словарь элементами из объекта словаря или повторяемого объекта пар ключ/значение. Он не возвращает никакого значения (не возвращает None).
<pre>
d = {1: "one", 2: "three"}
d1 = {2: "two"} # updates the value of key
d.update(d1)
print(d)
d1 = {3: "three"} # adds element with key
d.update(d1)
print(d)</pre>
Вывод:
<pre>
{1: 'one', 2: 'two'}<br>
{1: 'one', 2: 'two', 3: 'three'}
</pre>
<li> Использование синтаксиса с ключом в квадратных скобках для получения интересующего вас значения из словаря имеет один потенциальный недостаток: если запрашиваемого ключа не существует, то вы получите сообщение об ошибке. Чтобы не получать ошибку, используют метод get()<br>
<b>get(key, default=None)</b><br>
Возвращает значение для key, если key есть в словаре, иначе значение по умолчанию. Если значение по умолчанию не задано, то по умолчанию используется значение None, так что этот метод никогда не выдает ошибку KeyError.
<p>
<li> dict.clear() - очищает словарь.
<p>
<li> dict.copy() - возвращает копию словаря.
<p>
<li> classmethod dict.fromkeys(seq[, value]) - создает словарь с ключами из seq и значением value (по умолчанию None).
<p>
<li> dict.items() - возвращает пары (ключ, значение).
<p>
<li> dict.keys() - возвращает ключи в словаре.
<p>
<li> dict.pop(key[, default]) - удаляет ключ и возвращает значение. Если ключа нет, возвращает default (по умолчанию бросает исключение).
<p>
<li> dict.popitem() - удаляет и возвращает пару (ключ, значение). Если словарь пуст, бросает исключение KeyError. Помните, что словари неупорядочены.
<p>
<li> dict.setdefault(key[, default]) - возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением default (по умолчанию None).
<p>
<li> dict.update([other]) - обновляет словарь, добавляя пары (ключ, значение) из other. Существующие ключи перезаписываются. Возвращает None (не новый словарь!).
<p>
<li> dict.values() - возвращает значения в словаре.
</ul>
<h4 align=center>Вложение данных (создание сложных структур)</h4>
Иногда бывает нужно сохранить множество словарей в списке или сохранить список как значение элемента словаря. Создание сложных структур такого рода называется вложением (nesting). Вы можете вложить множество словарей в список, список элементов в словарь или даже словарь в другой словарь. Как наглядно показывают следующие примеры, вложение — чрезвычайно мощный механизм.
<p>
<b>Список словарей</b><br>
Словарь alien_0 содержит разнообразную информацию об одном пришельце, но в нем нет места для хранения данных о втором пришельце, не говоря уже об армаде пришельцев. Как смоделировать флот вторжения? Например, можно создать
список, в котором каждый элемент представляет собой словарь с информацией о пришельце. Например, следующий код создает список с данными о трех пришельцах:
<pre>
aliens.py
alien_0 = {'color': 'green', 'points': 5}
alien_1 = {'color': 'yellow', 'points': 10}
alien_2 = {'color': 'red', 'points': 15}

aliens = [alien_0, alien_1, alien_2]
for alien in aliens:
print(alien)
</pre>
Сначала создаются три словаря, каждый из которых представляет отдельного пришельца. Каждый словарь заносится в список aliens. Наконец, программа перебирает список и выводит данные о каждом пришельце:
<pre>
{'color': 'green', 'points': 5}
{'color': 'yellow', 'points': 10}
{'color': 'red', 'points': 15}
</pre>
Конечно, в реалистичном примере будут использоваться данные о более чем трех пришельцах, которые будут генерироваться автоматически. В следующем примере функция range() создает флот из 30 пришельцев:
<pre>
# Создание пустого списка для хранения данных о пришельцах.
aliens = []

# Создание 30 зеленых пришельцев.
for alien_number in range(30):
    new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}
    aliens.append(new_alien)
# Вывод данных о первых пяти пришельцах:
for alien in aliens[:5]:
print(alien)
print("...")
# Вывод количества созданных пришельцев.
print(f"Total number of aliens: {len(aliens)}")
</pre>
В начале примера список для хранения данных обо всех пришельцах, которые будут созданы, пуст. Функция range() возвращает множество чисел, которое просто сообщает Python, сколько раз должен повторяться цикл. При каждом выполнении цикла создается новый пришелец, который затем добавляется в список aliens. Срез используется для вывода данных о первых пяти пришельцах, а затем выво­дится длина списка (для демонстрации того, что программа действительно сгенери­ровала весь флот из 30 пришельцев).
<p>
Все пришельцы обладают одинаковыми характеристиками, но Python рассматривает любого пришельца как отдельный объект, что позволяет изменять атрибуты каждого владельца по отдельности.
<p>
Как работать с таким множеством? Представьте, что в этой игре некоторые пришельцы меняют цвет и начинают двигаться быстрее. Когда приходит время смены цветов, мы можем воспользоваться циклом for и оператором if для изменения цвета. Например, чтобы превратить первых трех пришельцев в желтых, двигающихся со средней скоростью и приносящих игроку по 10 очков, можно действовать так:
<pre>
# Создание пустого списка для хранения данных о пришельцах.
aliens = []
# Создание 30 зеленых пришельцев.
for alien_number in range (30):
    new_alien = {'color': 'green', 'points': 5, 'speed': 'slow'}
    aliens.append(new_alien)

for alien in aliens[:3]:
    if alien['color'] == 'green':
        alien['color'] = 'yellow'
        alien['speed'] = 'medium'
        alien['points'] = 10

# Вывод данных о первых пяти пришельцах:
for alien in aliens[:5]:
    print(alien)
print("...")
</pre>
Чтобы изменить первых трех пришельцев, мы перебираем элементы среза, содержащего информацию только о них. В данный момент все пришельцы зеленые ( 'green' ), но так будет не всегда, поэтому мы пишем оператор if , который гарантирует, что изменяться будут только зеленые пришельцы. Если пришелец зеленый, то его цвет меняется на желтый ( 'yellow' ), скорость на среднюю ( 'medium' ), а награда увеличивается до 10 очков.
<p>
Цикл можно расширить, добавив блок elif для превращения желтых пришельцев в красных — быстрых и приносящих игроку по 15 очков. Мы не станем приводить весь код, а цикл выглядит так:
<pre>
for alien in aliens[0:3]:
    if alien['color'] == 'green':
        alien['color'] = 'yellow'
        alien['speed'] = 'medium'
        alien['points'] = 10
    elif alien['color'] == 'yellow':
        alien['color'] = 'red'
        alien['speed'] = 'fast'
        alien['points'] = 15
</pre>
Решение с хранением словарей в списке встречается достаточно часто, когда каждый словарь содержит разные атрибуты одного объекта. Все словари в списке должны иметь одинаковую структуру, чтобы вы могли перебрать список и выполнить с каждым
объектом словаря одни и те же операции.
<p>
<b>Список в словаре</b><br>
Вместо того чтобы помещать словарь в список, иногда бывает удобно совершить обратное действие. Представьте, как бы вы описали в программе заказанную пиццу. Если ограничиться только списком, то сохранить удастся разве что список начинок
для пиццы. При использовании словаря список начинок может быть всего лишь одним аспектом описания пиццы. В следующем примере для каждой пиццы сохраняются два вида информации: тип коржа и список начинок. Последний представляет собой значение, связанное
с ключом 'toppings' . Чтобы использовать элементы в списке, нужно указать имя словаря и ключ 'toppings' , как и для любого другого значения в словаре. Вместо одного значения будет получен список начинок:
<pre>
# Сохранение информации о заказанной пицце.
pizza = {
    'crust': 'thick',
    'toppings': ['mushrooms', 'extra cheese'],
    }

# Описание заказа.
print(f"You ordered a {pizza['crust']}-crust pizza "
    "with the following toppings:")
for topping in pizza['toppings']:
    print(f"\t{topping}")
</pre>
Работа начинается со словаря, в котором хранится информация о заказанной пицце. С ключом в словаре 'crust' связано строковое значение 'thick' . С другим ключом 'toppings' связано значение-список, в котором хранятся данные обо всех заказанных начинках. Затем выводится описание заказа перед изготовлением пиццы.<br>
Если вам нужно разбить длинную строку в вызове функции print() , то выберите точку для разбиения выводимой строки и закончите ее кавычкой. Добавьте в следующую строку отступ, открывающую кавычку и продолжите строку. Python автоматически объединяет все строки, обнаруженные в круглых скобках. Для вывода начинок пишется цикл for. Чтобы вывести список начинок, мы используем
ключ 'toppings' , а Python берет список начинок из словаря.
<pre>
You ordered a thick-crust pizza with the following toppings:
	mushrooms
	extra cheese
</pre>
Вложение списка в словарь может применяться каждый раз, когда с одним ключом словаря должно быть связано несколько значений.
<p>
Другой пример: один участник опроса мог бы выбрать сразу несколько любимых языков. При переборе словаря значение, связанное с каждым человеком, представляло бы собой список языков (вместо одного языка). В цикле for словаря создается цикл для перебора списка языков, связанных с каждым участником:
<pre>
favorite_languages = {
    'jen': ['python', 'rust'],
    'sarah': ['c'],
    'edward': ['rust', 'go'],
    'phil': ['python', 'haskell'],
    }

for name, languages in favorite_languages.items():
    print(f"\n{name.title()}'s favorite languages are:")
    for language in languages:
        print(f"\t{language.title()}")
</pre>
Значение, связанное с каждым именем, теперь представляет собой список. У одних участников единственный любимый язык программирования, у других таких языков несколько. При переборе словаря переменная languages используется для хранения каждого значения из него, поскольку мы знаем, что оно будет представлять собой список. В основном цикле по элементам словаря другой цикл перебирает элементы списка любимых языков каждого участника. Теперь каждый участник опроса может указать сколько угодно любимых языков программирования:
<pre>
Jen's favorite languages are:
    Python
    Rust

Sarah's favorite languages are:
    C

Edward's favorite languages are:
    Ruby
    Go

Phil's favorite languages are:
    Python
    Haskell
</pre>
<p>
<b>Вложение словарей</b><br>
Словарь можно вложить в другой словарь, но в таких случаях код быстро усложняется. Например, если на сайте есть несколько пользователей с уникальными именами, то вы можете использовать их имена как ключи в словаре. Информация о каждом пользователе при этом хранится в словаре, который применяется как значение, связанное с именем. В следующем примере о каждом пользователе хранятся три вида информации: имя, фамилия и место жительства. Чтобы получить доступ к этим данным, переберите имена пользователей и словарь с информацией, связанной с каждым именем:
<pre>
users = {
    'aeinstein': {
        'first': 'albert',
        'last': 'einstein',
        'location': 'princeton',
        },

    'mcurie': {
        'first': 'marie',
        'last': 'curie',
        'location': 'paris',
        },
    }

for username, user_info in users.items():
    print(f"\nUsername: {username}")
    full_name = f"{user_info['first']} {user_info['last']}"
    location = user_info['location']
    print(f"\tFull name: {full_name.title()}")
    print(f"\tLocation: {location.title()}")
</pre>
В программе определяется словарь users , содержащий два ключа: для пользователей 'aeinstein' и 'mcurie' . Значение, связанное с каждым ключом, представляет собой словарь с именем, фамилией и местом жительства пользователя. В процессе перебора словаря users Python сохраняет каждый ключ в переменной username , а словарь, связанный с каждым именем пользователя, — в переменной user_info . Внутри основного цикла в словаре выводится имя пользователя. Затем начинается работа с внутренним словарем. Переменная user_info , содержащая словарь с информацией о пользователе, содержит три ключа: 'first' , 'last' и 'location' . Каждый ключ используется для создания отформатированных данных, содержащих полное имя и место жительства пользователя, а затем для вывода сводки известной информации о пользователе:
<pre>
Username: aeinstein
    Full name: Albert Einstein
    Location: Princeton

Username: mcurie
    Full name: Marie Curie
    Location: Paris
</pre>
Обратите внимание на идентичность структур словарей всех пользователей. Хотя Python этого и не требует, наличие единой структуры упрощает работу с вложенными словарями. Если словари разных пользователей будут содержать разные
ключи, то код в цикле for заметно усложнится.
<pre>


</pre>
<a name="collections"><h3 align=center>Коллекции</h3>
Ссылки: <a href="https://habr.com/ru/articles/319164/">Python: коллекции, часть 1/4: классификация, общие подходы и методы, конвертация</a>
<h4>Проверка принадлежности элемента коллекции c помощью оператора in</h4>
<p>
x in s — вернет True, если элемент входит в коллекцию s и False — если не входит<br>
Есть и вариант проверки не принадлежности: x not in s, где есть по сути, просто добавляется отрицание перед булевым значением предыдущего выражения.
<pre>
my_list = ['a', 'b', 'c', 'd', 'e', 'f']
print('a' in my_list)           # True
print('q' in my_list)           # False
print('a' not in my_list)       # False
print('q' not in my_list)       # True
</pre>
Для словаря возможны варианты, понятные из кода ниже:
<pre>
my_dict = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
print('a' in my_dict)               # True - без указания метода поиск по ключам
print('a' in my_dict.keys())        # True - аналогично примеру выше
print('a' in my_dict.values())      # False - так как 'а' — ключ, не значение
print(1 in my_dict.values())        # True
</pre>
Можно ли проверять пары? Можно!
<pre>
print(('a',1) in my_dict.items())   # True
print(('a',2) in my_dict.items())   # False
</pre>
Для строки можно искать не только один символ, но и подстроку:
<pre>
print('ab' in 'abc')    # True
</pre>
<h4>Обход всех элементов коллекции в цикле for in</h4>
В данном случае, в цикле будут последовательно перебираться элементы коллекции, пока не будут перебраны все из них.
<pre>
for elm in my_list:
    print(elm)
</pre>
Обратите внимание на следующие моменты:<br>
Порядок обработки элементов для не индексированных коллекций будет не тот, как при их создании
У прохода в цикле по словарю есть свои особенности:
<pre>
 for elm in my_dict:
     	# При таком обходе словаря, перебираются только ключи
	# равносильно for elm in my_dict.keys()
     	print(elm)

 for elm in my_dict.values():
     	# При желании можно пройти только по значениям
     	print(elm)
</pre>
Но чаще всего нужны пары ключ(key) — значение (value).
<pre>
for key, value in my_dict.items():
	# Проход по .items() возвращает кортеж (ключ, значение), 
	# который присваивается кортежу переменных key, value
	print(key, value)
</pre>
Возможная ошибка: Не меняйте количество элементов коллекции в теле цикла во время итерации по этой же коллекции! — Это порождает не всегда очевидные на первый взгляд ошибки.<br>
Чтобы этого избежать подобных побочных эффектов, можно, например, итерировать копию коллекции:
<pre>
for elm in list(my_list):
    	# Теперь можете удалять и добавлять элементы в исходный список my_list,
    	# так как итерация идет по его копии.
</pre>
<h4>Функции min(), max(), sum()</h4>
Функции min(), max() — поиск минимального и максимального элемента соответственно — работают не только для числовых, но и для строковых значений.
<p>
sum() — суммирование всех элементов, если они все числовые.
<pre>
print(min(my_list))               # a
print(sum(my_dict.values())) 
</pre>
<h4>Общие методы для части коллекций</h4>
Ряд методов у коллекционных типов используется в более чем одной коллекции для решения задач одного типа.
<p>
<img src="./images/python_base11.png">
<p>
<b>Объяснение работы методов и примеры:</b>
<p>
<b>.count()</b> — метод подсчета определенных элементов для неуникальных коллекций (строка, список, кортеж), возвращает сколько раз элемент встречается в коллекции.
<pre>
my_list = [1, 2, 2, 2, 2, 3]
print(my_list.count(2))     # 4 экземпляра элемента равного 2
print(my_list.count(5))     # 0 - то есть такого элемента в коллекции нет
</pre>
<b>.index()</b> — возвращает минимальный индекс переданного элемента для индексированных коллекций (строка, список, кортеж)
<pre>
my_list = [1, 2, 2, 2, 2, 3]
print(my_list.index(2))  # первый элемент равный 2 находится по индексу 1 (индексация с нуля!)
print(my_list.index(5))  # ValueError: 5 is not in list - отсутствующий элемент выдаст ошибку!
</pre>
<b>.copy()</b> — метод возвращает неглубокую (не рекурсивную) копию коллекции (список, словарь, оба типа множества).
<pre>
my_set = {1, 2, 3}
my_set_2 = my_set.copy()
print(my_set_2 == my_set)  # True - коллекции равны - содержат одинаковые значения
print(my_set_2 is my_set)  # False - коллекции не идентичны - это разные объекты с разными id
</pre>
<b>.clear()</b> — метод изменяемых коллекций (список, словарь, множество), удаляющий из коллекции все элементы и превращающий её в пустую коллекцию.
<pre>
my_set = {1, 2, 3}
print(my_set)  # {1, 2, 3}
my_set.clear()
print(my_set)  # set()
</pre>
<b>Особые методы сравнения множеств (set, frozenset)</b>
<p>
set_a.isdisjoint(set_b) — истина, если set_a и set_b не имеют общих элементов.
<p>
set_b.issubset(set_a) — если все элементы множества set_b принадлежат множеству set_a, то множество set_b целиком входит в множество set_a и является его подмножеством (set_b — подмножество)
<p>
set_a.issuperset(set_b) — соответственно, если условие выше справедливо, то set_a — надмножество
<pre>
set_a = {1, 2, 3}              
set_b = {2, 1}                  # порядок элементов не важен!
set_c = {4}
set_d = {1, 2, 3}

print(set_a.isdisjoint(set_c))  # True - нет общих элементов
print(set_b.issubset(set_a))    # True  - set_b целиком входит в set_a, значит set_b - подмножество
print(set_a.issuperset(set_b))  # True - set_b целиком входит в set_a, значит set_a - надмножество

При равенстве множеств они одновременно и подмножество и надмножество друг для друга
print(set_a.issuperset(set_d))  # True
print(set_a.issubset(set_d))    # True
</pre>
<h4>Конвертация одного типа коллекции в другой</h4>
В зависимости от стоящих задач, один тип коллекции можно конвертировать в другой тип коллекции. Для этого, как правило достаточно передать одну коллекцию в функцию создания другой (они есть в таблице выше).
<pre>
my_tuple = ('a', 'b', 'a')
my_list = list(my_tuple)
my_set = set(my_tuple)		        # теряем индексы и дубликаты элементов!
my_frozenset = frozenset(my_tuple)      # теряем индексы и дубликаты элементов!
print(my_list, my_set, my_frozenset)    # ['a', 'b', 'a'] {'a', 'b'} frozenset({'a', 'b'})
</pre>
Обратите внимание, что при преобразовании одной коллекции в другую возможна потеря данных:
<p>
При преобразовании в множество теряются дублирующие элементы, так как множество содержит только уникальные элементы! Собственно, проверка на уникальность, обычно и является причиной использовать множество в задачах, где у нас есть в этом потребность.
<p>
При конвертации индексированной коллекции в неиндексированную теряется информация о порядке элементов, а в некоторых случаев она может быть критически важной!
<p>
После конвертации в не изменяемый тип, мы больше не сможем менять элементы коллекции — удалять, изменять, добавлять новые. Это может привести к ошибкам в наших функциях обработки данных, если они были написаны для работы с изменяемыми коллекциями.
<p>
Дополнительные детали:<br>
Способом выше не получится создать словарь, так как он состоит из пар ключ: значение.<br>
Это ограничение можно обойти, создав словарь комбинируя ключи со значениями с использованием zip():
<pre>
my_keys = ('a', 'b', 'c')
my_values = [1, 2]      # Если количество элементов разное - 
		        # будет отработано пока хватает на пары - лишние отброшены
my_dict = dict(zip(my_keys, my_values))
print(my_dict)         # {'a': 1, 'b': 2}
</pre>
Создаем строку из другой коллекции:
<pre>
my_tuple = ('a', 'b', 'c')
my_str = ''.join(my_tuple)
print(my_str)       # abc
</pre>
Возможная ошибка: Если Ваша коллекция содержит изменяемые элементы (например список списков), то ее нельзя конвертировать в не изменяемую коллекцию, так как ее элементы могут быть только не изменяемыми!
<pre>
my_list = [1, [2, 3], 4]
my_set = set(my_list)   # TypeError: unhashable type: 'list'
</pre>
Ссылка: <a href="https://habr.com/ru/articles/319200/">Python: коллекции, часть 2/4: индексирование, срезы, сортировка</a>
<h4>Индексирование</h4>
Рассмотрим индексированные коллекции (их еще называют последовательности — sequences) — список (list), кортеж (tuple), строку (string).
<p>
Под <b>индексированностью</b> имеется ввиду, что элементы коллекции располагаются в определённом порядке, каждый элемент имеет свой индекс от 0 (то есть первый по счёту элемент имеет индекс не 1, а 0) до индекса на единицу меньшего длины коллекции (т.е. len(mycollection)-1).
<p>
Для всех индексированных коллекций можно получить значение элемента по его индексу в квадратных скобках. Причем, можно задавать отрицательный индекс, это значит, что будем находить элемент с конца считая обратном порядке.
<p>
При задании отрицательного индекса, последний элемент имеет индекс -1, предпоследний -2 и так далее до первого элемента индекс которого равен значению длины коллекции с отрицательным знаком, то есть (-len(mycollection).
<pre>
my_str = "abcde"
	print(my_str[0]) 		# a - первый элемент
	print(my_str[-1])		# e - последний элемент 
	print(my_str[len(my_str)-1]) 	# e - так тоже можно взять последний элемент
	print(my_str[-2]) 		# d - предпоследний элемент
</pre>
<h4>Изменение элемента списка по индексу</h4>
Поскольку кортежи и строки у нас неизменяемые коллекции, то по индексу мы можем только брать элементы, но не менять их:
<pre>
my_tuple = (1, 2, 3, 4, 5)
print(my_tuple[0])	  # 1
my_tuple[0] = 100         # TypeError: 'tuple' object does not support item assignment
</pre>
А вот для списка, если взятие элемента по индексу располагается в левой части выражения, а далее идёт оператор присваивания =, то мы задаём новое значение элементу с этим индексом.
<pre>
my_list = [1, 2, 3, [4, 5]]
my_list[0] = 10
my_list[-1][0] = 40
print(my_list)      	# [10, 2, 3, [40, 5]]
</pre>
UPD: Примечание: Для такого присвоения, элемент уже должен существовать в списке, нельзя таким образом добавить элемент на несуществующий индекс.
<pre>
my_list = [1, 2, 3, 4, 5]
my_list[5] = 6      # IndexError: list assignment index out of range
</pre>
<h4>Срезы</h4>
Синтаксис среза:
<p>
Очень часто, надо получить не один какой-то элемент, а некоторый их набор ограниченный определенными простыми правилами — например первые 5 или последние три, или каждый второй элемент — в таких задачах, вместо перебора в цикле намного удобнее использовать так называемый срез (slice, slicing).
<p>
Следует помнить, что взяв элемент по индексу или срезом (slice) мы не как не меняем исходную коллекцию, мы просто скопировали ее часть для дальнейшего использования (например добавления в другую коллекцию, вывода на печать, каких-то вычислений). Поскольку сама коллекция не меняется — это применимо как к изменяемым (список) так и к неизменяемым (строка, кортеж) последовательностям.
<p>
Синтаксис среза похож на таковой для индексации, но в квадратных скобках вместо одного значения указывается 2-3 через двоеточие:
<pre>
my_collection[start:stop:step]  # старт, стоп и шаг
</pre>
<b>Особенности среза:</b><br>
Отрицательные значения старта и стопа означают, что считать надо не с начала, а с конца коллекции.
<p>
Отрицательное значение шага — перебор ведём в обратном порядке справа налево.
<p>
Если не указан старт [:stop:step]— начинаем с самого края коллекции, то есть с первого элемента (включая его), если шаг положительный или с последнего (включая его), если шаг отрицательный (и соответственно перебор идет от конца к началу).
<p>
Если не указан стоп [start:: step] — идем до самого края коллекции, то есть до последнего элемента (включая его), если шаг положительный или до первого элемента (включая его), если шаг отрицательный (и соответственно перебор идет от конца к началу).
<p>
step = 1, то есть последовательный перебор слева направо указывать не обязательно — это значение шага по умолчанию. В таком случае достаточно указать [start:stop]<br>
Можно сделать даже так [:] — это значит взять коллекцию целиком
<p>
ВАЖНО: При срезе, первый индекс входит в выборку, а второй нет!<br>
То есть от старта включительно, до стопа, где стоп не включается в результат. Математически это можно было бы записать как [start, stop) или пояснить вот таким правилом:<br>
[ &lt;первый включаемый> : &lt;первый НЕ включаемый> : <шаг> ]
<p>
<b>Поэтому, например, mylist[::-1] не идентично mylist[:0:-1],</b> так как в первом случае мы включим все элементы, а во втором дойдем до 0 индекса, но не включим его!
<p>
<img src="./images/python_base12.png">
<h4>Именованные срезы</h4>
Чтобы избавится от «магических констант», особенно в случае, когда один и тот же срез надо применять многократно, можно задать константы с именованными срезами с пользованием специальной функции slice()()
<p>
Примечание: Nonе соответствует опущенному значению по-умолчанию. То есть [:2] становится slice(None, 2), а [1::2] становится slice(1, None, 2).
<pre>
person = ('Alex', 'Smith', "May", 10, 1980)
NAME, BIRTHDAY = slice(None, 2), slice(2, None)       
	# задаем константам именованные срезы
        # данные константы в квадратных скобках заменятся соответствующими срезами
print(person[NAME])      # ('Alex', 'Smith')
print(person[BIRTHDAY])  # ('May', 10, 1980)

my_list = [1, 2, 3, 4, 5, 6, 7]
EVEN = slice(1, None, 2)
print(my_list[EVEN])     # [2, 4, 6]
</pre>
<h4>Изменение списка срезом</h4>
Важный момент, на котором не всегда заостряется внимание — с помощью среза можно не только получать копию коллекции, но в случае списка можно также менять значения элементов, удалять и добавлять новые.<br>
Проиллюстрируем это на примерах ниже:<br>
Даже если хотим добавить один элемент, необходимо передавать итерируемый объект, иначе будет ошибка TypeError: can only assign an iterable
<pre>
my_list = [1, 2, 3, 4, 5]
# my_list[1:2] = 20     # TypeError: can only assign an iterable
my_list[1:2] = [20]     # Вот теперь все работает
print(my_list)          # [1, 20, 3, 4, 5]
</pre>
Для вставки одиночных элементов можно использовать срез, код примеров есть ниже, но делать так не рекомендую, так как такой синтаксис хуже читать. Лучше использовать методы списка .append() и .insert():
<p>
Срез аналоги .append() и insert()<br>
Можно менять части последовательности — это применение выглядит наиболее интересным, так как решает задачу просто и наглядно.
<pre>
my_list = [1, 2, 3, 4, 5]
my_list[1:3] = [20, 30]  # вместо 2 и 3 элемента
print(my_list)          # [1, 20, 30, 4, 5]
my_list[1:3] = [0]      # нет проблем заменить два элемента на один
print(my_list)          # [1, 0, 4, 5]
my_list[2:] = [40, 50, 60]   # или два элемента на три
print(my_list)               # [1, 0, 40, 50, 60]
</pre>
Можно просто удалить часть последовательности
<pre>
my_list = [1, 2, 3, 4, 5]
my_list[:2] = []    # или del my_list[:2]
print(my_list)      # [3, 4, 5]
</pre>
<h4>Выход за границы индекса</h4>
<b>Обращение по индексу по сути является частным случаем среза, когда мы обращаемся только к одному элементу, а не диапазону</b>. Но есть очень важное отличие в обработке ситуации с отсутствующим элементом с искомым индексом.
<p>
Обращение к несуществующему индексу коллекции вызывает ошибку:
<pre>
my_list = [1, 2, 3, 4, 5]
print(my_list[-10])       # IndexError: list index out of range
print(my_list[10])        # IndexError: list index out of range
</pre>
А в случае выхода границ среза за границы коллекции никакой ошибки не происходит:
<pre>
my_list = [1, 2, 3, 4, 5]
print(my_list[0:10])      # [1, 2, 3, 4, 5] — отработали в пределах коллекции
print(my_list[10:100])	  # [] - таких элементов нет — вернули пустую коллекцию
print(my_list[10:11])     # [] - проверяем 1 отсутствующий элемент - пустая коллекция, без ошибки
</pre>
Примечание: Для тех случаев, когда функционала срезов недостаточно и требуются более сложные выборки, можно воспользоваться синтаксисом выражений-генераторов, рассмотрению которых посвещена 4 статья цикла.
<h4>3. Сортировка элементов коллекции</h4>
Сортировка элементов коллекции важная и востребованная функция, постоянно встречающаяся в обычных задачах. Тут есть несколько особенностей, на которых не всегда заостряется внимание, но которые очень важны.
<h4>3.1 Функция sorted()</h4>
Мы может использовать функцию sorted() для вывода списка сортированных элементов любой коллекции для последующее обработки или вывода.
<p>
функция не меняет исходную коллекцию, а возвращает новый список из ее элементов;
<p>
не зависимо от типа исходной коллекции, вернётся список (list) ее элементов;
<p>
поскольку она не меняет исходную коллекцию, ее можно применять к неизменяемым коллекциям;
<p>
Поскольку при сортировке возвращаемых элементов нам не важно, был ли у элемента некий индекс в исходной коллекции, можно применять к неиндексированным коллекциям;
<p>
Имеет дополнительные не обязательные аргументы:<br>
reverse=True — сортировка в обратном порядке<br>
key=funcname (начиная с Python 2.4) — сортировка с помощью специальной функции funcname, она может быть как стандартной функцией Python, так и специально написанной вами для данной задачи функцией и лямбдой.
<pre>
my_list = [2, 5, 1, 7, 3]
my_list_sorted = sorted(my_list)
print(my_list_sorted)       # [1, 2, 3, 5, 7]

my_set = {2, 5, 1, 7, 3}
my_set_sorted = sorted(my_set, reverse=True)
print(my_set_sorted)        # [7, 5, 3, 2, 1]
</pre>
Пример сортировки списка строк по длине len() каждого элемента:
<pre>
my_files = ['somecat.jpg', 'pc.png', 'apple.bmp', 'mydog.gif']
my_files_sorted = sorted(my_files, key=len)
print(my_files_sorted)      # ['pc.png', 'apple.bmp', 'mydog.gif', 'somecat.jpg']
</pre>
<h4>3.2 Функция reversed()</h4>
Функция reversed() применяется для последовательностей и работает по другому:
<p>
возвращает генератор списка, а не сам список;
<p>
если нужно получить не генератор, а готовый список, результат можно обернуть в list() или же вместо reversed() воспользоваться срезом [: :-1];
<p>
она не сортирует элементы, а возвращает их в обратном порядке, то есть читает с конца списка;
<p>
из предыдущего пункта понятно, что если у нас коллекция неиндексированная — мы не можем вывести её элементы в обратном порядке и эта функция к таким коллекциям не применима — получим «TypeError: argument to reversed() must be a sequence»;
<p>
не позволяет использовать дополнительные аргументы — будет ошибка «TypeError: reversed() does not take keyword arguments».
<pre>
my_list = [2, 5, 1, 7, 3]
my_list_sorted = reversed(my_list)
print(my_list_sorted)           # &lt;listreverseiterator object at 0x7f8982121450>
print(list(my_list_sorted))     # [3, 7, 1, 5, 2]
print(my_list[::-1])            # [3, 7, 1, 5, 2] - тот же результат с помощью среза
</pre>
<h4>3.3 Методы списка .sort() и .reverse()</h4>
У списка (и только у него) есть особые методы .sort() и .reverse() которые делают тоже самое, что соответствующие функции sorted() и reversed(), но при этом:
<p>
Меняют сам исходный список, а не генерируют новый;
<p>
Возвращают None, а не новый список;
<p>
поддерживают те же дополнительные аргументы;
<p>
в них не надо передавать сам список первым параметром, более того, если это сделать — будет ошибка — не верное количество аргументов.
<pre>
my_list = [2, 5, 1, 7, 3]
my_list.sort()
print(my_list)          # [1, 2, 3, 5, 7]
</pre>
Обратите внимание: Частая ошибка начинающих, которая не является ошибкой для интерпретатора, но приводит не к тому результату, который хотят получить.
<pre>
my_list = [2, 5, 1, 7, 3]
my_list = my_list.sort()
print(my_list)          # None
</pre>
<h4>3.4 Особенности сортировки словаря</h4>
В сортировке словаря есть свои особенности, вызванные тем, что элемент словаря — это пара ключ: значение.
<p>
UPD: Так же, не забываем, что говоря о сортировке словаря, мы имеем ввиду сортировку полученных из словаря данных для вывода или сохранения в индексированную коллекцию. Сохранить данные сортированными в самом стандартном словаре не получится, они в нем, как и других неиндексированных коллекциях находятся в произвольном порядке.
<p>
sorted(my_dict) — когда мы передаем в функцию сортировки словарь без вызова его дополнительных методов — идёт перебор только ключей, сортированный список ключей нам и возвращается;
<p>
sorted(my_dict.keys()) — тот же результат, что в предыдущем примере, но прописанный более явно;
<p>
sorted(my_dict.items()) — возвращается сортированный список кортежей (ключ, значение), сортированных по ключу;
<p>
sorted(my_dict.values()) — возвращается сортированный список значений
<pre>
my_dict = {'a': 1, 'c': 3, 'e': 5, 'f': 6, 'b': 2, 'd': 4}
mysorted = sorted(my_dict)
print(mysorted)           # ['a', 'b', 'c', 'd', 'e', 'f']
mysorted = sorted(my_dict.items())
print(mysorted)           # [('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e', 5), ('f', 6)]
mysorted = sorted(my_dict.values())
print(mysorted)           # [1, 2, 3, 4, 5, 6]
</pre>
Отдельные сложности может вызвать сортировка словаря не по ключам, а по значениям, если нам не просто нужен список значений, и именно выводить пары в порядке сортировки по значению.
<p>
Для решения этой задачи можно в качестве специальной функции сортировки передавать lambda-функцию lambda x: x[1] которая из получаемых на каждом этапе кортежей (ключ, значение) будет брать для сортировки второй элемент кортежа.
<pre>
population = {"Shanghai": 24256800, "Karachi": 23500000, "Beijing": 21516000, "Delhi": 16787941}
# отсортируем по возрастанию населения:
population_sorted = sorted(population.items(), key=lambda x: x[1])
print(population_sorted)
# [('Delhi', 16787941), ('Beijing', 21516000), ('Karachi', 23500000), ('Shanghai', 24256800)]
</pre>
UPD от ShashkovS: 3.5 Дополнительная информация по использованию параметра key при сортировке
<p>
Допустим, у нас есть список кортежей названий деталей и их стоимостей.<br>
Нам нужно отсортировать его сначала по названию деталей, а одинаковые детали по убыванию цены.
<pre>
shop = [('каретка', 1200), ('шатун', 1000), ('седло', 300),
        ('педаль', 100), ('седло', 1500), ('рама', 12000),
        ('обод', 2000), ('шатун', 200), ('седло', 2700)]

def prepare_item(item):
    return (item[0], -item[1])

shop.sort(key=prepare_item)
</pre>
Результат сортировки:
<pre>
for det, price in shop:
    print('{:<10} цена: {:>5}р.'.format(det, price))

# каретка    цена:  1200р.
# обод       цена:  2000р.
# педаль     цена:   100р.
# рама       цена: 12000р.
# седло      цена:  2700р.
# седло      цена:  1500р.
# седло      цена:   300р.
# шатун      цена:  1000р.
# шатун      цена:   200р.
</pre>
Перед тем, как сравнивать два элемента списка к ним применялась функция prepare_item, которая меняла знак у стоимости (функция применяется ровно по одному разу к каждому элементу. В результате при одинаковом первом значении сортировка по второму происходила в обратном порядке.
<p>
Чтобы не плодить утилитарные функции, вместо использования сторонней функции, того же эффекта можно добиться с использованием лямбда-функции.
<pre>
# Данные скопировать из примера выше
shop.sort(key=lambda x: (x[0], -x[1]))
</pre>
Дополнительные детали и примеры использования параметра key:<br>
wiki.python.org/moin/HowTo/Sorting#Key_Functions (на английском).
<h4>UPD от ShashkovS: 3.6 Устойчивость сортировки</h4>
Допустим данные нужно отсортировать сначала по столбцу А по возрастанию, затем по столбцу B по убыванию, и наконец по столбцу C снова по возрастанию.
<p>
Если данные в столбце B числовые, то при помощи подходящей функции в key можно поменять знак у элементов B, что приведёт к необходимому результату.
<p>
А если все данные текстовые? Тут есть такая возможность.<br>
Дело в том, что сортировка sort в Python устойчивая (начиная с Python 2.2), то есть она не меняет порядок «одинаковых» элементов.<br>
Поэтому можно просто отсортировать три раза по разным ключам:
<pre>
data.sort(key=lambda x: x['C'])
data.sort(key=lambda x: x['B'], reverse=True)
data.sort(key=lambda x: x['А'])
</pre>
Ссылка: <a href="https://habr.com/ru/articles/319876/">Python: коллекции, часть 3/4: объединение коллекций, добавление и удаление элементов</a>
<p>
Продолжим изучать общие принципы работы со стандартными коллекциями (модуль collections в ней не рассматривается) Python. Будут рассматриваться способы объединения и обновления коллекций с формированием новой или изменением исходной, а также способы добавлять и удалять элементы в изменяемые коллекции.
<h4>1. Объединение строк, кортежей, списков, словарей без изменения исходных</h4>
Рассмотрим способы объединения строк, кортежей, списков, словарей без изменения исходных коллекций — когда из нескольких коллекций создаётся новая коллекция того же тип без изменения изначальных.
<ol>
<li> <b>Объединение строк (string) и кортежей (tuple)</b> возможна с использованием оператора сложения «+»
<pre>
str1 = 'abc'
str2 = 'de'
str3 = str1 + str2
print(str3)         # abcde

tuple1 = (1, 2, 3)
tuple2 = (4, 5)
tuple3 = tuple1 + tuple2
print(tuple3)       # (1, 2, 3, 4, 5)
</pre>
<li> <b>Для объединения списков (list)</b> возможны три варианта без изменения исходного списка:
<ul>
<li> Добавляем все элементы второго списка к элементам первого, (аналог метод .extend() но без изменения исходного списка):
<pre>
a = [1, 2, 3]
b = [4, 5]
c = a + b           
print(a, b, c)      # [1, 2, 3]  [4, 5]  [1, 2, 3, 4, 5]
</pre>
<li> Добавляем второй список как один элемент без изменения исходного списка (аналог метода.append() но без изменения исходного списка):
<pre>
a = [1, 2, 3]
b = [4, 5]
c = a + [b]
print(a, b, c)     # [1, 2, 3]  [4, 5]  [1, 2, 3, [4, 5]]
</pre>
<li> UPD: Способ добавленный longclaps в комментариях:
<pre>
a, b = [1, 2, 3], [4, 5]
c = [*a, *b]  # работает на версии питона 3.5 и выше
print(c)      # [1, 2, 3, 4, 5]
</ul>
<li> <b>Со словарем (dict)</b> все не совсем просто.
<p>
Сложить два словаря чтобы получить третий оператором + Питон не позволяет «TypeError: unsupported operand type(s) for +: 'dict' and 'dict'».
<p>
Это можно сделать по-другому комбинируя методы .copy() и .update():
<pre>
dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
dict3 = dict1.copy()
dict3.update(dict2)
print(dict3)        	# {'a': 1, 'c': 3, 'b': 2, 'd': 4}
</pre>
В Питоне 3.5 появился новый более изящный способ:
<pre>
dict1 = {'a': 1, 'b': 2}
dict2 = {'c': 3, 'd': 4}
dict3 = {**dict1, **dict2}
print(dict3)        	# {'a': 1, 'c': 3, 'b': 2, 'd': 4}
</pre>
</ol>
<h4>2. Объединение множеств без изменения исходных</h4>
Для обоих типов множеств (set, frozenset) возможны различные варианты комбинации множеств (исходные множества при этом не меняются — возвращается новое множество).
<pre>
# Зададим исходно два множества (скопировать перед каждым примером ниже)
a = {'a', 'b'}
b = {    'b', 'c'}	# отступ перед b для наглядности
</pre>
Объединение (union):
<pre>
c = a.union(b)     # c = b.union(a) даст такой же результат	
# c = a + b        # Обычное объединение оператором + не работает
		   # TypeError: unsupported operand type(s) for +: 'set' and 'set'
c = a | b          # Альтернативная форма записи объединения
print(c)	   # {'a', 'c', 'b'}
</pre>
Пересечение (intersection):
<pre>
c = a.intersection(b)    # c = b.intersection(a) даст такой же результат
c = a & b                # Альтернативная форма записи пересечения
print(c)                 # {'b'}
</pre>
Пересечение более 2-х множеств сразу:
<pre>
a = {'a', 'b'}
b = {     'b', 'c'}
c = {    'b', 'd'}
d = a.intersection(b, c)	# Первый вариант записи
d = set.intersection(a, b, c)   # Второй вариант записи (более наглядный)
print(d)                        # {'b'}
</pre>
Разница (difference) — результат зависит от того, какое множество из какого вычитаем:
<pre>
c = a.difference(b)      # c = a - b другой способ записи дающий тот же результат
print(c)                 # {'a'}
c = b.difference(a)      # c = b - a другой способ записи дающий тот же результат
print(c)                 # {'c'}
</pre>
Симметричная разница (symmetric_difference) Это своего рода операция противоположная пересечению — выбирает элементы из обеих множеств которые не пересекаются, то есть все кроме совпадающих:
<pre>
c = b.symmetric_difference(a)   
# c = a.symmetric_difference(b)       # даст такой же результат
c = b ^ a                             # Альтернативная форма записи симметричной разницы
print(c)        		      # {'a', 'c'}
</pre>
<h4>3. Объединение списка, словаря и изменяемого множества с изменением исходной коллекции</h4>
Для списка<br>
Добавляем все элементы второго списка к элементам первого с измением первого списка методом .extend():
<pre>
a.extend(b)    # a += b эквивалентно a.extend(b)
print(a, b)    # [1, 2, 3, 4, 5]  [4, 5]
</pre>
Добавляем второй список как один элемент с изменением первого списка методом .append():
<pre>
 a.append(b)    # a += [b] эквивалентно a.append(b)
 print(a, b)    # [1, 2, 3, [4, 5]]  [4, 5]
</pre>
Для изменения словаря с добавления элементов другого словаря используется метод .update().<br>
Обратите внимание: для совпадающих ключей словаря при этом обновляются значения:
<pre>
dict1 = {'a': 1, 'b': 2}
dict2 = {'a': 100, 'c': 3, 'd': 4}
dict1.update(dict2)
print(dict1)        # {'a': 100, 'c': 3, 'b': 2, 'd': 4}
</pre>
Для изменяемого множества (set) кроме операций, описанных в предыдущем разделе, также возможны их аналоги, но уже с изменением исходного множества — эти методы заканчиваются на _update. Результат зависит от того, какое множество каким обновляем.
<p>
.difference_update()
<pre>
a = {'a', 'b'}
b = {     'b', 'c'}
a.difference_update(b)
print(a, b)         # {'a'} {'b', 'c'}
a = {'a', 'b'}
b = {     'b', 'c'}
b.difference_update(a)
print(a, b)         # {'a', 'b'} {'c'}

.intersection_update()

a = {'a', 'b'}
b = {     'b', 'c'}
a.intersection_update(b)
print(a, b)         # {'b'} {'b', 'c'}

a = {'a', 'b'}
b = {     'b', 'c'}
b.intersection_update(a)
print(a, b)         # {'b', 'a'} {'b'}

.symmetric_difference_update()

a = {'a', 'b'}
b = {     'b', 'c'}
a.symmetric_difference_update(b)    
print(a, b)         # {'c', 'a'} {'c', 'b'}

a = {'a', 'b'}
b = {     'b', 'c'}
b.symmetric_difference_update(a)
print(a, b)         # {'a', 'b'} {'c', 'a'}
</pre>
<h4>4 Добавление и удаление элементов изменяемых коллекций</h4>
Добавление и удаление элементов в коллекцию возможно только для изменяемых коллекций: списка (list), множества (только set, не frozenset), словаря (dict). Причём для списка, который является индексированной коллекцией, также важно на какую позицию мы добавляем элемент.
<p>
<img src="./images/python_base13.png">
<h4>5 Особенности работы с изменяемой и не изменяемой коллекцией</h4>
Строка неизменяемая коллекция — если мы ее меняем — мы создаем новый объект!
<pre>
str1 = 'abc'
print(str1, id(str1))       # abc 140234080454000
str1 += 'de'
print(str1, id(str1))       # abcde 140234079974992 - Это НОВЫЙ объект, с другим id!
</pre>
Пример кода с двумя исходно идентичными строками.
<pre>
str1 = 'abc'
str2 = str1
print(str1 is str2)       # True - это две ссылки на один и тот же объект!
str1 += 'de'              # Теперь переменная str1 ссылается на другой объект!
print(str1 is str2)       # False - теперь это два разных объекта!
print(str1, str2)         # abcde abc - разные значения
</pre>
Список изменяем и тут надо быть очень внимательным, чтобы не допустить серьезную ошибку! Сравните данный пример с примером со строками выше:
<pre>
list1 = [1, 2, 3]
list2 = list1
print(list1 is list2)     # True - это две ссылки на один и тот же объект!
# А дальше убеждаемся, насколько это важно:
list1 += [4]
print(list1, list2)       # [1, 2, 3, 4] [1, 2, 3, 4] 
# изменилось значение ОБЕИХ переменных, так как обе переменные ссылаются на один объект!
</pre>
А если нужна независимая копия, с которой можно работать отдельно?
<pre>
list1 = [1, 2, 3]
list2 = list(list1)       # Первый способ копирования
list3 = list1[:]          # Второй способ копирования
list4 = list1.copy()      # Третий способ копировани - только в Python 3.3+
print(id(list1), id(list2), id(list3), id(list4))      
# все 4 id разные, что значит что мы создали 4 разных объекта

list1 += [4]              # меняем исходный список
print(list1, list2, list3, list4)       # [1, 2, 3, 4] [1, 2, 3] [1, 2, 3] [1, 2, 3]  
# как мы и хотели - изменив исходный объект, его копии остались не тронутыми
</pre>
<pre>

-------------------------------------------------------------------------------------------------------------------

</pre>
<a name="generator"><h3 align=center>Все о генераторах</h3>
Ссылка: <a href="https://habr.com/ru/articles/320288/">Python: коллекции, часть 4/4: Все о выражениях-генераторах, генераторах списков, множеств и словарей</a>
<p>
Будут рассмотрены: выражения-генераторы, генераторы списка, словаря и множества, вложенные генераторы (5 вариантов), работа с enumerate(), range(). А также: классификация и терминология, синтаксис, аналоги в виде циклов и примеры применения.
<h4>1. Определения и классификация</h4>
1.1 Что и зачем<br>
Генераторы выражений предназначены для компактного и удобного способа генерации коллекций элементов, а также преобразования одного типа коллекций в другой.
<p>
В процессе генерации или преобразования возможно применение условий и модификация элементов.
<p>
Генераторы выражений являются синтаксическим сахаром и не решают задач, которые нельзя было бы решить без их использования.
<p>
<b>1.2 Преимущества использования генераторов выражений</b><br>
Более короткий и удобный синтаксис, чем генерация в обычном цикле.
<p>
Более понятный и читаемый синтаксис чем функциональный аналог сочетающий одновременное применение функций map(), filter() и lambda.
<p>
В целом: быстрее набирать, легче читать, особенно когда подобных операций много в коде.
<h4>1.3 Классификация и особенности</h4>
Сразу скажу, что существует некоторая терминологическая путаница в русских названиях того, о чем мы будем говорить.<br>
В данной статье используются следующие обозначения:<br>
<b>выражение-генератор (generator expression)</b> — выражение в круглых скобках которое выдает создает на каждой итерации новый элемент по правилам.
<p>
<b>генератор коллекции — обобщенное название для генератора списка (list comprehension), генератора словаря (dictionary comprehension) и генератора множества (set comprehension)</b>.
<p>
<img src="./images/python_base14.png">
<h4>2. Синтаксис</h4>
Для начала приведем иллюстрацию общего синтаксиса выражения-генератора.
Важно: этот синтаксис одинаков и для выражения-генератора и для всех трех типов генераторов коллекций, разница заключается, в каких скобках он будет заключен (смотрите предыдущую иллюстрацию).
<p>
<img src="./images/python_base15.png">
<p>
Общие принципы важные для понимания:<br>
Ввод — это итератор — это может быть функция-генератор, выражение-генератор, коллекция — любой объект поддерживающий итерацию по нему.
<p>
Условие — это фильтр при выполнении которого элемент пойдет в финальное выражение, если элемент ему не удовлетворяет, он будет пропущен.
<p>
Финальное выражение — преобразование каждого выбранного элемента перед его выводом или просто вывод без изменений.
<h4>2.1 Базовый синтаксис</h4>
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]    # Пусть у нас есть исходный список
list_b = [x for x in list_a]           # Создадим новый список используя генератор списка
print(list_b)                          # [-2, -1, 0, 1, 2, 3, 4, 5]
print(list_a is list_b)                # False - это разные объекты!
</pre>
По сути, ничего интересного тут не произошло, мы просто получили копию списка. Делать такие копии или просто перегонять коллекции из типа в тип с помощью генераторов особого смысла нет — это можно сделать значительно проще применив соответствующие методы или функции создания коллекций (рассматривались в первой статье цикла).
<p>
Мощь генераторов выражений заключается в том, что мы можем задавать условия для включения элемента в новую коллекцию и можем делать преобразование текущего элемента с помощью выражения или функции перед его выводом (включением в новую коллекцию).
<h4>2.2 Добавляем условие для фильтрации</h4>
Важно: Условие проверяется на каждой итерации, и только элементы ему удовлетворяющие идут в обработку в выражении.<br>
Добавим в предыдущий пример условие — брать только четные элементы.
<pre>
# if x % 2 == 0 - остаток от деления на 2 равен нулю - число четное
list_a = [-2, -1, 0, 1, 2, 3, 4, 5] 
list_b = [x for x in list_a <b>if x % 2 == 0</b>]
print(list_b)   # [-2, 0, 2, 4]
</pre>
Мы можем использовать несколько условий, комбинируя их логическими операторами:
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [x for x in list_a <b>if x % 2 == 0 and x > 0</b>]
# берем те x, которые одновременно четные и больше нуля
print(list_b)   # [2, 4]
</pre>
<h4>2.3 Добавляем обработку элемента в выражении</h4>
Мы можем вставлять не сам текущий элемент, прошедший фильтр, а результат вычисления выражения с ним или результат его обработки функцией.
<p>
Важно: Выражение выполняется независимо на каждой итерации, обрабатывая каждый элемент индивидуально.
<p>
Например, можем посчитать квадраты значений каждого элемента:
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [<b>x**2</b> for x in list_a]
print(list_b)   # [4, 1, 0, 1, 4, 9, 16, 25]
</pre>
Или посчитать длины строк c помощью функции len()
<pre>
list_a = ['a', 'abc', 'abcde']
list_b = [<b>len(x)</b> for x in list_a]
print(list_b)   # [1, 3, 5]
</pre>
<h4>Генератор списка с двумя циклами</h4>
Генераторы списков также могут использовать вложенные циклы для создания новых списков. Например, если у нас есть два списка, и мы хотим получить список всех возможных пар элементов из этих списков, мы можем использовать следующий синтаксис:
<pre>
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
pairs = [(x, y) <b>for x in list1 for y in list2</b>]
print(pairs)
# Output: [(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]
</pre>
В этом примере мы используем две переменные x и y для итерации по двум спискам list1 и list2 соответственно. Выражение (x, y) создает кортеж из пары элементов.
<h4>2.4 Ветвление выражения</h4>
Обратите внимание: Мы можем использовать (начиная с Python 2.5) в выражении конструкцию if-else для ветвления финального выражения.<br>
В таком случае:<br>
Условия ветвления пишутся не после, а перед итератором.
В данном случае if-else это не фильтр перед выполнением выражения, а ветвление самого выражения, то есть переменная уже прошла фильтр, но в зависимости от условия может быть обработана по-разному!
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [<b>x if x < 0 else x**2</b> for x in list_a]
# Если x-отрицательное - берем x, в остальных случаях - берем квадрат x
print(list_b)   # [-2, -1, 0, 1, 4, 9, 16, 25]
</pre>
Никто не запрещает комбинировать фильтрацию и ветвление:
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = [<b>x**3 if x < 0 else x**2</b> for x in list_a <b>if x % 2 == 0</b>]
# вначале фильтр пропускает в выражение только четные значения
# после этого ветвление в выражении для отрицательных возводит в куб, а для остальных в квадрат
print(list_b)   # [-8, 0, 4, 16]
</pre>
Этот же пример в виде цикла:
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_b = []
for x in list_a:
    if x % 2 == 0:
        if x < 0:
            list_b.append(x ** 3)
        else:
            list_b.append(x ** 2)
print(list_b)   # [-8, 0, 4, 16]
</pre>
<h4>2.5 Улучшаем читаемость</h4>
Не забываем, что в Python синтаксис позволяет использовать переносы строк внутри скобок. Используя эту возможность, можно сделать синтаксис генераторов выражений более легким для чтения:
<pre>
numbers = range(10)

# Before
squared_evens = [n ** 2 for n in numbers if n % 2 == 0]

# After
squared_evens = [
    n ** 2
    for n in numbers
    if n % 2 == 0
]
</pre>
<h4>3. Аналоги в виде цикла for и в виде функций</h4>
Как уже говорилось выше, задачи решаемые с помощью генераторов выражений можно решить и без них. Приведем другие подходы, которые могут быть использованы для решения тех же задач.<br>
Для примера возьмем простую задачу — сделаем из списка чисел список квадратов четных чисел и решим ее с помощью трех разных подходов:
<p>
<b>3.1 Решение с помощью генератора списка</b>
<pre>
numbers = range(10)
squared_evens = [n ** 2 for n in numbers if n % 2 == 0]
print(squared_evens)   # [0, 4, 16, 36, 64]
</pre>
<b>3.2. Решение c помощью цикла for</b><br>
Важно: Каждый генератор выражений можно переписать в виде цикла for, но не каждый цикл for можно представить в виде такого выражения.
<pre>
numbers = range(10)
squared_evens = []
for n in numbers:
    if n % 2 == 0:
        squared_evens.append(n ** 2)
print(squared_evens)   # [0, 4, 16, 36, 64]
</pre>
В целом, для очень сложных и комплексных задач, решение в виде цикла может быть понятней и проще в поддержке и доработке. Для более простых задач, синтаксис выражения-генератора будет компактней и легче в чтении.
<h4>3.3. Решение с помощью функций.</h4>
Для начала, замечу, что выражение генераторы и генераторы коллекций — это тоже функциональный стиль, но более новый и предпочтительный.<br>
Можно применять и более старые функциональные подходы для решения тех же задач, комбинируя map(), lambda и filter().
<pre>
numbers = range(10)
squared_evens = map(lambda n: n ** 2, filter(lambda n: n % 2 == 0, numbers))
print(squared_evens)         # &lt;map object at 0x7f661e5dba20>
print(list(squared_evens))   # [0, 4, 16, 36, 64]
</pre>
# Примечание: в Python 2 в переменной squared_evens окажется сразу список, а в Python 3 «map object», который мы превращаем в список с помощью list()
<p>
Несмотря на то, что подобный пример вполне рабочий, читается он тяжело и использование синтаксиса генераторов выражений будет более предпочительным и понятным.
<h4>4. Выражения-генераторы</h4>
Выражения-генераторы (generator expressions) доступны, начиная с Python 2.4. Основное их отличие от генераторов коллекций в том, что они выдают элемент по-одному, не загружая в память сразу всю коллекцию.
<p>
UPD: Еще раз обратите внимание на этот момент: если мы создаем большую структуру данных без использования генератора, то она загружается в память целиком, соответственно, это увеличивает расход памяти Вашим приложением, а в крайних случаях памяти может просто не хватить и Ваше приложение «упадет» с MemoryError. В случае использования выражения-генератора, такого не происходит, так как элементы создаются по-одному, в момент обращения.
<p>
Пример выражения-генератора:
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (<b>i for i in list_a</b>)    # выражение-генератор
print(next(my_gen))     # -2 - получаем очередной элемент генератора
print(next(my_gen))     # -1 - получаем очередной элемент генератора
</pre>
Особенности выражений-генераторов:
<ul>
<li> Генаратор нельзя писать без скобок — это синтаксическая ошибка.
<pre>
# my_gen = i for i in list_a      # SyntaxError: invalid syntax
</pre>
<li> При передаче в функцию дополнительные скобки необязательны
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_sum = sum(<b>i for i in list_a</b>)
# my_sum = sum((i for i in list_a))  # так тоже можно
print(my_sum)   # 12
</pre>
<li> Нельзя получить длину функцией len()
<pre>
# my_len = len(i for i in list_a)  # TypeError: object of type 'generator' has no len()
</pre>
<li> Нельзя распечатать элементы функцией print()
<pre>
print(my_gen)   # <generator object <genexpr> at 0x7f162db32af0>
</pre>
Обратите внимание, что после прохождения по выражению-генератору оно остается пустым!
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)
print(sum(my_gen))  # 12
print(sum(my_gen))  # 0
</pre>
<li> Выражение-генератор может быть бесконечным.
<pre>
import itertools
inf_gen = (x for x in itertools.count())  # бесконечный генератор от 0 to бесконечности!
</pre>
Будьте осторожны в работе с такими генераторами, так как при не правильном использовании «эффект» будет как от бесконечного цикла.
<p>
<li> К выражению-генератору не применимы срезы!
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)
my_gen_sliced = my_gen[1:3]
# TypeError: 'generator' object is not subscriptable
</pre>
</ul>
Из генератора легко получать нужную коллекцию. Это подробно рассматривается в следующей главе.
<h4>5. Генерация стандартных коллекций</h4>
<b>5.1 Создание коллекций из выражения-генератора</b><br>
Создание коллекций из выражения-генератора с помощью функций list(), tuple(), set(), frozenset()<br>
Примечание: Так можно создать и неизменное множество и кортеж, так как неизменными они станет уже после генерации.
<p>
Внимание: Для строки такой способ не работает! Синтаксис создания генератора словаря таким образом имеет свои особенности, он рассмотрен в следующем под-разделе.
<p>
Передачей готового выражения-генератора присвоенного переменной в функцию создания коллекции.
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_gen = (i for i in list_a)   # выражение-генератор
my_list = list(my_gen) 
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]
</pre>
Написание выражения-генератора сразу внутри скобок вызываемой функции создания коллекции.
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = list(i for i in list_a)
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]
</pre>
То же самое для кортежа, множества и неизменного множества
<h4>5.2 Специальный синтаксис генераторов коллекций</h4>
В отличии от выражения-генератора, которое выдает значение по-одному, не загружая всю коллекцию в память, при использовании генераторов коллекций, коллекция генерируется сразу целиком.
<p>
Соответственно, вместо особенности выражений-генераторов перечисленных выше, такая коллекция будет обладать всеми стандартными свойствами характерными для коллекции данного типа.
<p>
Обратите внимание, что для генерации множества и словаря используются одинаковые скобки, разница в том, что у словаря указывается двойной элемент ключ: значение.
<p>
<b>Генератор списка (list comprehension):</b>
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = [i for i in list_a]
print(my_list)          # [-2, -1, 0, 1, 2, 3, 4, 5]
</pre>
Не пишите круглые скобки в квадратных!
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_list = [(i for i in list_a)]
print(my_list)          # [&lt;generator object &lt;genexpr> at 0x7fb81103bf68>]
</pre>
<b>Генератор множества (set comprehension)</b>
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
my_set= {i for i in list_a}
print(my_set)       # {0, 1, 2, 3, 4, 5, -1, -2} - порядок случаен
</pre>
<b>Генератор словаря (dictionary comprehension)</b><br>
переворачивание словаря
<pre>
dict_abc = {'a': 1, 'b': 2, 'c': 3, 'd': 3}
dict_123 = {v: k for k, v in dict_abc.items()}
print(dict_123)  # {1: 'a', 2: 'b', 3: 'd'}
                 # Обратите внимание, мы потеряли "с"! Так как значения были одинаковы, 
                 # то когда они стали ключами, только последнее значение сохранилось.
</pre>
Словарь из списка:
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
dict_a = {x: x**2 for x in list_a}
print(dict_a)   # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, -2: 4, -1: 1, 5: 25}
</pre>
Важно! Такой синтаксис создания словаря работает только в фигурных скобках, выражение-генератор так создать нельзя, для этого используется немного другой синтаксис (благодарю longclaps за подсказку в комментариях):
<pre>
# dict_gen = (x: x**2 for x in list_a)      # SyntaxError: invalid syntax
dict_gen = ((x, x ** 2) for x in list_a)    # Корректный вариант генератора-выражения для словаря
# dict_a = dict(x: x**2 for x in list_a)    # SyntaxError: invalid syntax
dict_a = dict((x, x ** 2) for x in list_a)  # Корректный вариант синтаксиса от @longclaps
</pre>
<h4>5.3 Генерация строк</h4>
Для создания строки вместо синтаксиса выражений-генераторов используется метод строки .join(), которому в качестве аргументов можно передать выражение генератор.
Обратите внимание: элементы коллекции для объединения в строку должны быть строками!
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
# используем генератор прямо в .join() одновременно приводя элементы к строковому типу
my_str = ''.join(str(x) for x in list_a)
print(my_str)  # -2-1012345
</pre>
<h4>6. Периодичность и частичный перебор</h4>
<b>6.1 Работа с enumerate()</b><br>
Иногда в условиях задачи в условии-фильтре нужна не проверка значения текущего элемента, а проверка на определенную периодичность, то есть, например, нужно брать каждый третий элемент.
<p>
Для подобных задач можно использовать функцию enumerate(), задающую счетчик при обходе итератора в цикле:
<pre>
for i, x in enumerate(iterable)
</pre>
здесь x — текущий элемент, i — его порядковый номер, начиная с нуля
<p>
Проиллюстрируем работу с индексами:
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_d = [<b>(i, x) for i, x in enumerate(list_a)</b>]
print(list_d)   # [(0, -2), (1, -1), (2, 0), (3, 1), (4, 2), (5, 3), (6, 4), (7, 5)]
</pre>
Теперь попробуем решить реальную задачу — выберем в генераторе списка каждый третий элемент из исходного списка:
<pre>
list_a = [-2, -1, 0, 1, 2, 3, 4, 5]
list_e = [<b>x for i, x in enumerate(list_a, 1) if i % 3 == 0</b>]
print(list_e)   # [0, 3]
</pre>
Важные особенности работы функции enumerate():
<p>
Возможны два варианта вызова функции enumerate():
<ol>
<li> enumerate(iterator) без второго параметра считает с 0.
<p>
<li> enumerate(iterator, start) — начинает считать с значения start. Удобно, например, если нам надо считать с 1, а не 0.
</ol>
enumerate() возвращает кортеж из порядкового номера и значения текущего элемента итератора. Кортеж в выражении-генераторе результате можно получить двумя способами:
<ol>
<li> (i, j) for i, j in enumerate(iterator) — скобки в первой паре нужны!
<p>
<li>pair for pair in enumerate(mylist) — мы работаем сразу с парой
</ol>
Индексы считаются для всех обработанных элементов, без учета прошли они в дальнейшем условие или нет!
<pre>
first_ten_even = [(i, x) for i, x in enumerate(range(10)) if x % 2 == 0]
print(first_ten_even)   # [(0, 0), (2, 2), (4, 4), (6, 6), (8, 8)]
</pre>
Функция enumerate() не обращается к каким-то внутренним атрибутам коллекции, а просто реализует счетчик обработанных элементов, поэтому ничего не мешает ее использовать для неупорядоченных коллекций не имеющих индексации.
<p>
Если мы ограничиваем количество элементов включенных в результат по enumerate() счетчику (например if i < 10), то итератор будет все равно обработан целиком, что в случае огромной коллекции будет очень ресурс-затратно. Решение этой проблемы рассматривается ниже в под-разделе «Перебор части итерируемого».
<h4>6.2 Перебор части итерируемого.</h4>
Иногда бывает задача из очень большой коллекции или даже бесконечного генератора получить выборку первых нескольких элементов, удовлетворяющих условию.
<p>
Если мы используем обычное генераторное выражение с условием ограничением по enumerate() индексу или срез полученной результирующей коллекции, то нам в любом случае придется пройти всю огромную коллекцию и потратить на это уйму компьютерных ресурсов.
<p>
Выходом может быть использование функции islice() из пакета itertools.
<pre>
import itertools
first_ten = (itertools.islice((x for x in range(1000000000) if x % 2 == 0), 10))
print(list(first_ten))  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
</pre>
<h4>7. Вложенные циклы и генераторы</h4>
Рассмотрим более комплексные варианты, когда у нас циклы или сами выражения-генераторы являются вложенными. Тут возможны несколько вариантов, со своими особенностями и сферой применения, чтобы не возникало путаницы, рассмотрим их по-отдельности, а после приведем общую схему.
<b>7.1 Вложенные циклы</b><br>
В результате генерации получаем одномерную структуру.<br>
Важно! При работае с вложенными циклами внутри генератора выражений порядок следования инструкций for in будет такой же (слева-направо), как и в аналогичном решении без генератора, только на циклах (сверху-вниз)! Тоже справедливо и при более глубоких уровнях вложенности.
<h4>7.1.1 Вложенные циклы for где циклы идут по независимым итераторам</h4>
Общий синтаксис:
<pre>
[expression for x in iter1 for y in iter2]
</pre>
Применение: генерируем одномерную структуру, используя данные из двух итераторов.
<p>
Например, создадим словарь, используя кортежи координат как ключи, заполнив для начала его значения нулями.
<pre>
rows = 1, 2, 3
cols = 'a', 'b'
my_dict = {(col, row): 0 for row in rows for col in cols}
print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}
</pre>
Дальше можем задавать новые значения или получать их:
<pre>
my_dict['b', 2] = 10   # задаем значение по координатному ключу-кортежу
print(my_dict['b', 2])   # 10 - получаем значение по координатному ключу-кортежу
</pre>
<p>
Тоже можно сделать и с дополнительными условиями-фильтрами в каждом цикле:
<pre>
rows = 1, 2, 3, -4, -5
cols = 'a', 'b', 'abc'
# Для наглядности разнесем на несколько строк
my_dict = {
    (col, row): 0  # каждый элемент состоит из ключа-кортежа и нулевого знаечния
    for row in rows if row > 0   # Только положительные значения
    for col in cols if len(col) == 1  # Только односимвольные
    }
print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}
</pre>
Эта же задача решенная с помощью цикла:
<pre>
rows = 1, 2, 3, -4, -5
cols = 'a', 'b', 'abc'
my_dict = {}
for row in rows:
    if row > 0:
        for col in cols:
            if len(col) == 1:
                my_dict[col, row] = 0
print(my_dict)  # {('a', 1): 0, ('b', 2): 0, ('b', 3): 0, ('b', 1): 0, ('a', 3): 0, ('a', 2): 0}
</pre>
<h4>7.1.2 Вложенные циклы for где внутренний цикл идет по результату внешнего цикла</h4>

Общий синтаксис:
<pre>
 [expression for x in iterator for y in x]
</pre>
Применение: Стандартный подход, когда нам надо обходить двумерную структуру данных, превращая ее в «плоскую» одномерную. В данном случае, мы во внешнем цикле проходим по строкам, а во внутреннем по элементам каждой строки нашей двумерной структуры.
<p>
Допустим у нас есть двумерная матрица — список списков. И мы желаем преобразовать ее в плоский одномерный список.
<pre>
matrix = [[0, 1, 2, 3],
          [10, 11, 12, 13],
          [20, 21, 22, 23]]

# Решение с помощью генератора списка:
flattened = [n for row in matrix for n in row]
print(flattened)    # [0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23]
</pre>
Таже задача, решенная с помощью вложенных циклов:
<pre>
flattened = []
for row in matrix:
    for n in row:
        flattened.append(n)
print(flattened)
</pre>
<h4>7.2 Вложенные генераторы</h4>
Вложенными могут быть не только циклы for внутри выражения-генератора, но и сами генераторы.
Такой подход применяется когда нам надо строить двумерную структуру.
<p>
Важно!: В отличии от примеров выше с вложенными циклами, для вложенных генераторов, вначале обрабатывается внешний генератор, потом внутренний, то есть порядок идет справа-налево.
<p>
Ниже рассмотрим два варианта подобного использования.
<p>
<b>7.2.1 — Вложенный генератор внутри генератора — двумерная из двух одномерных</b><br>
Общий синтаксис:
<pre>
 [[expression for y in iter2] for x in iter1]
</pre>
Применение: генерируем двумерную структуру, используя данные из двух одномерных итераторов.
<p>
Для примера создадим матрицу из 5 столбцов и 3 строк и заполним ее нулями:
<pre>
w, h = 5, 3  # зададим ширину и высотку матрицы
matrix = [[0 for x in range(w)] for y in range(h)]
print(matrix)   # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
</pre>
Создание этой же матрицы двумя вложенными циклами - обратите внимание на порядок вложения:
<pre>
matrix = []
for y in range(h):
    new_row = []
    for x in range(w):
        new_row.append(0)
    matrix.append(new_row)
print(matrix)   # [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
</pre>
Примечание: После создания можем работать с матрицей как с обычным двумерным массивом:
<pre>
# теперь можно добавлять значения по координатам (координаты - индексы в списке списков)
matrix[0][0] = 1
matrix[1][3] = 3
print(matrix)   # [[1, 0, 0, 0, 0], [0, 0, 0, 3, 0], [0, 0, 0, 0, 0]]

# Получаем значение по произвольным координатам
x, y = 1, 3
print(matrix[x][y])  # 3
</pre>
<p>
<b>7.2.2 — Вложенный генератор внутри генератора — двумерная из двумерной</b><br>
Общий синтаксис:
<pre>
 [[expression for y in x] for x in iterator]
</pre>
Применение: Обходим двумерную структуру данных, сохраняя результат в другую двумерную структуру.
<p>
Возьмем матрицу:<br>
matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
<p>
Возведем каждый элемент матрицы в квадрат:
<pre>
squared = [[cell**2 for cell in row] for row in matrix]
print(squared)    # [[1, 4, 9, 16], [25, 36, 49, 64], [81, 100, 121, 144]]
</pre>
Эта же операция в виде вложенных циклов:
<pre>
squared = []
for row in matrix:
    new_row = []
    for cell in row:
        new_row.append(cell**2)
    squared.append(new_row)
print(squared)    # [[1, 4, 9, 16], [25, 36, 49, 64], [81, 100, 121, 144]]
</pre>
Обобщим все вышеперечисленные варианты в одной схеме (полный размер по клику):
<p>
<img src="./images/python_base16.png">
<h4>7.3 — Генератор итерирующийся по генератору</h4>
Так как любой генератор может использоваться как итератор в цикле for, это так же можно использовать и для создания генератора по генератору.<br>
При этом синтаксически это может записываться в два выражения или объединяться во вложенный генератор. Проиллюстрирую и такую возможность.<br>
Допустим у нас есть два таких генератора списков:
<pre>
list_a = [x for x in range(-2, 4)]    # Так сделано для дальнейшего примера синтаксиса, 
                                      # конечно в подобной задаче досточно только range(-2, 4)
list_b = [x**2 for x in list_a]
</pre>
Тоже самое можно записать и в одно выражение, подставив вместо list_a его генератор списка:
<pre>
list_c = [x**2 for x in [x for x in range(-2, 4)]]
print(list_c)  # [4, 1, 0, 1, 4, 9]
</pre>
UPD от longclaps: Преимущество от комбинирования генераторов на примере сложной функции f(x) = u(v(x))
<pre>
list_c = [t + t ** 2  for t in (x ** 3 + x ** 4 for x in range(-2, 4))]
</pre>
<h4>8. Использование range()</h4>
Говоря о способах генерации коллекций, нельзя обойти вниманием простую и очень удобную функцию range(), которая предназначена для создания арифметических последовательностей.
<p>
<b>Особенности функции range():</b>
<ul>
<li> Наиболее часто функция range() применяется для запуска цикла for нужное количество раз. Например, смотрите генерацию матрицы в примерах выше.
<p>
<li> В Python 3 range() возвращает генератор, который при каждом к нему обращении выдает очередной элемент.
<p>
<li> Исполльзуемые параметры аналогичны таковым в срезах (кроме первого примера с одним параметром):
<ul>
<li> range(stop) — в данном случае с 0 до stop-1;
<li> range(start, stop) — Аналогично примеру выше, но можно задать начало отличное от нуля, можно и отрицательное;
<li> range(start, stop, step) — Добавляем параметр шага, который может быть отрицательным, тогда перебор в обратном порядке.
</ul>
<li> В Python 2 были 2 функции:<br>
range(...) которая аналогична выражению list(range(...)) в Python 3 — то есть она выдавала не итератор, а сразу готовый список. То есть все проблемы возможной нехватки памяти, описанные в разделе 4 актуальны, и использовать ее в Python 2 надо очень аккуратно!
<p>
xrange(...) — которая работала аналогично range(...) в Python 3 и из 3 версии была исключена.
<p>
Примеры использования:
<pre>
print(list(range(5)))           # [0, 1, 2, 3, 4]
print(list(range(-2, 5)))       # [-2, -1, 0, 1, 2, 3, 4]
print(list(range(5, -2, -2)))   # [5, 3, 1, -1]
</pre>
<h4>9. Приложение 1. Дополнительные примеры</h4>
<b>9.1 Последовательный проход по нескольким спискам</b>
<pre>
import itertools
l1 = [1,2,3]
l2 = [10,20,30]
result = [l*2 for l in itertools.chain(l1, l2)]
print(result)   # [2, 4, 6, 20, 40, 60]
</pre>
<b>9.2 Транспозиция матрицы</b><br>
(Преобразование матрицы, когда строки меняются местами со столбцами).<br>
Возьмем матрицу.
<pre>
matrix = [[1, 2, 3, 4],
          [5, 6, 7, 8],
          [9, 10, 11, 12]]
</pre>
Сделаем ее транспозицию с помощью генератора выражений:
<pre>
transposed = [[row[i] for row in matrix] for i in range(len(matrix[0]))]
print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</pre>
Эта же транспозиция матрицы в виде цикла:
<pre>
transposed = []
for i in range(len(matrix[0])):
    new_row = []
    for row in matrix:
        new_row.append(row[i])
    transposed.append(new_row)
print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</pre>
И немного черной магии от @longclaps:
<pre>
transposed = list(map(list, zip(*matrix)))
print(transposed)  # [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]
</pre>
<h4>9.3 Задача выбора только рабочих дней</h4>
<pre>
# Формируем список дней от 1 до 31 с которым будем работать
days = [d for d in range(1, 32)]

# Делим список дней на недели
weeks = [days[i:i+7] for i in range(0, len(days), 7)]
print(weeks)   # [[1, 2, 3, 4, 5, 6, 7], [8, 9, 10, 11, 12, 13, 14], [15, 16, 17, 18, 19, 20, 21],
 [22, 23, 24, 25, 26, 27, 28], [29, 30, 31]]

# Выбираем в каждой неделе только первые 5 рабочих дней, отбрасывая остальные
work_weeks = [week[0:5] for week in weeks]
print(work_weeks)   # [[1, 2, 3, 4, 5], [8, 9, 10, 11, 12], [15, 16, 17, 18, 19], [22, 23, 24, 25, 26], [29, 30, 31]]

# Если нужно одним списком дней - можно объединить
wdays = [item for sublist in work_weeks for item in sublist]
print(wdays)   # [1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 22, 23, 24, 25, 26, 29, 30, 31]
</pre>
Можно убрать выходные еще более изящно, используя только индексы:
<pre>
# Формируем список дней от 1 до 31 с которым будем работать
days = [d for d in range(1, 32)]

wdays6 = [wd for (i, wd) in enumerate(days, 1) if i % 7 != 0]  # Удаляем каждый 7-й день
# Удаляем каждый 6 день в оставшихся после первого удаления:
wdays5 = [wd for (i, wd) in enumerate(wdays6, 1) if i % 6 != 0]

print(wdays5)
# [1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 22, 23, 24, 25, 26, 29, 30, 31]

# Обратите внимание, что просто объединить два условия в одном if не получится,
# как минимум потому, что 12-й день делится на 6, но не выпадает на последний 2 дня недели!

# Шикарное короткое решение от @sophist:
days = [d + 1 for d in range(31) if d % 7 < 5]
</pre>
<pre>

============================================================================================================================

</pre>
<h3 align=center><a name="gener">Генератор коллекций</h3>
<i>не стоит путать «генераторы коллекций» (comprehensions, они же «включения») и «генераторы-итераторы». Первые — мощный 
синтаксический сахар для генерации коллекций «на лету», вторые — способ получения значений по запросу. </i>

<h4>Генерация списков:</h4>
Список можно создавать с помощью так называемых генераторных выражений, шаблон:
<pre>(выражение for j in итерируемый объект if условие)</pre>
Где for, in, if — ключевые слова, j — переменная.
<p>
Пример: <pre>a = (i**2 for i in range(1,5))</pre>
<pre>num = [int(i) for i in input().split()]</pre>
Если на вход подавать числа, то на выходе будет список из чисел.<br>
Если же для получения списка использовать попроще конструкцию:
<pre>num = input().split()</pre>
то здесь даже если подавать на вход числа, на выходе будет список из односимвольных строк.
<pre>
>>> numbers = [int(i) for i in input().split()]
1 3 5 6 10
>>> numbers
[1, 3, 5, 6, 10]
>>> num = input().split()
1 3 5 6 10
>>> num
['1', '3', '5', '6', '10']</pre>

<h4>Генерация словарей:</h4>
Общий шаблон генераторов словарей в Python:
<pre>
dict_variable = {key:value for (key,value) in dictonary.items()}</pre>
Это самый простой вариант генератора. При добавлении условий код усложнится.
<p>
Генератор словарей — мощная концепция, которую можно использовать для замены циклов и лямбда-функций. При этом не все циклы for могут быть записаны как генератор словаря, но любой генератор можно переписать с использованием цикла for.
<p>
Рассмотрим следующую задачу. Вы хотите создать новый словарь, где ключами будут четные числа в диапазоне от 0 до 10, а значениями — квадраты этих чисел.
<p>
Давайте посмотрим, как можно решить эту проблему, используя цикл for и генератор словарей:
<pre>
numbers = range(10)
new_dict_for = {}
# Добавляем значения в `new_dict` с помощью цикла for 
for n in numbers:
    if n%2==0:
        new_dict_for[n] = n**2
print(new_dict_for)
# {0: 0, 8: 64, 2: 4, 4: 16, 6: 36}
# Используем генератор словаря
new_dict_comp = {n:n**2 for n in numbers if n%2 == 0}
print(new_dict_comp)
# {0: 0, 8: 64, 2: 4, 4: 16, 6: 36}</pre>

<h4>Инверсия словаря</h4>
<pre>
d = {'A': 1, 'B': 2, 'C': 3}
 
    inverse_dict = {v: k for k, v in d.items()}
    print(inverse_dict)            # {1: 'A', 2: 'B', 3: 'C'}</pre>

<p>
<h3 align=center><a name="table">Прямоугольная матрица</h3>
Иногда нам приходится использовать таблицы с данными для решения своих задач. Такие таблицы называются матрицами или двумерными массивами.
<p>
В Python подобные таблицы можно представить в виде списка, элементы которого являются другими списками.
<p>
Создать такой массив в Python можно разными способами. Первый способ:
<pre>
# Создание таблицы с размером 3x3, заполненной нулями
a = 3           
mas = [0] * a 
for i in range(a): 
    mas[i] = [0] * a 
print(mas) # Выведет [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</pre>

Второй способ предполагает создание пустого списка с добавлением в него новых списков. Рассмотрим на примере:
<pre>
# Создание таблицы с размером 2x2, заполненной единицами
a = 3
mas = [] 
for i in range(a): 
    mas.append([1] * a)
print(mas) # Выведет [[1, 1, 1], [1, 1, 1], [1, 1, 1]]</pre>
                                 
Третьим и самым простым способом является генератор списков с x строками, которые будут состоять из y элементов. Пример: 
<pre>
# Создание таблицы с размером 3x3, заполненной двойками
a = 3
mas = [[2] * a for i in range(a)]
print(mas) # Выведет [[2, 2, 2], [2, 2, 2], [2, 2, 2]]</pre>
4 способ:  
<pre>a = [[0 for j in range(m)] for i in range(n)]</pre>
Здесь получаем матрицу из n строк и m  столбцов, заполненную нулями.
<p>
Для обработки и <b>вывода двухмерных списков</b> используются два вложенных цикла. Первый цикл – по порядковому номеру строки, второй – по ее элементам. Например, вывести массив можно так:
<pre>
mas = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
for i in range(0, len(mas)):
    for i2 in range(0, len(mas[i])):
        print(mas[i][i2], end=' ')
    print()
# Выведет
1 1 1
1 1 1
1 1 1</pre>
То же самое можно сделать не по индексам, а по значениям массива:
<pre>
mas = [[1, 1, 1], [1, 1, 1], [1, 1, 1]]
for i in mas: 
    for i2 in i: 
        print(i2, end=' ') 
    print()
# Выведет
1 1 1
1 1 1
1 1 1
</pre>
</ul>
<pre>

</pre>
<a name="user_struct"><h3 align=center>Пользовательские структуры данных</h3>
Ссылка: <a href="https://teletype.in/@pythontalk/data_structures_algorithms">Структуры данных и алгоритмы в Python</a>
<p>
<ol>
<li> <b>Матрица</b> — это двумерный массив, в котором каждый элемент имеет строго одинаковый размер. Для создания матрицы мы будем использовать библиотеку NumPy.
<pre>
import numpy as np

a = np.array([[1,2,3,4],[4,55,1,2],
            [8,3,20,19],[11,2,22,21]])
</pre>
<p>
<li> <b>Байт-массив</b><br>
Байт-массив в Python — это изменяемая последовательность целых чисел в диапазоне 0 <= x < 256.
<pre>
# Создание массива
a = bytearray((12, 8, 25, 2))
print(a)
# bytearray(b'\x0c\x08\x19\x02')
</pre>
<p>
<li> <b>Связанный список</b><br>
Связанный список — это линейная структура данных, в которой элементы не хранятся в смежных областях памяти. Элементы в таком списке связаны между собой с помощью указателей, как показано на рисунке ниже:
<p>
<img src="images/python_collection.png">
<p>
Связанный список представлен как указатель на первый узел, который называется Head. Если связанный список пуст, то значение в Head равно NULL. Каждый узел в списке состоит как минимум из двух частей: данных и указателя (или ссылки) на следующий узел.<br>
Реализуем связанный список:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:        # true если head = none
            self.head = new_node
            return
        
        last_node = self.head
        while last_node.next:
            last_node = last_node.next

        last_node.next = new_node



ll = LinkedList()
ll.append(5)
print(ll)           # &lt;__main__.LinkedList object at 0x7f038e477f40>
print(ll.head)      # &lt;__main__.Node object at 0x7fcb949cb100>
print(ll.head.data) # 5
print(ll.head.next) # None

ll.append(10)
print(ll.head)      # &lt;__main__.Node object at 0x7fcb949cb100>
print(ll.head.data) # 5
print(ll.head.next) # &lt;__main__.Node object at 0x7fe12c593610>
print(ll.head.next.data) # 10

# Создадим простой связный список с тремя узлами:

# Исполнение начинается отсюда
if __name__=='__main__':

	# начнём с пустого списка
	llist = LinkedList()

	llist.head = Node(1)
	second = Node(2)
	third = Node(3)

'''
	Создали три узла.
	Их имена: head, second и third

	llist.head	   second		   third
		|			 |				 |
		|			 |				 |
	+----+------+	 +----+------+	 +----+------+
	| 1 | None |	 | 2 | None |	 | 3 | None |
	+----+------+	 +----+------+	 +----+------+
	'''

	llist.head.next = second # связываем первый узел со вторым

	'''
	Первый узел ссылается на второй.
	Теперь они связаны.

	llist.head	   second		   third
		|			 |				 |
		|			 |				 |
	+----+------+	 +----+------+	 +----+------+
	| 1 | o-------->| 2 | null |	 | 3 | null |
	+----+------+	 +----+------+	 +----+------+
	'''

	second.next = third # связываем второй узел с третьим

	'''
    Второй узел ссылается на третий.
	Теперь они связаны.

	llist.head	 second			 third
		|			 |				 |
		|			 |				 |
	+----+------+	 +----+------+	 +----+------+
	| 1 | o-------->| 2 | o-------->| 3 | null |
	+----+------+	 +----+------+	 +----+------+
	'''
</pre></td></tr></table>
<p>
<b>Обход связанного списка</b><br>
В предыдущем скрипте мы создали простой связный список с тремя узлами. Давайте обойдем его и выведем данные каждого узла. Для обхода напишем метод print_list() в классе LinkedList, который выводит в консоль любой данный ей список.
<pre>
class LinkedList:
	def __init__(self):
		self.head = None

	# печатает содержимое связанного списка
	<b>def print_list(self):</b>
		temp = self.head
		while temp:
			print(temp.data)
			temp = temp.next

if __name__=='__main__':

	llist = LinkedList()

	llist.head = Node(1)
	second = Node(2)
	third = Node(3)

	llist.head.next = second
	second.next = third

	llist.print_list()

>>>OUTPUT
# 1
# 2
# 3
</pre>
<p>
<li> <b>Стек (Stack)</b><br>
Стек — это линейная структура данных, которая хранит элементы по принципу «последний вошел/первый вышел» (LIFO) или «первый вошел/последний вышел» (FILO). В стеке новый элемент добавляется и удаляется только с одного конца. Операции вставки и удаления часто называют push и pop.
<p>
<li> <b>Очередь (Queue)</b><br>
Как и стек, очередь представляет собой линейную структуру данных, которая хранит элементы по принципу «первым пришел — первым ушел» (FIFO). В очереди первым удаляется последний добавленный элемент. 
<p>

<li> <b>Двусвязный список</b> (Deque (дек)<br>
Двусторонняя очередь, поддерживает добавление и удаление элементов с обоих концов.<br>
Пример инициализации:
<pre>
from collections import deque

my_deque = deque([1, 2, 3, 4])
</pre>
Используется для реализация очередей и стеков, где важен доступ с обеих сторон структуры.<br>
Актуальность: актуальна для задач с очередями и стеками.
<p>
<li> Очередь с приоритетом
<p>
<li> Куча (Heap)
<p>
<li> Бинарное дерево (Binary tree)
<p>
Бинарное дерево поиска (Binary Search Tree)
<p>
<li> Графы (Graphs)
</ol>
<pre>








</pre>
</div></body></html>
