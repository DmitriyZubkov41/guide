<html><head>
<style>
.menu {
       height: 100%;
       width: 140px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 155px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Примеры</title>
<div class="menu">

<a href="#while">Циклы</a><br>
<a href="#dict">Словари</a><br>
<a href="#fun">Функции</a><br>
<a href="#file">Файлы</a><br>
<a href="#modul">Модули</a><br>
<a href="#obiekt">Объекты</a><br>
<a href="#oop">ООП</a><br>
</div>
<div class="content">
<h2 align=center>Примеры:</h2>
<ol>

<h4>Циклы:</h4>
<li> <a name="while">Напишите программу, которая считывает с консоли числа (по одному в строке) до тех пор, пока сумма введённых чисел не будет равна 0 и сразу после этого выводит сумму квадратов всех считанных чисел.
<br>Гарантируется, что в какой-то момент сумма введённых чисел окажется равной 0, после этого считывание продолжать не нужно.
<pre>
s = 0
y = 0
while True:
    x = int(input())
    s += x
    y += x*x
    if s == 0:
        break
print(y)</pre>

<li> Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ... (число повторяется столько раз, чему равно). На вход программе передаётся неотрицательное целое число n — столько элементов последовательности должна отобразить программа. На выходе ожидается последовательность чисел, записанных через пробел в одну строку.
<br>Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.<br>
Мое решение:
<pre>
k = 1
n = int(input())
m = [] # полный список
for i in range(1,n+1):
    m = m + [i]*i
for a in m:
    print(a,end=' ')
    k += 1
    if k > n:
        break
print()</pre>
Не моё:
<pre>
n = int(input())
a = []
i = 0
while len(a) < n:
    a += [i] * i
    i += 1
print(*a[:n])</pre>


<li> Напишите программу, которая принимает на вход список чисел в одной строке и выводит на экран в одну строку значения, которые встречаются в нём более одного раза.<br>
Моё решение:
<pre>
list = [int(i) for i in input().split()]
list_end = []
i = 0
while len(list) > 1:
    find_number = list[i]
    list.remove(list[i])
    if find_number in list and not find_number in list_end:
        list_end.append(find_number)
for element in list_end:
    print(element,end=' ')</pre>
Другое решение:
<pre>
a, c = [str(i) for i in input().split()], []
for i in a:
    if i not in c and a.count(i) > 1:
        c.append(i)
        print(i, end=' ')</pre>
        
<li> На вход программы подаётся список чисел lst и число x. Программа должна выдавать на выход в виде одной строки позиции расположения числа х в списке чисел lst. Если число х в списке lst  не обнаружено, необходимо вывести на выход строкой "Отсутствует".
<pre>
lst = [int(i) for i in input().split()]
x = int(input())
# Перебрать список lst по элементам
# каждый элемент сравнивать с x
# если совпадает, то напечатать индекс
# если же нет, то следующий элемент вытаскиваем
i = 0  #    определяем переменную, иначе будет ошибка
if x not in lst:
    print('Отсутствует')
else:
    for lst[i] in lst:
        if lst[i] == x:
            print(i, end=' ')
        i += 1

# 1. Ошибка <font color=red>IndexError: list assignment index out of range</font> возникает в Python, когда нельзя присвоить значение элементу,
 который ещё не существует в списке. Ошибку устранил, когда в <b>for num[i] in lst:</b> num[i] поменял на lst[i]
# 2. В <b>for lst[i] in lst:</b> i автоматически не прибавляет на 1</pre>

Не моё решение:
<pre>
lst, x = input().split(), input()
if x in lst:
    for i in range(len(lst)):
        if lst[i] == x:
            print(i, end=' ')
else:
    print('Отсутствует')</pre>
В этом решении цикл по индексу списка, а не по элементу списка, как у меня.
<p>
==============================================================================================

<li> 
<pre>
#!/usr/bin/env python3
''' Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк. После последней строки
 матрицы идёт строка, содержащая только строку "end"

Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j равен сумме элементов первой матрицы
 на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится с 
 противоположной стороны матрицы.

В случае одной строки/столбца элемент сам себе является соседом по соответствующему 
направлению.'''
table = []
while True:
    table.append([x for x in input().split()])
    if table[-1] == ['end']:
        break
# удалим end
table.remove(['end'])
# str - количество элементов в table - это коли-во строк матрицы
# stolb - количество элементов в элементе table - это коли-во столбцов матрицы
if len(table) == 1:
    delta_str = 0
else:
    delta_str = 1
if len(table[0]) == 1:
    delta_stolb = 0
else:
    delta_stolb = 1
for str in range(len(table)): # по строкам
    if str == len(table) - 1:
        str = str - len(table)
    for stolb in range(len(table[str])):
        if stolb == len(table[str]) - 1:
            stolb = stolb - len(table[str])
        print(int(table[str + delta_str][stolb]) + int(table[str - delta_str][stolb]) + int(table[str][stolb + delta_stolb]) + int(table[str][stolb - delta_stolb]), end=' ')
    print()</pre>
Другое решение:
<pre>
a = [[int(i) for i in input().split()]]
b = input()
while b != 'end' :
    a.append([int(i) for i in b.split()])
    b = input()
for i in range(len(a)): 
    for j in range(len(a[i])): 
        print((a[i-1][j] + a[(i+1) % len(a)][j] + a[i][j-1] + a[i][(j+1) % len(a[i])]), end=' ')
    print()</pre>
Еще решение:
<pre>
c = []
while True:
    a = [i for i in input().split()]
    if a == ['end']:
        break
    c.append(a)
n, m = len(c), len(c[0])
for i in range(n):
    for j in range(m):
        x = int(c[i][j-1]) + int(c[i][j+1-m]) + int(c[i-1][j]) + int(c[i+1-n][j])
        print(x, end=' ')
    print()</pre>
==============================================================================================




<li>
<pre>
Выведите таблицу размером n×n, заполненную числами от 1 до n 2 по спирали, выходящей из левого верхнего угла и закрученной по часовой стрелке:
n = int(input())
krug = 1
stroka = 0 # первая строка
stolb = 0
<b>table = [[0 for j in range(n)] for i in range(n)]</b> # создаём n*n таблицу
# вправо
while table[stroka][stolb] != n*n:
    # вправо
    for stolb in range(krug -1, n - krug + 1):
        if stolb == 0:
            table[0][0] = 1
        else:
            table[stroka][stolb] = table[stroka][stolb-1] + 1
    if table[stroka][stolb] == n*n:
        break
    # вниз
    for stroka in range(krug,n - krug + 1):
        table[stroka][stolb] = table[stroka-1][stolb] + 1
    if table[stroka][stolb] == n*n:
        break
    # влево
    for stolb in range(-krug - 1, -n + krug - 2, -1):
        table[stroka][stolb] = table[stroka][stolb+1] + 1
    if table[stroka][stolb] == n*n:
        break
    # вверх
    for stroka in range(-krug - 1, -n + krug - 1, -1):
        table[stroka][stolb] = table[stroka+1][stolb] + 1
    if table[stroka][stolb] == n*n:
        break
    krug += 1
for stroka in range(n):
    for stolb in range(n):
        print(table[stroka][stolb], end=' ')
    print()</pre>
Вызвало затруднение, определение двухмерного массива, table[] или table[[]]  неправильно. Правильно получилось, когда использовал генератор для формирования таблицы.
<p>
Другое решение:
<pre>
n=int(input())
<b>t=[[0]*n for i in range (n)]</b>
i,j=0,0
for k in range(1, n*n+1):
  t[i][j]=k
  if k==n*n: break
  if i<=j+1 and i+j<n-1: j+=1
  elif i<j and i+j>=n-1: i+=1
  elif i>=j and i+j>n-1: j-=1
  elif i>j+1 and i+j<=n-1: i-=1
<b>for i in range(n):
    print(*t[i])</b></pre>
Более понятнее выглядит способ задания таблицы.<br>
Также интересен способ вывода строк с помощью print(*t[i])
<p>

<li><br>
После дрессировки черепашка научилась понимать и запоминать указания биологов следующего вида:<br>
север 10<br>
запад 20
юг 30<br>
восток 40<br>
где первое слово — это направление, в котором должна двигаться черепашка, а число после слова — это положительное расстояние в сантиметрах, которое должна пройти черепашка.
<p>
Но команды даются быстро, а черепашка ползёт медленно, и программисты догадались, что можно написать программу, которая определит, куда в итоге биологи приведут черепашку. Для этого программисты просят вас написать программу, которая выведет точку, в которой окажется черепашка после всех команд. Для простоты они решили считать, что движение начинается в точке (0, 0), и движение на восток увеличивает первую координату, а на север — вторую.
<p>
Программе подаётся на вход число команд n, которые нужно выполнить черепашке, после чего n строк с самими командами. Вывести нужно два числа в одну строку: первую и вторую координату конечной точки черепашки. Все координаты целочисленные.
<pre>
x = 0
y = 0
command = [input() for _ in range(int(input()))]
for str in command:
    if str.split()[0] == 'запад':
        x = x - int(str.split()[1])
    elif str.split()[0] == 'восток':
        x += int(str.split()[1])
    elif str.split()[0] == 'юг':
        y = y - int(str.split()[1])
    else: # север +y
        y += int(str.split()[1])
print(x, y)</pre>
<b>Другое:</b>
<pre>
dict = {'север': 0, 'юг': 0, 'запад': 0, 'восток': 0}

for _ in range(int(input())):
    key, value = input().split()
    dict[key] += int(value)

print(dict['восток'] - dict['запад'], dict['север'] - dict['юг'])</pre>
</ol>






<h4 align=center><a name="fun">Функции</h4>
<ol>
<li> Напишите функцию f(x), которая возвращает значение следующей функции, определённой на всей числовой прямой:
<p>
<img src="./images/python_base4.png">
<pre>
def f(x):
    if x <= -2:
        return 1 - (x + 2) ** 2
    elif -2 < x <= 2:
        return -x / 2
    else:
        return (x - 2) ** 2 + 1</pre>


<li><br>
Напишите функцию modify_list(l), которая принимает на вход список целых чисел, удаляет из него все нечётные значения, а чётные нацело делит на два. Функция не должна ничего возвращать, требуется только изменение переданного списка.
<pre>
def modify_list(lst):
    l = len(lst)
    for i in range(l-1, -1, -1):
        if lst[i] % 2 == 0:
            lst[i] = lst[i] // 2
        else:
            del lst[i]</pre>
Другое решение:
<pre>def modify_list(l):
    l[:] = [i//2 for i in l if not i % 2]</pre>
<i>логика такая, так как список l в памяти уже есть и его нужно перезаписать, то есть изменить сам объект списка, поэтому тут я делаю срез всего списка от начала до конца и меняю сам объект. если написать просто l = [i//2 for i in l if not i % 2] в данном случае будет создан новый объект, под него выделена память и переменная l будет уже ссылаться на него, а старая ссылка на исходный объект списка сотрется. т.е происходит не изменение объекта, а перенаправление ссылки у переменной l. я не проверял может и такой вариант сработает но подумал что он учтет занимаемую память и выдаст ошибку, так как была задача одна и там подобный подход выдавал ошибку, а сделал l[:] (изменил сам весь объект) все заработало.
<p>
дело в том что for и while полезны для больших конструкций, а генератор списков [ for ] введен для того что бы писать коротенькие вещи в одну строку, что б ради одной двух операций внутри цикла не писать по 3-4 строчки кода с обычным циклом.
<p>
i%2 выдает либо 0 либо 1. или иначе False True. not i - переворачивает выданный результат. Т.е. в данной ситуации мы должны выполнять действие (i//2) если условие if даст True, но четное число при делении даст остаток 0 (6%2=0 - False) поэтому нам необходимо перевернуть результат (not False - True)</i>


<p>
<li>
Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое маленькое целое число y, такое что:
<p>
y больше или равно x<br>
y делится нацело на 5
<pre>
def  closest_mod_5(x = int(input())):
    for num in range(x, x*5 + 1):
        if num % 5 == 0:
            return num
print(closest_mod_5())</pre>
Другое:
<pre>
def closest_mod_5(x):
    while x % 5 != 0:
        x += 1
    return x</pre>


</ol>


<h3 align=center><a name="dict">Словарь</h3>
<ol>
<li><br>
Напишите функцию update_dictionary(d, key, value), которая принимает на вход словарь d и два числа: key и value.<br>
Если ключ key есть в словаре d, то добавьте значение value в список, который хранится по этому ключу. Если ключа key нет в словаре, то нужно добавить значение в список по ключу 2∗key. Если и ключа 2∗key нет, то нужно добавить ключ 2∗key в словарь и сопоставить ему список из переданного элемента [value].
<pre>
def update_dictionary(d, key, value):
    if key in d.keys(): # есть такой ключ
        d[key] += [value]
    else:                        # нет ключа
        if 2*key in d.keys(): #  есть ключ 2*key
            d[2*key] += [value]
        else:
            d[2 * key] = [value]</pre>
Другое:
<pre>
def update_dictionary(d, key, value):
    if key in d:
        d[key] += [value]
    elif 2 * key in d:
        d[2 * key] += [value]
    else:
        d[2 * key] = [value]</pre>
Ещё:
<pre>
def update_dictionary(d, key, value):
    if key not in d:
        key = 2 * key
    if key not in d:
        d[key] = list()
    d[key].append(value)</pre>


<li> <b>Словарь</b><br>
Напишите программу, которая принимает на стандартный вход список игр футбольных команд с результатом матча и выводит на стандартный вывод сводную таблицу результатов всех матчей.
<p>
За победу команде начисляется 3 очка, за поражение — 0, за ничью — 1.
<p>
Формат ввода следующий:<br>
В первой строке указано целое число n — количество завершенных игр.<br>
После этого идет n строк, в которых записаны результаты игры в следующем формате:
<br>Первая_команда;Забито_первой_командой;Вторая_команда;Забито_второй_командой
<p>
Вывод программы необходимо оформить следующим образом:
Команда:Всего_игр Побед Ничьих Поражений Всего_очков
<pre>
win = {}  # количество побед
loss = {} # 
pat = {}  # количество ничьих
point = {}  # количество очков
number_game = {}  # количество игр, проведенных клубом
n = int(input('Количество игр:'))
for i in range(n):
    game = input('Игра:').strip() # Создали список из проведенных игр
    '''Теперь по каждому первому элементу и последнему элементу game создаем словари,
    где ключ - клуб'''
    #print(game)
    if int(game.split(';')[1]) > int(game.split(';')[3]): # победа         
        if game.split(';')[0] not in number_game.keys():
            number_game[game.split(';')[0]] = 1
            win[game.split(';')[0]] = 1
            pat[game.split(';')[0]] = 0
            loss[game.split(';')[0]] = 0
            point[game.split(';')[0]] = 3
        else:
            number_game[game.split(';')[0]] += 1
            win[game.split(';')[0]] += 1
            point[game.split(';')[0]] += 3
        if game.split(';')[2] not in number_game.keys():
            number_game[game.split(';')[2]] = 1
            win[game.split(';')[2]] = 0
            pat[game.split(';')[2]] = 0
            loss[game.split(';')[2]] = 1
            point[game.split(';')[2]] = 0
        else:
            number_game[game.split(';')[2]] += 1
            loss[game.split(';')[2]] += 1
            
    elif  int(game.split(';')[1]) < int(game.split(';')[3]): # ПОРАЖЕНИЕ 1 клуба и победа второго клуба        
        if game.split(';')[0] not in number_game.keys():
            number_game[game.split(';')[0]] = 1
            win[game.split(';')[0]] = 0
            pat[game.split(';')[0]] = 0
            loss[game.split(';')[0]] = 1
            point[game.split(';')[0]] = 0
        else:
            number_game[game.split(';')[0]] += 1
            loss[game.split(';')[0]] += 1
        if game.split(';')[2] not in number_game.keys():
            number_game[game.split(';')[2]] = 1
            win[game.split(';')[2]] = 1
            pat[game.split(';')[2]] = 0
            loss[game.split(';')[2]] = 0
            point[game.split(';')[2]] = 3
        else:
            number_game[game.split(';')[2]] += 1
            win[game.split(';')[2]] += 1    
            point[game.split(';')[2]] += 3
            
    else:                                            # ничья
            if game.split(';')[0] not in pat.keys():
                number_game[game.split(';')[0]] = 1
                win[game.split(';')[0]] = 0
                pat[game.split(';')[0]] = 1
                loss[game.split(';')[0]] = 0
                point[game.split(';')[0]] = 1
            else:
                number_game[game.split(';')[0]] += 1
                pat[game.split(';')[0]] +=1
                point[game.split(';')[0]] +=1 
            if game.split(';')[2] not in pat.keys():
                number_game[game.split(';')[2]] = 1
                win[game.split(';')[2]] = 0
                pat[game.split(';')[2]] = 1
                loss[game.split(';')[2]] = 0
                point[game.split(';')[2]] = 1
            else:
                number_game[game.split(';')[2]] += 1
                pat[game.split(';')[2]] +=1
                point[game.split(';')[2]] +=1

for key in  number_game.keys():
    print(key+':'+str(number_game[key]), win[key], pat[key], loss[key], point[key])</pre>           
Ошибка:
<pre>print(number_game[game.split(';')[0]])
<font color=red>KeyError: 'Спартак'</font></pre>
Проблему решил проверкой на вхождение ключа в словарь и в зависимости от результата создавал новую пару или
делал приращение к существующему ключу
<p>
<i>Советую попробовать разобраться в defaultdict из модуля collections (from collections import defaultdict). Для того, чтобы первый раз добавить элемент, когда там еще нет никаких ключей-значений, используйте функцию lambda:<br>
games = defaultdict(lambda: {'Games': 0, ''Wins': 0,  и т.д.}) 
<p>
Далее после этого уже не надо будет делать проверки, есть ли элемент в словаре. Дефолтдикт по умолчанию добавляет новый ключ, если его там нет, присваивая ему значение 0. То есть дальше можно не делать проверки на то, есть ли элемент в словаре, и если нет, то добавить. Можно будет сразу писать СЛОВАРЬ[Ключ] = ЧТО-ТО. И он не будет возвращать KeyError
<p>
Он может упростить процесс добавления значений в словарь, если вы будете использовать словарь, а в словаре по ключам значения будут в виде словарей типа games = {"Спартак": {"Wins': 1, 'Loses': 0, 'Games': 0 и т.д.}} Чтобы добавить что-то во вложенный словарь, например, количество побед, надо просто написать: games['Спартак']['Wins'] += 3, и в результате у вас добавится количество побед во вложенном словаре.</i>
<p>
<i>"Иллюстрация, как обращаться к элементу списка, если такой список является значением в словаре:
<pre>example = {'A': [22, 33, 44], 'B': [10, 20]}

print(example['A'][1])</pre>
Будет напечатано: 33"</i>
<p>       
Ещё:
<pre>
def command(c, res):
    if not c in dct: dct[c] = [0, 0, 0, 0, 0]
    dct[c] = [dct[c][0] + 1, 
                dct[c][1] + 1 if res == 3 else dct[c][1],
                dct[c][2] + 1 if res == 1 else dct[c][2],
                dct[c][3] + 1 if res == 0 else dct[c][3],
                dct[c][4] + res,]  
dct = {}
for i in range(int(input())):
    c1, g1, c2, g2 = input().split(';')    
    command(c1, 3 if int(g1) > int(g2) else 1 if int(g1) == int(g2) else 0)
    command(c2, 3 if int(g2) > int(g1) else 1 if int(g1) == int(g2) else 0)
for c in dct:
    print('{}:{} {} {} {} {}'.format(c, *dct[c]))</pre>
Ещё:
<pre>
a=[input().split(';') for i in range(int(input()))]
b={i:[] for i in set([i[0] for i in a])|set([i[2] for i in a])}
for i in a:
	b[i[0]].append(1 if i[1]==i[3] else 3 if i[1]&gt;i[3] else 0)
	b[i[2]].append(1 if i[1]==i[3] else 3 if i[1]&lt;i[3] else 0)
for i in b: print('%s:%i %i %i %i %i'%(i,len(b[i]),b[i].count(3),b[i].count(1),b[i].count(0),sum(b[i])))</pre>


<li><br>
Напишите программу, которая умеет шифровать и расшифровывать шифр подстановки. Программа принимает на вход две строки одинаковой длины, на первой строке записаны символы исходного алфавита, на второй строке — символы конечного алфавита, после чего идёт строка, которую нужно зашифровать переданным ключом, и ещё одна строка, которую нужно расшифровать.'''
<pre>
str_zashifr = []
str_shifr = []
shifr_rashifr = []
<b>alfavit = {key:0 for key in input()}</b>
shifr = input()
# сопоставляем ключу alfafit значение из shifr
i = 0
for key in alfavit.keys():
    alfavit[key] = shifr[i]
    i +=1
#print(alfavit)
str = input()
str_shifr = input()
for l in str:
    str_zashifr +=alfavit[l]
# print(*str_zashifr)
for l in str_zashifr:
    print(l, end='')
print()
# Перевернем словарь
<b>inv_alfavit = {v: k for k, v in alfavit.items()}</b>
for l in str_shifr:
    shifr_rashifr += inv_alfavit[l]  
for l in shifr_rashifr:
    print(l, end='')
print()</pre>
Создал словарь через input()<br>
Использовал переворачивание словаря.
<p>
Ещё решение:
<pre>
<b>a,b,c,d=input(),input(),input(),input()</b>
print(''.join(b[a.index(i)] for i in c))
print(''.join(a[b.index(i)] for i in d))</pre>


<li> <b>Словарь</b><br>
Напишите программу, которая прочитает этот файл и подсчитает для каждого класса средний рост учащегося.
<p>
Файл состоит из набора строк, каждая из которых представляет собой три поля:<br>
Класс Фамилия Рост
<p>
Класс обозначается только числом. Буквенные модификаторы не используются. Номер класса может быть от 1 до 11 включительно. В фамилии нет пробелов, а в качестве роста используется натуральное число, но при подсчёте среднего требуется вычислить значение в виде вещественного числа.
<p>
Выводить информацию о среднем росте следует в порядке возрастания номера класса (для классов с первого по одиннадцатый). Если про какой-то класс нет информации, необходимо вывести напротив него прочерк.
<pre>
d = {key:[0, 0] for key in range(1,12)} # создали словарь
with open('/home/dmitriy/Python/mypython/dataset_3380_5.txt') as f:
    for line in f:
        #print(line.split()[0])
        # создадим словарь d, где ключ будет от 1 до 11, а значения сумма ростов и счетчик школьников
        # значение словаря список из двух чисел: d[key][0] и d[key][1]
        d[int(line.split()[0])] = [d[int(line.split()[0])][0] + int(line.split()[2]), d[int(line.split()[0])][1] + 1]
for key in d.keys():
    if d[key][1] == 0:
        print(key, '-')
    else:
        print(key, d[key][0] / d[key][1])</pre>
<b>Другое решение, похоже на мое, но синтаксис грамотный</b>
<pre>
# Делаем словарь {1:[0,0], 2:[0,0]... 11:[0,0]}, где [0:0] = [сумма ростов : кол-во учеников]
tab = {i:[0,0] for i in range(1,12)} 

with open ('dataset_3380_5.txt') as inf:

	# Заполняем словарь:
	for i in inf:
		line = i.strip().split('\t')
		tab [ int(line[0]) ] [0] += int(line[2]) # tab[класс][0] += рост ученика
		tab [ int(line[0]) ] [1] += 1            # tab[класс][1] += 1 (счетчик учеников в классе)
	
	# Распечатка:
	for i in tab.keys():
		if tab[i][1] == 0:
			print (i, '-') # распечатываем класс, в котором нет учеников
		else:
			# считаем и распечатываем средний рост для i-го класса:
			print (i, ( tab[i][0] / tab[i][1] ))</pre>




<li> Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания пространств имен и добавление в них переменных.
<pre>
n = int(input())
d = {'None':'global'}


def get(ns, var):     #  get namespace var или get ns var
    result = []
    # print('d.values()=', d.values())
    
    # преобразуем список детей d.values() в список элементов result
    for i in d.values():
        if type(i) != list:
            result.append(i)
        else:
            for n in range(len(i)):
                result.append(i[n])
    #print('result=', result)
    
    '''ns может не входить в список ключей (родителей)'''
    if ns in d.keys():
        #print('ns=', ns, ' d[ns]=', d[ns])
        if var in d[ns]:   #  переменная var входит в список родителя ns
            # print('var=', var, 'входит в состав (', d[ns], ') родителя ns=', ns)
            return print(ns)
        elif ns in result: # var не входит в ns, но ns входит в список детей
            if ns == 'global':
                return print('None')
            # print(var, 'не входит в ', ns, ' но ', ns, ' входит в список детей ', result)
            # нужно найти ключ для ns (куда ns входит)
            for key in d.keys():
                if ns in d[key]: 
                    # print(ns, ' находится в ', key, ' снова выполняем функцию')
                    return get(key, var)
        else:
            #print(var, ' не входит в ', ns, ' и ', ns, ' никуда не входит')
            return print('None')  
    else:
        # print(ns, ' не входит в список родителей (d.keys()) ', d.keys())
        if ns in result:
            # print(ns, ' входит в список детей (result) ', result) 
            '''надо найти куда ns входит'''
            for key in d.keys():
                if ns in d[key]: 
                    # print(ns, ' находится в ', key, ' снова выполняем функцию')
                    return get(key, var)
        else:
            # print(ns, ' не входит в список детей result ', result)
            return print('None')
        
for _ in range(n):
    str = input().split()
    
    if str[0] == 'add':
        if str[1] in d.keys():
            if type(d[str[1]]) == list:
                lst = ','.join(d[str[1]]).split(',')
                lst.append(str[2])
                d[str[1]] = lst
            else:
                d[str[1]] = [d[str[1]], str[2]]
        else:
            d[str[1]] = str[2]       
    
    elif str[0] == 'create':
        if str[2] in d.keys():
            if type(d[str[2]]) == list:
                <b><font color=green>lst = ','.join(d[str[2]]).split(',')</font>
                <font color=blue>lst.append(str[1])</font></b>
                d[str[2]] = lst
                #print(d[str[2]])
            else:
                d[str[2]] = [d[str[2]], str[1]]
        else:
            d[str[2]] = str[1]       
            
    elif str[0] == 'get':
        get(str[1], str[2])</pre>
3 дня писал этот код. Замотался с добавлением  элемента в значение словаря, так чтобы все элементы были в одном списке, а не списки в списке.
<ol>
<li> <font color=green><b>Чтобы список разделить на отдельные элементы - строки и потом назад в список</b>, используется конструкция<br>
lst = ','.join(d[str[1]]).split(',')<br>
Здесь с помощью joint преобразуем список ['a, b'] в строку 'a, b' а с помощью split(',') преобразуем назад в список ['a', 'b']</font>

<li> <font color=blue>Если писать lst = lst.append(), то будет возвращаться None. Чтобы нормально метод работал, нужно писать lst.append()</font> Метод не работает со строкой.
</ol>
<p>
<b>Другое решение:</b><br>
<i>Пример решения. Будем храним две структуры:<br>
1) Кто чей родитель<br>
2) Переменные объявленные в данном пространстве имён
<p>
Если команда create -- создаём новое пространство имён (запоминаем родителя и создаём пустое множество переменных, объявленных в этом пространстве имен).
<p>
Если команда add -- то просто помещаем имя переменной в соответствующее множество.
<p>
Если команда get -- то проверяем наличие данной переменной в нашем пространстве имён, если не нашли: проверяем в родителе. Если не нашли в родителе, проверяем в родителе родителя и так далее. Как только нашли имя переменной -- вывели на экран пространство имён, в котором нашли. Если в процессе поиска мы имя не нашли (fst is None) -- выводим None на экран.</i>
<pre>
n = int(input())

parent = {"global": None}
vs = {"global": set()}

for _ in range(n):
    t, fst, snd = input().split()
    if t == "create":
        parent[fst] = snd
        vs[fst] = set()
    elif t == "add":
        <b>vs[fst].add(snd)</b>
    else:  # t == get
        while fst is not None:
            if snd in vs[fst]:
                break
            fst = parent[fst]
        print(fst)</pre>
<b>Элементы добавлять в значение словаря удобно с помощью метода add()</b>        
        
		
</ol>


<ol>
<li> <b>Преобразование списка в строку и назад в список с целью сделать список из отдельных слов<br>
<font color=blue>Множество из списка.</font></b><br>
<font color=brown>Методы цепочкой</font>
<p>
На вход программе первой строкой передаётся количество 
d известных нам слов, после чего на d строках указываются эти слова. Затем передаётся количество 
l строк текста для проверки, после чего l строк текста.
<p>
Выведите уникальные "ошибки" в произвольном порядке. Работу производите без учёта регистра.
<pre>
list1 = []
list2 = []
d = int(input())
for i in range(d):
    <font color=brown>list1.append(input().lower())</font>
l = int(input())
for i in range(l):
    list2.append(input().lower())
<b>'''print(list2) # список из фраз
list2 = ' '.join(list2) # преобразовали список в одну строку без запятых
list2 = list2.split()   # преобразовали строку назад в список но из отдельных слов
'''
list2 = ' '.join(list2).split()
<font color=blue>list2 = set(list2)</font></b>
print(list2)
for i in list2:
    if i not in list1:
        print(i)
</pre>
<pre>list1 = list1.append(input())
<font color=red>AttributeError: 'NoneType' object has no attribute 'append'</font></pre>
Устранил ошибку, когда изменил выражение list1 = list1.append(input()) на list1.append(input())
<p>
Другое решение:<br>
<font color=green>Способ создания множества/списка из нескольких вводов одной строкой</font>
<pre>
# формируем множество известных слов на основании построчного ввода
<font color=green>dic = {input().lower() for _ in range(int(input()))}</font>

# заводим пустое множество для приема текста
wrd = set()

# т.к. текст построчно подается, а также в каждой строке несколько слов,
# то каждую строку превращаем во множество и добавляем в единое множество wrd
for _ in range(int(input())):
    wrd |= {i.lower() for i in input().split()}

# на вывод отправляем результат вычитания словарного множества dic
# из текстового множества wrd; впереди ставим *, чтобы раскрыть поэлементно
print(*(wrd-dic), sep="\n")</pre>
wrd |= {...} отвечает за добавление множества {...} в единое wrd (аналог метода update)<br>
заменил ненужные символы переменных на _






<p>
<li><br> <b>Множество<br>применение одновременно нескольких методов</b>
<br>
Программа должна считывать одну строку со стандартного ввода и выводить для каждого уникального слова в  этой строке число его повторений (без учёта регистра) в формате "слово количество".<br>
Порядок вывода слов может быть произвольным, каждое уникальное слово﻿ должно выводиться только один раз.
<pre>
<b>str = input().lower().split()</b>
for i in set(str):
    print(i, str.count(i)</pre>

<li><br>
Напишите программу, которая считывает строку с числом n, которое задаёт количество чисел, которые нужно считать. Далее 
считывает n строк с числами xi, по одному числу в каждой строке. Итого будет n+1 строк.
При считывании числа xi программа должна на отдельной строке вывести значение f(xi). Функция f(x) уже реализована и доступна 
для вызова. 
Функция вычисляется достаточно долго и зависит только от переданного аргумента x. Для того, чтобы уложиться в ограничение по времени, нужно избежать повторного вычисления значений.<br>
Моё:
<pre>
n = int(input())
l = []
d = {}
for i in range(n):
    l.append(int(input()))
'''Проходим каждый элемент списка
Вычисляем функцию и добавляем i и f в словарь
Если на следующем элементе уже вычисляли функцию (входит в словарь), то выводим значение для текущего ключа из словаря'''
for i in l:
    if i not in d.keys(): # еще не выполняли функцию по этому числу
        d[i] = f(i)
        print(i, f(i))
    else:
        print(i, d[i])</pre>
Другое:
<pre>
a=[int(input()) for i in range(int(input()))]
b={x:f(x) for x in set(a)}
for i in a:
    print(b[i])</pre>
Ещё:
<pre>
d = {}
for _ in range(int(input())):
    x = int(input())
    if x not in d:
        d[x] = f(x)
    print(d[x])</pre>         

<li> <a name="file"><b>Файл, методы работы с файлами</b>
<pre>
'''Напишите программу, которая считывает из файла строку, соответствующую тексту, сжатому с помощью кодирования повторов, и
производит обратную операцию, получая исходный текст.'''
with open('/home/dmitriy/Python/mypython/dataset_3363_2 (1).txt') as inf:
  for line in inf:
      line = line.strip()
      # print(line)
  simvol = ''
  num = ''
  str = ''
  for i in range(len(line)):
      ''' если символ является цифрой, тогда запоминаем ее в переменной num строкового типа
      если следующий символ снова цифра, тогда добавляем ее в num
      если же буква, тогда переменную символа simvol умножаем на int(num) и записывает эту строку в новый файл new_file.txt'''
      if '0' <= line[i] <= '9': # цифра
          num = num + line[i]
          if i == len(line) - 1: # последний символ
              str = str + simvol * int(num)
      else:  # буква
          # умножаем предыдущую букву на num и обнуляем num
          # print('simvol=',line[i], 'type(num)=',type(num),'num=',num)
          if i != 0:
              str = str + simvol * int(num)
          # print('stroka=', str)
          simvol = line[i]
          num = '0'
inf.close()
with open('/home/dmitriy/Python/mypython/dataset_3363_2_modify.txt', 'w') as ouf:
    ouf.write(str)</pre>
<b>Не моё:</b>
<pre>
with open('dataset_3363_2.txt', 'r') as f:
    s = f.readline().strip()
i = 0
while i < len(s):
    j = i + 1
    while j < len(s) and s[j].isdigit():
        j += 1
    print(s[i] * int(s[i+1:j]), end='')
    i = j</pre>
Первый символ - гарантированно буква.
Перебираем все последующие, пока они цифровые или пока не достигнут конец строки.<br>
После внутреннего цикла j либо указывает на следующую букву, либо на конец строки. В обоих случаях между s[i] и s[j] - цифры,
 составляющие нужное нам число повторов символа s[i].<br>
Печатаем символ нужное число раз, присваиваем i индекс следующей буквы для новой итерации цикла.    
<p>
<li> <b>Файл</b><br>
Напишите программу, которая считывает текст из файла (в файле может быть больше одной строки) и выводит самое частое слово в 
этом тексте и через пробел то, сколько раз оно встретилось. Если таких слов несколько, вывести лексикографически первое (можно 
использовать оператор < для строк).
<pre>
word = ''
d = {} 
maksimum = 0
spisok_max = {}
maks_word = ''
with open('/home/dmitriy/Python/mypython/dataset_3363_3.txt') as f:
  for line in f:
      line.strip() # удаляем служебные символы
      #print(line)
      for word in line.split():
          # заполняем словарь
          if word in d.keys():
              d[word] += 1
          else:
              d[word] =1 
# ищем максимальное количество слов
for key, value in d.items():
    if value > maksimum:
        spisok_max = {key:value}
        maksimum = value
    elif value == maksimum:
       spisok_max[key] = value
for key in spisok_max.keys():
    if key > maks_word:
        maks_word = key
print(maks_word, spisok_max[maks_word])
# Со строкой метод append не работает, чтобы добавить строку, используем оператор приращения.
# TypeError: can only concatenate str (not "list") to str: 
# TypeError: unsupported operand type(s) for +=: 'set' and 'list'
# for i in stroka переберет строку по буквам, чтобы по словам нужно использовать: for i in stroka.split()
</pre>
Ещё:
<pre>
<b>with open('dataset_3363_3.txt') as inf, open('MostPopularWord.txt','w') as ouf:
    maxc = 0
    s = inf.read().lower().strip().split()</b>
    s.sort()
    for word in s:
        counter = s.count(word)
        if counter > maxc:
            maxc = counter
            result_word = word
    ouf.write(result_word +' ' + str(maxc))</pre>
Без словаря, сразу читаем файл и сортируем список слов, чтобы потом первое найденное было лексиграфически впереди.
<br>
<b>Оказывается конструкция with является циклом.</b>

<li> <b>Файл, методы, циклы, списки</b>
<pre>
19:50 - 21:30 (1 ас и 40 минут)
Имеется файл с данными по успеваемости абитуриентов. Он представляет из себя набор строк, где в каждой строке записана следующая информация:

Фамилия;Оценка_по_математике;Оценка_по_физике;Оценка_по_русскому_языку

Поля внутри строки разделены точкой с запятой, оценки — целые числа.

Напишите программу, которая считывает исходный файл с подобной структурой и для каждого абитуриента записывает его среднюю оценку по трём предметам на отдельной строке, соответствующей этому абитуриенту, в файл с ответом.

Также вычислите средние баллы по математике, физике и русскому языку по всем абитуриентам и добавьте полученные значения, разделённые пробелом, последней строкой в файл с ответом.'''
d = {} # ключ - фамилия, значение - список из оценок
s = ''
num = 0
familia = []
ball = []
mathem = 0
phizik = 0
rus = 0
with open('/home/dmitriy/Python/mypython/dataset_3363_4.txt') as f:
    s = f.read().strip().split()
    for l in s:
        l = l.split(';')
        # print(l)
        for i in range(len(l)):
            if i % 4 == 0:
                familia.append(l[i])
                num = 0
            elif (i - 3) % 4 == 0:
                ball.append((num + int(l[i])) / 3)
                rus = rus + int(l[i])
            else:
                num = num + int(l[i])
                if (i - 1) % 4 == 0:
                    mathem = mathem + int(l[i])
                elif (i - 2) % 4 == 0:
                    phizik = phizik + int(l[i])
for i in ball:
    print(i)            
print(mathem/len(familia), phizik/len(familia), rus/len(familia))</pre>
<b>Ещё:</b>
<pre>
koll, a1, b1, c1 = 0, 0, 0, 0
with open('dataset_3363_4.txt', 'r') as inf:
    for line in inf:
        line = line.strip().split(';')
        a, b, c = int(line[1]), int(line[2]), int(line[3])
        print((a+b+c)/3)
        koll += 1
        a1 += a
        b1 += b
        c1 += c
print((a1/koll), (b1/koll), (c1/koll))</pre>

<li> <a name="modul"><b>Модули</b><br>
Напишите программу, которая подключает модуль math и, используя значение числа π из этого модуля, находит для переданного ей на 
стандартный ввод радиуса круга периметр этого круга и выводит его на стандартный вывод.
<pre>
from math import pi
print(float(input()) * pi * 2)</pre>
<p>
<li> Напишите программу, которая запускается из консоли и печатает значения всех переданных аргументов на экран (имя скрипта 
выводить не нужно). Не изменяйте порядок аргументов при выводе.
<p>
Для доступа к аргументам командной строки программы подключите модуль sys и используйте переменную argv из этого модуля.
<pre>
import sys
print(*sys.argv[1::])</pre>
Метод sys.argv выдаст список, где первый элемент - это имя вызвавшей программы, а следующие - это аргументы программы. Поскольку нам не нужно имя программы, то к списку применяем срез.
<br><img src="./images/python_example.png"><br>
Первую и вторую команду применили без среза.<br>
3 команду без звездочки внутри print()
<p>
<li>
Скачайте файл. В нём указан адрес другого файла, который нужно скачать с использованием модуля requests и посчитать число строк в нём.
<p>
Используйте функцию get для получения файла.
<p>
После получения файла вы можете проверить результат, обратившись к полю text. Если результат работы скрипта не принимается, проверьте поле url на правильность. Для подсчёта количества строк разбейте текст с помощью метода splitlines.
<pre>
import requests
# Прочитаем url со скачанного файла
with open('/home/dmitriy/Python/mypython/dataset_3378_2.txt') as f:
    s = f.read()
    # print(s)  #  адрес страницы, которую нужно скачать
r = requests.get(s)  # простой get-запрос
#print('Ответ сервера:', '\n', r.text.splitlines()) # вывод ответа от сервера
#print('Ответ сервера:', '\n', r.text)
for i in r.text.splitlines():
    print(i)
print('количество строк=', len(r.text.splitlines()))
</pre>
<font color=red>SyntaxError: unexpected character after line continuation character</font><br>
Данная ошибка означает, что где-то болтается '\'  вне строки. После того, как в print('Ответ сервера:', <font color=red>\n</font>, r.text) <b>\n</b> заключил в кавычки, ошибка исчезла.
<p>
r = requests.get(s).splitline()  # простой get-запрос<br>
<font color=red>AttributeError: 'Response' object has no attribute 'splitline'</font><br>
Ошибку устранил, когда метод splitline() применил к объекту r.text, а не в команде <b>r = requests.get(s).splitline()</b>, которая вызывала ошибку.
<p>
<li><br>
Имеется набор файлов, каждый из которых, кроме последнего, содержит имя следующего файла.
Первое слово в тексте последнего файла: "We".
<p>
Скачайте предложенный файл. В нём содержится ссылка на первый файл из этого набора.
<p>
Все файлы располагаются в каталоге по адресу:
https://stepik.org/media/attachments/course67/3.6.3/
<p>
Загрузите содержимое ﻿последнего файла из набора, как ответ на это задание.
<pre>
url = 'https://stepik.org/media/attachments/course67/3.6.3/'
import requests
with open('/home/dmitriy/Python/mypython/dataset_3378_3.txt') as f:
    u = f.read()
    # u = u[len(url):]  # из файла dataset_3378_3.txt получаем полный url, поэтому чтобы использовать его в цикле обрезаем
    #print('Адрес 1 файла из набора:', url+u)
    print('Адрес 1 файла из набора:', u)
    # u = requests.get(url + u)
    u = requests.get(u)
k = 0 # счетчик файлов
while True:
    if u.text.split()[0] == 'We':
        break
    u = requests.get(url + u.text)
    print('k=', k, 'адрес следующего файла:', url+u.text)
    k +=1
print('Последний файл:\n\n', u.text)
</pre>
<font color=red>u = requests.get(str(url+u))<br>
TypeError: can only concatenate str (not "Response") to str</font><br>
Так и не смог решить проблему, извращенно сначало первый из набора отдельно вытащил url из файла и только к следующим через цикл посылал запрос. Похоже надо было так: <b>u = requests.get(url + u).text</b>

<p>
Не моё:
<pre>
import requests
url, name = 'https://stepik.org/media/attachments/course67/3.6.3/', '699991.txt'
while <b>name[:2] != 'We':</b>
    name = requests.get(url + name).text
print(name)</pre>
Еще:
<pre>
import requests
with open('dataset_3378_3.txt') as txt:
    a = txt.readline().strip()
print(a)
a = str(requests.get(a).text)
b = 'https://stepik.org/media/attachments/course67/3.6.3/'
while 'we' not in a:
    print(a)
    <b>a = requests.get(b + a).text</b>
print(a)</pre>

</ol>





<h3 align=center><a name="obiekt">Объекты</h3>
<ol>
<li> Реализуйте программу, которая будет вычислять количество различных объектов в списке.
Два объекта a и b считаются различными, если a is b равно False.
<p>
Вашей программе доступна переменная с названием objects, которая ссылается на список, содержащий не более 100 объектов. Выведите количество различных объектов в этом списке.
<pre>
objects = [1, 2, 1, 5, True, False, True, 'false', [], [1,2], [1,2]]
ans = 1
unik = {id(objects[0])}
massiv = [objects[0]]
for obj in objects: # доступная переменная objects
    if id(obj) in unik:
        continue
    else:
        unik.add(id(obj))
        massiv.append(obj)
        ans += 1

print('Список уникальных объектов = ', massiv)
print('Список ID уникальных объектов = ', unik)
print('Количество уникальных объектов = ', ans)</pre>
Вывод:
<pre>
[1, 2, 5, True, False, 'false', [], [1, 2], [1, 2]]
{9776672, 9461728, 9776704, 9464160, 9776800, 139738779320768, 139738778605952, 139738778694720, 139738778694640}</pre>
Дебильное решение, не учел, что свойство множества принимать только уникальное значение.
<p>
Грамотное другое решение:
<pre>
s=set()
for obj in objects:
    s.add(id(obj))
print(len(s))</pre>

</ol>

<h3 align=center><a name="oop">ООП</h3>
<ol>
<li> Реализуйте класс MoneyBox, для работы с виртуальной копилкой.
<p>
Каждая копилка имеет ограниченную вместимость, которая выражается целым числом – количеством монет, которые можно положить в копилку. Класс должен поддерживать информацию о количестве монет в копилке, предоставлять возможность добавлять монеты в копилку и узнавать, можно ли добавить в копилку ещё какое-то количество монет, не превышая ее вместимость.
<p>
При создании копилки, число монет в ней равно 0.
Примечание:
метод add(self, v) будет вызываться только если can_add(self, v) – True﻿."""
<pre>
class MoneyBox:
    def __init__(self, capacity):
        self.capacity = capacity
        
    def can_add(self, v):
        # True, если можно добавить v монет, False иначе
        if self.capacity >= v:
            return True
        else:
            return False

    def add(self, v):
        # положить v монет в копилку
        if self.can_add(v):
            self.capacity -= v</pre>
Блок:
<pre>
if self.capacity >= v:
            return True
        else:
            return False</pre>
можно заменить одной строкой: <b>return self.capacity >= v</b>
<p>
<li> Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой последовательности, затем сумму второй пятерки, и т. д.
<p>
Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. Например, 
сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.
<p>
Реализуйте класс Buffer, который будет накапливать в себе элементы последовательности и выводить сумму пятерок 
последовательных элементов по мере их накопления.
<p>
Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, 
т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.
<p>
Обратите внимание, что во время выполнения метода add выводить сумму пятерок может потребоваться несколько раз до тех пор, 
пока в буфере не останется менее пяти элементов.
<pre>
class Buffer:
    def __init__(self):
        self.lst = []
               
    def add(self, *a):
        '''
        Сохраняем список аргументов в self.lst (как отличить ввод в первый раз от повторного ввода)
        Считаем количество чисел в lst,
        если меньше 5, то ничего не делаем.
        Иначе печатаем сумму среза списка из первых пяти элементов
        В цикле пока длина не меньше 5:
          выводим сумму 5 элементов
          удаляем 5 первых элементов.
        '''
        for i in a:  # выводим аргументы в список
            self.lst.append(i)
        # print('self.lst=', self.lst)
        if len(self.lst) <5:
            return
        else:
            while len(self.lst) >= 5:
                print(sum(self.lst[:5:1]))
                del self.lst[0:5]
                
    def get_current_part(self):
        # вернуть сохраненные в текущий момент элементы последовательности в порядке, в котором они были добавлены
        return self.lst</pre>
<b>Грамотное решение:</b>
<pre>
class Buffer:
    def __init__(self):
        self.part = []

    def add(self, *a):
        for i in a:
            self.part.append(i)
            if len(self.part) == 5:
                print(sum(self.part))
                self.part.clear()

    def get_current_part(self):
        return self.part</pre>
Сразу считал 5 элементов, суммировал, выводил и удалял их, а не как я, запоминал весь ввод и потом считывал первые 5 элементов.

</div>
<br><br><br><br></body></html>
