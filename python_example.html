<html><head>
<style>
.menu {
       height: 100%;
       width: 130px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 140px; /* То же, что и ширина боковой панели */
           padding: 0px 0px 0px 0px;
         }
</style>
</head><body>
<title>Примеры</title>
<div class="menu">
<a href="python_base.html">Основы python</a> 
<a href="#print">Функция print()</a>
<a href="#format">Формирование строки</a>
<a href="#input">input()</a>
<a href="#while">Циклы</a>
<a href="#number">Числа</a>
<a href="#set">Множество</a>
<a href="#string">Строки</a>
<a href="#list">Список</a>
<a href="#dict">Словари</a>
Алгоритмы:
<a href="#matrix">Матрицы</a>
<a href="#lst_array">Односвязные списки</a>
<a href="#graf">Задачи на графы</a>
<a href="#fun">Функции:</a>
<a href="#recurs_fun">Рекурсивные функции</a>
<a href="#lambda">&nbsp;&nbsp; lambda-функции</a>
<a href="#modul">Модули:</a>
<a href="#stdin">&nbsp;&nbsp; stdin</a>
<a href="#obiekt">Объекты</a>
<a href="#oop">ООП</a>
<a href="#iterator">Итерироние классов</a>
<a href="#gener">Функции-итераторы</a>
<a href="#try">try / except</a>
<a href="#library">Библиотеки:</a>
</div>
<div class="content">
<a name="print"><h3 align=center>Функция print()</h3>
<b>Вывод числа в определенном формате, дробное число в научном формате (экспоненциальном)</b>
Требуется написать программу, осуществляющую преобразование из одних единиц измерения длины в другие.<br>
Формат ввода:<br>
Одна строка с фразой следующего вида: &lt;number> &lt;unit_from> in &lt;unit_to><br>
например, если пришла фраза "15.5 mile in km", то требуется перевести 15.5 миль в километры.<br>
Формат вывода: <b>Дробное число в научном формате (экспоненциальном), с точностью ровно два знака после запятой</b>.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
"""
Программа для перевода с одной системы измерения длины в другую
"""

dict = {'mile':1609, "yard":0.9144, "foot":0.3048, "inch":0.0254, "km":1000, "cm":0.01, "mm":0.001, "m":1}
res = 0.0

str = input()

lst = str.split()  # ['15.5', 'mile', 'in', 'km']
# print(lst)

<font color=red>for key in dict.keys():
    if key == lst[1]:</font>  # зачем перебирать словарь, можно сразу было брать значение по ключу
        res= float(lst[0]) * dict[key]  # получили длину в метрах
        # print("res=",res)
        break
# теперь надо перевести длину в метрах в длину в lst[3]
if lst[3] != 'm':
    for key in dict.keys():
        if lst[3] == key:
            res /=dict[key]
            break

print("без форматирования=", res)
print("формула 10.3={:10.3f}".format(res))
print("формула 20.3={:20.3f}".format(res))
print("res через e с двумя знаками после запятой={:.2e}".format(res))
# без format
<b>print("res через e с двумя знаками после запятой без format=%.2e"%(res))
print("res с двумя знаками после запятой без format=%.2f"%(res))
print("res с двумя знаками после запятой и всего 10 знаков, без format=%10.2f"%res)</b>

Вывод:
15.5 mile in km
без форматирования= 24.9395
формула 10.3=    24.939
формула 20.3=              24.939
res через e с двумя знаками после запятой=2.49e+01
res через e с двумя знаками после запятой без format=2.49e+01
res с двумя знаками после запятой без format=24.94
res с двумя знаками после запятой и всего 10 знаков, без format=     24.94
</pre></td></tr>
<tr><td valign=top>
Другое:
<pre>
d = {
    "mile": 1609,
    "yard": 0.9144,
    "foot": 0.3048,
    "inch": 0.0254,
    "km": 1000,
    "m": 1,
    "cm": 0.01,
    "mm": 0.001
}
num, from_, _, to = input().split(' ')
num = float(num)
print("{0:.2e}".format(num * d[from_] / d[to]))
</pre></td></tr></table>
<p>
1. 2.49e+01 - это 2.49 * 10 в 1 степени = 24,9
<p>
2. print('{:3.2e}'.format(ans) -  3 - это общее число знаков в числе, 2 - число знаков после  запятой.
<pre>

==========================================================================================================================

</pre>
<a name="format"><h3 align=center>Формирование строки</h3>
<b>Формирование строки 3 способами</b><br>
Напишите программу, которая считывает два имени и выводит стихотворение, в котором вместо A и B используются принятые имена.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
name1 = input()
name2 = input()

# <b>Сишный способ (через спецификаторы)</b>
str_format = '''%s and %s sat in the tree.
%s had fallen, %s was stolen.
What's remaining in the tree?''' % (name1, name2, name1, name2)
print(str_format)

print("--------------------")

# <b>Способ через format, меньше всего из 3 вариантов нравится</b>
str_format = '''{0} and {1} sat in the tree.
{0} had fallen, {1} was stolen.
What's remaining in the tree?'''.format(name1, name2)
print(str_format)

print("--------------------")

# <b>Способ через f</b> более всех нравится
print(f'''{name1} and {name2} sat in the tree.
{name1} had fallen, {name2} was stolen.
What's remaining in the tree?''')
</pre></td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Формирование строки времени в формате hh:mm:ss</b><br>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
# 1 способ через format или %:
def make_readable(seconds):
    #h = seconds // 3600
    #minutes = (seconds % 3600) // 60
    #second = seconds - h * 3600 - minutes * 60
    return '{:02}:{:02}:{:02}'.format(seconds//3600, seconds%3600//60, seconds%60)
    # или через сишный способ (%)
    # return "%02d:%02d:%02d" % (h, m, s)
    # или через f-строку:
    # return f'{seconds//3600:02d}:{(seconds%3600)//60:02d}:{seconds%60:02d}'


'''
#2 способ через модуль datetime:
import datetime
def make_readable(s):
    x=datetime.timedelta(seconds=s)
    return x
'''

print(make_readable(0))     # "00:00:00"
print(make_readable(59))    # "00:00:59"
print(make_readable(86399)) # "23:59:59"
</pre></td></tr></table>
<pre>
--------------------------------------------------------------------------------------------------------------------------
</pre>
<b>Рисование</b><br>
Напишите программу, которая выводит число в стиле LCD калькулятора. На вход программе подаётся последовательность цифр, которую нужно вывести на экран в специальном стиле. Размер всех цифр 4 символа в ширину и 7 символов в высоту. Между цифрами в выводе должен быть один пустой столбец. Перед первой цифрой не должно быть пробелов. Выведенные цифры должны быть обведены рамочкой, в углах которой находится символ x ("икс"), горизонтальная линия создаётся из символа - ("дефис"), а вертикальная из символа вертикальной черты: |.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
stroka_numbers = input()

print("x" + (5 * len(stroka_numbers) - 1) * "-" + "x")

d = {'0': (' -- ', '|  |', '|  |', '    ', '|  |', '|  |', ' -- '),
     '1': ('    ', '   |', '   |', '    ', '   |', '   |', '    '),
     '2': (' -- ', '   |', '   |', ' -- ', '|   ', '|   ', ' -- '),
     '3': (' -- ', '   |', '   |', ' -- ', '   |', '   |', ' -- '),
     '4': ('    ', '|  |', '|  |', ' -- ', '   |', '   |', '    '),
     '5': (' -- ', '|   ', '|   ', ' -- ', '   |', '   |', ' -- '),
     '6': (' -- ', '|   ', '|   ', ' -- ', '|  |', '|  |', ' -- '),
     '7': (' -- ', '   |', '   |', '    ', '   |', '   |', '    '),
     '8': (' -- ', '|  |', '|  |', ' -- ', '|  |', '|  |', ' -- '),
     '9': (' -- ', '|  |', '|  |', ' -- ', '   |', '   |', ' -- ')
     }


# на цифры надо 7 строк
for i in [0, 1, 2, 3, 4, 5, 6]:
    # выводим строку с индексом i
    print("|", end='')  # первый элемент строки
    for j in range(len(stroka_numbers)): # индекс цифры в списке
        print(d[stroka_numbers[j]][i], end='')
        <font color=red>if j == (len(stroka_numbers) - 1):</font>  # лишнее, достаточно было по завершении цикла выполнить print("|")
            <font color=red>print("|")
        else:
            print(" ", end='')</font>
print("x" + (5 * len(stroka_numbers) - 1) * "-" + "x")
</pre></td></tr></table>
<p>
У меня решение основано на словаре, ключами являются цифры, а значения - кортеж из строк цифры. Этот словарь, я скопировал из сайта, но если самому делать, то дело это долгое. В этом случае можно скопировать строку всех цифр в список:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
<b>ss = """
x--------------------------------------------------x
| --        --   --        --   --   --   --   --  |
||  |    |    |    | |  | |    |       | |  | |  | |
||  |    |    |    | |  | |    |       | |  | |  | |
|           --   --   --   --   --        --   --  |
||  |    | |       |    |    | |  |    | |  |    | |
||  |    | |       |    |    | |  |    | |  |    | |
| --        --   --        --   --        --   --  |
x--------------------------------------------------x
""".split('\n')</b>
ds = input()
for y in range(1,10):
    s = ss[y][0]  # здесь похоже, чтобы не учитывать добавленные строки на предыдущих итерациях, создаем новый объект
    <font color=green><b>for d in ds:</b></font>  # оказывается символы из строки можно вытаскивать в цикле без индекса.
        x = 5 * int(d)
        s += ss[y][1 + x: 6 + x]  # похоже срезаем по формуле y-строку символа d и добавляем её в строку s
    print(s[0:-1] + ss[y][0])  # выводим готовую y-строку и '|'. s[0:-1] - похоже тут последний символ (пробел) убираем
</pre></td></tr></table>
<p>
ss - список:
<b><pre>
['',
'x--------------------------------------------------x',
'| --        --   --        --   --   --   --   --  |',
'||  |    |    |    | |  | |    |       | |  | |  | |',
'||  |    |    |    | |  | |    |       | |  | |  | |', 
'|           --   --   --   --   --        --   --  |',
'||  |    | |       |    |    | |  |    | |  |    | |', 
'||  |    | |       |    |    | |  |    | |  |    | |', 
'| --        --   --        --   --        --   --  |',
'x--------------------------------------------------x', 
'']
</pre></b>
Если бы расщепляли input() без аргумента (split()), то элементами списка были бы все последовательности между пробелами, а не все отдельные строки в случае split('\n').
<pre>

===========================================================================================================================

</pre>
<a name="unicode"><h3 align=center>Unicode</h3>
кодируются символы из интервала 1F600—1F64F таблицы символов Юникода. Используется кодировка UTF-8. Напишите программу, которая шифрует текст шифром Цезаря.<br>
Формат ввода:<br>
На первой строке указывается используемый сдвиг шифрования: целое число. Положительное число соответствует сдвигу вправо. На второй строке указывается непустая фраза для шифрования.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
sdvig = int(input()) % 80
str_shifr = input().strip()

print('Result: "', end="")
for simvol in str_shifr:
    int_simvol = <b>ord(simvol)</b>  # получаем десятичное значение кода символа
    # print(int_simvol)
    if (int_simvol + sdvig) > 128591:
        modif_simvol = 128511 + (int_simvol + sdvig - 128591)
    elif (int_simvol + sdvig) < 128512:
        modif_simvol = 128592 + (int_simvol + sdvig - 128512)
    else:
        modif_simvol = int_simvol + sdvig
    print(<b>chr(modif_simvol)</b>, end="")  # переводим назад в символ
print('"')
</pre></td></tr>
<tr><td>
Не моё:
<pre>
upset, string = int(input()), input()
print('Result: "', *[chr(128512 + (ord(i) - 128512 + upset) % 80) for i in string], '"', end = '', sep = '')
</pre></td></tr></table>
<pre>

==========================================================================================================================

</pre>
<a name="input"><h3 align=center>input() - ввод с stdin</h3>
<b>Ввод строк до определённого условия, функция iter()</b><br>
Напишите программу, имитирующую обработчик команд от пользователя.<br>
Программа должна выводить оповещение о своём состоянии в следующем формате:<br>
Когда пользователь вводит команду, содержимое которой обозначим как <command>, программа должна вывести фразу<br>
Processing "&lt;command>" command...
Например, пользователь ввёл Come to me, в таком случае должна быть выведена строка:<br>
Processing "Come to me" command...<br>
Считывание команд должно продолжаться до ввода команды End, при этом программа должна вывести сообщение:<br>
Good bye!<br>
и завершиться
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
lst1 = []
while True:
    lst1.append(input())
    if lst1[-1] == 'End':
        print("Good bye!")
        break
    print(f"Processing \"{lst1[-1]}\" command...")
</pre></td>
<td valign=center>
<pre>
command = input()
while command != 'End':
    print(f'Processing "{command}" command...')
    command = input()
print('Good bye!')

Другое решение:
for c in <b>iter(input,'End')</b>:
    print('Processing "{}" command...'.format(c))
print('Good bye!')
</pre></td></tr></table>
<pre>


============================================================================================================================


</pre>
<a name="while"><h3 align=center>Циклы:</h3>
Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ... (число повторяется столько 
раз, чему равно). На вход программе передаётся неотрицательное целое число n — столько элементов последовательности должна 
отобразить программа. На выходе ожидается последовательность чисел, записанных через пробел в одну строку.
<br>Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Мое решение:
<pre>
k = 1
n = int(input())
m = [] # полный список
for i in range(1,n+1):
    m = m + [i]*i
for a in m:
    print(a,end=' ')
    k += 1
    if k > n:
        break
print()
</pre>
</td><td valign=top>
Не моё:
<pre>
n = int(input())
a = []
i = 0
while len(a) < n:
    a += [i] * i
    i += 1
print(*a[:n])
</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая принимает на вход список чисел в одной строке и выводит на экран в одну строку значения, 
которые встречаются в нём более одного раза.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё решение:
<pre>
list = [int(i) for i in input().split()]
list_end = []
i = 0
while len(list) > 1:
    find_number = list[i]
    list.remove(list[i])
    if find_number in list and not find_number in list_end:
        list_end.append(find_number)
for element in list_end:
    print(element,end=' ')
</pre>
</td><td>
Другое решение:
<pre>
a, c = [str(i) for i in input().split()], []
for i in a:
    if i not in c and a.count(i) > 1:
        c.append(i)
        print(i, end=' ')
</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>        
На вход программы подаётся список чисел lst и число x. Программа должна выдавать на выход в виде одной строки позиции 
расположения числа х в списке чисел lst. Если число х в списке lst  не обнаружено, необходимо вывести на выход строкой 
"Отсутствует".
<pre>
lst = [int(i) for i in input().split()]
x = int(input())
# Перебрать список lst по элементам
# каждый элемент сравнивать с x
# если совпадает, то напечатать индекс
# если же нет, то следующий элемент вытаскиваем
i = 0  #    определяем переменную, иначе будет ошибка
if x not in lst:
    print('Отсутствует')
else:
    for lst[i] in lst:
        if lst[i] == x:
            print(i, end=' ')
        i += 1

# 1. Ошибка <font color=red>IndexError: list assignment index out of range</font> возникает в Python, когда нельзя присвоить значение элементу,
 который ещё не существует в списке. Ошибку устранил, когда в <b>for num[i] in lst:</b> num[i] поменял на lst[i]
# 2. В <b>for lst[i] in lst:</b> i автоматически не прибавляет на 1</pre>

Не моё решение:
<pre>
lst, x = input().split(), input()
if x in lst:
    for i in range(len(lst)):
        if lst[i] == x:
            print(i, end=' ')
else:
    print('Отсутствует')</pre>
В этом решении цикл по индексу списка, а не по элементу списка, как у меня.
<pre>

-----------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк. После последней строки
 матрицы идёт строка, содержащая только строку "end"
<p>
Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j равен сумме элементов первой матрицы
 на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится с  противоположной стороны 
 матрицы.<br>
В случае одной строки/столбца элемент сам себе является соседом по соответствующему направлению.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
table = []
while True:
    table.append([x for x in input().split()])
    if table[-1] == ['end']:
        break
# удалим end
table.remove(['end'])
# str - количество элементов в table - это коли-во строк матрицы
# stolb - количество элементов в элементе table - это коли-во столбцов матрицы
if len(table) == 1:
    delta_str = 0
else:
    delta_str = 1
if len(table[0]) == 1:
    delta_stolb = 0
else:
    delta_stolb = 1
for str in range(len(table)): # по строкам
    if str == len(table) - 1:
        str = str - len(table)
    for stolb in range(len(table[str])):
        if stolb == len(table[str]) - 1:
            stolb = stolb - len(table[str])
        print(int(table[str + delta_str][stolb]) + int(table[str - delta_str][stolb]) + \
        int(table[str][stolb + delta_stolb]) + int(table[str][stolb - delta_stolb]), end=' ')
    print()
</pre>
</td></tr>
<tr><td>
Другое решение:
<pre>
a = [[int(i) for i in input().split()]]
b = input()
while b != 'end' :
    a.append([int(i) for i in b.split()])
    b = input()
for i in range(len(a)): 
    for j in range(len(a[i])): 
        print((a[i-1][j] + a[(i+1) % len(a)][j] + a[i][j-1] + a[i][(j+1) % len(a[i])]), end=' ')
    print()</pre>
Еще решение:
<pre>
c = []
while True:
    a = [i for i in input().split()]
    if a == ['end']:
        break
    c.append(a)
n, m = len(c), len(c[0])
for i in range(n):
    for j in range(m):
        x = int(c[i][j-1]) + int(c[i][j+1-m]) + int(c[i-1][j]) + int(c[i+1-n][j])
        print(x, end=' ')
    print()
</pre>
</td></tr></table>
<pre>

-----------------------------------------------------------------------------------------------------------------

</pre>
После дрессировки черепашка научилась понимать и запоминать указания биологов следующего вида:<br>
север 10<br>
запад 20
юг 30<br>
восток 40<br>
где первое слово — это направление, в котором должна двигаться черепашка, а число после слова — это положительное расстояние в сантиметрах, которое должна пройти черепашка.
<p>
Но команды даются быстро, а черепашка ползёт медленно, и программисты догадались, что можно написать программу, которая 
определит, куда в итоге биологи приведут черепашку. Для этого программисты просят вас написать программу, которая выведет 
точку, в которой окажется черепашка после всех команд. Для простоты они решили считать, что движение начинается в точке (0, 
0), и движение на восток увеличивает первую координату, а на север — вторую.
<p>
Программе подаётся на вход число команд n, которые нужно выполнить черепашке, после чего n строк с самими командами. Вывести нужно два числа в одну строку: первую и вторую координату конечной точки черепашки. Все координаты целочисленные.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
x = 0
y = 0
command = [input() for _ in range(int(input()))]
for str in command:
    if str.split()[0] == 'запад':
        x = x - int(str.split()[1])
    elif str.split()[0] == 'восток':
        x += int(str.split()[1])
    elif str.split()[0] == 'юг':
        y = y - int(str.split()[1])
    else: # север +y
        y += int(str.split()[1])
print(x, y)
</pre>
</td><td>
<b>Другое:</b>
<pre>
dict = {'север': 0, 'юг': 0, 'запад': 0, 'восток': 0}

for _ in range(int(input())):
    key, value = input().split()
    dict[key] += int(value)

print(dict['восток'] - dict['запад'], dict['север'] - dict['юг'])
</pre>
</td></tr></table>
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Пропуск итерации в цикле</b><br>
В римской системе счисления для обозначения чисел используются следующие символы (справа записаны числа, которым они соответствуют в десятичной системе счисления):
<pre>
I = 1
V = 5
X = 10
L = 50
C = 100
D = 500
M = 1000
</pre>
Будем использовать вариант, в котором числа 4, 9, 40, 90, 400 и 900 записываются как вычитание из большего числа меньшего: IV, IX, XL, XC, CD и CM, соответственно.<br>
Напишите программу, которая переводит число из римской в десятичную систему счисления.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
r_dict = {'I' : 1, 'V' : 5, 'X' : 10, 'L' : 50, 'C' : 100, 'D' : 500, 'M' : 1000}
r_number = input() + '/'  # MCMLXXXIV
#r_number = input()
number = 0
i = 0
# for i in range(len(r_number)-1):
while i < len(r_number):
   print(i)
   if r_number[i] == '/':
       break
   if r_number[i+1] == '/' or r_dict[r_number[i]] >= r_dict[r_number[i+1]]:
        number += r_dict[r_number[i]]
   elif r_dict[r_number[i]] < r_dict[r_number[i+1]]:
       number += (r_dict[r_number[i+1]] - r_dict[r_number[i]])
       i += 1
   i +=1
   print(number)
print(number)
</pre></td></tr>
<tr><td>
<pre>
a = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
text = input()
sum = 0
for i in <b>range(len(text)-1):</b> # пропускаем последний элемент, чтобы потом его вручную прибавить
    if a[text[i]] < a[text[i + 1]]:
        sum -= a[text[i]]
    else:
        sum += a[text[i]]
<b>sum += a[text[len(text)-1]]</b>  # не надо придумывать костыль с последним элементом
print(sum)
</pre></td></tr>
<tr><td valign=top>
Другое:
<pre>
a, d, temp, s = {'I': 1, 'V' : 5, 'X' : 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000},0, 0, input()[::-1]
for i in s:
    d += a[i] if temp <= a[i] else -a[i]
    temp = a[i]
print(d)
</pre>
<font color=green>input()[::-1]</font> переворачивает строку<br>
Идём с обратной стороны строки, если предыдущий символ больше текущего, то вычитаем из результата текущий, иначе прибавляем</td></tr></table>
<p>
1. как в for i in range(len(n)): следующую итерацию пропустить<br>
В for i in range(len(n)): никак не пропустишь i, поэтому лучше использовать другой цикл while, где счетчик вручную увеличивают.
<p>
2. Ошибка «TypeError: 'type' object is not subscriptable» в Python возникает, когда пытаются получить доступ к элементу объекта, используя индекс, а объект не поддерживает такую операцию.
<pre>

======================================================================================================================

</pre>
<a name="number"><h3 align=center>Числа</h3>
<b>Сокращенная запись операций с числами</b><br>
Напишите функцию, которая для заданного натурального числа n генерирует последовательность чисел, описанную в гипотезе Коллатца:<br>
Если n четное, то делим его пополам, если нечётное, то умножаем на 3 и прибавляем 1. С итогом вычисления снова проделываем эту операцию до тех пор, пока в результате не будет получено число 1.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
n = int(input())

print(n, end=' ')
while n != 1:
    if n % 2 == 0:
         n //= 2
    else:
        <b>n = n * 3 + 1</b>
        # n (*= 3) +1 SyntaxError: invalid syntax
        # n *= 3 + 1 # 68
        #(n *= 3) + 1  SyntaxError: invalid syntax
    print(n, end=' ')
</pre></td></tr></table>
<p>
Здесь интересно, что если n *= 3 + 1 и n=17, то результат будет 68, а не 52. И как не пробовал сокращенно записать, не получилось.
<pre>

-------------------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, которая принимает на вход список чисел и число, после чего выводит все позиции, на которых это число встречается в переданном списке. Позиции в списке нумеруются с нуля. Если число x не найдено в списке, нужно вывести строку "None" (без кавычек, с большой буквы).
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
lst_int = input().split()
number = int(input())
a = None

for i in range(len(lst_int)):
    if number == int(lst_int[i]):
        print(i, end=' ')
        a = 1
if (a == None):
    print(a)

#[print(i, end=' ') for i in range(len(lst_int)) if number == int(lst_int[i])]
</pre></td></tr>
<tr><td valign=top>
<pre>
s = input().split(' ')
sub = input() 
print(*([i for i, x in enumerate(s) if x == sub] or ['None']), sep=' ')
</pre>
Если получим пустой список, то он с точки зрения логики считается как False, а список со строкой "None" будет не пустой всегда, т.е. истина! Эта строка и выведется, т.к. впереди списка - звездочка. А если список не пустой (он считается "Тру"), то выведутся его элементы, поскольку второй список - со строкой "Нан" не будет при этом рассматриваться. Вот так это работает.</td></tr>
<tr><td>
<pre>
a = input().split()
n = input()

if not n in a:
    print("None")
else:
    for i in range(len(a)):
        if a[i] == n:
            print(i)
</pre>
Без создания переменной a, как у меня. И сравниваюся строки, нет лишнего перевода в числа.</td></tr></table>
<pre>

-----------------------------------------------------------------------------------------------------------------------

</pre>
<b>в stdin вводим последовательность чисел, получаем из нее список чисел, функция map()</b><br>
Последовательность n>0 целых чисел называется jolly jumper в случае, если значения абсолютных разностей последовательных элементов принимают все возможные значения между 1 и n−1.<br>
Например, последовательность 1 -3 -4 -1 1 является jolly jumper последовательностью.<br>
Будем считать, что последовательность из одного числа является jolly jumper.<br>
Напишите программу, которая проверяет, является ли введённая последовательность jolly jumper.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
<b>lst_int = list(map(int, input().split()))</b>
new_lst = []
n = len(lst_int)

for i in range(1, n):
    new_lst.append(abs(lst_int[i] - lst_int[i-1]))
new_lst.sort()
print("сортированный список=", new_lst)
print([i for i in range(1, n)])
if new_lst == [i for i in range(1, n)]:
    print("Jolly")
else:
    print("Not jolly")
</pre></td>
<td valign=top>
Другое:
<pre>
x=list(map(int,input().split()))
y=list(map(lambda i, j: abs(i - j), x[0:-1], x[1:]))
print(['Not jolly','Jolly'][set(range(1,len(x)))==set(y)])

Другое, похожее на мое, только упакованное:
a = [int(i) for i in input().split()]
print('Jolly' if sorted([abs(a[i]-a[i+1]) for i in range(len(a)-1)]) ==
                        [i for i in range(1,len(a))] else 'Not jolly')
</pre></td></tr></table>
<pre>

---------------------------------------------------------------------------------------------------------------------

</pre>
<b>Записать в 2 переменные через input последовательность из 2 чисел</b><br>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
n1, n2 = [int(x) for x in input().split()]
# или: n1, n2 = map(int, input().split())

for i in range(n1, n2+1):
    if i % 3 == 0 and i % 5 != 0:
        print("Fizz")
    elif i % 5 == 0 and i % 3 != 0:
        print("Buzz")
    elif i % 5 == 0 and i % 3 == 0:
        print("FizzBuzz")
    else:
        print(i)
</pre></td>
<td valign=top>
Другое:
<pre>
start, end = map(int, input().split())
for i in range(start, end + 1):
    print('Fizz' * (i % 3 == 0) + 'Buzz' * (i % 5 == 0) or i)
</pre></td></tr></table>
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Сокращенная запись арифметических операций</b><br>
Перевод чисел из римской системы в арабскую
<p>
<table border=1 style="border-collapse:collapse;"><tr><td>
<pre>
number = int(input())

dict1 = {1000: 'M',900: 'CM',500: 'D', 400: 'CD', 100: 'C', 90: 'XC', 50: 'L', 40: 'XL', 10: 'X', 9: 'IX', 5: 'V', 4: 'IV', 1: 'I'}
str1 = ''

for key in dict1:
    if number / key >= 1:
        str1 += (number // key) * dict1[key]
        number %= key


print(str1)
</pre></td></tr></table>
<p>
1. UnboundLocalError: local variable 'str1' referenced before assignment<br>
Перетащил str1 из глобальной области внутрь функции и делаю возврат str1
<pre>


========================================================================================================================


</pre>
<a name="set"><h3 align=center>Множество</h3>
<b>Преобразование списка в строку и назад в список с целью сделать список из отдельных слов<br>
<font color=blue>Множество из списка.</font></b><br>
<font color=brown>Методы цепочкой</font>
<p>
На вход программе первой строкой передаётся количество 
d известных нам слов, после чего на d строках указываются эти слова. Затем передаётся количество 
l строк текста для проверки, после чего l строк текста.
<p>
Выведите уникальные "ошибки" в произвольном порядке. Работу производите без учёта регистра.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
list1 = []
list2 = []
d = int(input())
for i in range(d):
    <font color=brown>list1.append(input().lower())</font>
l = int(input())
for i in range(l):
    list2.append(input().lower())
<b>'''print(list2) # список из фраз
list2 = ' '.join(list2) # преобразовали список в одну строку без запятых
list2 = list2.split()   # преобразовали строку назад в список но из отдельных слов
'''
list2 = ' '.join(list2).split()
<font color=blue>list2 = set(list2)</font></b>
print(list2)
for i in list2:
    if i not in list1:
        print(i)
</pre>
</td></tr></table>
<pre>list1 = list1.append(input())
<font color=red>AttributeError: 'NoneType' object has no attribute 'append'</font></pre>
Устранил ошибку, когда изменил выражение list1 = list1.append(input()) на list1.append(input())
Другое решение:<br>
<font color=green>Способ создания множества/списка из нескольких вводов одной строкой</font>
<pre>
# формируем множество известных слов на основании построчного ввода
<font color=green>dic = {input().lower() for _ in range(int(input()))}</font>

# заводим пустое множество для приема текста
wrd = set()

# т.к. текст построчно подается, а также в каждой строке несколько слов,
# то каждую строку превращаем во множество и добавляем в единое множество wrd
for _ in range(int(input())):
    wrd |= {i.lower() for i in input().split()}

# на вывод отправляем результат вычитания словарного множества dic
# из текстового множества wrd; впереди ставим *, чтобы раскрыть поэлементно
print(*(wrd-dic), sep="\n")</pre>
wrd |= {...} отвечает за добавление множества {...} в единое wrd (аналог метода update)<br>
заменил ненужные символы переменных на _
<pre>


----------------------------------------------------------------------------------------------------


</pre>
<br> <b>Множество<br>применение одновременно нескольких методов</b>
<br>
Программа должна считывать одну строку со стандартного ввода и выводить для каждого уникального слова в  этой строке число его повторений (без учёта регистра) в формате "слово количество".<br>
Порядок вывода слов может быть произвольным, каждое уникальное слово﻿ должно выводиться только один раз.
<pre>
<b>str = input().lower().split()</b>
for i in set(str):
    print(i, str.count(i)</pre>
<pre>

-------------------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, которая принимает на вход список целых чисел и выводит на экран значения, которые повторяются в нём более одного раза.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
list_int = input().split()
set_int = set()

for n in list_int:
    if list_int.count(n) > 1:
        set_int.add(n)        
for n in set_int:
    print(n, end=' ')
</pre></td>
<td valign=top>
<pre>
a = input().split()
b = set(a)
print(*[i for i in b if a.count(i) > 1])
</pre></td></tr></table>
<pre>

======================================================================================================================

</pre>
<a name="string"><h2 align=center>Строки</h2>
<pre>
Examples:
accum("abcd") -> "A-Bb-Ccc-Dddd"
accum("RqaEzty") -> "R-Qq-Aaa-Eeee-Zzzzz-Tttttt-Yyyyyyy"
accum("cwAt") -> "C-Ww-Aaa-Tttt"
</pre>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
Мое:
<pre>
def accum(st):
    lst1 = []
    for i in range(1,len(st)+1):
       lst1.append((st[i-1] * i).title())

    return '-'.join(lst1)

print(accum("ZpglnRxqenU"))
</pre></td>
<td valign=top>
<pre>
def accum(s):
    return '-'.join(c.upper() + c.lower() * i for i, c in enumerate(s))
</pre></td></tr></table>
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Объединение строк, сортировка списка по длине элементов sort()</b><br>
Даны список слов strarr и число k .<br>
Нужно получить список из соединенных k раз элементов strarr и вернуть самое длинное.<br>
Если k больше длины массива или k = 0, то вернуть ""
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
Мое:
<pre>
def longest_consec(strarr, k):
    if len(strarr) == 0 or k > len(strarr) or k <= 0:
        return ""
    else:
        list_words = []
        for i in range(len(strarr)-k+1):
            word = ''
            <font color=red>for j  in range(i, i+k):
                word +=strarr[j]</font>

            list_words.append(word)

        list_words.sort(key=lambda s: len(s), reverse=True)
    
    return list_words[0]

print(longest_consec([], 3))
</pre></td>
<td valign=top>
Не моё:
<pre>
def longest_consec(strarr, k):
    result = ""
    
    if k > 0 and len(strarr) >= k:
        for index in range(len(strarr) - k + 1):
            <font color=green>s = ''.join(strarr[index:index+k])</font>
            if len(s) > len(result):
                result = s
            
    return result
</td></tr></table>
<p>
В строке list_words.sort(key=lambda s: len(s), reverse=True)<br>
для сортировки по длине элементов применил ключ len(s), reverse=True означает, что элементы будут располагаться по убыванию длины.
<p>
В s = ''.join(strarr[index:index+k])<br>
берём сразу срез элементов (не через цикл как у меня) и преобразуем в строку.
<p>
<b>Наверное решение можно было сформировать двигаясь от искомого решения к заданным условиям задачи:<br>
результат нужен в виде наибольшей строки, значит объявляем строку result<br>
далее нужно было вспомнить про срезы списков и метод преобразования списков в строку - join</b>
<pre>


----------------------------------------------------------------------------------------------------------------------

</pre>
<b>Преобразование строки, копирование в пустую строку, библиотека itertools, регулярные выражения</b><br>
Кодирование длин серий — это базовый алгоритм сжатия данных.<br>
На вход алгоритму подаётся строка, содержащая символы латинского алфавита. Эта строка разбивается на группы одинаковых символов, идущих подряд ("серии"). Каждая серия характеризуется повторяющимся символом и количеством повторений. Именно эта информация и записывается в код: сначала пишется длина серии повторяющихся символов, затем сам символ. У серий длиной в один символ количество повторений будем опускать.<br>
Например, рассмотрим строку: aaabccccCCaB<br>
Разобъём её на серии<br>
aaa b cccc CC a B<br>
После чего закодируем серии и получим итоговую строку, которую и будем считать результатом работы алгоритма:<br>
3ab4c2CaB
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
Мое:
<pre>
str1 = input()
count = 1
str2 =''

if len(str1) == 1:
    print(str1)
else:
    for i in range(1, len(str1)):
        if str1[i] != str1[i-1]:
            if count == 1:
                <b>str2 +=str1[i-1]</b>
                if i == len(str1) - 1:
                    str2 +=str1[i]
            else:
                <b>str2 += str(count)+str1[i-1]</b>
            count = 1
        else:
            if i == len(str1) - 1:
                str2 += str(count+1)+str1[i-1]
            count +=1
    print(str2)
</pre></td>
<td valign=top>
Похожее на моё:
<pre>
s = input()+ ' '
first_index = -1
for i in range(len(s)-1):
    if (s[i] != s[i+1]):
        # count, first_index = i - first_index, i
        # Эта строчка эквивалентна:
        count = i - first_index
        first_index = i

        print(str(count)*<b>(count > 1)</b> + s[i], end = '')
        # Можно так:
        print(str(count) + s[i] if count > 1 else s[i], end='')
</pre>
1. В самой нижней строчке (count > 1) - это условие, если не истинно, тогда str(count) не будет выводиться
<p>
2. Добавляемый пробел никак не влияет на вывод, как бы его не существует.</td></tr></table>
<p>
1. Как в список в качестве одно элемента передать число со строкой<br>
Не работает tmp_str = chr + str(count) Получаю:<br>
TypeError: 'str' object is not callable<br>
Проблему решил когда имя строки поменял с str на str1<br>
<font size=7 color=brown>Больше не называть строковый объект по имени str</font>
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
<b>Через модуль библиотеки itertools</b>
<pre>
from itertools import groupby

for i, j in groupby(input()):
    c = len(list(j))
    print(str(c)*(c > 1), i, sep='', end='')
print(i)  # 3ab4c2CaBB
print(j) # &lt;itertools._grouper object at 0x7...>
</pre></td>
<td valign=top>
<b>Через регулярку:</b>
<pre>
import re

#получаем серии в виде списка кортежей
# для: aaabccccCCaB
# [('aaa', 'a'), ('b', 'b'), ('cccc', 'c'), ('CC', 'C'), ('a', 'a'), ('B', 'B')]
series = <b>re.findall(r'(([a-zA-Z])\2*)', input())</b>
# Другой вариант: re.findall(r'((\w)\2*)', input())
#формируем строку, удаляя длины, равные 1
print(''.join([re.sub(r'\b1\b', '',str(len(crt[0])))+crt[1] for crt in series]))
</pre></td></tr></table>
<pre>

-----------------------------------------------------------------------------------------------------------------------

</pre>
<b></b><br>
Подсчёт символов в строке.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def count(s):
    dict_ch = {}
    for ch in set(s):
        dict_ch[ch] = s.count(ch)
    
    return dict_ch

print(count('aba'))
</pre></td>
<td valign=top>
<pre></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Подсчёт уникальных слов в строке, метод Counter модуля collections</b><br>
Когда Антон прочитал «Войну и мир», ему стало интересно, сколько слов и в каком количестве используется в этой книге. 
Помогите Антону написать упрощённую версию такой программы, которая сможет подсчитать слова, разделённые пробелом и вывести получившуюся статистику. Программа должна выводить для каждого уникального слова число его повторений (без учёта регистра).
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
'''
Способы чтения и файлов и stdin:
import fileinput

for line in fileinput.input():
    print(line)

import sys

for line in sys.stdin:
    print(line)
'''
<font color=red>lst_str = input().lower().split()</font>
print(lst_str)
set_str = set(lst_str)
print(set_str)
for word in set_str:
    print(word, lst_str.count(word))
</pre></td>
<td valign=top>
<pre>
s=input().lower().split()
[print(i, s.count(i)) for i in set(s)]
</pre>
Говорят, что <b>так делать не стоит</b>. Сложность этого решения O(n^2), то есть нужно пройтись по списку n раз для каждого элемента. причем O=Θ, то есть в самом лучшем и худшем варианте всегда будет сложность O(n^2). Для очень больших n расчет будет очень долгим.<br>
Если же воспользуетесь <b>встроенной функцией Counter from collections</b>, то сложность будет всего O(n).</td>
<td valign=top>
<pre>
<b>from collections import Counter</b>

text = input().lower().split()

d = Counter(text)

for i in d:
    print(i, ' ', d[i])

</pre>
# d = Counter(text)  для 'a aa abC aa ac abc bcd a' вернёт словарь Counter({'a': 2, 'aa': 2, 'abc': 2, 'ac': 1, 'bcd': 1})
<p>
По умолчанию в цикле берут ключ словаря
</td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Метод строки replace(), замена отдельных символов в предложении</b><br>
Ваша задача - написать функцию, которая принимает строку и возвращает новую строку с удаленными гласными. Например, строка "This website is for losers LOL!" станет "Ths wbst s fr lsrs LL!".
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def disemvowel(string_):
    vowels = 'aeiouAEIOU'
    for vowel in vowels:
        string_ = <b>string_.replace(vowel, '')</b>

    return string_

print(disemvowel("This website is for losers LOL!"))
</pre>
Через метод replace()</td>
<td valign=top>
Другое:
<pre>
def disemvowel(string):
    return "".join(c for c in string if c.lower() not in "aeiou")
</pre>
С помощью генератора кортежа</td></tr></table>
<pre>


=========================================================================================================================


</pre>
<a name="list"><h3 align=center>Список</h3>
Шифр Цезаря заключается в замене каждого символа входной строки на символ, находящийся на несколько позиций левее или правее его в алфавите.<br>
Для всех символов сдвиг один и тот же. Сдвиг циклический, т.е. если к последнему символу алфавита применить единичный сдвиг, то он заменится на первый символ, и наоборот.<br>
Напишите программу, которая шифрует текст шифром Цезаря.<br>
Используемый алфавит − пробел и малые символы латинского алфавита: ' abcdefghijklmnopqrstuvwxyz'
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
sdvig = int(input())
alfavit = ' abcdefghijklmnopqrstuvwxyz'
str_shifr = input().strip()

sdvig = sdvig % len(alfavit)
print(sdvig)
print('Result: "', end="")
for simvol in str_shifr:
    index = alfavit.find(simvol)
    if (index + sdvig) >= len(alfavit):
        other_simvol = alfavit[index+sdvig-len(alfavit)]
    else:
        other_simvol = alfavit[index+sdvig]
    
    print(other_simvol, end="")
print('"')
</pre></td>
<td valign=top>
<pre>
shift = int(input())
s_in = input().strip()
s_out = ''
abc = ' abcdefghijklmnopqrstuvwxyz'
for i in s_in:
    s_out += abc[(abc.find(i) + shift)%27]
print(f'Result: "{s_out}"')
</pre></td></tr></table>
<p>
1. Можно было весь код заменить после 2 строки на:
<pre>
res = [abc[(abc.index(c) + n) % len(abc)] for c in inp]
print('Result: "' + ''.join(res) + '"')
</pre>
2. Специально для таких задач в языке Питон созданы методы строки: maketrans и translate . Первый - создаёт словарь соответствия алфавит - шифр, второй - кодирует данную строку согласно этому словарю. Вместо вызова функции maketrans можно подставить и свой словарь. https://www.tutorialspoint.com/python3/string_translate.htm
<pre>

----------------------------------------------------------------------------------------------------------------------

</pre>
<b>Сортировка множества, генератор списка</b><br>
На вход программе подаётся строка, содержащая слова, разделённые пробелом. Программа должна вывести статистику длин слов в полученной строке, от меньшей длины слова к большей
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
lst_statist = <b>[len(word) for word in input().split()]</b>  # генерируем из строки слов список из слов
lst_set_length = list(set(lst_statist))  # преобразуем в множество и сразу в список, в 3 примере sorted сразу к множеству
# print(lst_set_length)
for number in sorted(lst_set_length):
    print(f'{number}: {lst_statist.count(number)}')
</pre></td></tr>
<tr><td valign=top>
<pre>
lib = {}
for item in input().split():
    lib[len(item)] = lib.<font color=red>get(len(item), 0)</font> + 1
    
for key, value in sorted(lib.items()):
    print(key, ": ", value, sep='')
</pre></td></tr>
<tr><td>
<pre>
s = input()
lst = list(map(len, s.split()))
for i in <font color=red>sorted(set(lst))</font>:  # непонятно, функция sorted применена к множеству, получается необязательно преобразовывать в список
    print('{}: {}'.format(i, lst.count(i)))
</pre></td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Функция join() преобразует список в строку.</b><br>
В какой-то момент вам надоело использовать имена файлов с пробелами и вы решили написать программу, которая переименовывает все файлы, содержащие пробелы в имени, заменив группы пробелов на символ подчёркивания "_".
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
lst_str = list(input().strip())
new_lst =[]

for i in range(len(lst_str)):
    if lst_str[i] == ' ' and new_lst[-1] != '_':
        new_lst.append('_')
        continue
    if lst_str[i] == ' ' and new_lst[-1] == '_':
        continue
    new_lst.append(lst_str[i])

print(''.join(new_lst))
</pre></td></tr></table>
<p>
Часа два думал над тем как в Решениях одной строкой сделали:
<pre>
print('_'.join(input().split()))
</pre>
<font size=4>input().split() получает список элементов без разницы сколько пробелов между этими элементами в введённой строке.</font>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Замена элемента-символа на число, создание копии списка, считывание ввода из нескольких строк одинаковой длины в прямоугольную матрицу</b><br>
Напишите программу, вычисляющую следующее состояние поля для Game of life.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
import copy

n, m = map(int, input().split())
lst1 = []

for _ in range(n):
      lst1.append(input())

lst2 = []
lst3 = []

# в lst1 записываем единицы нолики вместо . и X в lst1
for row in range(n):
    for col in range(m):
        if lst1[row][col] == '.':
            lst2.append(0)
        else:
            lst2.append(1)
lst2 = [[lst2[i*m + j] for j in range(m)] for i in range(n)]
'''
# Этот код можно было реализовать одной строкой:
# <font color=green size=4><b>a = [[int(c == 'X') for c in input()] for _ in range(n)]</b></font>

lst3 = copy.deepcopy(lst2)


for row in range(n):
    for col in range(m):
        
        '''<font color=gray>
        Не подходит для случая n = 1 (1 список внутри списка)
        if row == n - 1:
            row = -1
        if col == m - 1:
            col = -1
        summa = lst2[row-1][col-1] + lst2[row-1][col] + lst2[row-1][col+1] + lst2[row][col-1] + lst2[row][col+1] + 
                lst2[row+1][col-1] + lst2[row+1][col] + lst2[row+1][col+1]</font>
        '''

        summa1 = lst2[(row - 1) % n][(col - 1) % m]
        summa2 = lst2[(row - 1) % n][(col) % m]
        summa3 = lst2[(row - 1) % n][(col + 1) % m]
        summa4 = lst2[(row) % n][(col - 1) % m]
        summa5 = lst2[(row) % n][(col + 1) % m]
        summa6 = lst2[(row + 1) % n][(col - 1) % m]
        summa7 = lst2[(row + 1) % n][(col) % m]
        summa8 = lst2[(row + 1) % n][(col + 1) % m]
        summa = summa1 + summa2 + summa3 + summa4 + summa5 + summa6 + summa7 + summa8
        #print("row=", row, "col=", col, "summa=", summa)
        if summa < 2 or summa > 3:
            lst3[row][col] = 0
        if summa == 3:
            lst3[row][col] = 1
            
for row in range(n):
    for col in range(m):
        if lst3[row][col] == 0:
            lst3[row][col] = '.'
        else:
            lst3[row][col] = 'X'
        print(lst3[row][col], end='')
        if col == m - 1: print()
</pre></td></tr></table>
<p>
1. TypeError: 'str' object does not support item assignment<br>
Как элемент списка типа строка заменить на число<br>
Никак. Просто создаем новый список lst3 и в нём присваиваем значения из списка lst2
<pre>

-------------------------------------------------------------------------------------------------------------------------

</pre>
<b>codewars 4 kuy<br>
Как не выйти за пределы списка при сравнении текущего эемента со следуюшим</b><br>
Завершите решение так, чтобы оно принимало список целых чисел в порядке возрастания и возвращало правильно отформатированную строку в формате диапазона:
<pre>
solution([-10, -9, -8, -6, -3, -2, -1, 0, 1, 3, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18, 19, 20])
# returns "-10--8,-6,-3-1,3-5,7-11,14,15,17-20"
</pre>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def solution(args):
    modify_list = []
    <b>i = 0
    while i < len(args):</b>
        count = 0
        if i == len(args)-1:
            modify_list.append(str(args[i]))
        else:
            if args[i] != args[i+1] -1:
                modify_list.append(str(args[i]))
            else:
                while ((i+count+1) < len(args)) and (args[i+count] == args[i+count+1] -1):
                    count +=1
                if count < 2:
                    modify_list.append(str(args[i]))
                    count = 0
                else:
                    modify_list.append(str(args[i])+'-'+str(args[i+count]))
        
        <b>i = i+count+1</b>
    
    return ','.join(modify_list)


print(solution([-6,-3,-2,-1,0,1,3,4,5,7,8,9,10,11,14,15,17,18,19,20,22]))
# '-6,-3-1,3-5,7-11,14,15,17-20,22'
</pre></td></tr>
<tr><td>
<pre>
def solution(args):
    out = []
    beg = end = args[0]
    
    for n in args[1:] + [""]:        
        if n != end + 1:
            if end == beg:
                out.append( str(beg) )
            elif end == beg + 1:
                out.extend( [str(beg), str(end)] )
            else:
                out.append( str(beg) + "-" + str(end) )
            beg = n
        end = n
    
    return ",".join(out)
</pre></td></tr></table>
<p>
<font color=brown size=5>Чтобы не выйти за пределы списка при сравнении элемента со следующим в Python, можно было к списку добавить какой-нибудь не числовой элемент типа ""</font> . Я не реализовал эту идею.
<p>
В цикле иногда происходит скачок сразу на несколько индексов, поэтому for для цикла не подходит.
<pre>

===========================================================================================================================

</pre>
<h3 align=center><a name="dict">Словарь</h3>
<b></b>
Напишите программу, которая определяет, бьёт ли одна карта другую. Если встречаются две карты одной масти, то побеждает та, у которой выше значение; Если карты разных мастей, то карта, имеющая козырную масть, побеждает; Если карты разных мастей и нет козырных, то никто не побеждает. Программа должна вывести слово First, если первая карта бьёт вторую, Second, если вторая карта бьёт первую, Error, если ни одна из карт не может побить другую.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
force_card = {'6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}
<font color=red>card1, card2 = [str(i) for i in input().split()]</font>  # проще так: first, second = input().split()
# print(card1)
# print(card2)
print(card1[:-1])
print(type(card1[:-1])) 

kozir = input()

if card1[-1] == card2[-1]:  # так как количество знаков в строке может быть 2 или 3 (разное), то берем по индексу -1
    if force_card[card1[:-1]] > force_card[card2[:-1]]: 
        print("First")
    else:
        print("Second")
else:
    if card1[-1] != kozir and card2[-1] != kozir:
        print("Error")
    elif card1[-1] == kozir:
        print("First")
    elif card2[-1] == kozir:
        print("Second")
</pre></td></tr></table>
<p>
1. force_card = {'6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}<br>
Ключи берем в кавычки потому что интепретатор сайта выдает ошибку при ранге карты =10 на строке if force_card[card1[:-1]] > force_card[card2[:-1]]:
<p>
2. force_card[card1[:-1]] - это из синтаксиса взятия подстроки из строки. str[:-1] берем все символы из строки кроме последнего.
<pre>


-------------------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, которая умеет шифровать и расшифровывать шифр подстановки. Программа принимает на вход две строки 
одинаковой длины, на первой строке записаны символы исходного алфавита, на второй строке — символы конечного алфавита, после 
чего идёт строка, которую нужно зашифровать переданным ключом, и ещё одна строка, которую нужно расшифровать.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
str_zashifr = []
str_shifr = []
shifr_rashifr = []
<b>alfavit = {key:0 for key in input()}</b>
shifr = input()
# сопоставляем ключу alfafit значение из shifr
i = 0
for key in alfavit.keys():
    alfavit[key] = shifr[i]
    i +=1
#print(alfavit)
str = input()
str_shifr = input()
for l in str:
    str_zashifr +=alfavit[l]
# print(*str_zashifr)
for l in str_zashifr:
    print(l, end='')
print()
# Перевернем словарь
<b>inv_alfavit = {v: k for k, v in alfavit.items()}</b>
for l in str_shifr:
    shifr_rashifr += inv_alfavit[l]  
for l in shifr_rashifr:
    print(l, end='')
print()</pre>
Создал словарь через input()<br>
Использовал переворачивание словаря.
</td><td>
Ещё решение:
<pre>
<b>a,b,c,d=input(),input(),input(),input()</b>
print(''.join(b[a.index(i)] for i in c))
print(''.join(a[b.index(i)] for i in d))
</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>

<b>Словарь</b><br>
Напишите программу, которая прочитает этот файл и подсчитает для каждого класса средний рост учащегося.
<p>
Файл состоит из набора строк, каждая из которых представляет собой три поля:<br>
Класс Фамилия Рост
<p>
Класс обозначается только числом. Буквенные модификаторы не используются. Номер класса может быть от 1 до 11 включительно. В 
фамилии нет пробелов, а в качестве роста используется натуральное число, но при подсчёте среднего требуется вычислить значение 
в виде вещественного числа.
<p>
Выводить информацию о среднем росте следует в порядке возрастания номера класса (для классов с первого по одиннадцатый). Если 
про какой-то класс нет информации, необходимо вывести напротив него прочерк.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
d = {key:[0, 0] for key in range(1,12)} # создали словарь
with open('/home/dmitriy/Python/mypython/dataset_3380_5.txt') as f:
    for line in f:
        #print(line.split()[0])
        # создадим словарь d, где ключ будет от 1 до 11, а значения сумма ростов и счетчик школьников
        # значение словаря список из двух чисел: d[key][0] и d[key][1]
        d[int(line.split()[0])] = [d[int(line.split()[0])][0] + int(line.split()[2]), d[int(line.split()[0])][1] + 1]
for key in d.keys():
    if d[key][1] == 0:
        print(key, '-')
    else:
        print(key, d[key][0] / d[key][1])</pre>
</td></tr></table>
<p>
<b>Другое решение, похоже на мое, но синтаксис грамотный</b>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
# Делаем словарь {1:[0,0], 2:[0,0]... 11:[0,0]}, где [0:0] = [сумма ростов : кол-во учеников]
tab = {i:[0,0] for i in range(1,12)} 

with open ('dataset_3380_5.txt') as inf:

	# Заполняем словарь:
	for i in inf:
		line = i.strip().split('\t')
		tab [ int(line[0]) ] [0] += int(line[2]) # tab[класс][0] += рост ученика
		tab [ int(line[0]) ] [1] += 1            # tab[класс][1] += 1 (счетчик учеников в классе)
	
	# Распечатка:
	for i in tab.keys():
		if tab[i][1] == 0:
			print (i, '-') # распечатываем класс, в котором нет учеников
		else:
			# считаем и распечатываем средний рост для i-го класса:
			print (i, ( tab[i][0] / tab[i][1] ))
</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая считывает строку с числом n, которое задаёт количество чисел, которые нужно считать. Далее 
считывает n строк с числами xi, по одному числу в каждой строке. Итого будет n+1 строк.
При считывании числа xi программа должна на отдельной строке вывести значение f(xi). Функция f(x) уже реализована и доступна 
для вызова. 
Функция вычисляется достаточно долго и зависит только от переданного аргумента x. Для того, чтобы уложиться в ограничение по времени, нужно избежать повторного вычисления значений.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
n = int(input())
l = []
d = {}
for i in range(n):
    l.append(int(input()))
'''Проходим каждый элемент списка
Вычисляем функцию и добавляем i и f в словарь
Если на следующем элементе уже вычисляли функцию (входит в словарь),
то выводим значение для текущего ключа из словаря'''
for i in l:
    if i not in d.keys(): # еще не выполняли функцию по этому числу
        d[i] = f(i)
        print(i, f(i))
    else:
        print(i, d[i])
</pre>
</td><td>        
Другое:
<pre>
a=[int(input()) for i in range(int(input()))]
b={x:f(x) for x in set(a)}
for i in a:
    print(b[i])</pre>
Ещё:
<pre>
d = {}
for _ in range(int(input())):
    x = int(input())
    if x not in d:
        d[x] = f(x)
    print(d[x])
</pre>         
</td></tr></table>
<pre>

---------------------------------------------------------------------------------------------------------------------

</pre>
<b>Игра: минное поле, считывание многострочной строки в словарь, считывание двух чисел через пробел</b><br>
Поле для игры сапёр представляет собой сетку размером n×m. В ячейке сетки может находиться или отсутствовать мина.<br>
Напишите программу, которая выводит "решённое" поле, т.е. для каждой ячейки, не являющейся миной, указывается число мин, находящихся в соседних ячейках (учитывая диагональные направления).
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
Моё:
<pre>
n, m = map(int, input().split())
board = {}

for row_index in range(n):
    row_str = input()
    for column_index in range(m):
        board[(row_index, column_index)] = row_str[column_index]
        # print(board[(row_index, column_index)], end='')

for row_index in range(n):
    for column_index in range(m):
        if board[(row_index, column_index)] == '.':
            count = 0
            if (row_index > 0 and column_index > 0 and board[(row_index-1, column_index-1)] == '*'):
                count +=1
            if (row_index > 0 and board[(row_index-1, column_index)] == '*'):
                count +=1
            if (row_index > 0 and column_index < (m-1) and board[(row_index-1, column_index+1)] == '*'):
                count +=1
            if (column_index > 0 and board[(row_index, column_index-1)] == '*'):
                count +=1
            if (column_index < (m-1) and board[(row_index, column_index+1)] == '*'):
                count +=1
            if (row_index < (n-1) and column_index > 0 and board[(row_index+1, column_index-1)] == '*'):
                count +=1
            if (row_index < (n-1) and board[(row_index+1, column_index)] == '*'):
                count +=1
            if (row_index < (n-1) and column_index < (m-1) and board[(row_index+1, column_index+1)] == '*'):
                count +=1
            board[(row_index, column_index)] = count
        print(board[(row_index, column_index)], end='')
        if column_index == (m-1):
            print()
</pre>         
</td></tr></table>
<p>
1. Можно было записать строку минного поля в список списков:
<pre>
mines = []
for i in range(n):
    mines += [input()]
</pre>
и элементы этого списка имеют два индекса: mines[i][j], где i - это номер внутреннего списка в общем списке, а j - это номер символа во внутреннем списке.
<p>
2. Можно было подсчет мин сделать без 8 условий:
<pre>
for i in range(1, n + 1):
    for j in range(1, m + 1):
        print('*' if a[i][j] == '*'
              else sum(a[x][y] == '*' for x in (i - 1, i, i + 1) for y in (j - 1, j, j + 1)), end='')
</pre>
<pre>

---------------------------------------------------------------------------------------------------------------------

</pre>
<pre>



====================================================================================================================



</pre>
<h2 align=center>Алгоритмы:</h2>
<a name="matrix"><h3 align=center>Матрицы</h3>
<b>Квадратная матрица, заполняемая по спирали, создание матрицы</b><br>
Выведите таблицу размером n×n, заполненную числами от 1 до n 2 по спирали, выходящей из левого верхнего угла и закрученной по 
часовой стрелке:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
n = int(input())
krug = 1
stroka = 0 # первая строка
stolb = 0
<b>table = [[0 for j in range(n)] for i in range(n)]</b> # создаём n*n таблицу
# вправо
while table[stroka][stolb] != n*n:
    # вправо
    for stolb in range(krug -1, n - krug + 1):
        if stolb == 0:
            table[0][0] = 1
        else:
            table[stroka][stolb] = table[stroka][stolb-1] + 1
    if table[stroka][stolb] == n*n:
        break
    # вниз
    for stroka in range(krug,n - krug + 1):
        table[stroka][stolb] = table[stroka-1][stolb] + 1
    if table[stroka][stolb] == n*n:
        break
    # влево
    for stolb in range(-krug - 1, -n + krug - 2, -1):
        table[stroka][stolb] = table[stroka][stolb+1] + 1
    if table[stroka][stolb] == n*n:
        break
    # вверх
    for stroka in range(-krug - 1, -n + krug - 1, -1):
        table[stroka][stolb] = table[stroka+1][stolb] + 1
    if table[stroka][stolb] == n*n:
        break
    krug += 1
for stroka in range(n):
    for stolb in range(n):
        print(table[stroka][stolb], end=' ')
    print()
</pre></td></tr></table>
<p>
Вызвало затруднение, определение двухмерного массива, table[] или table[[]]  неправильно. Правильно получилось, когда 
использовал генератор для формирования таблицы.
<pre>

-------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Codewars 4 kuy</b><br>
<a href="https://codereview.stackexchange.com/questions/190053/clockwise-spiral-traversal-of-2d-input-matrix">Объяснение решения</a>
<p>
Имеется массив n x n, верните элементы массива, расположенные от крайних элементов к среднему элементу, двигаясь по часовой стрелке.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def snail(table):
    n = len(table[0])
    output = []
    top_row = 0
    bottom_row = n - 1
    left_col = 0
    right_col = n - 1
    while top_row <= bottom_row and left_col <= right_col:
        output.extend(table[top_row][left_col:right_col+1])                               # верхняя строка слева направо
        if len(output) == n * n: break
        top_row +=1
        output.extend(table[row][right_col] for row in range(top_row, bottom_row+1))      # правый столбец сверху вниз
        if len(output) == n * n: break   
        right_col -=1
        output.extend(table[bottom_row][col] for col in range(right_col, left_col-1, -1)) # нижняя строка справа налево 
        if len(output) == n * n: break
        bottom_row -=1
        #print("нижняя строка:", output)
        output.extend(table[row][left_col] for row in range(bottom_row, top_row-1, -1))    # левый столбец снизу вверх
        #print("левый столбец:", output)
        if len(output) == n * n: break
        left_col +=1
        
    return output

array = [[1,2,3],
         [4,5,6],
         [7,8,9]]

print(snail(array))  # [1,2,3,6,9,8,7,4,5]
</pre></td></tr></table>
<p>
Не мои решения:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import numpy as np

def snail(array):
    m = []
    array = np.array(array)
    while len(array) > 0:
        m += array[0].tolist()
        array = np.rot90(array[1:])
    return m
</pre></td>
<td>
<pre>
def snail(array):
    out = []
    while len(array):
        out += array.pop(0)
        array = list(zip(*array))[::-1] # Rotate
    return out
</pre></td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Пример обхода в глубину</b><br>
Решение судоку.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from copy import deepcopy

N = {1, 2, 3, 4, 5, 6, 7, 8, 9}

def sudoku(puzzle):
    copy_p = deepcopy(puzzle)                                
    for row in range(9):
        for col in range(9):
            if puzzle[row][col] != 0 and row == 8 and col == 8:
                #print("!!!!ПОБЕДА")
                return puzzle

            # пустая ячейка
            if copy_p[row][col] == 0:                                   
                lst_square = get_lst_square(copy_p, row, col)           
                #print(f"Список {lst_square} для row={row} и col={col}")
                
                #Блок, если нет вариантов
                if len(lst_square) == 0:                               
                    return 0                                
                # Блок, когда есть варианты
                else:                                                   
                    for n in range(len(lst_square)):                    
                        copy_p[row][col] = lst_square[n]
                        #print(f"Проверяем n={n}, copy_p[{row}][{col}]={lst_square[n]} из списка {lst_square}")
                        matrix = sudoku(copy_p)
                        if  matrix != 0:
                            return matrix
                                                                 
                        #print(f"этот вариант n={n}, copy_p[{row}][{col}] = {lst_square[n]} из списка {lst_square} не прошел")
                        # если перебрали все значения из списка и никакой не дошел до победы
                        if n == len(lst_square) - 1:
                            return 0
            
            

def get_lst_square(matrix, row, col):
    """Получаем список возможных чисел для ячейки row, col"""
    set_square = set()
    #смотрим строку row
    for i in range(9):
        if matrix[row][i] !=0:
            set_square.add(matrix[row][i])
    #теперь смотрим столбец col:
    for i in range(9):
        if matrix[i][col] !=0:
            set_square.add(matrix[i][col])
    # теперь найти числа из блока:
    start_row = (row // 3) * 3
    end_row = start_row + 2
    start_col = (col // 3) * 3
    end_col= start_col + 2
    for i in range(start_row, end_row+1):
        for j in range(start_col, end_col+1):
            if matrix[i][j] !=0:
                set_square.add(matrix[i][j])
    matrix[row][col] = list(N - set_square)
    return   matrix[row][col]                   # возвращает или список возможных чисел или пустой список

    
def printMatrix(matrix):
    for i in range(len(matrix)):
        print(matrix[i])

        
puzzle = [[5,3,0,0,7,0,0,0,0],
          [6,0,0,1,9,5,0,0,0],
          [0,9,8,0,0,0,0,6,0],
          [8,0,0,0,6,0,0,0,3],
          [4,0,0,8,0,3,0,0,1],
          [7,0,0,0,2,0,0,0,6],
          [0,6,0,0,0,0,2,8,0],
          [0,0,0,4,1,9,0,0,5],
          [0,0,0,0,8,0,0,7,9]]

puzzle1 = [[5,3,0,0,7,0,0,0,0],
          [6,0,0,1,9,5,0,0,0],
          [0,9,8,0,0,0,0,6,0],
          [8,0,0,0,6,0,0,0,3],
          [4,0,0,8,0,3,0,0,1],
          [7,0,0,0,2,0,0,0,6],
          [0,6,0,0,0,0,2,8,0],
          [0,0,0,4,1,9,0,0,5],
          [0,0,0,0,8,0,1,7,0]]

'''
[[5,3,4,6,7,8,9,1,2],
[6,7,2,1,9,5,3,4,8],
[1,9,8,3,4,2,5,6,7],
[8,5,9,7,6,1,4,2,3],
[4,2,6,8,5,3,7,9,1],
[7,1,3,9,2,4,8,5,6],
[9,6,1,5,3,7,2,8,4],
[2,8,7,4,1,9,6,3,5],
[3,4,5,2,8,6,1,7,9]]
'''

print("Первая матрица")
printMatrix(sudoku(puzzle))
print("Вторая матрица")
printMatrix(sudoku(puzzle1))
</pre></td></tr></table>
<p>
Долго разбирался почему при выводе матрицы ниже появлялась строка None . Оказывается функция всегда что-то возвращает, даже если в ней отсутствует return, в этом случае она возвращает None . Поэтому не нужно было print(funk()), а просто вызвать функцию funk() .
<pre>

=============================================================================================================================

</pre>
<a name="lst_array"><h3 align=center>Односвязные списки</h3>
Создайте односвязный список с узлами, хранящими целые числа. Реали­зуйте метод для добавления нового узла в конец списка.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:        # true если head = none
            self.head = new_node
            return
        
        last_node = self.head
        while last_node.next:
            last_node = last_node.next

        last_node.next = new_node



ll = LinkedList()
ll.append(5)
print(ll)           # &lt;__main__.LinkedList object at 0x7f038e477f40>
print(ll.head)      # &lt;__main__.Node object at 0x7fcb949cb100>
print(ll.head.data) # 5
print(ll.head.next) # None

ll.append(10)
print(ll.head)      # &lt;__main__.Node object at 0x7fcb949cb100>
print(ll.head.data) # 5
print(ll.head.next) # &lt;__main__.Node object at 0x7fe12c593610>
print(ll.head.next.data) # 10
</pre></td></tr></table>
<pre>

=======================================================================================================================

</pre>
<a name="graf"><h3 align=center>Задачи на графы</h3>
Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания 
пространств имен и добавление в них переменных.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
n = int(input())
d = {'None':'global'}

def get(ns, var):     #  get namespace var или get ns var
    result = []
    # print('d.values()=', d.values())
    
    # преобразуем список детей d.values() в список элементов result
    for i in d.values():
        if type(i) != list:
            result.append(i)
        else:
            for n in range(len(i)):
                result.append(i[n])
    #print('result=', result)
    
    '''ns может не входить в список ключей (родителей)'''
    if ns in d.keys():
        #print('ns=', ns, ' d[ns]=', d[ns])
        if var in d[ns]:   #  переменная var входит в список родителя ns
            # print('var=', var, 'входит в состав (', d[ns], ') родителя ns=', ns)
            return print(ns)
        elif ns in result: # var не входит в ns, но ns входит в список детей
            if ns == 'global':
                return print('None')
            # print(var, 'не входит в ', ns, ' но ', ns, ' входит в список детей ', result)
            # нужно найти ключ для ns (куда ns входит)
            for key in d.keys():
                if ns in d[key]: 
                    # print(ns, ' находится в ', key, ' снова выполняем функцию')
                    return get(key, var)
        else:
            #print(var, ' не входит в ', ns, ' и ', ns, ' никуда не входит')
            return print('None')  
    else:
        # print(ns, ' не входит в список родителей (d.keys()) ', d.keys())
        if ns in result:
            # print(ns, ' входит в список детей (result) ', result) 
            '''надо найти куда ns входит'''
            for key in d.keys():
                if ns in d[key]: 
                    # print(ns, ' находится в ', key, ' снова выполняем функцию')
                    return get(key, var)
        else:
            # print(ns, ' не входит в список детей result ', result)
            return print('None')
        
for _ in range(n):
    str = input().split()
    
    if str[0] == 'add':
        if str[1] in d.keys():
            if type(d[str[1]]) == list:
                lst = ','.join(d[str[1]]).split(',')
                lst.append(str[2])
                d[str[1]] = lst
            else:
                d[str[1]] = [d[str[1]], str[2]]
        else:
            d[str[1]] = str[2]       
    
    elif str[0] == 'create':
        if str[2] in d.keys():
            if type(d[str[2]]) == list:
                <b><font color=green>lst = ','.join(d[str[2]]).split(',')</font>
                <font color=blue>lst.append(str[1])</font></b>
                d[str[2]] = lst
                #print(d[str[2]])
            else:
                d[str[2]] = [d[str[2]], str[1]]
        else:
            d[str[2]] = str[1]       
            
    elif str[0] == 'get':
        get(str[1], str[2])
</pre>
</td><tr></table>      
3 дня писал этот код. Замотался с добавлением  элемента в значение словаря, так чтобы все элементы были в одном списке, а не 
списки в списке.
<ol>
 <li> <font color=green><b>Чтобы список разделить на отдельные элементы - строки и потом назад в список</b>, используется 
конструкция<br>
lst = ','.join(d[str[1]]).split(',')<br>
Здесь с помощью joint преобразуем список ['a, b'] в строку 'a, b' а с помощью split(',') преобразуем назад в список ['a', 
'b']</font>

 <li> <font color=blue>Если писать lst = lst.append(), то будет возвращаться None. Чтобы нормально метод работал, нужно писать 
lst.append()</font> Метод не работает со строкой.
</ol>
<p>
<b>Другое решение:</b><br>
<i>Пример решения. Будем храним две структуры:<br>
1) Кто чей родитель<br>
2) Переменные объявленные в данном пространстве имён
<p>
Если команда create -- создаём новое пространство имён (запоминаем родителя и создаём пустое множество переменных, объявленных 
в этом пространстве имен).
<p>
Если команда add -- то просто помещаем имя переменной в соответствующее множество.
<p>
Если команда get -- то проверяем наличие данной переменной в нашем пространстве имён, если не нашли: проверяем в родителе. 
Если не нашли в родителе, проверяем в родителе родителя и так далее. Как только нашли имя переменной -- вывели на экран 
пространство имён, в котором нашли. Если в процессе поиска мы имя не нашли (fst is None) -- выводим None на экран.</i>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
n = int(input())

parent = {"global": None}
vs = {"global": set()}

for _ in range(n):
    t, fst, snd = input().split()
    if t == "create":
        parent[fst] = snd
        vs[fst] = set()
    elif t == "add":
        <b>vs[fst].add(snd)</b>
    else:  # t == get
        while fst is not None:
            if snd in vs[fst]:
                break
            fst = parent[fst]
        print(fst)
</pre>
</td></tr></table>
<b>Элементы добавлять в значение словаря удобно с помощью метода add().</b>  <i>Это если значение является множеством.
</i>      
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
31.10.2024:<br>
Формат входных данных<br>
В первой строке входных данных содержится целое число n - число классов.
<p>
В следующих n строках содержится описание наследования классов. В i-й строке указано от каких классов наследуется i-й класс. 
Обратите внимание, что класс может ни от кого не наследоваться. Гарантируется, что класс не наследуется сам от себя (прямо или 
косвенно), что класс не наследуется явно от одного класса более одного раза.
<p>
В следующей строке содержится число q - количество запросов.
<p>
В следующих q строках содержится описание запросов в формате <имя класса 1> <имя класса 2>.
Имя класса – строка, состоящая из символов латинского алфавита, длины не более 50.
<p>
Формат выходных данных<br>
Для каждого запроса выведите в отдельной строке слово "Yes", если класс 1 является предком класса 2, и "No", если не является.
<pre>
Sample Input:
4
A
B : A
C : A
D : B C
4
A B
B D
C D
D A
Sample Output:
Yes
Yes
Yes
No
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td rowspan=2 valign=top>
<b>Мое решение:</b>
<pre>
d = {}

# Функция перебора родителей
def find(upclass, class2):
    for i in class2:
        if class1 in d[i]:
            res = True
            return res
        else:
            res = find(class1, d[i])
            if res == True:
                return res
            else:
                continue    
    return
    
# Цикл добавления классов в словарь
for _ in range(int(input())):
    s = input().split(' : ')
    if len(s) > 1:
        if s[0] in d.keys():
            <b>d[s[0]] = d[s[0]] + s[1].split()</b>
        else:
            d[s[0]] = s[1].split()
    else:
        d[s[0]] = []

# Отправка запросов    
for _ in range(int(input())):
    lst = input().split()
    if len(lst) == 1:
        print('Yes')
    else:
        class1 = lst[0]
        class2 = lst[1]
        if class1 == class2:
            print('Yes')
        elif class2 not in d.keys() or d[class2] == []:
            print('No')
        elif class1 in d[class2]: 
            print('Yes')
        else:
            res = find(class1, d[class2]) 
            if res == True:
                print('Yes')
            else:
                print('No')
</pre>
</td></tr></table>
<p>
<b>Добавление элемента в словарь:</b><br>
В строке <b>d[s[0]] = d[s[0]] + s[1].split()</b> я получаю новое значение словаря: в первоначальный список элементов d[s[0]] 
вкладываю s[1]<br>
Если s[1] добавлять сразу: <b>d[s[0]] = d[s[0]] + s[1]</b>, то получим ошибку:
<br><font color=red>TypeError: can only concatenate list (not "str") to list</font><br>
Ни append(), ни add, update join не приводили к нужному результату
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td rowspan=2 valign=top>
<b>Другое решение:</b>
<pre>
def test(parent, child):
    if parent == child or parent in base[child]:
        return 'Yes'
    for i in base[child]:
        if test(parent, i) == 'Yes':
            return 'Yes'
    return 'No'

base = {}
<font color=brown>for com in [input().split(' ') for i in range(int(input()))]:</font>
    base[com[0]] = com[2:len(com)]
for com in [input().split(' ') for i in range(int(input()))]:
    print (test(com[0], com[1]))
</pre>
</td></tr></table>
<p>
<font color=brown>я не могу понять почему вывод идет только после окончания ввода, а не после каждого ввода значений для
проверки...</font>
<p>
<i>Так происходит потому что в  этой части кода:
<pre>
for com in [input().split(' ') for i in range(int(input()))]:
     print (test(com[0], com[1]))</pre>
мы сначала с помощью генератора списков [input().split(' ') for i in range(int(input()))]<br>
создаём собственно список, вводя все данные, и только потом передаём этот список циклу for com in [сформированный 
список],который прогоняет это список через функцию test. Короче говоря, тут два цикла (первый в генераторе списков). В первом 
вводим данные, во втором - проверяем.</i>
<p>
Чтобы ответ, как Вы хотите, возвращался сразу после каждого ввода, последние  две строчки нужно было бы переписать как-то так:
<pre>
for i in range(int(input())):

    com = input().split(' ')

    print (test(com[0], com[1]))</pre>
https://all-python.ru/osnovy/generator-spiska.html

<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td rowspan=2 valign=top>
<b>Другое решение:</b>
<pre>
n = int(input())

parents = {}
for _ in range(n):
    a = input().split()
    <b>parents[a[0]] = [] if len(a) == 1 else a[2:]</b>

def is_parent(child, parent):
    return child == parent or any(map(lambda p: is_parent(p, parent), parents[child]))

q = int(input())
for _ in range(q):
    a, b = input().split()
    print("Yes" if is_parent(b, a) else "No")
</pre>
</td></tr></table>
<p>
1. Здесь в <b>parents[a[0]] = [] if len(a) == 1 else a[2:]</b><br>
идет перезапись в значение словаря, но не добавление, как реализовано у меня.
<p>
2. <b>a, b = input().split()</b> вызовет ошибку:
<font color=red>ValueError: not enough values to unpack (expected 2, got 1)</font><br>
если ввести запрос из одного элемента, типа A.
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Еще одна задачка на так называемые графы.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
n = int(input())
d = {}
exceptions = []

def find(ns):
    if ns in d.keys():
        for m in d[ns]:
            if m in exceptions[0 : i]:
                return True
            else:
                if find(m) == True:
                    return True
        return False
    else:
        return False     
        
for _ in range(n):
    s = input().split()
    if len(s) > 1:
        d[s[0]] = s[2:]
    else:
        d[s[0]] = ''
       

for i in range(int(input())):
    s = input()
    if s not in exceptions:
        exceptions.append(s)


for i in range(1, len(exceptions)):
    if exceptions[i] in exceptions[0 : i] or find(exceptions[i]) == True:
        print('Исключить', exceptions[i])</pre>
</td><td>
<pre>
parents = {}
for _ in range(int(input())):
    a = input().split()
    parents[a[0]] = [] if len(a) == 1 else a[2:]

def is_parent(child, parent):
    if child == parent: return True
    for p in parents[child]:
        if is_parent(p, parent ): return True
    return False

exceptions = []
for _ in range(int(input())):
    a = input().strip()
    for i in exceptions:
        if is_parent(a,i):
            print(a)
            break
    exceptions.append(a)
</pre>
</td>
</tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Вам дано описание наследования классов в формате JSON.
Описание представляет из себя массив JSON-объектов, которые соответствуют классам. У каждого JSON-объекта есть поле name, 
которое содержит имя класса, и поле parents, которое содержит список имен прямых предков.
<br>Пример: [{"name": "A", "parents": []}, {"name": "B", "parents": ["A", "C"]}, {"name": "C", "parents": ["A"]}]
<p>
Гарантируется, что никакой класс не наследуется от себя явно или косвенно, и что никакой класс не наследуется явно от одного 
класса более одного раза.<br>
Для каждого класса вычислите предком скольких классов он является и выведите эту информацию в следующем формате.
<pre>
&lt;имя класса&gt; : &lt;количество потомков&gt;
</pre>
Выводить классы следует в лексикографическом порядке.
<pre>
Sample Input:

[{"name": "A", "parents": []}, {"name": "B", "parents": ["A", "C"]}, {"name": "C", "parents": ["A"]}]
Sample Output:

A : 3
B : 1
C : 2
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<b>Мое решение:</b>
<pre>
import json
 
json_stroka = json.loads(input())
st = set()
d = {}

def find_child(parent, grandchild):
    for line in json_stroka: # вытаскиваем строку из json
        # вытаскиваем из этой строки некоторого родителя   
        <font color=red>for some_parent in line['parents']:</font>
            # если сын, внук правнук является родителем
            <font color=green><b>if grandchild in some_parent.split():</b></font>
                <b>d[parent] = d[parent] + ' ' + line['name']</b>
          # теперь его проверяем является ли он родителем
                find_child(parent, line['name'])
     
    return

for i in json_stroka:
    st.add(i['name'])
    for _ in i['parents']:
        st.add(_)
for i in st:
    d[i] = <font color=red>i</font>
    
for parent in d.keys():
    find_child(parent, parent)
    
for key, val in sorted(d.items()): 
    print(key, ':', len(set(val.split())))
</pre>
</td></tr>
<tr><td>
<b>Другое:</b>
<pre>
import json

scheme = json.loads(input())
# scheme = [{"A": []}, {"B": ["A"]}, {"C": ["A"]}, {"D": ["B", "C"]}, {"V": ["D"]}]

parent_and_children = {item['name']: [] for item in scheme}
# {'A': [], 'B': [], 'C': [], 'D': [], 'V': []}

for item in scheme:
    for parent in parent_and_children:
        if parent in item['parents']:
            <b>parent_and_children[parent].append(item['name'])</b>
# {'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': ['V'], 'V': []}
# если класс есть в parents - его прямые дети добавляются в словарь

for item in parent_and_children:
    parent_and_children[item] = set(parent_and_children[item])
# {'A': {'C', 'B'}, 'B': {'D'}, 'C': {'D'}, 'D': {'V'}, 'V': set()}
# словари с детьми преобразуются в множества


# https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    for upcoming in graph[start] - visited:
        dfs(graph, upcoming, visited)
    return visited


# parent_and_children = {'A': {'C', 'B'}, 'B': {'D'}, 'C': {'D'}, 'D': {'V'}, 'V': set()}
# dfs(parent_and_children, 'A') = {'A', 'D', 'C', 'V', 'B'}
for item in sorted(parent_and_children.keys()):
    print(item, ':', len(dfs(parent_and_children, item)))
</pre>
</td></tr></table>
1. Замотался добавлять элемент в значение словаря:
<pre>
d[parent] = d[parent].append(line['name'])
AttributeError: 'str' object has no attribute 'append'

d[parent] = d[parent] + line['name'].split()
TypeError: can only concatenate str (not "list") to str

d[parent].append(line['name'].split())
AttributeError: 'str' object has no attribute 'append'

d[parent] = list(d[parent]).append(line['name'].split())
TypeError: 'NoneType' object is not iterable

list(d[parent]).append(line['name'].split())
RecursionError: maximum recursion depth exceeded while calling a Python object

 d[parent] = list(d[parent]) + line['name']
TypeError: can only concatenate list (not "str") to list

d[parent] = d[parent].split() + line['name'].split()
AttributeError: 'list' object has no attribute 'split'
</pre>
В конце концов просто стал добавлять элемент как строку к строке через пробел: d[parent] = d[parent] + ' ' + line['name']<br>
В результате значение словаря имеет тип не список, как раньше, а строка.
<p>
Думаю если бы блок
<pre>
for i in st:
    d[i] = <font color=red>i</font></pre>
записал как:
<pre>
for i in st:
    d[i] = <b>[i]</b></pre>
то проблем с append не было.
<p>
Далее возникла 2 проблема:
<p>
2. d[parent] = d[parent] + ' ' + line['name'] # бесконечное добавление<br>
Проблема возникла из-за того, что в <b>if grandchild in some_parent:</b> бывают случаи, например: grandchild = 'E' и 
some_parent = 'ED' и результат True, хотя на самом деле это разные классы. Решил проблему, просто преобразовав some_parent в 
список: <b>if grandchild in some_parent.split():</b>
<p>
3. <font color=red>for some_parent in line['parents']:</font> Зря я вытаскивал отдельно родителя, можно сразу было делать 
<b>if grandchild in line[parents]:</b> как сделано в другом решении.
<pre>



=========================================================================================================================




</pre>
<h3 align=center><a name="fun">Функции</h3>
<b>Функция ничего не возвращает и должна изменить поданный список, через генератор списка  или функцию pop</b>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def modify_list(l):
    """
       Функция принимает на вход список целых чисел, удаляет из него все нечётные значения,
        а чётные нацело делит на два. Функция не должна ничего возвращать, требуется 
        только изменение переданного списка
    """
    '''
    # 1 способ через генератор списка
    # l = [n // 2 for n in l if n % 2 == 0] такая запись почему-то вызывала ошибку на сайте.
    <b>l[:] = [n // 2 for n in l if n % 2 == 0]</b>
    '''

    # 2 способ с помощью pop
    for i in <b>range(len(l)-1, -1, -1)</b>:  # чтобы не было проблем с индексацией после удаления, обход с конца списка начинаем
       if l[i] % 2 != 0:
           <b>l.pop(i)</b>
       else:
           l[i] = l[i] // 2

l = [1, 2, 3, 4, 5, 6, 10]
modify_list(l)
print(l)
</pre></td></tr></table>
<pre>

-----------------------------------------------------------------------------------------------------------------------

</pre>
Напишите функцию f(x), которая возвращает значение следующей функции, определённой на всей числовой прямой:
<p>
<img src="./images/python_base4.png">
<pre>
def f(x):
    if x <= -2:
        return 1 - (x + 2) ** 2
    elif -2 < x <= 2:
        return -x / 2
    else:
        return (x - 2) ** 2 + 1
</pre>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
Напишите функцию modify_list(l), которая принимает на вход список целых чисел, удаляет из него все нечётные значения, а чётные 
нацело делит на два. Функция не должна ничего возвращать, требуется только изменение переданного списка.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<pre>
def modify_list(lst):
    l = len(lst)
    for i in range(l-1, -1, -1):
        if lst[i] % 2 == 0:
            lst[i] = lst[i] // 2
        else:
            del lst[i]
</pre>
</td><td valign=top>
Другое решение:
<pre>def modify_list(l):
    l[:] = [i//2 for i in l if not i % 2]
</pre>
</td></tr></table>
<p>
<i>логика такая, так как список l в памяти уже есть и его нужно перезаписать, то есть изменить сам объект списка, поэтому тут 
я делаю срез всего списка от начала до конца и меняю сам объект. если написать просто l = [i//2 for i in l if not i % 2] в 
данном случае будет создан новый объект, под него выделена память и переменная l будет уже ссылаться на него, а старая ссылка 
на исходный объект списка сотрется. т.е происходит не изменение объекта, а перенаправление ссылки у переменной l. я не 
проверял может и такой вариант сработает но подумал что он учтет занимаемую память и выдаст ошибку, так как была задача одна и 
там подобный подход выдавал ошибку, а сделал l[:] (изменил сам весь объект) все заработало.
<p>
дело в том что for и while полезны для больших конструкций, а генератор списков [ for ] введен для того что бы писать 
коротенькие вещи в одну строку, что б ради одной двух операций внутри цикла не писать по 3-4 строчки кода с обычным циклом.
<p>
i%2 выдает либо 0 либо 1. или иначе False True. not i - переворачивает выданный результат. Т.е. в данной ситуации мы должны 
выполнять действие (i//2) если условие if даст True, но четное число при делении даст остаток 0 (6%2=0 - False) поэтому нам 
необходимо перевернуть результат (not False - True)</i>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое 
маленькое целое число y, такое что:
<br>y больше или равно x<br>
y делится нацело на 5
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
def  closest_mod_5(x = int(input())):
    for num in range(x, x*5 + 1):
        if num % 5 == 0:
            return num
print(closest_mod_5())
</pre>
</td><td valign=top>
Другое:
<pre>
def closest_mod_5(x):
    while x % 5 != 0:
        x += 1
    return x
</pre>
</td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Кэширование функции, декоратор, lru_cache</b><br>
Имеется реализованная функция f(x), принимающая на вход целое число x, которая вычисляет некоторое целочисленое значение и возвращает его в качестве результата работы. Функция вычисляется достаточно долго, ничего не выводит на экран, не пишет в файлы и зависит только от переданного аргумента x.<br>
Напишите программу, которая вычисляет значение этой функции для n чисел. Для ускорения вычисления <b>необходимо сохранять уже вычисленные значения функции при известных аргументах</b>.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Простой способ:
<pre>
dict = {}
n = int(input())
for _ in range(n):
    x = int(input())
    if x not in dict.keys():
        dict[x] = f(x)
    print(dict[x])
</pre>
</td>
<td valign=top>
С помощью lru_cache
<pre>
import functools

@functools.lru_cache(None)
def m(x):
	return f(x)

n = int(input())
for _ in range(n):
	x = int(input())
	print(m(x))
</pre></td>
<td valign=top>
<pre>
from functools import lru_cache

n = int(input())
f = lru_cache(maxsize=n)(f)

for x in range(n):
    print(f(int(input())))
</pre>
Создавать свой дополнительный декоратор не обязательно. Можно применить функцию:<br>
lru_cache(maxsize=n)(&lt;аргумент_функция>)<br>
получая новую функцию с памятью максимум на n значений.</td></tr></table>
<pre>

-------------------------------------------------------------------------------------------------------------------------

</pre>
Головомка Ханойская башня
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#!/usr/bin/env python3

"""THE TOWER OF HANOI, by Al Sweigart al@inventwithpython.com
Головоломка с перемещением дисков."""

import copy
import sys

TOTAL_DISKS = 5 # Чем больше дисков, тем сложнее головоломка.


# Изначально все диски находятся на стержне A:
<b>SOLVED_TOWER = list(range(TOTAL_DISKS, 0, -1))</b>  # создаём список при TOTAL_DISKS = 5: [5, 4, 3, 2, 1]


def displayDisk(width):
    """Выводит диск заданной ширины. Ширина 0 означает отсутствие диска."""
    emptySpace = " " * (TOTAL_DISKS - width)
    if width == 0:
        # Вывести сегмент стержня без диска:
        print(f"{emptySpace}||{emptySpace}", end="")
    else:
        # Вывести диск:
        disk = "@" * width
        numLabel = str(width).rjust(2, "_")  # преобразует width в строку и выравнивает по правому краю, width=3, тогда вывод: _3
        print(f"{emptySpace}{disk}{numLabel}{disk}{emptySpace}", end="")


def displayTowers(towers):
    """Выводит три башни с дисками."""

    # Вывести три башни:
    for level in range(TOTAL_DISKS, -1, -1):
        for tower in (towers["A"], towers["B"], towers["C"]):
            if level >= len(tower):
                displayDisk(0) # Вывести пустой стержень без диска.
            else:
                displayDisk(tower[level]) # Вывести диск.
        print()

    # Вывести обозначения башен A, B и C:
    emptySpace = " " * (TOTAL_DISKS)
    print("{0} A{0}{0} B{0}{0} C\n".format(emptySpace))


def getPlayerMove(towers):
    """Запрашивает ход у пользователя. Возвращает (fromTower, toTower)."""
    while True: # Пока пользователь не введет допустимый ход.
        print('Enter the letters of "from" and "to" towers, or QUIT.')
        print("(e.g., AB to moves a disk from tower A to tower B.)")
        print()
        response = input("> ").upper().strip()
        if response == "QUIT":
            print("Thanks for playing!")
            sys.exit()

        # Убедиться в том, что пользователь ввел допустимые обозначения башен:
        if response not in ("AB", "AC", "BA", "BC", "CA", "CB"):
            print("Enter one of AB, AC, BA, BC, CA, or CB.")
            continue # Снова запросить ход.
        # Более содержательные имена переменных:
        <font color=green><b>fromTower, toTower = response[0], response[1]</b></font>  # <b>эквивалентно fromTower = response[0]</b> и <b>toTower = response[1]</b>
        if len(towers[fromTower]) == 0:
            # Башня fromTower не может быть пустой:
            print("You selected a tower with no disks.")
            continue # Снова запросить ход.
        elif len(towers[toTower]) == 0:
            # На пустую башню можно переместить любой диск:
            <font color=green>return fromTower, toTower</font>  # возвращает сразу два значения
        elif towers[toTower][-1] < towers[fromTower][-1]:
            print("Can't put larger disks on top of smaller ones.")
            continue # Снова запросить ход.
        else:
            # Допустимый ход, вернуть выбранные башни:
            return fromTower, toTower


def main():
    """Проводит одну игру Ханойская башня."""
    print(
    """THE TOWER OF HANOI, by Al Sweigart al@inventwithpython.com
    Move the tower of disks, one disk at a time, to another tower. Larger
    disks cannot rest on top of a smaller disk.
    More info at https://en.wikipedia.org/wiki/Tower_of_Hanoi
    """
    )
    """Словарь towers содержит ключи "A", "B" и "C", и значения - списки, 
    представляющие стопку дисков. Список содержит целые числа, представляющие
    диски разных размеров, а начало списка представляет низ башни. Для игры
    с 5 дисками список [5, 4, 3, 2, 1] представляет заполненную башню. Пустой
    список list [] представляет башню без дисков. В списке [1, 3] больший диск
    находится на меньшем диске, такая конфигурация недопустима. Список [3, 1]
    допустим, так как меньшие диски могут размещаться на больших."""
   
    <b>towers = {"A": copy.copy(SOLVED_TOWER), "B": [], "C": []}</b>  # словарь

    while True: # Один ход для каждой итерации цикла.
        # Вывести башни и диски:
        displayTowers(towers)

        # Запросить ход у пользователя:
        <font color=green>fromTower, toTower = getPlayerMove(towers)</font>  # так через функцию получаем два значения, <font color=red>переменные не объявляются</font>

        # Переместить верхний диск с fromTower на toTower:
        disk = towers[fromTower].pop()
        towers[toTower].append(disk)
    
        # Проверить, решена ли головоломка:
        if SOLVED_TOWER in (towers["B"], towers["C"]):
            displayTowers(towers) # Вывести башни в последний раз.
            print("You have solved the puzzle! Well done!")
            sys.exit()



# Если программа была запущена (а не импортирована), начать игру:
if __name__ == "__main__":
    main()
</pre></td></tr></table>
<p>
В книге описание функций расположено ниже функции main(), но при запуске программы получал ошибку, что функция не определена. Только после того как переместил их выше, программа заработала.
</pre>
</td></tr></table>
<pre>

--------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Игра 4 в ряд из книги Python. Чистый код для продолжаюших стр. 301</b>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#!/usr/bin/env python3

"""Игра на выстраивание четырех фишек в ряд."""
import sys

# Константы, используемые для вывода игрового поля:
EMPTY_SPACE = "." # Точки проще подсчитать, чем пробелы.
PLAYER_X = "X"
PLAYER_O = "O"

# Примечание: если BOARD_WIDTH изменится, обновите BOARD_TEMPLATE и COLUMN_LABELS.
BOARD_WIDTH = 7
BOARD_HEIGHT = 6
COLUMN_LABELS = ("1", "2", "3", "4", "5", "6", "7")
assert len(COLUMN_LABELS) == BOARD_WIDTH

# Шаблонная строка для вывода игрового поля:
BOARD_TEMPLATE = """
1234567
+-------+
|{}{}{}{}{}{}{}|
|{}{}{}{}{}{}{}|
|{}{}{}{}{}{}{}|
|{}{}{}{}{}{}{}|
|{}{}{}{}{}{}{}|
|{}{}{}{}{}{}{}|
+-------+"""
def main():
    """Проводит одну игру Четыре в ряд."""  <font color=gray># Чтобы увидеть документацию (doc-строку) import и help(name_file.main)</font>
    print("""Два игрока по очереди опускают фишки в один из семи столбцов,
         стараясь выстроить четыре фишки по вертикали, горизонтали или диагонали.""")
    
    # Подготовка новой игры:
    gameBoard = getNewBoard()  <font color=gray># словарь, содержащий игровое поле, ключи = кортежи (columnIndex, rowIndex), значения = точке</font>
    playerTurn = PLAYER_X
    while True: # Обрабатывает ход игрока.
        # Вывод игрового поля и получение хода игрока:
        displayBoard(gameBoard)
        playerMove = getPlayerMove(playerTurn, gameBoard)  <font color=gray># кортеж из номера столбца и номера строки</font>
        gameBoard[playerMove] = playerTurn  <font color=gray># в словаре gameBoard значение с точки меняем на playerTurn</font>

        # Проверка победы или ничьей:
        if isWinner(playerTurn, gameBoard):
            displayBoard(gameBoard) # В последний раз вывести поле.
            print("Player {} has won!".format(playerTurn))
            sys.exit()
        elif isFull(gameBoard):  <font color=gray># все клетки заполнены</font>
            displayBoard(gameBoard) # В последний раз вывести поле.
            print("There is a tie!")
            sys.exit()  <font color=gray># можно break</font>

        # Ход передается другому игроку:
        if playerTurn == PLAYER_X:
            playerTurn = PLAYER_O
        elif playerTurn == PLAYER_O:
            playerTurn = PLAYER_X

def getNewBoard():
    """Возвращает словарь, представляющий игровое поле.
    Ключи - кортежи (columnIndex, rowIndex) с двумя целыми числами,
    а значения - одна из строк "X", "O" or "." (пробел)."""
    board = {}
    for rowIndex in range(BOARD_HEIGHT):
        for columnIndex in range(BOARD_WIDTH):
            board[(columnIndex, rowIndex)] = EMPTY_SPACE
    return board

def displayBoard(board):
    """Выводит на экран игровое поле и фишки."""

    # Подготовить список, передаваемый строковому методу format() для
    # шаблона игрового поля. Список содержит все фишки игрового поля
    # и пустые ячейки, перечисляемые слева направо, сверху вниз:
    tileChars = []
    for rowIndex in range(BOARD_HEIGHT):
        for columnIndex in range(BOARD_WIDTH):
            tileChars.append(board[(columnIndex, rowIndex)])  # в список добавляем значения словаря board

    # Выводит игровое поле:
    <b>print(BOARD_TEMPLATE.format(<font color=red>*</font>tileChars)</b>

def getPlayerMove(playerTile, board):
    """Предлагает игроку выбрать столбец для размещения фишки.
    Возвращает кортеж (столбец, строка) итогового положения фишки."""
    while True: # Пока игрок не введет допустимый ход.
        print(f"Player {playerTile}, enter 1 to {BOARD_WIDTH} or QUIT:")
        
        response = input("> ").upper().strip()
        if response == "QUIT":
            print("Thanks for playing!")
            sys.exit()

        if response not in COLUMN_LABELS:
            print(f"Enter a number from 1 to {BOARD_WIDTH}.")
            continue # Снова запросить ход.

        columnIndex = int(response) - 1

        # -1, потому что индексы начинаются с 0.
        # Если столбец заполнен, снова запросить ход:
        if board[(columnIndex, 0)] != EMPTY_SPACE:
            print("That column is full, select another one.")
            continue # Снова запросить ход.

        # Начать снизу, найти первую пустую ячейку.
        for rowIndex in range(BOARD_HEIGHT - 1, -1, -1):  # in [6, 5, 4, 3, 2, 1, 0]
            if board[(columnIndex, rowIndex)] == EMPTY_SPACE:
                return (columnIndex, rowIndex)

def isFull(board):
    """Возвращает True, если в `board` не осталось пустых ячеек, иначе возвращается False."""
    for rowIndex in range(BOARD_HEIGHT):
        for columnIndex in range(BOARD_WIDTH):
            if board[(columnIndex, rowIndex)] == EMPTY_SPACE:
                return False # Пустая ячейка найдена, вернуть False.
    return True # Все ячейки заполнены.

def isWinner(playerTile, board):
    """Возвращает True, если `playerTile` образует ряд из четырех фишек
    в `board`, в противном случае возвращается False."""

    # Проверить всю доску в поисках четырех фишек в ряд:
    for columnIndex in range(BOARD_WIDTH - 3):
        for rowIndex in range(BOARD_HEIGHT):
            # Проверить четверку направо:
            tile1 = board[(columnIndex, rowIndex)]
            tile2 = board[(columnIndex + 1, rowIndex)]
            tile3 = board[(columnIndex + 2, rowIndex)]
            tile4 = board[(columnIndex + 3, rowIndex)]
            if tile1 == tile2 == tile3 == tile4 == playerTile:
                return True

    for columnIndex in range(BOARD_WIDTH):
        for rowIndex in range(BOARD_HEIGHT - 3):
            # Проверить четверку вниз:
            tile1 = board[(columnIndex, rowIndex)]
            tile2 = board[(columnIndex, rowIndex + 1)]
            tile3 = board[(columnIndex, rowIndex + 2)]
            tile4 = board[(columnIndex, rowIndex + 3)]
            if tile1 == tile2 == tile3 == tile4 == playerTile:
                return True

    for columnIndex in range(BOARD_WIDTH - 3):
        for rowIndex in range(BOARD_HEIGHT - 3):
            # Проверить четверку по диагонали направо вниз:
            tile1 = board[(columnIndex, rowIndex)]
            tile2 = board[(columnIndex + 1, rowIndex + 1)]
            tile3 = board[(columnIndex + 2, rowIndex + 2)]
            tile4 = board[(columnIndex + 3, rowIndex + 3)]
            if tile1 == tile2 == tile3 == tile4 == playerTile:
                return True

            # Проверить четверку по диагонали налево вниз:
            tile1 = board[(columnIndex + 3, rowIndex)]
            tile2 = board[(columnIndex + 2, rowIndex + 1)]
            tile3 = board[(columnIndex + 1, rowIndex + 2)]
            tile4 = board[(columnIndex, rowIndex + 3)]
            if tile1 == tile2 == tile3 == tile4 == playerTile:
                return True
    return False

# Если программа была запущена (а не импортирована), начать игру:
if __name__ == "__main__":
    main()
</pre></td></tr></table>
<p>
<b>print(BOARD_TEMPLATE.format(*tileChars)</b><br>
Шаблонная строка содержит фигурные скобки {} , которые метод format() заменит содержимым игрового поля (списка tileChars). <font color=red>Непонятно, что значит звездочка внутри круглых скобок</font>.<br>
<i>В подразделе «Использование * при создании вариадических функций» (с. 201) показано, как использовать этот синтаксис для обработки значений в списке как отдельных аргументов функции; код print(*['cat', 'dog', 'rat']) эквивалентен print('cat', 'dog', 'rat') . Звездочка необходима, потому что метод format() ожидает получить один аргумент для каждой пары фигурных скобок, а не один аргумент-список.</i>
<pre>


=========================================================================================================================

</pre>
<a name="recurs_fun"><h3 align=center>Рекурсивные функции</h3>
При заданном n возьмите сумму цифр из n. Если это значение содержит более одной цифры, продолжайте уменьшать таким образом, пока не получится однозначное число. Входными данными будет неотрицательное целое число.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def digital_root(n):
    str_n = str(n)
    if len(str_n) > 1:
        result = 0        
        for i in str_n:
            result +=int(i)
        n = result
        print("adres n до рекурсии=", id(n), "n=", n)
        digital_root(n)
        print("adres n после рекурсии=", id(n), "n=", n)
        return n

    return n

print(digital_root(493193))
</pre>
<font color=red>Передаю n и возвращаю его, но почему-то после выполнения рекурсивной функции n не меняется</font>. Потому что не изменял внутри тела функции n. <font color=green>Надо было n = digital_root()</font></td>
<td>
<pre>
def digital_root(n):
    str_n = str(n)
    if len(str_n) > 1:
        result = 0        
        for i in str_n:
            result +=int(i)
        print("adres n до рекурсии=", id(n), "n=", n)
        <b>n = digital_root(result)</b>
        print("adres n после рекурсии=", id(n), "n=", n)
    
    return n

print(digital_root(493193))
</pre>
Базовый случай тут, когда len(n) == 1</td></tr>
<tr rowspan=2><td>
<pre>
def digital_root(n):
    return n if n < 10 else digital_root(sum(map(int,str(n))))

print(digital_root(493193))  # 2
print(sum([1, 2, 3, 4, 5]))  # 15
print(map(int, str(493193))) # &lt;map object at 0x7f60f81e5f4
</pre></td></tr></table>
<pre>

-------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Переменные в рекурсивной функции</b><br>
Напишите функцию persistence, которая принимает положительный параметр num и возвращает его мультипликативную стойкость, то есть количество раз, которое вы должны умножить на цифры в num, пока не получите единственную цифру.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def persistence(n, count=0):
    result = 1
    if n > 9:
        for i in str(n):
            result *=int(i)
        count +=1
        count = persistence(result, count)

    return count  

print(persistence(39))    # 3
print(persistence(4))     # 0
print(persistence(25))    # 2
#print(persistence(999))  # 4

Если count объявить global внутри функции, то алгоритм будет работать
правильно, но при каждом следующем вызове функции, сount сохраняет
свое значение с предыдущего вызова функции.</pre></td>
<td valign=top>
Без вызова рекурсии:
<pre>
def persistence(n):
    n = str(n)
    count = 0
    while len(n) > 1:
        p = 1
        for i in n:
            p *= int(i)
        n = str(p)
        count += 1
    return count
</pre></td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>

<b>Вставка списка в список в виде элементов</b><br>
Кривая Коха -- это простой геометрический фрактал.<br>
Строится этот фрактал следующим образом: берётся отрезок, разделяется на три равных части. Вместо средней части вставляется два таких же отрезка, поставленные под углом 60 градусов друг к другу. Этот процесс повторяется на каждой итерации: каждый отрезок заменяется четырьмя.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def get_turn(n):
    listTurn = []
    if n != 1:
        listTurnPrev = get_turn(n-1)
        listTurn.extend(listTurnPrev)
        listTurn.append('turn 60')
        listTurn.extend(listTurnPrev)
        listTurn.append('turn -120')
        listTurn.extend(listTurnPrev)
        listTurn.append('turn 60')
        listTurn.extend(listTurnPrev)
        return listTurn
    else:
        listTurn1 = ['turn 60', 'turn -120', 'turn 60']
        return  listTurn1

l = get_turn(int(input()))
for element in l:
    print(element)
</pre></td>
<td valign=top>
<pre>
def koch(n):
    if n > 0:
        koch(n - 1)
        print('turn 60')
        koch(n - 1)
        print('turn -120')
        koch(n - 1)
        print('turn 60')
        koch(n - 1)

koch(int(input()))
</pre></td></tr></table>
<pre>

------------------------------------------------------------------------------------------------------------------------

</pre>
<b>Список, независимый от оригинального списка</b><br>
Ханойская башня -- одна из широко известных головоломок, условие которой состоит в следующем:<br>
Имеется три стержня (пронумеруем их числами 1, 2 и 3). На первом стержне находится n колец с радиусами от 1 до n. Кольца отсортированы по радиусу, и наибольшее кольцо лежит ниже всех. Вам требуется найти и записать алгоритм переноса всех n колец с первого стержня на третий по следующим правилам:<br>
за один ход можно переносить только одно кольцо;<br>
нельзя класть большее кольцо на меньшее.<br>
Программа должна вывести на экран кратчайшую последовательность действий, необходимую для того, чтобы перенести все кольца с первого стержня на третий.<br>
Формат ввода:<br>
Строка, содержащая положительное целое число n.<br>
Формат вывода:<br>
Порядок действий для решения головоломки. Каждое действие записывается на отдельной строке. Действие записывается в формате "номер стержня, с которого снимаем кольцо" - "номер стержня, на который надеваем кольцо".
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<pre>
import copy

n = int(input())
towers_winner = {1: [], 2: [], 3: [i for i in range(n, 0, -1)]}
#towers_winner = {'A': [], 'B': [], 'C': [i for i in range(n, 0, -1)]} в выводе башни должны обозначаться числами
LST_TOWERS = [1, 2, 3]
#LST_TOWERS = ['A', 'B', 'C']
best_path = []

def check_step(towers, lst_towers, from_tower, to_tower):
    """
    Задача, проверить, что можно ходить так
    """
    check_towers = copy.deepcopy(towers)
    if len(towers[to_tower]) != 0 and towers[from_tower][-1] > towers[to_tower][-1]:
        #print(f"Диск на {from_tower} больше диска на {to_tower}, поэтому ход запрещен")        
        return 0
    else:
        disk = check_towers[from_tower].pop()
        check_towers[to_tower].append(disk)
        if check_towers in lst_towers :
            #print(f"Уже была такая позиция, поэтому ход с {from_tower} к {to_tower} запрещен")
            return 0
    #print("Проверку прошел, ход разрешён")    
    return 1

def do_next_step(towers, path, lst_towers):
    '''
    Задача функции: сделать ход и записать его в path
    tower - текущение положение дисков
    path - список ходов
    lst_tower - список положений дисков после каждого хода
    '''
    
    global best_path
    #print("_________Думаем над ходом________________")
    for from_tower in LST_TOWERS:
        if len(towers[from_tower]) == 0:
            continue
        lst_to_towers = LST_TOWERS.copy()
        #lst_to_towers.pop(from_tower-1)
        lst_to_towers.remove(from_tower)
        for to_tower in lst_to_towers:
            #print(f"from_tower={from_tower} для to_tower от {lst_to_towers[0]} до {lst_to_towers[-1]}, to_tower={to_tower}")
            #print(f"Положение: path={path}")
            #print(f"Положение: towers={towers}")
            #print(f"Положение: lst_towers={lst_towers}")
            copy_towers = copy.deepcopy(towers)
            copy_path = copy.deepcopy(path)
            copy_lst_towers = copy.deepcopy(lst_towers)
            if check_step(copy_towers, copy_lst_towers, from_tower, to_tower) != 0:
                #print(f"Ход разрешили, ходим от {from_tower} башни в {to_tower}")
                disk = copy_towers[from_tower].pop()
                copy_towers[to_tower].append(disk)
                copy_path.append([from_tower, to_tower])
                copy_lst_towers.append(copy.deepcopy(copy_towers))
                #print("Список ходов: path=", copy_path)
                #print("Текущее положение дисков: towers=", copy_towers)
                if len(best_path) != 0 and len(copy_path) >= len(best_path):
                    return
                if copy_towers != towers_winner:
                    do_next_step(copy_towers, copy_path, copy_lst_towers)
                else:
                    #print("Достигли цели")           
                    if len(copy_path) < len(best_path) or len(best_path) == 0:
                        best_path = copy.deepcopy(copy_path)
                        print("Лучший маршрут ходов: best_path=", best_path)
                    return

do_next_step({1: [i for i in range(n, 0, -1)], 2: [], 3: []}, [], [{1: [i for i in range(n, 0, -1)], 2: [], 3: []}])
#do_next_step({'A': [i for i in range(n, 0, -1)], 'B': [], 'C': []}, [], [{'A': [i for i in range(n, 0, -1)], 'B': [], 'C': []}])
for i in best_path:
    print(i[0], "-", i[1]) 
</pre></td></tr></table>
<ol>
<li> Как определить, что если походим так (from_tower and to_tower), то это будет повторение положения дисков (элемент в path_tower был такой).<br>
Создаем для этого отдельную функцию check_step(from_tower, to_tower)
<p>
<li> <b>Как создать независимую копию словаря (списка) так чтобы изменения в копии не влияли на оригинал?</b><br>
Теоретически для этого рекомендуют или использовать метод copy() или через приведение типа - dict(obj)<br>
Но у меня почему-то оригинал в обоих способах меняется.<br>
<i> Также обратите внимание, что функция dict.copy() является неглубокой, если в ней есть вложенный список/etc, изменения будут применены к обоим. IIRC. Deepcopy позволит избежать этого.</i><br>
Проблему решил так: check_towers = copy.deepcopy(towers)<br>
предварительно: import copy
<p>
<li> При возврате к предыдущему шагу переменные сохраняют значение с последней итерации цикла<br>
Создал копии оригинала и их отправляю в рекурсивной функции
<p>
<li> Сделал обозначения башен в виде букв: A B C, но когда нужно удалить элемент списка: lst_to_towers[from_tower].pop()<br>
то получаю ошибку:<br>
<font color=red>TypeError: list indices must be integers or slices, not str</font><br>
В этом случае использовать более универсальный метод removed, но поскольку по заданию все равно нужен вывод башен в виде чисел, оставил обозначение в виде чисел и метод pop.
</ol>
<p>
Решение давало результат только до n=4, при n = 5 даже не находило вариант. Потому сайт не принял решение. Грамотное решение:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
n = int(input())
path = []

def move_tower(n,from_tower, to_tower, sredn_tower):
    if n >= 1:
        move_tower(n-1,from_tower, sredn_tower, to_tower)
        move_disk(from_tower,to_tower)
        move_tower(n-1,sredn_tower,to_tower,from_tower)

def move_disk(from_tower,to_tower):
    path.append([from_tower, to_tower])

move_tower(n, 1, 3, 2)
for i in path:
    print(i[0], "-", i[1])
</pre></td></tr></table>
<p>
Получал результат сразу.
<pre>



=========================================================================================================================



</pre>
<h3 align=center><a name="lambda">lambda-функции</h3>
Лямбда функции предоставляют нам удобный способ создать функцию «прямо на месте».<br>
Но иногда, когда нужно создавать много однотипных лямбда функций, еще удобнее будет создать функцию, которая будет их 
генерировать.
<p>
Реализуйте функцию mod_checker(x, mod=0), которая будет генерировать лямбда функцию от одного аргумента y, которая будет 
возвращать True, если остаток от деления y на x равен mod, и False иначе.
<pre>
def mod_checker(x, mod=0):
    return lambda y: y % x == mod
</pre>
<pre>

---------------------------------------------------------------------------------------------------------------------------

</pre>
<b>lambda-функции, замыкания</b><br>
Нужно провести вычисления с использованием функций и получить результаты.
<pre>
seven(times(five())) # must return 35
four(plus(nine())) # must return 13
eight(minus(three())) # must return 5
six(divided_by(two())) # must return 3
</pre>
Решение:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def zero(funk = None): return 0 if not funk else funk(0)  # возвращает 0, если нет аргумента, иначе функцию funk с аргументом 0

def one(funk = None): return 1 if not funk else funk(1)

def two(funk = None): return 2 if not funk else funk(2)

def three(funk = None): return 3 if not funk else funk(3)

def four(funk = None): return 4 if not funk else funk(4)

def five(funk = None): return 5 if not funk else funk(5)

def six(funk = None): return 6 if not funk else funk(6)

def seven(funk = None): return 7 if not funk else funk(7)

def eight(funk = None): return 8 if not funk else funk(8)

def nine(funk = None): return 9 if funk == None else funk(9)

def plus(n): return lambda x: x+n
def minus(n): return lambda x: x-n
def times(n): return lambda  x: x*n
def divided_by(n): return lambda  x: int(x/n)

print(one(divided_by(nine())))  # 0

print(seven(plus(nine())))      # 16
</pre></td></tr></table>
<p>
Значение аргумента по умолчанию равно None. None - это такая формализованная “пустота” в питоне. Если что-то пусто (отсутствует), мы ему придаём значение None.
<p>
В конструкции:<br>
def plus(n): return lambda x: x+n<br>
лямбда-функция является замыканием 

<pre>



===========================================================================================================================



</pre>
<h3 align=center><a name="modul">Модули</h3>
Напишите программу, которая подключает модуль math и, используя значение числа π из этого модуля, находит для переданного ей на
стандартный ввод радиуса круга периметр этого круга и выводит его на стандартный вывод.
<pre>
from math import pi
print(float(input()) * pi * 2)
</pre>
<pre>


-----------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая запускается из консоли и печатает значения всех переданных аргументов на экран (имя скрипта 
выводить не нужно). Не изменяйте порядок аргументов при выводе.
<p>
Для доступа к аргументам командной строки программы подключите модуль sys и используйте переменную argv из этого модуля.
<pre>
import sys
print(*sys.argv[1::])</pre>
Метод sys.argv выдаст список, где первый элемент - это имя вызвавшей программы, а следующие - это аргументы программы. Посколь
ку нам не нужно имя программы, то к списку применяем срез.
<br><img src="./images/python_example.png"><br>
Первую и вторую команду применили без среза.<br>
3 команду без звездочки внутри print()
<pre>


--------------------------------------------------------------------------------------------------------------------------


</pre>
Скачайте файл. В нём указан адрес другого файла, который нужно скачать с использованием модуля requests и посчитать число 
строк в нём.
<p>
Используйте функцию get для получения файла.
<p>
После получения файла вы можете проверить результат, обратившись к полю text. Если результат работы скрипта не принимается, 
проверьте поле url на правильность. Для подсчёта количества строк разбейте текст с помощью метода splitlines.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
import requests
# Прочитаем url со скачанного файла
with open('/home/dmitriy/Python/mypython/dataset_3378_2.txt') as f:
    s = f.read()
    # print(s)  #  адрес страницы, которую нужно скачать
r = requests.get(s)  # простой get-запрос
#print('Ответ сервера:', '\n', r.text.splitlines()) # вывод ответа от сервера
#print('Ответ сервера:', '\n', r.text)
for i in r.text.splitlines():
    print(i)
print('количество строк=', len(r.text.splitlines()))
</pre>
</td></tr></table>
<font color=red>SyntaxError: unexpected character after line continuation character</font><br>
Данная ошибка означает, что где-то болтается '\'  вне строки. После того, как в print('Ответ сервера:', <font color=red>\n
</font>, r.text) <b>\n</b> заключил в кавычки, ошибка исчезла.
<p>
r = requests.get(s).splitline()  # простой get-запрос<br>
<font color=red>AttributeError: 'Response' object has no attribute 'splitline'</font><br>
Ошибку устранил, когда метод splitline() применил к объекту r.text, а не в команде <b>r = requests.get(s).splitline()</b>, 
которая вызывала ошибку.
<pre>


----------------------------------------------------------------------------------------------------------------------


</pre>
Имеется набор файлов, каждый из которых, кроме последнего, содержит имя следующего файла.
Первое слово в тексте последнего файла: "We".
<p>
Скачайте предложенный файл. В нём содержится ссылка на первый файл из этого набора.
<p>
Все файлы располагаются в каталоге по адресу:
https://stepik.org/media/attachments/course67/3.6.3/
<p>
Загрузите содержимое ﻿последнего файла из набора, как ответ на это задание.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
url = 'https://stepik.org/media/attachments/course67/3.6.3/'
import requests
with open('/home/dmitriy/Python/mypython/dataset_3378_3.txt') as f:
    u = f.read()
    # u = u[len(url):]
    #print('Адрес 1 файла из набора:', url+u)
    print('Адрес 1 файла из набора:', u)
    # u = requests.get(url + u)
    u = requests.get(u)
k = 0 # счетчик файлов
while True:
    if u.text.split()[0] == 'We':
        break
    u = requests.get(url + u.text)
    print('k=', k, 'адрес следующего файла:', url+u.text)
    k +=1
print('Последний файл:\n\n', u.text)
</pre>
</td></tr></table>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Не моё:
<pre>
import requests
url, name = 'https://stepik.org/media/attachments/course67/3.6.3/', '699991.txt'
while <b>name[:2] != 'We':</b>
    name = requests.get(url + name).text
print(name)</pre>
Еще:
<pre>
import requests
with open('dataset_3378_3.txt') as txt:
    a = txt.readline().strip()
print(a)
a = str(requests.get(a).text)
b = 'https://stepik.org/media/attachments/course67/3.6.3/'
while 'we' not in a:
    print(a)
    <b>a = requests.get(b + a).text</b>
print(a)
</pre>
</td></tr></table>
<font color=red>u = requests.get(str(url+u))<br>
TypeError: can only concatenate str (not "Response") to str</font><br>
Так и не смог решить проблему, извращенно сначало первый из набора отдельно вытащил url из файла и только к следующим через 
цикл посылал запрос. Похоже надо было так: <b>u = requests.get(url + u).text</b>
<pre>


-------------------------------------------------------------------------------------------------------------------------


</pre>
В первой строке дано три числа, соответствующие некоторой дате date -- год, месяц и день.<br>
Во второй строке дано одно число days -- число дней.<br>
Вычислите и выведите год, месяц и день даты, которая наступит, когда с момента исходной даты date пройдет число дней, равное 
days.<br>
Примечание: Для решения этой задачи используйте стандартный модуль datetime.
Вам будут полезны класс datetime.date для хранения даты и класс datetime.timedelta﻿ для прибавления дней к дате.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td rowspan=3 valign=top>
Моё:
<pre>
from datetime import datetime as dt, timedelta

first_date=dt.strptime(input(), '%Y %m %d')
end_date = first_date + timedelta(int(input()))
end_date1 = end_date.strftime('%Y %m %d')
date = end_date1.split()
for i in date:
    print(int(i), end=' ')</pre>
</td>
<td>
Другое:
<pre>
import datetime
inp = datetime.datetime.strptime(input(), "%Y %m %d")
inp += datetime.timedelta(days=int(input())) 
print(f'{inp.year} {inp.month} {inp.day}')

</pre>
</td></tr>
<tr><td>
Другое:
<pre>
import datetime
y, m, d = map(int, input().split())
days = int(input())
current = datetime.date(year=y, month=m, day=d)
current += datetime.timedelta(days=days)
print("{} {} {}".format(current.year, current.month, current.day))</pre>
</td></tr>
<tr>
<td>
Ещё:
<pre>
import datetime
<b>(y,m,d) = [int(n) for n in input().split()]</b>
d = datetime.date(y, m, d)+ datetime.timedelta(int(input()))
print(d.year, d.month, d.day)</pre>
</td></tr></table>
<p>
1. Скажите, пожалуйста, почему datetime.datetime...? А если datetime.strptime, то "datetime не имеет атрибута strptime"
<br>
Потому что метод класса datetime, который преобразует строку в datetime, есть операция datetime.strptime(date_string, format). 
То есть, чтобы корректно написать операцию переформатирования введенной строки в формат даты, мы сначала прописываем класс 
datetime, затем через точку метод datetime.strptime().. в скобках - соответствующие аргументы
<pre>


----------------------------------------------------------------------------------------------------------------------



</pre>
<a name='os'><b>Модуль os</b><br>
Вам дана в архиве (ссылка) файловая структура, состоящая из директорий и файлов.
<br>Вам необходимо распаковать этот архив, и затем найти в данной файловой структуре все директории, в которых есть хотя бы 
один файл с расширением ".py". 
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
from os import getcwd, walk, chdir

chdir('/home/dmitriy/Python/mypython/main')
lst = set()
for root, directories, filenames in walk(getcwd()):
    for filename in filenames:
        if filename.endswith('.py'):
            lst.add(root[30::])
for x in sorted(lst):
    print(x)</pre>
</td>
<td valign=top>
Другое:
<pre>
import os

for cur_dir, subdirs, files in os.walk("main"):
    for file in files:
        if file.endswith(".py"):
            print(cur_dir)
            break
</pre>
</td></tr></table>
<p>
1. os.walk() идет по директориям в алфавитном порядке. За счет этого можно не сортировать итоговый список.<br>
2. chdir - переход на нужную папку<br>
getcwd() - текущая папка<br>
walk(dir) - выдает генератор - итератор, где его элемент состоит из строки (каталог), списка входящих каталогов и еще один 
список из файлов. <br>
3. lst.add(root[30::]) - срез, чтобы обрезать лишний путь к каталогу.
<pre>



=======================================================================================================================



</pre>
<h3 align=center><a name="stdin">Модуль stdin</h3>
<b>stdin api</b>
<p>
В этой задаче вам необходимо воспользоваться API сайта numbersapi.com<br>
Вам дается набор чисел. Для каждого из чисел необходимо узнать, существует ли интересный математический факт об этом числе.<br>
Для каждого числа выведите Interesting, если для числа существует интересный факт, и Boring иначе.<br>
Выводите информацию об интересности чисел в таком же порядке, в каком следуют числа во входном файле.
<p>
Пример запроса к интересному числу:<br>
http://numbersapi.com/31/math?json=true<br>
Пример запроса к скучному числу:<br>
http://numbersapi.com/999/math?json=true
<pre>
Пример входного файла:
31
999
1024
502
﻿Пример выходного файла:
Interesting
Boring
Interesting
Boring
</pre>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
import json
from sys import stdin
import requests


number = int()
for number in stdin:
    url = 'http://numbersapi.com/'+number.strip()+'/math?json=true'
    r = requests.get(url).text
    json_stroka = json.loads(r)
    if json_stroka['found'] == True:
        print('Interesting')
    else:
        print('Boring')
</pre>
</td></tr>
<tr><td>
Другое:
<pre>
import requests
import json

def is_interesting(x):
    url = "http://numbersapi.com/"; + str(x) + "/math?json=true"
    resp = requests.get(url).text
    js = json.loads(resp)
    return js["found"]

with open("input.txt") as fi:
    for line in fi:
        print("Interesting" if is_interesting(line.rstrip()) else "Boring")
</pre>
</td></tr></table>
Я не понял задание и вводил числа через stdin, а не из файла, как у других.<br>
Получил проблему, что после ввода чисел столбцом вывод начинается сразу автоматом и со строки последнего числа и не выводит 
результат для последнего числа, нажимаю enter, чтобы вывести его:
<p>
<img src="./images/python_example1.png">
<pre>



=======================================================================================================================



</pre>
<h3 align=center><a name="obiekt">Объекты</h3>
Реализуйте программу, которая будет вычислять количество различных объектов в списке.
Два объекта a и b считаются различными, если a is b равно False.
<p>
Вашей программе доступна переменная с названием objects, которая ссылается на список, содержащий не более 100 объектов. 
Выведите количество различных объектов в этом списке.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
objects = [1, 2, 1, 5, True, False, True, 'false', [], [1,2], [1,2]]
ans = 1
unik = {id(objects[0])}
massiv = [objects[0]]
for obj in objects: # доступная переменная objects
    if id(obj) in unik:
        continue
    else:
        unik.add(id(obj))
        massiv.append(obj)
        ans += 1

print('Список уникальных объектов = ', massiv)
print('Список ID уникальных объектов = ', unik)
print('Количество уникальных объектов = ', ans)</pre>
Вывод:
<pre>
[1, 2, 5, True, False, 'false', [], [1, 2], [1, 2]]
{9776672, 9461728, 9776704, 9464160, 9776800, 139738779320768, 139738778605952, 139738778694720}
</pre>
Дебильное решение, не учел, что свойство множества принимать только уникальное значение.
</td><td>
Грамотное другое решение:
<pre>
s=set()
for obj in objects:
    s.add(id(obj))
print(len(s))
</pre>
</td></tr></table>
<pre>



===================================================================================================================



</pre>
<h3 align=center><a name="oop">ООП</h3>
Реализуйте класс MoneyBox, для работы с виртуальной копилкой.
<p>
Каждая копилка имеет ограниченную вместимость, которая выражается целым числом – количеством монет, которые можно положить в 
копилку. Класс должен поддерживать информацию о количестве монет в копилке, предоставлять возможность добавлять монеты в 
копилку и узнавать, можно ли добавить в копилку ещё какое-то количество монет, не превышая ее вместимость.
<p>
При создании копилки, число монет в ней равно 0.
Примечание: метод add(self, v) будет вызываться только если can_add(self, v) – True﻿.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
class MoneyBox:
    def __init__(self, capacity):
        self.capacity = capacity
        
    def can_add(self, v):
        # True, если можно добавить v монет, False иначе
        if self.capacity >= v:
            return True
        else:
            return False

    def add(self, v):
        # положить v монет в копилку
        if self.can_add(v):
            self.capacity -= v
</pre>
</td></tr></table>
Блок:
<pre>
if self.capacity >= v:
            return True
        else:
            return False
</pre>
можно заменить одной строкой: <b>return self.capacity >= v</b>
<pre>


------------------------------------------------------------------------------------------------------------------------


</pre>
Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой 
последовательности, затем сумму второй пятерки, и т. д.
<p>
Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. Например, 
сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.
<p>
Реализуйте класс Buffer, который будет накапливать в себе элементы последовательности и выводить сумму пятерок 
последовательных элементов по мере их накопления.
<p>
Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, 
т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.
<p>
Обратите внимание, что во время выполнения метода add выводить сумму пятерок может потребоваться несколько раз до тех пор, 
пока в буфере не останется менее пяти элементов.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<b>Моё:</b>
<pre>
class Buffer:
    def __init__(self):
        self.lst = []
               
    def add(self, *a):
        for i in a:  # выводим аргументы в список
            self.lst.append(i)
        # print('self.lst=', self.lst)
        if len(self.lst) <5:
            return
        else:
            while len(self.lst) >= 5:
                print(sum(self.lst[:5:1]))
                del self.lst[0:5]
                
    def get_current_part(self):
        return self.lst</pre>
</td><td>
<b>Грамотное решение:</b>
<pre>
class Buffer:
    def __init__(self):
        self.part = []

    def add(self, *a):
        for i in a:
            self.part.append(i)
            if len(self.part) == 5:
                print(sum(self.part))
                self.part.clear()

    def get_current_part(self):
        return self.part
</pre>
</td></tr></table>
<p>
Сразу считал 5 элементов, суммировал, выводил и удалял их, а не как я, запоминал весь ввод и потом считывал первые 5 элементов.
</td></tr></table>
<pre>


----------------------------------------------------------------------------------------------


</pre>
<b>Задача:</b> Реализуйте структуру данных, представляющую собой расширенную структуру стек. Необходимо поддерживать 
добавление элемента на вершину стека, удаление с вершины стека, и необходимо поддерживать операции сложения, вычитания, 
умножения и целочисленного деления.
<p>
Операция сложения на стеке определяется следующим образом. Со стека снимается верхний элемент (top1), затем снимается 
следующий верхний элемент (top2), и затем как результат операции сложения на вершину стека кладется элемент, равный top1 + 
top2.
<p>
Аналогичным образом определяются операции вычитания (top1 - top2), умножения (top1 * top2) и целочисленного деления (top1 // 
top2).
<p>
Реализуйте эту структуру данных как класс ExtendedStack, отнаследовав его от стандартного класса list.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<pre>
class ExtendedStack(<b>list</b>):
        
    def sum(self):
        # операция сложения
        self.append(self.pop() + self.pop())
           

    def sub(self):
        # операция вычитания
        self.append(self.pop() - self.pop())
        #print(self.lst) 

    def mul(self):
        # операция умножения
        self.append(self.pop() * self.pop())
        

    def div(self):
        # операция целочисленного деления
        self.append(self.pop() // self.pop())
</pre>
</td></tr></table>
1. Здесь поскольку ExtendedStack унаследован от класса list, то при создании экземпляра ExtendedStack нужно в аргументе 
указать список:
<br>my_class = ExtendedStack([1, 2, 3])
<p>
2 момент: self будет <b>равен не my_class</b>, а списку, указанному при создании экземпляра.
<pre>


-------------------------------------------------------------------------------------------------------------------


</pre>
<b>Задача:</b><br>
Одно из применений множественного наследование – расширение встроенного метода за счет одноименного метода класса.<br>
Например, если нам понадобится логировать какую-то информацию при обращении к методам класса.
<p>
Рассмотрим класс Loggable:
<pre>
import time

class Loggable:
    def log(self, msg):
        print(str(time.ctime()) + ": " + str(msg))</pre>
У него есть ровно один метод log, который позволяет выводить в лог (в данном случае в stdout) какое-то сообщение, добавляя при 
этом текущее время.<br>
Реализуйте класс LoggableList, отнаследовав его от классов list и Loggable таким образом, чтобы при добавлении элемента в 
список посредством метода append в лог отправлялось сообщение, состоящее из только что добавленного элемента.
<br>Примечание: Ваша программа не должна содержать класс Loggable. При проверке вашей программе будет доступен этот класс, и 
он будет содержать метод log, описанный выше.
<p>
<b>По существу нужно расширить функционал обычного метода append, чтобы дополнительно еще шла запись в лог.</b>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<pre>
#!/usr/bin/env python3
import time

class Loggable:
    def log(self, msg):
        print(str(time.ctime()) + ": " + str(msg))
        
class LoggableList(list, Loggable):
           
    def append(self, elem): 
        <font color=red>list.append(self, elem)</font>
        super().log(elem)
</pre></td>
<td>
<b>Выполнение:</b>
<pre>
dmitriy@945G-M3:~$ python3 -i ~/Python//mypython/1.py
>>> my_class = LoggableList()
>>> my_class.__dict__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'dict' object is not callable
>>> <font color=red>my_class.__dict__
{}</font>
>>> my_class
[]
>>> my_class.append(5)
Fri Nov  1 13:40:58 2024: 5
>>> my_class
[5]
>>> my_class2 = LoggableList([1, 2, 3, 4])
>>> my_class2
[1, 2, 3, 4]
>>> my_class2.append(5)
Fri Nov  1 13:46:07 2024: 5
>>> my_class2
[1, 2, 3, 4, 5]
>>> <font color=red>self</font>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in <module>
NameError: name 'self' is not defined
>>> my_log.log('hhhh')
Fri Nov  1 15:10:24 2024: hhhh
>>> type(my_log)
&lt;class '__main__.Loggable'&gt;
>>> my_log.__dict__
{}
>>> my_log.append(5)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in <module>
AttributeError: 'Loggable' object has no attribute 'append'
>>> type(my_class)
&lt;class '__main__.LoggableList'&gt;
</pre>
</td></tr></table>
<p>
1. Непонятно, когда нужно создавать конструктор класса, когда нет. В данной задаче с конструктором с аргументом lst stepik 
решение не принимал.<br>
Думал, что только через конструктор можно создать экземпляр с конкретным списком, но нет, в примере выше создал my_class2 со 
списком [1, 2, 3, 4]
<p>
2. Непонятно что с  self
<p>
3. Почему при вызове my_class.__dict__ ответ - пустой словарь {}. Нет скажем атрибута append()
<p>
4. Почему при вызове метода append() его нужно вызывать из класса list.
<br>Если self.append(elem), то возникает бесконечная рекурсия, т.к. интерпретатор ищет append в классе LoggableList.<br>
Но опять же почему в классе LoggableList нет метода append. Если родителем является list, то вроде как экземпляр должен 
унаследовать его методы в том числе append.
<p>
<b>Другое грамотное решение:</b>
<pre>
class LoggableList(list, Loggable):
    def append(self, x):
        list.append(self, x)
        self.log(x)
</pre>
<font color=red>Непонятно почему при вызове метода log() из родительского класса не используется функция super()</font><br>
<i>Полагаю, прямое обращение self.log(x) в данном случае работает просто быстрее и чуть короче в коде, чем super().log(x). 
Другого принципиального отличия не вижу. Исходя из описания вот тут https://docs.python.org/3/library/functions.html?
highlight=super#super﻿ ни что не мешает в этом примере использовать super() для доступа к родительскому методу даже без его 
модификации.</i>
<p>
<b>Почему  в строке: list.append(self, x) метод  append принимает self ?</b><br>
<i>мы обращаемся к методу класса а не его экземпляра, в этом случае нужно передать и значение для self, если бы мы обращались 
к нему как к экземпляру, тогда было бы self.append(x)</i>
<pre>
>>> a = [1, 2]
>>> b = 5
>>> list.append(a, b)
>>> a
[1, 2, 5]
>>> a.append(6)
>>> a
[1, 2, 5, 6]
</pre>
<pre>



============================================================================================================



</pre>
<h3 align=center>Исключения</h3>
Реализуйте класс PositiveList, отнаследовав его от класса list, для хранения положительных целых чисел.
Также реализуйте новое исключение NonPositiveError.
<p>
В классе PositiveList переопределите метод append(self, x) таким образом, чтобы при попытке добавить неположительное целое 
число бросалось исключение NonPositiveError и число не добавлялось, а при попытке добавить положительное целое число, число 
добавлялось бы как в стандартный list.
<br>В данной задаче гарантируется, что в качестве аргумента x метода append всегда будет передаваться целое число.
<br>Примечание: Положительными считаются числа, строго большие нуля.'''
<pre>
class  NonPositiveError(Exception):
    print(x, 'меньше нуля')
    
class PositiveList(list):
    def append(self, x):
        if x <= 0:
                raise NonPositiveError(x)
        else:
            list.append(self, x)
</pre>
<pre>



=================================================================================================================



</pre>
<h3 align=center><a name="iterator">Итерирование классов</h3>
Задача по перебору класса:<br>
На вход класса подаем итерируемый объект. Функция класса - перебрать этот объект и выдать в итоге отфильтрованный объект.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
class multifilter:
    def judge_half(pos, neg):
        # допускает элемент, если его допускает
        # хотя бы половина фукнций (pos >= neg)
        <font color=red>if pos >= neg:
            return True
        else:
            return False</font>
                
    def judge_any(pos, neg):
        # допускает элемент, если его допускает
        # хотя бы одна функция (pos >= 1)
        if pos >= 1:
            return True
        else:
            return False
            
    def judge_all(pos, neg):
        # допускает элемент, если его 
        # допускают все функции (neg == 0)
        if neg ==0:
            return True
        else:
            return False    

    def __init__(self, iterable, *funcs, judge=judge_any):
        # создаем экземпляр класса multifilter
        self.iterable = iterable
        self.judge = judge
        <font color=red>self.funcs = []
        for i in funcs:
            self.funcs.append(i)</font>
        
    def __iter__(self):
        for i in self.iterable:
            self.pos = 0
            self.neg = 0
            for f in self.funcs:
                if f(i):
                    self.pos += 1
                else:
                    self.neg += 1
            if self.judge(<font color=red>self.pos, self.neg</font>):
                yield i</pre>
</td><td valign=top>
Другое:
<pre>
class multifilter:
    def judge_half(pos, neg):
        <font color=green>return pos >= neg</font>

    def judge_any(pos, neg):
        return pos > 0

    def judge_all(pos, neg):
        return neg == 0

    def __init__(self, iterable, *funcs, judge=judge_any):
        self.iterator = iter(iterable)
        <b>self.funcs = funcs</b>
        self.judge = judge

    def __iter__(self):
        return self

    def __next__(self):
        while (True):
            elem = next(self.iterator)
            pos, neg = 0, 0
            for func in self.funcs:
                if func(elem):
                    pos += 1
                else:
                    neg += 1

            if self.judge(pos, neg):
                return elem</pre>
</td></tr></table>
<p>
<b>Выполнение:</b>
<pre>
def mul2(x):
    return x % 2 == 0

def mul3(x):
    return x % 3 == 0

def mul5(x):
    return x % 5 == 0

a = [i for i in range(31)] # [0, 1, 2, ... , 30]

print(list(multifilter(a, mul2, mul3, mul5))) 
# [0, 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30]

print(list(multifilter(a, mul2, mul3, mul5, judge=multifilter.judge_half))) 
# [0, 6, 10, 12, 15, 18, 20, 24, 30]

print(list(multifilter(a, mul2, mul3, mul5, judge=multifilter.judge_all))) 
# [0, 30]
</pre>
<pre>



======================================================================================================================



</pre>
<h3 align=center><a name="gener">Функции-итераторы</h3>
Реализуйте функцию-генератор primes, которая будет генерировать простые числа в порядке возрастания, начиная с числа 2.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Первоначальный вариант:
<pre>
def primes(*args):
    lst = args
    print(lst)
    print(type(lst))
    count = 0
    for i in lst:
        if i < 2:
            continue
        for k in range(2, i + 1):
            if k % i:
                count +=1
        if count == 2:
            yield i
</pre>
</td>
<td valign=top>
Итоговое решение:
<pre>
import itertools
def primes():
    a = 1
    while True:  # просто пример
        count = 0
        a += 1
        for i in range(1, a + 1):
            if a % i == 0:
                count +=1
        if count == 2:
            yield i</pre>
</td></tr></table>
1. Как реализовать бесконечный диапазон?<br>
2. Где начнется выполняться функция при повторном ее вызове?<br>
3 lst = [args] <font color=red>not supported between instances of 'tuple' and 'int'</font><br>
4. Первоначальный вариант был ошибочен из-за команды проверки: <i>print(list(itertools.takewhile(lambda x : x <= 31, 
primes())))</i>
<pre>



=======================================================================================================



</pre>
<a name="try"><h3 align=center>try / except - обработка исключений (ошибок)</h3>
Напишите функцию get_int(start_message, error_message, end_message), принимающую три строки в качестве аргументов. Функция должна запрашивать у пользователя ввод до тех пор, пока не будет введено целое число (строка, принимаемая функцией int без ошибок).
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
def get_int(start_message, error_message, end_message):
    print(start_message) 
    while True:
        try:
            s = input()
            #if (s.isdigit()):
            s = int(s)
            print(end_message)
            return s
        except:
            print(error_message)

get_int('Input int number:', 'Wrong value. Input int number:', 'Thank you.')
</pre></td></tr></table>
<p>
isdigit() не замечает отрицательные числа. Поэтому, если с ней решать, то сначала убираем минус:<br>
n.lstrip('-+').isdigit()<br>
и потом когда возвращать число, назад минус добавлять.
<pre>


===========================================================================================================================


</pre>
<a name="library"><h3 align=center>Библиотеки:</h3>
<b>Модуль  permutations из библиотеки itertools</b><br>
Получить из слова весь возможный список слов и вывести номер слова в этом отсортированном списке.
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
<b>from itertools import permutations</b>

def list_position(word):
    list_words = []
    for i in permutations(word):
        list_words.append(''.join(i))
        
    list_words = list(set(list_words))
    list_words.sort()
    return list_words.index(word)+1

#list_position('ABAB')
#list_position('BAAA')
print(list_position('QUESTION'))
</pre></td></tr></table>
<p>
<a href="https://kotoff.net/article/python/97-generacija-vsevozmozhnyh-kombinacij-iz-nabora-simvolov-kombinatorika-v-python-itertools.html">Ссылка</a><br>
Модуль  permutations формирует список слов из входного слова.
<pre>







</pre></body></html>
