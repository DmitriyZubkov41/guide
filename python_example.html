<html><head>
<style>
.menu {
       height: 100%;
       width: 80px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 6px 8px 6px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 90px; /* То же, что и ширина боковой панели */
           padding: 0px 0px 0px 0px;
         }
</style>
</head><body>
<title>Примеры</title>
<div class="menu">

<a href="#while">Циклы</a><br>
<a href="#dict">Словари</a><br>
<a href="#graf">Задачи на графы</a><br>
<a href="#fun">Функции:</a>
<a href="#lambda">&nbsp;&nbsp; lambda-функции</a>
<a href="#file">Файлы</a><br>
<a href="#modul">Модули:</a>
<a href="#os">&nbsp;&nbsp; os</a>
<a href="#stdin">&nbsp;&nbsp; stdin</a>
<a href="#obiekt">Объекты</a>
<a href="#oop">ООП</a>
<a href="#iterator">Итерироние классов</a>
<a href="#gener">Функции-итераторы</a>
<a href="#text">Работа с текстом</a>
<a href="#table">Работа с таблицами</a>
<a href="#xml">Работа с XML</a>
</div>

<div class="content">
<a name="while"><h3 align=center>Циклы:</h3>
Напишите программу, которая считывает с консоли числа (по одному в строке) до тех пор, пока сумма 
введённых чисел не будет равна 0 и сразу после этого выводит сумму квадратов всех считанных чисел.
<br>Гарантируется, что в какой-то момент сумма введённых чисел окажется равной 0, после этого считывание продолжать не нужно.
<pre>
s = 0
y = 0
while True:
    x = int(input())
    s += x
    y += x*x
    if s == 0:
        break
print(y)</pre>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ... (число повторяется столько 
раз, чему равно). На вход программе передаётся неотрицательное целое число n — столько элементов последовательности должна 
отобразить программа. На выходе ожидается последовательность чисел, записанных через пробел в одну строку.
<br>Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Мое решение:
<pre>
k = 1
n = int(input())
m = [] # полный список
for i in range(1,n+1):
    m = m + [i]*i
for a in m:
    print(a,end=' ')
    k += 1
    if k > n:
        break
print()
</pre>
</td><td>
Не моё:
<pre>
n = int(input())
a = []
i = 0
while len(a) < n:
    a += [i] * i
    i += 1
print(*a[:n])
</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая принимает на вход список чисел в одной строке и выводит на экран в одну строку значения, 
которые встречаются в нём более одного раза.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё решение:
<pre>
list = [int(i) for i in input().split()]
list_end = []
i = 0
while len(list) > 1:
    find_number = list[i]
    list.remove(list[i])
    if find_number in list and not find_number in list_end:
        list_end.append(find_number)
for element in list_end:
    print(element,end=' ')
</pre>
</td><td>
Другое решение:
<pre>
a, c = [str(i) for i in input().split()], []
for i in a:
    if i not in c and a.count(i) > 1:
        c.append(i)
        print(i, end=' ')
</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>        
На вход программы подаётся список чисел lst и число x. Программа должна выдавать на выход в виде одной строки позиции 
расположения числа х в списке чисел lst. Если число х в списке lst  не обнаружено, необходимо вывести на выход строкой 
"Отсутствует".
<pre>
lst = [int(i) for i in input().split()]
x = int(input())
# Перебрать список lst по элементам
# каждый элемент сравнивать с x
# если совпадает, то напечатать индекс
# если же нет, то следующий элемент вытаскиваем
i = 0  #    определяем переменную, иначе будет ошибка
if x not in lst:
    print('Отсутствует')
else:
    for lst[i] in lst:
        if lst[i] == x:
            print(i, end=' ')
        i += 1

# 1. Ошибка <font color=red>IndexError: list assignment index out of range</font> возникает в Python, когда нельзя присвоить значение элементу,
 который ещё не существует в списке. Ошибку устранил, когда в <b>for num[i] in lst:</b> num[i] поменял на lst[i]
# 2. В <b>for lst[i] in lst:</b> i автоматически не прибавляет на 1</pre>

Не моё решение:
<pre>
lst, x = input().split(), input()
if x in lst:
    for i in range(len(lst)):
        if lst[i] == x:
            print(i, end=' ')
else:
    print('Отсутствует')</pre>
В этом решении цикл по индексу списка, а не по элементу списка, как у меня.
<pre>

-----------------------------------------------------------------------------------------------------------------

</pre>
Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк. После последней строки
 матрицы идёт строка, содержащая только строку "end"
<p>
Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j равен сумме элементов первой матрицы
 на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится с  противоположной стороны 
 матрицы.<br>
В случае одной строки/столбца элемент сам себе является соседом по соответствующему направлению.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
table = []
while True:
    table.append([x for x in input().split()])
    if table[-1] == ['end']:
        break
# удалим end
table.remove(['end'])
# str - количество элементов в table - это коли-во строк матрицы
# stolb - количество элементов в элементе table - это коли-во столбцов матрицы
if len(table) == 1:
    delta_str = 0
else:
    delta_str = 1
if len(table[0]) == 1:
    delta_stolb = 0
else:
    delta_stolb = 1
for str in range(len(table)): # по строкам
    if str == len(table) - 1:
        str = str - len(table)
    for stolb in range(len(table[str])):
        if stolb == len(table[str]) - 1:
            stolb = stolb - len(table[str])
        print(int(table[str + delta_str][stolb]) + int(table[str - delta_str][stolb]) + \
        int(table[str][stolb + delta_stolb]) + int(table[str][stolb - delta_stolb]), end=' ')
    print()
</pre>
</td><td>
Другое решение:
<pre>
a = [[int(i) for i in input().split()]]
b = input()
while b != 'end' :
    a.append([int(i) for i in b.split()])
    b = input()
for i in range(len(a)): 
    for j in range(len(a[i])): 
        print((a[i-1][j] + a[(i+1) % len(a)][j] + a[i][j-1] + a[i][(j+1) % len(a[i])]), end=' ')
    print()</pre>
Еще решение:
<pre>
c = []
while True:
    a = [i for i in input().split()]
    if a == ['end']:
        break
    c.append(a)
n, m = len(c), len(c[0])
for i in range(n):
    for j in range(m):
        x = int(c[i][j-1]) + int(c[i][j+1-m]) + int(c[i-1][j]) + int(c[i+1-n][j])
        print(x, end=' ')
    print()
</pre>
</td></tr></table>
<pre>

-----------------------------------------------------------------------------------------------------------------

</pre>
Выведите таблицу размером n×n, заполненную числами от 1 до n 2 по спирали, выходящей из левого верхнего угла и закрученной по 
часовой стрелке:
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
n = int(input())
krug = 1
stroka = 0 # первая строка
stolb = 0
<b>table = [[0 for j in range(n)] for i in range(n)]</b> # создаём n*n таблицу
# вправо
while table[stroka][stolb] != n*n:
    # вправо
    for stolb in range(krug -1, n - krug + 1):
        if stolb == 0:
            table[0][0] = 1
        else:
            table[stroka][stolb] = table[stroka][stolb-1] + 1
    if table[stroka][stolb] == n*n:
        break
    # вниз
    for stroka in range(krug,n - krug + 1):
        table[stroka][stolb] = table[stroka-1][stolb] + 1
    if table[stroka][stolb] == n*n:
        break
    # влево
    for stolb in range(-krug - 1, -n + krug - 2, -1):
        table[stroka][stolb] = table[stroka][stolb+1] + 1
    if table[stroka][stolb] == n*n:
        break
    # вверх
    for stroka in range(-krug - 1, -n + krug - 1, -1):
        table[stroka][stolb] = table[stroka+1][stolb] + 1
    if table[stroka][stolb] == n*n:
        break
    krug += 1
for stroka in range(n):
    for stolb in range(n):
        print(table[stroka][stolb], end=' ')
    print()
</pre>
Вызвало затруднение, определение двухмерного массива, table[] или table[[]]  неправильно. Правильно получилось, когда 
использовал генератор для формирования таблицы.
</td><td>
Другое решение:
<pre>
n=int(input())
<b>t=[[0]*n for i in range (n)]</b>
i,j=0,0
for k in range(1, n*n+1):
  t[i][j]=k
  if k==n*n: break
  if i<=j+1 and i+j<n-1: j+=1
  elif i<j and i+j>=n-1: i+=1
  elif i>=j and i+j>n-1: j-=1
  elif i>j+1 and i+j<=n-1: i-=1
<b>for i in range(n):
    print(*t[i])</b>
</pre>
</td></tr></table>
Более понятнее выглядит способ задания таблицы.<br>
Также интересен способ вывода строк с помощью print(*t[i])
<pre>

-----------------------------------------------------------------------------------------------------------------

</pre>
После дрессировки черепашка научилась понимать и запоминать указания биологов следующего вида:<br>
север 10<br>
запад 20
юг 30<br>
восток 40<br>
где первое слово — это направление, в котором должна двигаться черепашка, а число после слова — это положительное расстояние в сантиметрах, которое должна пройти черепашка.
<p>
Но команды даются быстро, а черепашка ползёт медленно, и программисты догадались, что можно написать программу, которая 
определит, куда в итоге биологи приведут черепашку. Для этого программисты просят вас написать программу, которая выведет 
точку, в которой окажется черепашка после всех команд. Для простоты они решили считать, что движение начинается в точке (0, 
0), и движение на восток увеличивает первую координату, а на север — вторую.
<p>
Программе подаётся на вход число команд n, которые нужно выполнить черепашке, после чего n строк с самими командами. Вывести нужно два числа в одну строку: первую и вторую координату конечной точки черепашки. Все координаты целочисленные.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
x = 0
y = 0
command = [input() for _ in range(int(input()))]
for str in command:
    if str.split()[0] == 'запад':
        x = x - int(str.split()[1])
    elif str.split()[0] == 'восток':
        x += int(str.split()[1])
    elif str.split()[0] == 'юг':
        y = y - int(str.split()[1])
    else: # север +y
        y += int(str.split()[1])
print(x, y)
</pre>
</td><td>
<b>Другое:</b>
<pre>
dict = {'север': 0, 'юг': 0, 'запад': 0, 'восток': 0}

for _ in range(int(input())):
    key, value = input().split()
    dict[key] += int(value)

print(dict['восток'] - dict['запад'], dict['север'] - dict['юг'])
</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
<h3 align=center>Множество</h3>
<b>Преобразование списка в строку и назад в список с целью сделать список из отдельных слов<br>
<font color=blue>Множество из списка.</font></b><br>
<font color=brown>Методы цепочкой</font>
<p>
На вход программе первой строкой передаётся количество 
d известных нам слов, после чего на d строках указываются эти слова. Затем передаётся количество 
l строк текста для проверки, после чего l строк текста.
<p>
Выведите уникальные "ошибки" в произвольном порядке. Работу производите без учёта регистра.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
list1 = []
list2 = []
d = int(input())
for i in range(d):
    <font color=brown>list1.append(input().lower())</font>
l = int(input())
for i in range(l):
    list2.append(input().lower())
<b>'''print(list2) # список из фраз
list2 = ' '.join(list2) # преобразовали список в одну строку без запятых
list2 = list2.split()   # преобразовали строку назад в список но из отдельных слов
'''
list2 = ' '.join(list2).split()
<font color=blue>list2 = set(list2)</font></b>
print(list2)
for i in list2:
    if i not in list1:
        print(i)
</pre>
</td></tr></table>
<pre>list1 = list1.append(input())
<font color=red>AttributeError: 'NoneType' object has no attribute 'append'</font></pre>
Устранил ошибку, когда изменил выражение list1 = list1.append(input()) на list1.append(input())
Другое решение:<br>
<font color=green>Способ создания множества/списка из нескольких вводов одной строкой</font>
<pre>
# формируем множество известных слов на основании построчного ввода
<font color=green>dic = {input().lower() for _ in range(int(input()))}</font>

# заводим пустое множество для приема текста
wrd = set()

# т.к. текст построчно подается, а также в каждой строке несколько слов,
# то каждую строку превращаем во множество и добавляем в единое множество wrd
for _ in range(int(input())):
    wrd |= {i.lower() for i in input().split()}

# на вывод отправляем результат вычитания словарного множества dic
# из текстового множества wrd; впереди ставим *, чтобы раскрыть поэлементно
print(*(wrd-dic), sep="\n")</pre>
wrd |= {...} отвечает за добавление множества {...} в единое wrd (аналог метода update)<br>
заменил ненужные символы переменных на _
<pre>


----------------------------------------------------------------------------------------------------


</pre>
<br> <b>Множество<br>применение одновременно нескольких методов</b>
<br>
Программа должна считывать одну строку со стандартного ввода и выводить для каждого уникального слова в  этой строке число его повторений (без учёта регистра) в формате "слово количество".<br>
Порядок вывода слов может быть произвольным, каждое уникальное слово﻿ должно выводиться только один раз.
<pre>
<b>str = input().lower().split()</b>
for i in set(str):
    print(i, str.count(i)</pre>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
<h3 align=center><a name="dict">Словарь</h3>
Напишите программу, которая умеет шифровать и расшифровывать шифр подстановки. Программа принимает на вход две строки 
одинаковой длины, на первой строке записаны символы исходного алфавита, на второй строке — символы конечного алфавита, после 
чего идёт строка, которую нужно зашифровать переданным ключом, и ещё одна строка, которую нужно расшифровать.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
str_zashifr = []
str_shifr = []
shifr_rashifr = []
<b>alfavit = {key:0 for key in input()}</b>
shifr = input()
# сопоставляем ключу alfafit значение из shifr
i = 0
for key in alfavit.keys():
    alfavit[key] = shifr[i]
    i +=1
#print(alfavit)
str = input()
str_shifr = input()
for l in str:
    str_zashifr +=alfavit[l]
# print(*str_zashifr)
for l in str_zashifr:
    print(l, end='')
print()
# Перевернем словарь
<b>inv_alfavit = {v: k for k, v in alfavit.items()}</b>
for l in str_shifr:
    shifr_rashifr += inv_alfavit[l]  
for l in shifr_rashifr:
    print(l, end='')
print()</pre>
Создал словарь через input()<br>
Использовал переворачивание словаря.
</td><td>
Ещё решение:
<pre>
<b>a,b,c,d=input(),input(),input(),input()</b>
print(''.join(b[a.index(i)] for i in c))
print(''.join(a[b.index(i)] for i in d))
</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>

<b>Словарь</b><br>
Напишите программу, которая прочитает этот файл и подсчитает для каждого класса средний рост учащегося.
<p>
Файл состоит из набора строк, каждая из которых представляет собой три поля:<br>
Класс Фамилия Рост
<p>
Класс обозначается только числом. Буквенные модификаторы не используются. Номер класса может быть от 1 до 11 включительно. В 
фамилии нет пробелов, а в качестве роста используется натуральное число, но при подсчёте среднего требуется вычислить значение 
в виде вещественного числа.
<p>
Выводить информацию о среднем росте следует в порядке возрастания номера класса (для классов с первого по одиннадцатый). Если 
про какой-то класс нет информации, необходимо вывести напротив него прочерк.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
d = {key:[0, 0] for key in range(1,12)} # создали словарь
with open('/home/dmitriy/Python/mypython/dataset_3380_5.txt') as f:
    for line in f:
        #print(line.split()[0])
        # создадим словарь d, где ключ будет от 1 до 11, а значения сумма ростов и счетчик школьников
        # значение словаря список из двух чисел: d[key][0] и d[key][1]
        d[int(line.split()[0])] = [d[int(line.split()[0])][0] + int(line.split()[2]), d[int(line.split()[0])][1] + 1]
for key in d.keys():
    if d[key][1] == 0:
        print(key, '-')
    else:
        print(key, d[key][0] / d[key][1])</pre>
</td></tr></table>
<p>
<b>Другое решение, похоже на мое, но синтаксис грамотный</b>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
# Делаем словарь {1:[0,0], 2:[0,0]... 11:[0,0]}, где [0:0] = [сумма ростов : кол-во учеников]
tab = {i:[0,0] for i in range(1,12)} 

with open ('dataset_3380_5.txt') as inf:

	# Заполняем словарь:
	for i in inf:
		line = i.strip().split('\t')
		tab [ int(line[0]) ] [0] += int(line[2]) # tab[класс][0] += рост ученика
		tab [ int(line[0]) ] [1] += 1            # tab[класс][1] += 1 (счетчик учеников в классе)
	
	# Распечатка:
	for i in tab.keys():
		if tab[i][1] == 0:
			print (i, '-') # распечатываем класс, в котором нет учеников
		else:
			# считаем и распечатываем средний рост для i-го класса:
			print (i, ( tab[i][0] / tab[i][1] ))
</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая считывает строку с числом n, которое задаёт количество чисел, которые нужно считать. Далее 
считывает n строк с числами xi, по одному числу в каждой строке. Итого будет n+1 строк.
При считывании числа xi программа должна на отдельной строке вывести значение f(xi). Функция f(x) уже реализована и доступна 
для вызова. 
Функция вычисляется достаточно долго и зависит только от переданного аргумента x. Для того, чтобы уложиться в ограничение по времени, нужно избежать повторного вычисления значений.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
n = int(input())
l = []
d = {}
for i in range(n):
    l.append(int(input()))
'''Проходим каждый элемент списка
Вычисляем функцию и добавляем i и f в словарь
Если на следующем элементе уже вычисляли функцию (входит в словарь),
то выводим значение для текущего ключа из словаря'''
for i in l:
    if i not in d.keys(): # еще не выполняли функцию по этому числу
        d[i] = f(i)
        print(i, f(i))
    else:
        print(i, d[i])
</pre>
</td><td>        
Другое:
<pre>
a=[int(input()) for i in range(int(input()))]
b={x:f(x) for x in set(a)}
for i in a:
    print(b[i])</pre>
Ещё:
<pre>
d = {}
for _ in range(int(input())):
    x = int(input())
    if x not in d:
        d[x] = f(x)
    print(d[x])
</pre>         
</td></tr></table>
<pre>



====================================================================================================================



</pre>
<a name="graf"><h3 align=center>Задачи на графы</h3>
Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания 
пространств имен и добавление в них переменных.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
n = int(input())
d = {'None':'global'}

def get(ns, var):     #  get namespace var или get ns var
    result = []
    # print('d.values()=', d.values())
    
    # преобразуем список детей d.values() в список элементов result
    for i in d.values():
        if type(i) != list:
            result.append(i)
        else:
            for n in range(len(i)):
                result.append(i[n])
    #print('result=', result)
    
    '''ns может не входить в список ключей (родителей)'''
    if ns in d.keys():
        #print('ns=', ns, ' d[ns]=', d[ns])
        if var in d[ns]:   #  переменная var входит в список родителя ns
            # print('var=', var, 'входит в состав (', d[ns], ') родителя ns=', ns)
            return print(ns)
        elif ns in result: # var не входит в ns, но ns входит в список детей
            if ns == 'global':
                return print('None')
            # print(var, 'не входит в ', ns, ' но ', ns, ' входит в список детей ', result)
            # нужно найти ключ для ns (куда ns входит)
            for key in d.keys():
                if ns in d[key]: 
                    # print(ns, ' находится в ', key, ' снова выполняем функцию')
                    return get(key, var)
        else:
            #print(var, ' не входит в ', ns, ' и ', ns, ' никуда не входит')
            return print('None')  
    else:
        # print(ns, ' не входит в список родителей (d.keys()) ', d.keys())
        if ns in result:
            # print(ns, ' входит в список детей (result) ', result) 
            '''надо найти куда ns входит'''
            for key in d.keys():
                if ns in d[key]: 
                    # print(ns, ' находится в ', key, ' снова выполняем функцию')
                    return get(key, var)
        else:
            # print(ns, ' не входит в список детей result ', result)
            return print('None')
        
for _ in range(n):
    str = input().split()
    
    if str[0] == 'add':
        if str[1] in d.keys():
            if type(d[str[1]]) == list:
                lst = ','.join(d[str[1]]).split(',')
                lst.append(str[2])
                d[str[1]] = lst
            else:
                d[str[1]] = [d[str[1]], str[2]]
        else:
            d[str[1]] = str[2]       
    
    elif str[0] == 'create':
        if str[2] in d.keys():
            if type(d[str[2]]) == list:
                <b><font color=green>lst = ','.join(d[str[2]]).split(',')</font>
                <font color=blue>lst.append(str[1])</font></b>
                d[str[2]] = lst
                #print(d[str[2]])
            else:
                d[str[2]] = [d[str[2]], str[1]]
        else:
            d[str[2]] = str[1]       
            
    elif str[0] == 'get':
        get(str[1], str[2])
</pre>
</td><tr></table>      
3 дня писал этот код. Замотался с добавлением  элемента в значение словаря, так чтобы все элементы были в одном списке, а не 
списки в списке.
<ol>
 <li> <font color=green><b>Чтобы список разделить на отдельные элементы - строки и потом назад в список</b>, используется 
конструкция<br>
lst = ','.join(d[str[1]]).split(',')<br>
Здесь с помощью joint преобразуем список ['a, b'] в строку 'a, b' а с помощью split(',') преобразуем назад в список ['a', 
'b']</font>

 <li> <font color=blue>Если писать lst = lst.append(), то будет возвращаться None. Чтобы нормально метод работал, нужно писать 
lst.append()</font> Метод не работает со строкой.
</ol>
<p>
<b>Другое решение:</b><br>
<i>Пример решения. Будем храним две структуры:<br>
1) Кто чей родитель<br>
2) Переменные объявленные в данном пространстве имён
<p>
Если команда create -- создаём новое пространство имён (запоминаем родителя и создаём пустое множество переменных, объявленных 
в этом пространстве имен).
<p>
Если команда add -- то просто помещаем имя переменной в соответствующее множество.
<p>
Если команда get -- то проверяем наличие данной переменной в нашем пространстве имён, если не нашли: проверяем в родителе. 
Если не нашли в родителе, проверяем в родителе родителя и так далее. Как только нашли имя переменной -- вывели на экран 
пространство имён, в котором нашли. Если в процессе поиска мы имя не нашли (fst is None) -- выводим None на экран.</i>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
n = int(input())

parent = {"global": None}
vs = {"global": set()}

for _ in range(n):
    t, fst, snd = input().split()
    if t == "create":
        parent[fst] = snd
        vs[fst] = set()
    elif t == "add":
        <b>vs[fst].add(snd)</b>
    else:  # t == get
        while fst is not None:
            if snd in vs[fst]:
                break
            fst = parent[fst]
        print(fst)
</pre>
</td></tr></table>
<b>Элементы добавлять в значение словаря удобно с помощью метода add().</b>  <i>Это если значение является множеством.
</i>      
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
31.10.2024:<br>
Формат входных данных<br>
В первой строке входных данных содержится целое число n - число классов.
<p>
В следующих n строках содержится описание наследования классов. В i-й строке указано от каких классов наследуется i-й класс. 
Обратите внимание, что класс может ни от кого не наследоваться. Гарантируется, что класс не наследуется сам от себя (прямо или 
косвенно), что класс не наследуется явно от одного класса более одного раза.
<p>
В следующей строке содержится число q - количество запросов.
<p>
В следующих q строках содержится описание запросов в формате <имя класса 1> <имя класса 2>.
Имя класса – строка, состоящая из символов латинского алфавита, длины не более 50.
<p>
Формат выходных данных<br>
Для каждого запроса выведите в отдельной строке слово "Yes", если класс 1 является предком класса 2, и "No", если не является.
<pre>
Sample Input:
4
A
B : A
C : A
D : B C
4
A B
B D
C D
D A
Sample Output:
Yes
Yes
Yes
No
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td rowspan=2 valign=top>
<b>Мое решение:</b>
<pre>
d = {}

# Функция перебора родителей
def find(upclass, class2):
    for i in class2:
        if class1 in d[i]:
            res = True
            return res
        else:
            res = find(class1, d[i])
            if res == True:
                return res
            else:
                continue    
    return
    
# Цикл добавления классов в словарь
for _ in range(int(input())):
    s = input().split(' : ')
    if len(s) > 1:
        if s[0] in d.keys():
            <b>d[s[0]] = d[s[0]] + s[1].split()</b>
        else:
            d[s[0]] = s[1].split()
    else:
        d[s[0]] = []

# Отправка запросов    
for _ in range(int(input())):
    lst = input().split()
    if len(lst) == 1:
        print('Yes')
    else:
        class1 = lst[0]
        class2 = lst[1]
        if class1 == class2:
            print('Yes')
        elif class2 not in d.keys() or d[class2] == []:
            print('No')
        elif class1 in d[class2]: 
            print('Yes')
        else:
            res = find(class1, d[class2]) 
            if res == True:
                print('Yes')
            else:
                print('No')
</pre>
</td></tr></table>
<p>
<b>Добавление элемента в словарь:</b><br>
В строке <b>d[s[0]] = d[s[0]] + s[1].split()</b> я получаю новое значение словаря: в первоначальный список элементов d[s[0]] 
вкладываю s[1]<br>
Если s[1] добавлять сразу: <b>d[s[0]] = d[s[0]] + s[1]</b>, то получим ошибку:
<br><font color=red>TypeError: can only concatenate list (not "str") to list</font><br>
Ни append(), ни add, update join не приводили к нужному результату
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td rowspan=2 valign=top>
<b>Другое решение:</b>
<pre>
def test(parent, child):
    if parent == child or parent in base[child]:
        return 'Yes'
    for i in base[child]:
        if test(parent, i) == 'Yes':
            return 'Yes'
    return 'No'

base = {}
<font color=brown>for com in [input().split(' ') for i in range(int(input()))]:</font>
    base[com[0]] = com[2:len(com)]
for com in [input().split(' ') for i in range(int(input()))]:
    print (test(com[0], com[1]))
</pre>
</td></tr></table>
<p>
<font color=brown>я не могу понять почему вывод идет только после окончания ввода, а не после каждого ввода значений для
проверки...</font>
<p>
<i>Так происходит потому что в  этой части кода:
<pre>
for com in [input().split(' ') for i in range(int(input()))]:
     print (test(com[0], com[1]))</pre>
мы сначала с помощью генератора списков [input().split(' ') for i in range(int(input()))]<br>
создаём собственно список, вводя все данные, и только потом передаём этот список циклу for com in [сформированный 
список],который прогоняет это список через функцию test. Короче говоря, тут два цикла (первый в генераторе списков). В первом 
вводим данные, во втором - проверяем.</i>
<p>
Чтобы ответ, как Вы хотите, возвращался сразу после каждого ввода, последние  две строчки нужно было бы переписать как-то так:
<pre>
for i in range(int(input())):

    com = input().split(' ')

    print (test(com[0], com[1]))</pre>
https://all-python.ru/osnovy/generator-spiska.html

<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td rowspan=2 valign=top>
<b>Другое решение:</b>
<pre>
n = int(input())

parents = {}
for _ in range(n):
    a = input().split()
    <b>parents[a[0]] = [] if len(a) == 1 else a[2:]</b>

def is_parent(child, parent):
    return child == parent or any(map(lambda p: is_parent(p, parent), parents[child]))

q = int(input())
for _ in range(q):
    a, b = input().split()
    print("Yes" if is_parent(b, a) else "No")
</pre>
</td></tr></table>
<p>
1. Здесь в <b>parents[a[0]] = [] if len(a) == 1 else a[2:]</b><br>
идет перезапись в значение словаря, но не добавление, как реализовано у меня.
<p>
2. <b>a, b = input().split()</b> вызовет ошибку:
<font color=red>ValueError: not enough values to unpack (expected 2, got 1)</font><br>
если ввести запрос из одного элемента, типа A.
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Еще одна задачка на так называемые графы.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
n = int(input())
d = {}
exceptions = []

def find(ns):
    if ns in d.keys():
        for m in d[ns]:
            if m in exceptions[0 : i]:
                return True
            else:
                if find(m) == True:
                    return True
        return False
    else:
        return False     
        
for _ in range(n):
    s = input().split()
    if len(s) > 1:
        d[s[0]] = s[2:]
    else:
        d[s[0]] = ''
       

for i in range(int(input())):
    s = input()
    if s not in exceptions:
        exceptions.append(s)


for i in range(1, len(exceptions)):
    if exceptions[i] in exceptions[0 : i] or find(exceptions[i]) == True:
        print('Исключить', exceptions[i])</pre>
</td><td>
<pre>
parents = {}
for _ in range(int(input())):
    a = input().split()
    parents[a[0]] = [] if len(a) == 1 else a[2:]

def is_parent(child, parent):
    if child == parent: return True
    for p in parents[child]:
        if is_parent(p, parent ): return True
    return False

exceptions = []
for _ in range(int(input())):
    a = input().strip()
    for i in exceptions:
        if is_parent(a,i):
            print(a)
            break
    exceptions.append(a)
</pre>
</td>
</tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Вам дано описание наследования классов в формате JSON.
Описание представляет из себя массив JSON-объектов, которые соответствуют классам. У каждого JSON-объекта есть поле name, 
которое содержит имя класса, и поле parents, которое содержит список имен прямых предков.
<br>Пример: [{"name": "A", "parents": []}, {"name": "B", "parents": ["A", "C"]}, {"name": "C", "parents": ["A"]}]
<p>
Гарантируется, что никакой класс не наследуется от себя явно или косвенно, и что никакой класс не наследуется явно от одного 
класса более одного раза.<br>
Для каждого класса вычислите предком скольких классов он является и выведите эту информацию в следующем формате.
<pre>
&lt;имя класса&gt; : &lt;количество потомков&gt;
</pre>
Выводить классы следует в лексикографическом порядке.
<pre>
Sample Input:

[{"name": "A", "parents": []}, {"name": "B", "parents": ["A", "C"]}, {"name": "C", "parents": ["A"]}]
Sample Output:

A : 3
B : 1
C : 2
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<b>Мое решение:</b>
<pre>
import json
 
json_stroka = json.loads(input())
st = set()
d = {}

def find_child(parent, grandchild):
    for line in json_stroka: # вытаскиваем строку из json
        # вытаскиваем из этой строки некоторого родителя   
        <font color=red>for some_parent in line['parents']:</font>
            # если сын, внук правнук является родителем
            <font color=green><b>if grandchild in some_parent.split():</b></font>
                <b>d[parent] = d[parent] + ' ' + line['name']</b>
          # теперь его проверяем является ли он родителем
                find_child(parent, line['name'])
     
    return

for i in json_stroka:
    st.add(i['name'])
    for _ in i['parents']:
        st.add(_)
for i in st:
    d[i] = <font color=red>i</font>
    
for parent in d.keys():
    find_child(parent, parent)
    
for key, val in sorted(d.items()): 
    print(key, ':', len(set(val.split())))
</pre>
</td><td valign=top>
<b>Другое:</b>
<pre>
import json

scheme = json.loads(input())
# scheme = [{"A": []}, {"B": ["A"]}, {"C": ["A"]}, {"D": ["B", "C"]}, {"V": ["D"]}]

parent_and_children = {item['name']: [] for item in scheme}
# {'A': [], 'B': [], 'C': [], 'D': [], 'V': []}

for item in scheme:
    for parent in parent_and_children:
        if parent in item['parents']:
            <b>parent_and_children[parent].append(item['name'])</b>
# {'A': ['B', 'C'], 'B': ['D'], 'C': ['D'], 'D': ['V'], 'V': []}
# если класс есть в parents - его прямые дети добавляются в словарь

for item in parent_and_children:
    parent_and_children[item] = set(parent_and_children[item])
# {'A': {'C', 'B'}, 'B': {'D'}, 'C': {'D'}, 'D': {'V'}, 'V': set()}
# словари с детьми преобразуются в множества


# https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    for upcoming in graph[start] - visited:
        dfs(graph, upcoming, visited)
    return visited


# parent_and_children = {'A': {'C', 'B'}, 'B': {'D'}, 'C': {'D'}, 'D': {'V'}, 'V': set()}
# dfs(parent_and_children, 'A') = {'A', 'D', 'C', 'V', 'B'}
for item in sorted(parent_and_children.keys()):
    print(item, ':', len(dfs(parent_and_children, item)))
</pre>
</td></tr></table>
1. Замотался добавлять элемент в значение словаря:
<pre>
d[parent] = d[parent].append(line['name'])
AttributeError: 'str' object has no attribute 'append'

d[parent] = d[parent] + line['name'].split()
TypeError: can only concatenate str (not "list") to str

d[parent].append(line['name'].split())
AttributeError: 'str' object has no attribute 'append'

d[parent] = list(d[parent]).append(line['name'].split())
TypeError: 'NoneType' object is not iterable

list(d[parent]).append(line['name'].split())
RecursionError: maximum recursion depth exceeded while calling a Python object

 d[parent] = list(d[parent]) + line['name']
TypeError: can only concatenate list (not "str") to list

d[parent] = d[parent].split() + line['name'].split()
AttributeError: 'list' object has no attribute 'split'
</pre>
В конце концов просто стал добавлять элемент как строку к строке через пробел: d[parent] = d[parent] + ' ' + line['name']<br>
В результате значение словаря имеет тип не список, как раньше, а строка.
<p>
Думаю если бы блок
<pre>
for i in st:
    d[i] = <font color=red>i</font></pre>
записал как:
<pre>
for i in st:
    d[i] = <b>[i]</b></pre>
то проблем с append не было.
<p>
Далее возникла 2 проблема:
<p>
2. d[parent] = d[parent] + ' ' + line['name'] # бесконечное добавление<br>
Проблема возникла из-за того, что в <b>if grandchild in some_parent:</b> бывают случаи, например: grandchild = 'E' и 
some_parent = 'ED' и результат True, хотя на самом деле это разные классы. Решил проблему, просто преобразовав some_parent в 
список: <b>if grandchild in some_parent.split():</b>
<p>
3. <font color=red>for some_parent in line['parents']:</font> Зря я вытаскивал отдельно родителя, можно сразу было делать 
<b>if grandchild in line[parents]:</b> как сделано в другом решении.
<pre>



=========================================================================================================================




</pre>
<h3 align=center><a name="fun">Функции</h3>
Напишите функцию f(x), которая возвращает значение следующей функции, определённой на всей числовой прямой:
<p>
<img src="./images/python_base4.png">
<pre>
def f(x):
    if x <= -2:
        return 1 - (x + 2) ** 2
    elif -2 < x <= 2:
        return -x / 2
    else:
        return (x - 2) ** 2 + 1
</pre>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
Напишите функцию modify_list(l), которая принимает на вход список целых чисел, удаляет из него все нечётные значения, а чётные 
нацело делит на два. Функция не должна ничего возвращать, требуется только изменение переданного списка.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<pre>
def modify_list(lst):
    l = len(lst)
    for i in range(l-1, -1, -1):
        if lst[i] % 2 == 0:
            lst[i] = lst[i] // 2
        else:
            del lst[i]
</pre>
</td><td valign=top>
Другое решение:
<pre>def modify_list(l):
    l[:] = [i//2 for i in l if not i % 2]
</pre>
</td></tr></table>
<p>
<i>логика такая, так как список l в памяти уже есть и его нужно перезаписать, то есть изменить сам объект списка, поэтому тут 
я делаю срез всего списка от начала до конца и меняю сам объект. если написать просто l = [i//2 for i in l if not i % 2] в 
данном случае будет создан новый объект, под него выделена память и переменная l будет уже ссылаться на него, а старая ссылка 
на исходный объект списка сотрется. т.е происходит не изменение объекта, а перенаправление ссылки у переменной l. я не 
проверял может и такой вариант сработает но подумал что он учтет занимаемую память и выдаст ошибку, так как была задача одна и 
там подобный подход выдавал ошибку, а сделал l[:] (изменил сам весь объект) все заработало.
<p>
дело в том что for и while полезны для больших конструкций, а генератор списков [ for ] введен для того что бы писать 
коротенькие вещи в одну строку, что б ради одной двух операций внутри цикла не писать по 3-4 строчки кода с обычным циклом.
<p>
i%2 выдает либо 0 либо 1. или иначе False True. not i - переворачивает выданный результат. Т.е. в данной ситуации мы должны 
выполнять действие (i//2) если условие if даст True, но четное число при делении даст остаток 0 (6%2=0 - False) поэтому нам 
необходимо перевернуть результат (not False - True)</i>
<pre>


-----------------------------------------------------------------------------------------------------------------


</pre>
Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое 
маленькое целое число y, такое что:
<br>y больше или равно x<br>
y делится нацело на 5
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
def  closest_mod_5(x = int(input())):
    for num in range(x, x*5 + 1):
        if num % 5 == 0:
            return num
print(closest_mod_5())
</pre>
</td><td valign=top>
Другое:
<pre>
def closest_mod_5(x):
    while x % 5 != 0:
        x += 1
    return x
</pre>
</td></tr></table>
<pre>



=========================================================================================================================



</pre>
<h3 align=center><a name="lambda">lambda-функции</h3>
Лямбда функции предоставляют нам удобный способ создать функцию «прямо на месте».<br>
Но иногда, когда нужно создавать много однотипных лямбда функций, еще удобнее будет создать функцию, которая будет их 
генерировать.
<p>
Реализуйте функцию mod_checker(x, mod=0), которая будет генерировать лямбда функцию от одного аргумента y, которая будет 
возвращать True, если остаток от деления y на x равен mod, и False иначе.
<pre>
def mod_checker(x, mod=0):
    return lambda y: y % x == mod
</pre>
<pre>



========================================================================================================================



</pre>
<h3 align=center><a name="file">Файл, методы работы с файлами</h3>
Напишите программу, которая считывает из файла строку, соответствующую тексту, сжатому с помощью кодирования повторов, и
производит обратную операцию, получая исходный текст.
<pre>
with open('/home/dmitriy/Python/mypython/dataset_3363_2 (1).txt') as inf:
  for line in inf:
      line = line.strip()
      # print(line)
  simvol = ''
  num = ''
  str = ''
  for i in range(len(line)):
      ''' если символ является цифрой, тогда запоминаем ее в переменной num строкового типа
      если следующий символ снова цифра, тогда добавляем ее в num
      если же буква, тогда переменную символа simvol умножаем на int(num) и записывает эту строку в новый файл new_file.txt'''
      if '0' <= line[i] <= '9': # цифра
          num = num + line[i]
          if i == len(line) - 1: # последний символ
              str = str + simvol * int(num)
      else:  # буква
          # умножаем предыдущую букву на num и обнуляем num
          # print('simvol=',line[i], 'type(num)=',type(num),'num=',num)
          if i != 0:
              str = str + simvol * int(num)
          # print('stroka=', str)
          simvol = line[i]
          num = '0'
inf.close()
with open('/home/dmitriy/Python/mypython/dataset_3363_2_modify.txt', 'w') as ouf:
    ouf.write(str)</pre>
<b>Не моё:</b>
<pre>
with open('dataset_3363_2.txt', 'r') as f:
    s = f.readline().strip()
i = 0
while i < len(s):
    j = i + 1
    while j < len(s) and s[j].isdigit():
        j += 1
    print(s[i] * int(s[i+1:j]), end='')
    i = j</pre>
Первый символ - гарантированно буква.
Перебираем все последующие, пока они цифровые или пока не достигнут конец строки.<br>
После внутреннего цикла j либо указывает на следующую букву, либо на конец строки. В обоих случаях между s[i] и s[j] - цифры,
 составляющие нужное нам число повторов символа s[i].<br>
Печатаем символ нужное число раз, присваиваем i индекс следующей буквы для новой итерации цикла.    
<p>
<li> <b>Файл</b><br>
Напишите программу, которая считывает текст из файла (в файле может быть больше одной строки) и выводит самое частое слово в 
этом тексте и через пробел то, сколько раз оно встретилось. Если таких слов несколько, вывести лексикографически первое (можно 
использовать оператор < для строк).
<pre>
word = ''
d = {} 
maksimum = 0
spisok_max = {}
maks_word = ''
with open('/home/dmitriy/Python/mypython/dataset_3363_3.txt') as f:
  for line in f:
      line.strip() # удаляем служебные символы
      #print(line)
      for word in line.split():
          # заполняем словарь
          if word in d.keys():
              d[word] += 1
          else:
              d[word] =1 
# ищем максимальное количество слов
for key, value in d.items():
    if value > maksimum:
        spisok_max = {key:value}
        maksimum = value
    elif value == maksimum:
       spisok_max[key] = value
for key in spisok_max.keys():
    if key > maks_word:
        maks_word = key
print(maks_word, spisok_max[maks_word])
# Со строкой метод append не работает, чтобы добавить строку, используем оператор приращения.
# TypeError: can only concatenate str (not "list") to str: 
# TypeError: unsupported operand type(s) for +=: 'set' and 'list'
# for i in stroka переберет строку по буквам, чтобы по словам нужно использовать: for i in stroka.split()
</pre>
Ещё:
<pre>
<b>with open('dataset_3363_3.txt') as inf, open('MostPopularWord.txt','w') as ouf:
    maxc = 0
    s = inf.read().lower().strip().split()</b>
    s.sort()
    for word in s:
        counter = s.count(word)
        if counter > maxc:
            maxc = counter
            result_word = word
    ouf.write(result_word +' ' + str(maxc))</pre>
Без словаря, сразу читаем файл и сортируем список слов, чтобы потом первое найденное было лексиграфически впереди.
<br>
<b>Оказывается конструкция with является циклом.</b>
<pre>


--------------------------------------------------------------------------------------------------------------------


</pre>
<b>Чтение файла, импорт модуля, конструкция try/except/else</b>
<p>
Алиса зашифровала свою информацию с помощью библиотеки simple-crypt.<br>
Она представила информацию в виде строки, и затем записала в бинарный файл результат работы метода simplecrypt.encrypt.
Вам необходимо установить библиотеку simple-crypt, и с помощью метода simplecrypt.decrypt узнать, какой из паролей служит 
ключом для расшифровки файла с интересной информацией. Ответом для данной задачи служит расшифрованная интересная информация 
Алисы.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from simplecrypt import decrypt

with open('/home/dmitriy/Python/mypython/encrypted.bin', "rb") as inp:
    encrypted = inp.read()
    #print(encrypted)
with open('/home/dmitriy/Python/mypython/passwords.txt') as passw:
    for lst in passw:
        print(lst)
        try:
            s = decrypt(lst.strip(), encrypted)
        except Exception as e:
            print(f'Произошла ошибка: {e}')
            continue
        else:
            print('shifr=', s)</pre>
</td><td>
<pre>
import simplecrypt

encrypted = open("encrypted.bin", "rb").read()
passwords = open("passwords.txt").readlines()

for p in passwords:
    p = p.strip()
    try:
        s = simplecrypt.decrypt(p, encrypted)
    except simplecrypt.DecryptionException:
        continue

    print(s.decode("utf-8"))﻿</pre>
</td></tr></table>
<p>
Еще:
<pre>
import urllib
from simplecrypt import decrypt

ciphertext = <b>urllib.urlopen('https://stepik.org/media/attachments/lesson/24466/encrypted.bin').read()</b>
passwords = urllib.urlopen('https://stepik.org/media/attachments/lesson/24466/passwords.txt')

for password in passwords:
    try:
        plaintext = decrypt(password.strip(), ciphertext)
    except:
        pass
    else:
        print(plaintext)</pre>
<p>
1. Здесь в случае возникновения исключения (ошибка программы просто из-за плохого пароля) в блоке try выполнение программы 
переходит в блок except, там continue, то есть выполняется следующий итератор цикла. В случае, если пароль хороший, то 
выполняется блок else.
<p>
2. Функция strip() без аргументов удаляет в начале и в конце строки пробел. На этом примере, когда смотрел пароли, пробелы не 
видел, но был невидимый пернос строки. Возможно его также удаляет.
<p>
===========================================================================================
<p>
Вам дается текстовый файл, содержащий некоторое количество непустых строк.<br>
На основе него сгенерируйте новый текстовый файл, содержащий те же строки в обратном порядке.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
with open('/home/dmitriy/Python/mypython/1.txt') as f1:
    lst = f1.readlines() # вывели файл в список
    with open('/home/dmitriy/Python/mypython/2.txt', 'w') as f2:
        for i in range(-1, -len(lst) -1, -1):
            f2.write(lst[i].rstrip('\n') + "\n")
</pre>
</td></tr></table>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Не моё:
<pre>
with open('dataset_24465_4.txt', 'r') as fr, open('dataset_24465_4_w.txt', 'w') as fw:
    fw.writelines(fr.readlines()[::-1])</pre>
Ещё:
<pre>
lines = open("input.txt").readlines()
with open("output.txt", "w") as out:
    out.writelines(reversed(lines))
</pre>
</td></tr></table>
<pre>



========================================================================================================================



</pre>
<h3 align=center>Файл, методы, циклы, списки</h3>
19:50 - 21:30 (1 час и 40 минут)<br>
Имеется файл с данными по успеваемости абитуриентов. Он представляет из себя набор строк, где в каждой строке записана следующ
ая информация: <br>
Фамилия;Оценка_по_математике;Оценка_по_физике;Оценка_по_русскому_языку
<p>
Поля внутри строки разделены точкой с запятой, оценки — целые числа.
<p>
Напишите программу, которая считывает исходный файл с подобной структурой и для каждого абитуриента записывает его среднюю оце
нку по трём предметам на отдельной строке, соответствующей этому абитуриенту, в файл с ответом.
<p>
Также вычислите средние баллы по математике, физике и русскому языку по всем абитуриентам и добавьте полученные значения, разд
елённые пробелом, последней строкой в файл с ответом.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
d = {} # ключ - фамилия, значение - список из оценок
s = ''
num = 0
familia = []
ball = []
mathem = 0
phizik = 0
rus = 0
with open('/home/dmitriy/Python/mypython/dataset_3363_4.txt') as f:
    s = f.read().strip().split()
    for l in s:
        l = l.split(';')
        # print(l)
        for i in range(len(l)):
            if i % 4 == 0:
                familia.append(l[i])
                num = 0
            elif (i - 3) % 4 == 0:
                ball.append((num + int(l[i])) / 3)
                rus = rus + int(l[i])
            else:
                num = num + int(l[i])
                if (i - 1) % 4 == 0:
                    mathem = mathem + int(l[i])
                elif (i - 2) % 4 == 0:
                    phizik = phizik + int(l[i])
for i in ball:
    print(i)            
print(mathem/len(familia), phizik/len(familia), rus/len(familia))
</pre>
</td><td valign=top>
<b>Ещё:</b>
<pre>
koll, a1, b1, c1 = 0, 0, 0, 0
with open('dataset_3363_4.txt', 'r') as inf:
    for line in inf:
        line = line.strip().split(';')
        a, b, c = int(line[1]), int(line[2]), int(line[3])
        print((a+b+c)/3)
        koll += 1
        a1 += a
        b1 += b
        c1 += c
print((a1/koll), (b1/koll), (c1/koll))
</pre>
</td></tr></table>
<pre>



===========================================================================================================================



</pre>
<h3 align=center><a name="modul">Модули</h3>
Напишите программу, которая подключает модуль math и, используя значение числа π из этого модуля, находит для переданного ей на
стандартный ввод радиуса круга периметр этого круга и выводит его на стандартный вывод.
<pre>
from math import pi
print(float(input()) * pi * 2)
</pre>
<pre>


-----------------------------------------------------------------------------------------------------------------------


</pre>
Напишите программу, которая запускается из консоли и печатает значения всех переданных аргументов на экран (имя скрипта 
выводить не нужно). Не изменяйте порядок аргументов при выводе.
<p>
Для доступа к аргументам командной строки программы подключите модуль sys и используйте переменную argv из этого модуля.
<pre>
import sys
print(*sys.argv[1::])</pre>
Метод sys.argv выдаст список, где первый элемент - это имя вызвавшей программы, а следующие - это аргументы программы. Посколь
ку нам не нужно имя программы, то к списку применяем срез.
<br><img src="./images/python_example.png"><br>
Первую и вторую команду применили без среза.<br>
3 команду без звездочки внутри print()
<pre>


--------------------------------------------------------------------------------------------------------------------------


</pre>
Скачайте файл. В нём указан адрес другого файла, который нужно скачать с использованием модуля requests и посчитать число 
строк в нём.
<p>
Используйте функцию get для получения файла.
<p>
После получения файла вы можете проверить результат, обратившись к полю text. Если результат работы скрипта не принимается, 
проверьте поле url на правильность. Для подсчёта количества строк разбейте текст с помощью метода splitlines.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
import requests
# Прочитаем url со скачанного файла
with open('/home/dmitriy/Python/mypython/dataset_3378_2.txt') as f:
    s = f.read()
    # print(s)  #  адрес страницы, которую нужно скачать
r = requests.get(s)  # простой get-запрос
#print('Ответ сервера:', '\n', r.text.splitlines()) # вывод ответа от сервера
#print('Ответ сервера:', '\n', r.text)
for i in r.text.splitlines():
    print(i)
print('количество строк=', len(r.text.splitlines()))
</pre>
</td></tr></table>
<font color=red>SyntaxError: unexpected character after line continuation character</font><br>
Данная ошибка означает, что где-то болтается '\'  вне строки. После того, как в print('Ответ сервера:', <font color=red>\n
</font>, r.text) <b>\n</b> заключил в кавычки, ошибка исчезла.
<p>
r = requests.get(s).splitline()  # простой get-запрос<br>
<font color=red>AttributeError: 'Response' object has no attribute 'splitline'</font><br>
Ошибку устранил, когда метод splitline() применил к объекту r.text, а не в команде <b>r = requests.get(s).splitline()</b>, 
которая вызывала ошибку.
<pre>


----------------------------------------------------------------------------------------------------------------------


</pre>
Имеется набор файлов, каждый из которых, кроме последнего, содержит имя следующего файла.
Первое слово в тексте последнего файла: "We".
<p>
Скачайте предложенный файл. В нём содержится ссылка на первый файл из этого набора.
<p>
Все файлы располагаются в каталоге по адресу:
https://stepik.org/media/attachments/course67/3.6.3/
<p>
Загрузите содержимое ﻿последнего файла из набора, как ответ на это задание.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
url = 'https://stepik.org/media/attachments/course67/3.6.3/'
import requests
with open('/home/dmitriy/Python/mypython/dataset_3378_3.txt') as f:
    u = f.read()
    # u = u[len(url):]
    #print('Адрес 1 файла из набора:', url+u)
    print('Адрес 1 файла из набора:', u)
    # u = requests.get(url + u)
    u = requests.get(u)
k = 0 # счетчик файлов
while True:
    if u.text.split()[0] == 'We':
        break
    u = requests.get(url + u.text)
    print('k=', k, 'адрес следующего файла:', url+u.text)
    k +=1
print('Последний файл:\n\n', u.text)
</pre>
</td></tr></table>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Не моё:
<pre>
import requests
url, name = 'https://stepik.org/media/attachments/course67/3.6.3/', '699991.txt'
while <b>name[:2] != 'We':</b>
    name = requests.get(url + name).text
print(name)</pre>
Еще:
<pre>
import requests
with open('dataset_3378_3.txt') as txt:
    a = txt.readline().strip()
print(a)
a = str(requests.get(a).text)
b = 'https://stepik.org/media/attachments/course67/3.6.3/'
while 'we' not in a:
    print(a)
    <b>a = requests.get(b + a).text</b>
print(a)
</pre>
</td></tr></table>
<font color=red>u = requests.get(str(url+u))<br>
TypeError: can only concatenate str (not "Response") to str</font><br>
Так и не смог решить проблему, извращенно сначало первый из набора отдельно вытащил url из файла и только к следующим через 
цикл посылал запрос. Похоже надо было так: <b>u = requests.get(url + u).text</b>
<pre>


-------------------------------------------------------------------------------------------------------------------------


</pre>
В первой строке дано три числа, соответствующие некоторой дате date -- год, месяц и день.<br>
Во второй строке дано одно число days -- число дней.<br>
Вычислите и выведите год, месяц и день даты, которая наступит, когда с момента исходной даты date пройдет число дней, равное 
days.<br>
Примечание: Для решения этой задачи используйте стандартный модуль datetime.
Вам будут полезны класс datetime.date для хранения даты и класс datetime.timedelta﻿ для прибавления дней к дате.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td rowspan=3 valign=top>
Моё:
<pre>
from datetime import datetime as dt, timedelta

first_date=dt.strptime(input(), '%Y %m %d')
end_date = first_date + timedelta(int(input()))
end_date1 = end_date.strftime('%Y %m %d')
date = end_date1.split()
for i in date:
    print(int(i), end=' ')</pre>
</td>
<td>
Другое:
<pre>
import datetime
inp = datetime.datetime.strptime(input(), "%Y %m %d")
inp += datetime.timedelta(days=int(input())) 
print(f'{inp.year} {inp.month} {inp.day}')

</pre>
</td></tr>
<tr><td>
Другое:
<pre>
import datetime
y, m, d = map(int, input().split())
days = int(input())
current = datetime.date(year=y, month=m, day=d)
current += datetime.timedelta(days=days)
print("{} {} {}".format(current.year, current.month, current.day))</pre>
</td></tr>
<tr>
<td>
Ещё:
<pre>
import datetime
<b>(y,m,d) = [int(n) for n in input().split()]</b>
d = datetime.date(y, m, d)+ datetime.timedelta(int(input()))
print(d.year, d.month, d.day)</pre>
</td></tr></table>
<p>
1. Скажите, пожалуйста, почему datetime.datetime...? А если datetime.strptime, то "datetime не имеет атрибута strptime"
<br>
Потому что метод класса datetime, который преобразует строку в datetime, есть операция datetime.strptime(date_string, format). 
То есть, чтобы корректно написать операцию переформатирования введенной строки в формат даты, мы сначала прописываем класс 
datetime, затем через точку метод datetime.strptime().. в скобках - соответствующие аргументы
<pre>


----------------------------------------------------------------------------------------------------------------------



</pre>
<a name='os'><b>Модуль os</b><br>
Вам дана в архиве (ссылка) файловая структура, состоящая из директорий и файлов.
<br>Вам необходимо распаковать этот архив, и затем найти в данной файловой структуре все директории, в которых есть хотя бы 
один файл с расширением ".py". 
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
Моё:
<pre>
from os import getcwd, walk, chdir

chdir('/home/dmitriy/Python/mypython/main')
lst = set()
for root, directories, filenames in walk(getcwd()):
    for filename in filenames:
        if filename.endswith('.py'):
            lst.add(root[30::])
for x in sorted(lst):
    print(x)</pre>
</td>
<td valign=top>
Другое:
<pre>
import os

for cur_dir, subdirs, files in os.walk("main"):
    for file in files:
        if file.endswith(".py"):
            print(cur_dir)
            break
</pre>
</td></tr></table>
<p>
1. os.walk() идет по директориям в алфавитном порядке. За счет этого можно не сортировать итоговый список.<br>
2. chdir - переход на нужную папку<br>
getcwd() - текущая папка<br>
walk(dir) - выдает генератор - итератор, где его элемент состоит из строки (каталог), списка входящих каталогов и еще один 
список из файлов. <br>
3. lst.add(root[30::]) - срез, чтобы обрезать лишний путь к каталогу.
<pre>



=======================================================================================================================



</pre>
<h3 align=center><a name="stdin">Модуль stdin</h3>
<b>stdin api</b>
<p>
В этой задаче вам необходимо воспользоваться API сайта numbersapi.com<br>
Вам дается набор чисел. Для каждого из чисел необходимо узнать, существует ли интересный математический факт об этом числе.<br>
Для каждого числа выведите Interesting, если для числа существует интересный факт, и Boring иначе.<br>
Выводите информацию об интересности чисел в таком же порядке, в каком следуют числа во входном файле.
<p>
Пример запроса к интересному числу:<br>
http://numbersapi.com/31/math?json=true<br>
Пример запроса к скучному числу:<br>
http://numbersapi.com/999/math?json=true
<pre>
Пример входного файла:
31
999
1024
502
﻿Пример выходного файла:
Interesting
Boring
Interesting
Boring
</pre>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
Моё:
<pre>
import json
from sys import stdin
import requests


number = int()
for number in stdin:
    url = 'http://numbersapi.com/'+number.strip()+'/math?json=true'
    r = requests.get(url).text
    json_stroka = json.loads(r)
    if json_stroka['found'] == True:
        print('Interesting')
    else:
        print('Boring')
</pre>
</td><td valign=top>
Другое:
<pre>
import requests
import json

def is_interesting(x):
    url = "http://numbersapi.com/"; + str(x) + "/math?json=true"
    resp = requests.get(url).text
    js = json.loads(resp)
    return js["found"]

with open("input.txt") as fi:
    for line in fi:
        print("Interesting" if is_interesting(line.rstrip()) else "Boring")
</pre>
</td></tr></table>
Я не понял задание и вводил числа через stdin, а не из файла, как у других.<br>
Получил проблему, что после ввода чисел столбцом вывод начинается сразу автоматом и со строки последнего числа и не выводит 
результат для последнего числа, нажимаю enter, чтобы вывести его:
<p>
<img src="./images/python_example1.png">
<pre>



=======================================================================================================================



</pre>
<h3 align=center><a name="obiekt">Объекты</h3>
Реализуйте программу, которая будет вычислять количество различных объектов в списке.
Два объекта a и b считаются различными, если a is b равно False.
<p>
Вашей программе доступна переменная с названием objects, которая ссылается на список, содержащий не более 100 объектов. 
Выведите количество различных объектов в этом списке.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
objects = [1, 2, 1, 5, True, False, True, 'false', [], [1,2], [1,2]]
ans = 1
unik = {id(objects[0])}
massiv = [objects[0]]
for obj in objects: # доступная переменная objects
    if id(obj) in unik:
        continue
    else:
        unik.add(id(obj))
        massiv.append(obj)
        ans += 1

print('Список уникальных объектов = ', massiv)
print('Список ID уникальных объектов = ', unik)
print('Количество уникальных объектов = ', ans)</pre>
Вывод:
<pre>
[1, 2, 5, True, False, 'false', [], [1, 2], [1, 2]]
{9776672, 9461728, 9776704, 9464160, 9776800, 139738779320768, 139738778605952, 139738778694720}
</pre>
Дебильное решение, не учел, что свойство множества принимать только уникальное значение.
</td><td>
Грамотное другое решение:
<pre>
s=set()
for obj in objects:
    s.add(id(obj))
print(len(s))
</pre>
</td></tr></table>
<pre>



===================================================================================================================



</pre>
<h3 align=center><a name="oop">ООП</h3>
Реализуйте класс MoneyBox, для работы с виртуальной копилкой.
<p>
Каждая копилка имеет ограниченную вместимость, которая выражается целым числом – количеством монет, которые можно положить в 
копилку. Класс должен поддерживать информацию о количестве монет в копилке, предоставлять возможность добавлять монеты в 
копилку и узнавать, можно ли добавить в копилку ещё какое-то количество монет, не превышая ее вместимость.
<p>
При создании копилки, число монет в ней равно 0.
Примечание: метод add(self, v) будет вызываться только если can_add(self, v) – True﻿.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
class MoneyBox:
    def __init__(self, capacity):
        self.capacity = capacity
        
    def can_add(self, v):
        # True, если можно добавить v монет, False иначе
        if self.capacity >= v:
            return True
        else:
            return False

    def add(self, v):
        # положить v монет в копилку
        if self.can_add(v):
            self.capacity -= v
</pre>
</td></tr></table>
Блок:
<pre>
if self.capacity >= v:
            return True
        else:
            return False
</pre>
можно заменить одной строкой: <b>return self.capacity >= v</b>
<pre>


------------------------------------------------------------------------------------------------------------------------


</pre>
Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой 
последовательности, затем сумму второй пятерки, и т. д.
<p>
Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. Например, 
сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.
<p>
Реализуйте класс Buffer, который будет накапливать в себе элементы последовательности и выводить сумму пятерок 
последовательных элементов по мере их накопления.
<p>
Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, 
т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.
<p>
Обратите внимание, что во время выполнения метода add выводить сумму пятерок может потребоваться несколько раз до тех пор, 
пока в буфере не останется менее пяти элементов.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<b>Моё:</b>
<pre>
class Buffer:
    def __init__(self):
        self.lst = []
               
    def add(self, *a):
        for i in a:  # выводим аргументы в список
            self.lst.append(i)
        # print('self.lst=', self.lst)
        if len(self.lst) <5:
            return
        else:
            while len(self.lst) >= 5:
                print(sum(self.lst[:5:1]))
                del self.lst[0:5]
                
    def get_current_part(self):
        return self.lst</pre>
</td><td>
<b>Грамотное решение:</b>
<pre>
class Buffer:
    def __init__(self):
        self.part = []

    def add(self, *a):
        for i in a:
            self.part.append(i)
            if len(self.part) == 5:
                print(sum(self.part))
                self.part.clear()

    def get_current_part(self):
        return self.part
</pre>
</td></tr></table>
<p>
Сразу считал 5 элементов, суммировал, выводил и удалял их, а не как я, запоминал весь ввод и потом считывал первые 5 элементов.
</td></tr></table>
<pre>


----------------------------------------------------------------------------------------------


</pre>
<b>Задача:</b> Реализуйте структуру данных, представляющую собой расширенную структуру стек. Необходимо поддерживать 
добавление элемента на вершину стека, удаление с вершины стека, и необходимо поддерживать операции сложения, вычитания, 
умножения и целочисленного деления.
<p>
Операция сложения на стеке определяется следующим образом. Со стека снимается верхний элемент (top1), затем снимается 
следующий верхний элемент (top2), и затем как результат операции сложения на вершину стека кладется элемент, равный top1 + 
top2.
<p>
Аналогичным образом определяются операции вычитания (top1 - top2), умножения (top1 * top2) и целочисленного деления (top1 // 
top2).
<p>
Реализуйте эту структуру данных как класс ExtendedStack, отнаследовав его от стандартного класса list.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<pre>
class ExtendedStack(<b>list</b>):
        
    def sum(self):
        # операция сложения
        self.append(self.pop() + self.pop())
           

    def sub(self):
        # операция вычитания
        self.append(self.pop() - self.pop())
        #print(self.lst) 

    def mul(self):
        # операция умножения
        self.append(self.pop() * self.pop())
        

    def div(self):
        # операция целочисленного деления
        self.append(self.pop() // self.pop())
</pre>
</td></tr></table>
1. Здесь поскольку ExtendedStack унаследован от класса list, то при создании экземпляра ExtendedStack нужно в аргументе 
указать список:
<br>my_class = ExtendedStack([1, 2, 3])
<p>
2 момент: self будет <b>равен не my_class</b>, а списку, указанному при создании экземпляра.
<pre>


-------------------------------------------------------------------------------------------------------------------


</pre>
<b>Задача:</b><br>
Одно из применений множественного наследование – расширение встроенного метода за счет одноименного метода класса.<br>
Например, если нам понадобится логировать какую-то информацию при обращении к методам класса.
<p>
Рассмотрим класс Loggable:
<pre>
import time

class Loggable:
    def log(self, msg):
        print(str(time.ctime()) + ": " + str(msg))</pre>
У него есть ровно один метод log, который позволяет выводить в лог (в данном случае в stdout) какое-то сообщение, добавляя при 
этом текущее время.<br>
Реализуйте класс LoggableList, отнаследовав его от классов list и Loggable таким образом, чтобы при добавлении элемента в 
список посредством метода append в лог отправлялось сообщение, состоящее из только что добавленного элемента.
<br>Примечание: Ваша программа не должна содержать класс Loggable. При проверке вашей программе будет доступен этот класс, и 
он будет содержать метод log, описанный выше.
<p>
<b>По существу нужно расширить функционал обычного метода append, чтобы дополнительно еще шла запись в лог.</b>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<pre>
#!/usr/bin/env python3
import time

class Loggable:
    def log(self, msg):
        print(str(time.ctime()) + ": " + str(msg))
        
class LoggableList(list, Loggable):
           
    def append(self, elem): 
        <font color=red>list.append(self, elem)</font>
        super().log(elem)
</pre></td>
<td>
<b>Выполнение:</b>
<pre>
dmitriy@945G-M3:~$ python3 -i ~/Python//mypython/1.py
>>> my_class = LoggableList()
>>> my_class.__dict__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'dict' object is not callable
>>> <font color=red>my_class.__dict__
{}</font>
>>> my_class
[]
>>> my_class.append(5)
Fri Nov  1 13:40:58 2024: 5
>>> my_class
[5]
>>> my_class2 = LoggableList([1, 2, 3, 4])
>>> my_class2
[1, 2, 3, 4]
>>> my_class2.append(5)
Fri Nov  1 13:46:07 2024: 5
>>> my_class2
[1, 2, 3, 4, 5]
>>> <font color=red>self</font>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in <module>
NameError: name 'self' is not defined
>>> my_log.log('hhhh')
Fri Nov  1 15:10:24 2024: hhhh
>>> type(my_log)
&lt;class '__main__.Loggable'&gt;
>>> my_log.__dict__
{}
>>> my_log.append(5)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in <module>
AttributeError: 'Loggable' object has no attribute 'append'
>>> type(my_class)
&lt;class '__main__.LoggableList'&gt;
</pre>
</td></tr></table>
<p>
1. Непонятно, когда нужно создавать конструктор класса, когда нет. В данной задаче с конструктором с аргументом lst stepik 
решение не принимал.<br>
Думал, что только через конструктор можно создать экземпляр с конкретным списком, но нет, в примере выше создал my_class2 со 
списком [1, 2, 3, 4]
<p>
2. Непонятно что с  self
<p>
3. Почему при вызове my_class.__dict__ ответ - пустой словарь {}. Нет скажем атрибута append()
<p>
4. Почему при вызове метода append() его нужно вызывать из класса list.
<br>Если self.append(elem), то возникает бесконечная рекурсия, т.к. интерпретатор ищет append в классе LoggableList.<br>
Но опять же почему в классе LoggableList нет метода append. Если родителем является list, то вроде как экземпляр должен 
унаследовать его методы в том числе append.
<p>
<b>Другое грамотное решение:</b>
<pre>
class LoggableList(list, Loggable):
    def append(self, x):
        list.append(self, x)
        self.log(x)
</pre>
<font color=red>Непонятно почему при вызове метода log() из родительского класса не используется функция super()</font><br>
<i>Полагаю, прямое обращение self.log(x) в данном случае работает просто быстрее и чуть короче в коде, чем super().log(x). 
Другого принципиального отличия не вижу. Исходя из описания вот тут https://docs.python.org/3/library/functions.html?
highlight=super#super﻿ ни что не мешает в этом примере использовать super() для доступа к родительскому методу даже без его 
модификации.</i>
<p>
<b>Почему  в строке: list.append(self, x) метод  append принимает self ?</b><br>
<i>мы обращаемся к методу класса а не его экземпляра, в этом случае нужно передать и значение для self, если бы мы обращались 
к нему как к экземпляру, тогда было бы self.append(x)</i>
<pre>
>>> a = [1, 2]
>>> b = 5
>>> list.append(a, b)
>>> a
[1, 2, 5]
>>> a.append(6)
>>> a
[1, 2, 5, 6]
</pre>
<pre>



============================================================================================================



</pre>
<h3 align=center>Исключения</h3>
Реализуйте класс PositiveList, отнаследовав его от класса list, для хранения положительных целых чисел.
Также реализуйте новое исключение NonPositiveError.
<p>
В классе PositiveList переопределите метод append(self, x) таким образом, чтобы при попытке добавить неположительное целое 
число бросалось исключение NonPositiveError и число не добавлялось, а при попытке добавить положительное целое число, число 
добавлялось бы как в стандартный list.
<br>В данной задаче гарантируется, что в качестве аргумента x метода append всегда будет передаваться целое число.
<br>Примечание: Положительными считаются числа, строго большие нуля.'''
<pre>
class  NonPositiveError(Exception):
    print(x, 'меньше нуля')
    
class PositiveList(list):
    def append(self, x):
        if x <= 0:
                raise NonPositiveError(x)
        else:
            list.append(self, x)
</pre>
<pre>



=================================================================================================================



</pre>
<h3 align=center><a name="iterator">Итерирование классов</h3>
Задача по перебору класса:<br>
На вход класса подаем итерируемый объект. Функция класса - перебрать этот объект и выдать в итоге отфильтрованный объект.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
class multifilter:
    def judge_half(pos, neg):
        # допускает элемент, если его допускает
        # хотя бы половина фукнций (pos >= neg)
        <font color=red>if pos >= neg:
            return True
        else:
            return False</font>
                
    def judge_any(pos, neg):
        # допускает элемент, если его допускает
        # хотя бы одна функция (pos >= 1)
        if pos >= 1:
            return True
        else:
            return False
            
    def judge_all(pos, neg):
        # допускает элемент, если его 
        # допускают все функции (neg == 0)
        if neg ==0:
            return True
        else:
            return False    

    def __init__(self, iterable, *funcs, judge=judge_any):
        # создаем экземпляр класса multifilter
        self.iterable = iterable
        self.judge = judge
        <font color=red>self.funcs = []
        for i in funcs:
            self.funcs.append(i)</font>
        
    def __iter__(self):
        for i in self.iterable:
            self.pos = 0
            self.neg = 0
            for f in self.funcs:
                if f(i):
                    self.pos += 1
                else:
                    self.neg += 1
            if self.judge(<font color=red>self.pos, self.neg</font>):
                yield i</pre>
</td><td valign=top>
Другое:
<pre>
class multifilter:
    def judge_half(pos, neg):
        <font color=green>return pos >= neg</font>

    def judge_any(pos, neg):
        return pos > 0

    def judge_all(pos, neg):
        return neg == 0

    def __init__(self, iterable, *funcs, judge=judge_any):
        self.iterator = iter(iterable)
        <b>self.funcs = funcs</b>
        self.judge = judge

    def __iter__(self):
        return self

    def __next__(self):
        while (True):
            elem = next(self.iterator)
            pos, neg = 0, 0
            for func in self.funcs:
                if func(elem):
                    pos += 1
                else:
                    neg += 1

            if self.judge(pos, neg):
                return elem</pre>
</td></tr></table>
<p>
<b>Выполнение:</b>
<pre>
def mul2(x):
    return x % 2 == 0

def mul3(x):
    return x % 3 == 0

def mul5(x):
    return x % 5 == 0

a = [i for i in range(31)] # [0, 1, 2, ... , 30]

print(list(multifilter(a, mul2, mul3, mul5))) 
# [0, 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30]

print(list(multifilter(a, mul2, mul3, mul5, judge=multifilter.judge_half))) 
# [0, 6, 10, 12, 15, 18, 20, 24, 30]

print(list(multifilter(a, mul2, mul3, mul5, judge=multifilter.judge_all))) 
# [0, 30]
</pre>
<pre>



======================================================================================================================



</pre>
<h3 align=center><a name="gener">Функции-итераторы</h3>
Реализуйте функцию-генератор primes, которая будет генерировать простые числа в порядке возрастания, начиная с числа 2.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Первоначальный вариант:
<pre>
def primes(*args):
    lst = args
    print(lst)
    print(type(lst))
    count = 0
    for i in lst:
        if i < 2:
            continue
        for k in range(2, i + 1):
            if k % i:
                count +=1
        if count == 2:
            yield i
</pre>
</td>
<td valign=top>
Итоговое решение:
<pre>
import itertools
def primes():
    a = 1
    while True:  # просто пример
        count = 0
        a += 1
        for i in range(1, a + 1):
            if a % i == 0:
                count +=1
        if count == 2:
            yield i</pre>
</td></tr></table>
1. Как реализовать бесконечный диапазон?<br>
2. Где начнется выполняться функция при повторном ее вызове?<br>
3 lst = [args] <font color=red>not supported between instances of 'tuple' and 'int'</font><br>
4. Первоначальный вариант был ошибочен из-за команды проверки: <i>print(list(itertools.takewhile(lambda x : x <= 31, 
primes())))</i>
<pre>



=======================================================================================================



</pre>
<h3 align=center><a name="text">Работа с текстом</h3>
Вашей программе на вход подаются три строки s, a, b, состоящие из строчных латинских букв.
За одну операцию вы можете заменить все вхождения строки a в строку s на строку b.
<p>
Например, s = "abab", a = "ab", b = "ba", тогда после выполнения одной операции строка s перейдет в строку "baba", после 
выполнения двух и операций – в строку "bbaa", и дальнейшие операции не будут изменять строку s.
<p>
Необходимо узнать, после какого минимального количества операций в строке s не останется вхождений строки a. Если операций 
потребуется более 1000, выведите Impossible.
<p>
Выведите одно число – минимальное число операций, после применения которых в строке s не останется вхождений строки a, или 
Impossible, если операций потребуется более 1000.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
start_stroka = input()
enter_stroka = input()
shablon_stroka = input()
count = 0
if enter_stroka in start_stroka and enter_stroka in shablon_stroka:
        print('Impossible')
else:
    <font color=red>while count < 1001:</font> # лучше <b>while enter_stroka in start_stroka:</b>
        if enter_stroka in start_stroka:
            start_stroka = start_stroka.replace(enter_stroka, shablon_stroka)
            count += 1
        else:
            break
    if count < 1001:
        print(count)
    else:
        print('Impossible')
</pre>
</td><td valign=top>
Другое:
<pre>
s = input()
a = input()
b = input()

if a not in s:
    print(0)
elif a in b:
    print("Impossible")
else:
    ans = 0
    <font color=green>while a in s:</font>
        s = s.replace(a, b)
        ans += 1

    print(ans)</pre>
</td></tr></table>
<p>
Сначала хотел выполнить через рекурсивную функцию, но поскольку значение имел только последний вызов функции (хвостатая 
рекурсия), то выполнил итеративным способом.<br>
<b>Решения с рекурсией у других:</b>
<p>
<table border=1 style="border-collapse:collapse;"><tr><td valign=top>
№1
<pre>
def repl(s, a, b):
	if s.count(a) == 0:
		return 0
	return 1 + repl(s.replace(a, b), a, b)


s = input()
a = input()
b = input()
try:
	print(repl(s, a, b))
except RecursionError:
	print('Impossible')</pre>
</td>
<td v align=top>
№2
<pre>
def replacer(s: str, a: str, b: str, cnt: int) -> int:
    try:
        if a in s:
            new_s = s.replace(a, b)
            return replacer(new_s, a, b, cnt + 1)
        else:
            return cnt
    except RecursionError:
        return -1


s, a, b = [input() for _ in range(3)]
ans = replacer(s, a, b, 0)
print(ans if ans != -1 else 'Impossible')</pre>
</td></tr></table>
<p>
В первом примере базовым случаем является условие, когда нечего будет менять. Возврат функции равен счетчику. Когда достигли 
базового (конечного) условия, во всех вызванных функциях будут возврашать себя (счетчик), увеличивающийся на 1.
<p>
2 пример мне больще нравится. Здесь также базовое (конечное) условие, когда нечего менять. Но за счет того что count 
передается через аргумент функции, на базовом условии сразу получаем итоговый результат и через return его возвращаем. Внешние 
return также возвращают count. <b>Получается, что функция возвращает то, что возвращает конечный return.</b>
<pre>


-----------------------------------------------------------------------------------------------------------------------------


</pre>
Вашей программе на вход подаются две строки s и t, состоящие из строчных латинских букв.
<p>
Выведите одно число – количество вхождений строки t в строку s.
<pre>
s = input()
t = input()
count = 0
for i in range(0,len(s)):
    if t in s[i : i + len(t)]:
        count += 1
print(count)</pre>
<pre>


----------------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
Выведите строки, содержащие "cat" в качестве подстроки хотя бы два раза.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

lines = []
for line in stdin:
    if len(re.findall('cat', line)) >= 2:
        lines.append(line.rstrip('\n'))
for _ in lines:
    print(_)</pre>
</td><td valign=top>
Другое:
<pre>
import re
import sys

for line in sys.stdin:
    line = line.strip()
    if re.search(r"cat.*cat", line):
        print(line)</pre>
</td></tr></table>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Другое:
<pre>
import sys

print(*(s for s in sys.stdin if s.count('cat') > 1), sep='')
</pre>
</td></tr></table>
<pre>


-------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
Выведите строки, содержащие "cat" в качестве слова.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    if re.findall(r'\bcat\b', line.rstrip().lstrip()):
        print(line.rstrip('\n'))</pre>
</td><td valign=top>
Другое:
<pre>
import re
import sys

for line in sys.stdin:
    line = line.rstrip()
    if re.search(r"\bcat\b", line):
        print(line)</pre>
</td></tr></table>
<pre>


-------------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
Выведите строки, содержащие две буквы "z﻿", между которыми ровно три символа.
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    if re.search(r'z\D\D\Dz', line.rstrip()):
        print(line.rstrip())</pre>
</td><td valign=top>
Другое:
<pre>
import re
import sys

for line in sys.stdin:
    line = line.strip()
    if re.search(r"z...z", line):
        print(line)</pre>
</td></tr></table>
<pre>


-------------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
Выведите строки, содержащие обратный слеш "\﻿".
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    line = line.strip()
    if re.search(r'\\', line):
        print(line)</pre>
</td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
Выведите строки, содержащие слово, состоящее из двух одинаковых частей (тандемный повтор).
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    line = line.strip()
    if re.search(r'\b(.+)\1\b', line):
        print(line)</pre>
</td>
<td>
Другое:
<pre>
import re
import sys

for line in sys.stdin:
    line = line.strip()
    if re.search(r"\b(\w+)\1\b", line):
        print(line)
</pre></td></tr></table>
<pre>


-------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
В каждой строке замените все вхождения подстроки "human" на подстроку "computer"﻿ и выведите полученные строки.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    line = line.strip()
    print(re.sub('human', 'computer', line))</pre>
</td>
<td>
Другое:
<pre>
import re
import sys

print(re.sub(r'human', 'computer', sys.stdin.read()), end='')
</pre></td></tr></table>
<pre>


-----------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
В каждой строке замените первое вхождение слова, состоящего только из латинских букв "a" (регистр не важен), на слово "argh".
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    print(re.sub(r'\ba+\b', 'argh', line.strip(), count = 1, flags=re.IGNORECASE))</pre>
</td></tr>
<tr><td>
Другое:
<pre>
import sys
import re

[print(re.sub(r'\b[<b>aA]</b>+\b', 'argh', line.rstrip(), 1)) for line in sys.stdin]</pre></td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
В каждой строке поменяйте местами две первых буквы в каждом слове, состоящем хотя бы из двух букв.<br>
Буквой считается символ из группы \w.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    print(re.sub(r'\b(\w)(\w)', r'\2\1', line.strip()))</pre>
</td></tr></table>
<pre>


---------------------------------------------------------------------------------------------------------------------


</pre>
Вам дана последовательность строк.<br>
В каждой строке замените все вхождения нескольких одинаковых букв на одну букву.<br>
Буквой считается символ из группы \w.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
from sys import stdin
import re

for line in stdin:
    print(re.sub(r'(\w)\1+', r'\1', line.strip()))</pre>
</td></tr></table>
<pre>


------------------------------------------------------------------------------------------------------------------------


</pre>
Вашей программе на вход подаются две строки, содержащие url двух документов A и B.<br>
Выведите Yes, если из A в B можно перейти за два перехода, иначе выведите No.
<p>
Обратите внимание на то, что не все ссылки внутри HTML документа могут вести на существующие HTML документы.
<pre>
Sample Input 1:
<p>
https://stepik.org/media/attachments/lesson/24472/sample0.html
https://stepik.org/media/attachments/lesson/24472/sample2.html
Sample Output 1:

Yes</pre>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
import requests
import re

url1 = input()
url2 = input().replace('stepik.org', 'stepic.org')

r = requests.get(url1).text
pattern = r'href="(\S*)"'
lst = re.findall(pattern, r.strip())
s = []
for i in lst:
    r = requests.get(i).text
    s +=re.findall(pattern, r.strip())
if url2 in s:
    print('Yes')
else:
    print('No')</pre>
</td><td>
Другое:
<pre>
import re
import requests

start_url = input()
end_url = input()

found = False

link_pattern = re.compile(r'<a[^>]*?href="(.*?)"[^>]*?>')

resp = requests.get(start_url).text
for url in link_pattern.findall(resp):
    cur_resp = requests.get(url).text
    if end_url in link_pattern.findall(cur_resp):
        found = True
        break

print("Yes" if found else "No")</pre>
</td></tr></table>
<p>
<i>Кто-нибудь, объясните мне, пожалуйста, почему link_pattern.findall(resp) выдает очищенный от метатегов &lt;a href= &lt;/
a&gt; URL адрес? Т.е. полным совпадением (Full match) для данного регулярного выражения считается адрес, окруженный метатегами 
&lt;a href= &lt;/a&gt;, а "очищенный" от метатегов адрес является группой (Group 1).<br>
Почему link_pattern.findall(resp)выдает группы (т.е. только то, что в регулярном выражении заключено в круглые 
скобки), а не полное совпадение шаблона (Full match)?
<p>
"Если в шаблоне есть группирующие скобки, то вместо списка найденных подстрок будет возвращён список кортежей, в каждом из 
которых только соответствие каждой группе." https://habr.com/ru/post/349860/#Gruppy_i_refindall</i>
<pre>


-----------------------------------------------------------------------------------------------------------------------


</pre>
Вашей программе на вход подается ссылка на HTML файл.<br>
Вам необходимо скачать этот файл, затем найти в нем все ссылки вида &lt;a ... href="..." ... &gt; и вывести список сайтов, на 
которые есть ссылка.
<br>Сайтом в данной задаче будем называть имя домена вместе с именами поддоменов. То есть, это последовательность символов, 
которая следует сразу после символов протокола, если он есть, до символов порта или пути, если они есть, за исключением 
случаев с относительными ссылками вида &lt;a href="../some_path/index.html"&gt;.
<p>
Сайты следует выводить в алфавитном порядке.
<pre>
Пример HTML файла:

&lt;a href="http://stepik.org/courses"&gt;
&lt;a href='https://stepik.org'&gt;
&lt;a href='http://neerc.ifmo.ru:1345'&gt;
&lt;a href="ftp://mail.ru/distib" &gt;
&lt;a href="ya.ru"&gt;
&lt;a href="www.ya.ru"&gt;
&lt;a href="../skip_relative_links"&gt;

Пример ответа:
mail.ru
neerc.ifmo.ru
stepik.org
www.ya.ru
ya.ru</pre>
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
import requests
import re

url = input()
f = requests.get(url).text
pattern = r'&lt;a(?:.+?)href=[\'\"](?:[a-z]+:\/\/)?([a-z][\w\-\.]+)'
lst = set(re.findall(pattern, f))
st = sorted(lst)
for i in st:
    print(i)
</pre>
</td></tr></table>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Другое:
<pre>
import requests
import re

page = requests.get(input())

url_pattern = re.compile(r'&lt;a.*?href=["|\'](.*?:\/\/)?(\w.*?)([/|:].*)?["|\'].*')
links = sorted(set([link[1] for link in url_pattern.findall(page.text)]))
print(*links, sep='\n')
</pre>
</td></tr></table>
<pre>



=======================================================================================================================



</pre>
<a name="table"><h3 align=center>Работа с таблицами</h3>
Вам дана частичная выборка из датасета зафиксированных преступлений, совершенных в городе Чикаго с 2001 года по настоящее 
время.
<br>Одним из атрибутов преступления является его тип – Primary Type.
<br>Вам необходимо узнать тип преступления, которое было зафиксировано максимальное число раз в 2015 году.
<br>Файл с данными: Crimes.csv
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
Моё:
<pre>
import csv
import re
from collections import Counter

d = {}
lst = []
with open('/home/dmitriy/Python/mypython/Crimes.csv') as f:
    reader = csv.reader(f)
    for row in reader:
        if re.search(r'\d\d/\d\d/2015', row[2]):
            lst.append(row[5])
print(Counter(lst))
</pre>
</td><td valign=top>
Другое:
<pre>
from collections import Counter as c

with open('Crimes.csv') as f:
 data = csv.reader(f)
 print(c( row[5] for row in data <b>if '2015' in row[2]</b> ))
</pre>
Ошибка: нет import csv
<br>
------------------------------------------------------------
<br>
Другое:
<pre>
import csv

with open("Crimes.csv") as f:
     reader = csv.reader(f)
     crimes = []
     for row in reader:
         if "2015" in row[2]:
             crimes.append(row[5])
     print(max(crimes, key=crimes.count))</pre>
</td></tr></table>
<pre>



==================================================================================================================



</pre>
<a name="xml"><h3 align=center>Работа с данными XML-формата</h3>
Вам дано описание пирамиды из кубиков в формате XML.<br>
Кубики могут быть трех цветов: красный (red), зеленый (green) и синий (blue﻿).<br>
Для каждого кубика известны его цвет, и известны кубики, расположенные прямо под ним.<br>
Пример:
<pre>
&lt;cube color="blue"&gt;
  &lt;cube color="red"&gt;
    &lt;cube color="green"&gt;
    &lt;/cube&gt;
  &lt;/cube&gt;
  &lt;cube color="red"&gt;
  &lt;/cube&gt;
&lt;/cube&gt;
</pre> 
Введем понятие ценности для кубиков. Самый верхний кубик, соответствующий корню XML документа имеет ценность 1. Кубики, 
расположенные прямо под ним, имеют ценность 2. Кубики, расположенные прямо под нижележащими кубиками, имеют ценность 3. И т. д.
<br>Ценность цвета равна сумме ценностей всех кубиков этого цвета.
<br>Выведите через пробел три числа: ценности красного, зеленого и синего цветов.
<pre>
Sample Input:
&lt;cube color="blue"&gt;&lt;cube color="red"&gt;&lt;cube color="green"&gt;&lt;/cube&gt;&lt;/cube&gt;&lt;cube 
color="red"&gt;&lt;/cube&gt;&lt;/cube&gt;
Sample Output:
4 3 1
</pre>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td valign=top>
<b>Моё:</b>
<pre>
import xml.etree.ElementTree as ET
 
<font color=red>red_box = 0
green_box = 0
blue_box = 0</font>
root = ET.fromstring(input())

def search_cube(element, level):
    global red_box
    global blue_box
    global green_box
    for subelement in element.findall('cube'):
        if subelement.attrib['color'] == 'red':
            red_box += level
        elif subelement.attrib['color'] == 'green':
            green_box += level
        else:
            blue_box += level
    level += 1    
    for subelement in element.findall('cube'):
        search_cube(subelement, level)
        

if root.attrib['color'] == 'red':
    red_box = 1
elif root.attrib['color'] == 'green':
    green_box = 1
else:
    blue_box = 1
search_cube(root, 2)
print(red_box, green_box, blue_box)
</pre>
</td><td valign=top>
Другое:
<pre>
from xml.etree import ElementTree

root = ElementTree.fromstring(input())
<font color=green>colors = {"red": 0, "green": 0, "blue": 0}</font>

def getcubes(root, value):
    colors[root.attrib['color']] += value
    for child in root:
        getcubes(child, value+1)

getcubes(root,1)
print(colors["red"], colors["green"], colors["blue"])
</pre>
<p>
В отличии от моего:<br>
1. Вместо 3 переменных создал словарь. Это позволило заменить блок условий одной строчкой <i>colors[root.attrib['color']] += 
value</i>
<p>
2. Корневой узел разбирается в функции. Создает целостность кода.
</td></tr></table>



















</div>
<br><br><br><br></body></html>
