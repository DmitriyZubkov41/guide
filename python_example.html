<html><head>
<style>
.menu {
       height: 100%;
       width: 80px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 10px 0px 0px 10px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           margin-left: 90px; /* То же, что и ширина боковой панели */
           padding: 0px 0px 0px 5px;
         }
.no_double{border-collapse: collapse;}
</style>
</head><body>
<title>Примеры</title>
<div class="menu">

<a href="#while">Циклы</a><br>
<a href="#dict">Словари</a><br>
<a href="#fun">Функции:</a>
<a href="#lambda">&nbsp;&nbsp; lambda-функции</a>
<a href="#file">Файлы</a><br>
<a href="#modul">Модули:</a>
<a href="#os">&nbsp;&nbsp; os</a>
<a href="#obiekt">Объекты</a>
<a href="#oop">ООП</a>
<a href="#iterator">Итерирование классов</a>
<a href="#gener">Функции - итераторы</a>
</div>
<div class="content">
<h2 align=center>Примеры:</h2>
<ol>

<h4>Циклы:</h4>
<li> <a name="while">Напишите программу, которая считывает с консоли числа (по одному в строке) до тех пор, пока сумма введённых чисел не будет равна 0 и сразу после этого выводит сумму квадратов всех считанных чисел.
<br>Гарантируется, что в какой-то момент сумма введённых чисел окажется равной 0, после этого считывание продолжать не нужно.
<pre>
s = 0
y = 0
while True:
    x = int(input())
    s += x
    y += x*x
    if s == 0:
        break
print(y)</pre>

<li> Напишите программу, которая выводит часть последовательности 1 2 2 3 3 3 4 4 4 4 5 5 5 5 5 ... (число повторяется столько раз, чему равно). На вход программе передаётся неотрицательное целое число n — столько элементов последовательности должна отобразить программа. На выходе ожидается последовательность чисел, записанных через пробел в одну строку.
<br>Например, если n = 7, то программа должна вывести 1 2 2 3 3 3 4.<br>
Мое решение:
<pre>
k = 1
n = int(input())
m = [] # полный список
for i in range(1,n+1):
    m = m + [i]*i
for a in m:
    print(a,end=' ')
    k += 1
    if k > n:
        break
print()</pre>
Не моё:
<pre>
n = int(input())
a = []
i = 0
while len(a) < n:
    a += [i] * i
    i += 1
print(*a[:n])</pre>


<li> Напишите программу, которая принимает на вход список чисел в одной строке и выводит на экран в одну строку значения, которые встречаются в нём более одного раза.<br>
Моё решение:
<pre>
list = [int(i) for i in input().split()]
list_end = []
i = 0
while len(list) > 1:
    find_number = list[i]
    list.remove(list[i])
    if find_number in list and not find_number in list_end:
        list_end.append(find_number)
for element in list_end:
    print(element,end=' ')</pre>
Другое решение:
<pre>
a, c = [str(i) for i in input().split()], []
for i in a:
    if i not in c and a.count(i) > 1:
        c.append(i)
        print(i, end=' ')</pre>
        
<li> На вход программы подаётся список чисел lst и число x. Программа должна выдавать на выход в виде одной строки позиции расположения числа х в списке чисел lst. Если число х в списке lst  не обнаружено, необходимо вывести на выход строкой "Отсутствует".
<pre>
lst = [int(i) for i in input().split()]
x = int(input())
# Перебрать список lst по элементам
# каждый элемент сравнивать с x
# если совпадает, то напечатать индекс
# если же нет, то следующий элемент вытаскиваем
i = 0  #    определяем переменную, иначе будет ошибка
if x not in lst:
    print('Отсутствует')
else:
    for lst[i] in lst:
        if lst[i] == x:
            print(i, end=' ')
        i += 1

# 1. Ошибка <font color=red>IndexError: list assignment index out of range</font> возникает в Python, когда нельзя присвоить значение элементу,
 который ещё не существует в списке. Ошибку устранил, когда в <b>for num[i] in lst:</b> num[i] поменял на lst[i]
# 2. В <b>for lst[i] in lst:</b> i автоматически не прибавляет на 1</pre>

Не моё решение:
<pre>
lst, x = input().split(), input()
if x in lst:
    for i in range(len(lst)):
        if lst[i] == x:
            print(i, end=' ')
else:
    print('Отсутствует')</pre>
В этом решении цикл по индексу списка, а не по элементу списка, как у меня.
<p>
==============================================================================================

<li> 
<pre>
#!/usr/bin/env python3
''' Напишите программу, на вход которой подаётся прямоугольная матрица в виде последовательности строк. После последней строки
 матрицы идёт строка, содержащая только строку "end"

Программа должна вывести матрицу того же размера, у которой каждый элемент в позиции i, j равен сумме элементов первой матрицы
 на позициях (i-1, j), (i+1, j), (i, j-1), (i, j+1). У крайних символов соседний элемент находится с 
 противоположной стороны матрицы.

В случае одной строки/столбца элемент сам себе является соседом по соответствующему 
направлению.'''
table = []
while True:
    table.append([x for x in input().split()])
    if table[-1] == ['end']:
        break
# удалим end
table.remove(['end'])
# str - количество элементов в table - это коли-во строк матрицы
# stolb - количество элементов в элементе table - это коли-во столбцов матрицы
if len(table) == 1:
    delta_str = 0
else:
    delta_str = 1
if len(table[0]) == 1:
    delta_stolb = 0
else:
    delta_stolb = 1
for str in range(len(table)): # по строкам
    if str == len(table) - 1:
        str = str - len(table)
    for stolb in range(len(table[str])):
        if stolb == len(table[str]) - 1:
            stolb = stolb - len(table[str])
        print(int(table[str + delta_str][stolb]) + int(table[str - delta_str][stolb]) + \
        int(table[str][stolb + delta_stolb]) + int(table[str][stolb - delta_stolb]), end=' ')
    print()</pre>
Другое решение:
<pre>
a = [[int(i) for i in input().split()]]
b = input()
while b != 'end' :
    a.append([int(i) for i in b.split()])
    b = input()
for i in range(len(a)): 
    for j in range(len(a[i])): 
        print((a[i-1][j] + a[(i+1) % len(a)][j] + a[i][j-1] + a[i][(j+1) % len(a[i])]), end=' ')
    print()</pre>
Еще решение:
<pre>
c = []
while True:
    a = [i for i in input().split()]
    if a == ['end']:
        break
    c.append(a)
n, m = len(c), len(c[0])
for i in range(n):
    for j in range(m):
        x = int(c[i][j-1]) + int(c[i][j+1-m]) + int(c[i-1][j]) + int(c[i+1-n][j])
        print(x, end=' ')
    print()</pre>
==============================================================================================
<p>
<li>
Выведите таблицу размером n×n, заполненную числами от 1 до n 2 по спирали, выходящей из левого верхнего угла и закрученной по часовой стрелке:
<pre>
n = int(input())
krug = 1
stroka = 0 # первая строка
stolb = 0
<b>table = [[0 for j in range(n)] for i in range(n)]</b> # создаём n*n таблицу
# вправо
while table[stroka][stolb] != n*n:
    # вправо
    for stolb in range(krug -1, n - krug + 1):
        if stolb == 0:
            table[0][0] = 1
        else:
            table[stroka][stolb] = table[stroka][stolb-1] + 1
    if table[stroka][stolb] == n*n:
        break
    # вниз
    for stroka in range(krug,n - krug + 1):
        table[stroka][stolb] = table[stroka-1][stolb] + 1
    if table[stroka][stolb] == n*n:
        break
    # влево
    for stolb in range(-krug - 1, -n + krug - 2, -1):
        table[stroka][stolb] = table[stroka][stolb+1] + 1
    if table[stroka][stolb] == n*n:
        break
    # вверх
    for stroka in range(-krug - 1, -n + krug - 1, -1):
        table[stroka][stolb] = table[stroka+1][stolb] + 1
    if table[stroka][stolb] == n*n:
        break
    krug += 1
for stroka in range(n):
    for stolb in range(n):
        print(table[stroka][stolb], end=' ')
    print()</pre>
Вызвало затруднение, определение двухмерного массива, table[] или table[[]]  неправильно. Правильно получилось, когда использовал генератор для формирования таблицы.
<p>
Другое решение:
<pre>
n=int(input())
<b>t=[[0]*n for i in range (n)]</b>
i,j=0,0
for k in range(1, n*n+1):
  t[i][j]=k
  if k==n*n: break
  if i<=j+1 and i+j<n-1: j+=1
  elif i<j and i+j>=n-1: i+=1
  elif i>=j and i+j>n-1: j-=1
  elif i>j+1 and i+j<=n-1: i-=1
<b>for i in range(n):
    print(*t[i])</b></pre>
Более понятнее выглядит способ задания таблицы.<br>
Также интересен способ вывода строк с помощью print(*t[i])
<p>

<li><br>
После дрессировки черепашка научилась понимать и запоминать указания биологов следующего вида:<br>
север 10<br>
запад 20
юг 30<br>
восток 40<br>
где первое слово — это направление, в котором должна двигаться черепашка, а число после слова — это положительное расстояние в сантиметрах, которое должна пройти черепашка.
<p>
Но команды даются быстро, а черепашка ползёт медленно, и программисты догадались, что можно написать программу, которая определит, куда в итоге биологи приведут черепашку. Для этого программисты просят вас написать программу, которая выведет точку, в которой окажется черепашка после всех команд. Для простоты они решили считать, что движение начинается в точке (0, 0), и движение на восток увеличивает первую координату, а на север — вторую.
<p>
Программе подаётся на вход число команд n, которые нужно выполнить черепашке, после чего n строк с самими командами. Вывести нужно два числа в одну строку: первую и вторую координату конечной точки черепашки. Все координаты целочисленные.
<pre>
x = 0
y = 0
command = [input() for _ in range(int(input()))]
for str in command:
    if str.split()[0] == 'запад':
        x = x - int(str.split()[1])
    elif str.split()[0] == 'восток':
        x += int(str.split()[1])
    elif str.split()[0] == 'юг':
        y = y - int(str.split()[1])
    else: # север +y
        y += int(str.split()[1])
print(x, y)</pre>
<b>Другое:</b>
<pre>
dict = {'север': 0, 'юг': 0, 'запад': 0, 'восток': 0}

for _ in range(int(input())):
    key, value = input().split()
    dict[key] += int(value)

print(dict['восток'] - dict['запад'], dict['север'] - dict['юг'])</pre>
</ol>






<h4 align=center><a name="fun">Функции</h4>
<ol>
<li> Напишите функцию f(x), которая возвращает значение следующей функции, определённой на всей числовой прямой:
<p>
<img src="./images/python_base4.png">
<pre>
def f(x):
    if x <= -2:
        return 1 - (x + 2) ** 2
    elif -2 < x <= 2:
        return -x / 2
    else:
        return (x - 2) ** 2 + 1</pre>


<li><br>
Напишите функцию modify_list(l), которая принимает на вход список целых чисел, удаляет из него все нечётные значения, а чётные нацело делит на два. Функция не должна ничего возвращать, требуется только изменение переданного списка.
<pre>
def modify_list(lst):
    l = len(lst)
    for i in range(l-1, -1, -1):
        if lst[i] % 2 == 0:
            lst[i] = lst[i] // 2
        else:
            del lst[i]</pre>
Другое решение:
<pre>def modify_list(l):
    l[:] = [i//2 for i in l if not i % 2]</pre>
<i>логика такая, так как список l в памяти уже есть и его нужно перезаписать, то есть изменить сам объект списка, поэтому тут я делаю срез всего списка от начала до конца и меняю сам объект. если написать просто l = [i//2 for i in l if not i % 2] в данном случае будет создан новый объект, под него выделена память и переменная l будет уже ссылаться на него, а старая ссылка на исходный объект списка сотрется. т.е происходит не изменение объекта, а перенаправление ссылки у переменной l. я не проверял может и такой вариант сработает но подумал что он учтет занимаемую память и выдаст ошибку, так как была задача одна и там подобный подход выдавал ошибку, а сделал l[:] (изменил сам весь объект) все заработало.
<p>
дело в том что for и while полезны для больших конструкций, а генератор списков [ for ] введен для того что бы писать коротенькие вещи в одну строку, что б ради одной двух операций внутри цикла не писать по 3-4 строчки кода с обычным циклом.
<p>
i%2 выдает либо 0 либо 1. или иначе False True. not i - переворачивает выданный результат. Т.е. в данной ситуации мы должны выполнять действие (i//2) если условие if даст True, но четное число при делении даст остаток 0 (6%2=0 - False) поэтому нам необходимо перевернуть результат (not False - True)</i>


<p>
<li>
Напишите реализацию функции closest_mod_5, принимающую в качестве единственного аргумента целое число x и возвращающую самое маленькое целое число y, такое что:
<p>
y больше или равно x<br>
y делится нацело на 5
<pre>
def  closest_mod_5(x = int(input())):
    for num in range(x, x*5 + 1):
        if num % 5 == 0:
            return num
print(closest_mod_5())</pre>
Другое:
<pre>
def closest_mod_5(x):
    while x % 5 != 0:
        x += 1
    return x</pre>


</ol>


<h3 align=center><a name="dict">Словарь</h3>
<ol>
<li> <b>Словарь</b><br>
Напишите программу, которая принимает на стандартный вход список игр футбольных команд с результатом матча и выводит на стандартный вывод сводную таблицу результатов всех матчей.
<p>
За победу команде начисляется 3 очка, за поражение — 0, за ничью — 1.
<p>
Формат ввода следующий:<br>
В первой строке указано целое число n — количество завершенных игр.<br>
После этого идет n строк, в которых записаны результаты игры в следующем формате:
<br>Первая_команда;Забито_первой_командой;Вторая_команда;Забито_второй_командой
<p>
Вывод программы необходимо оформить следующим образом:
Команда:Всего_игр Побед Ничьих Поражений Всего_очков
<pre>
win = {}  # количество побед
loss = {} # 
pat = {}  # количество ничьих
point = {}  # количество очков
number_game = {}  # количество игр, проведенных клубом
n = int(input('Количество игр:'))
for i in range(n):
    game = input('Игра:').strip() # Создали список из проведенных игр
    '''Теперь по каждому первому элементу и последнему элементу game создаем словари,
    где ключ - клуб'''
    #print(game)
    if int(game.split(';')[1]) > int(game.split(';')[3]): # победа         
        if game.split(';')[0] not in number_game.keys():
            number_game[game.split(';')[0]] = 1
            win[game.split(';')[0]] = 1
            pat[game.split(';')[0]] = 0
            loss[game.split(';')[0]] = 0
            point[game.split(';')[0]] = 3
        else:
            number_game[game.split(';')[0]] += 1
            win[game.split(';')[0]] += 1
            point[game.split(';')[0]] += 3
        if game.split(';')[2] not in number_game.keys():
            number_game[game.split(';')[2]] = 1
            win[game.split(';')[2]] = 0
            pat[game.split(';')[2]] = 0
            loss[game.split(';')[2]] = 1
            point[game.split(';')[2]] = 0
        else:
            number_game[game.split(';')[2]] += 1
            loss[game.split(';')[2]] += 1
            
    elif  int(game.split(';')[1]) < int(game.split(';')[3]): # ПОРАЖЕНИЕ 1 клуба и победа второго клуба        
        if game.split(';')[0] not in number_game.keys():
            number_game[game.split(';')[0]] = 1
            win[game.split(';')[0]] = 0
            pat[game.split(';')[0]] = 0
            loss[game.split(';')[0]] = 1
            point[game.split(';')[0]] = 0
        else:
            number_game[game.split(';')[0]] += 1
            loss[game.split(';')[0]] += 1
        if game.split(';')[2] not in number_game.keys():
            number_game[game.split(';')[2]] = 1
            win[game.split(';')[2]] = 1
            pat[game.split(';')[2]] = 0
            loss[game.split(';')[2]] = 0
            point[game.split(';')[2]] = 3
        else:
            number_game[game.split(';')[2]] += 1
            win[game.split(';')[2]] += 1    
            point[game.split(';')[2]] += 3
            
    else:                                            # ничья
            if game.split(';')[0] not in pat.keys():
                number_game[game.split(';')[0]] = 1
                win[game.split(';')[0]] = 0
                pat[game.split(';')[0]] = 1
                loss[game.split(';')[0]] = 0
                point[game.split(';')[0]] = 1
            else:
                number_game[game.split(';')[0]] += 1
                pat[game.split(';')[0]] +=1
                point[game.split(';')[0]] +=1 
            if game.split(';')[2] not in pat.keys():
                number_game[game.split(';')[2]] = 1
                win[game.split(';')[2]] = 0
                pat[game.split(';')[2]] = 1
                loss[game.split(';')[2]] = 0
                point[game.split(';')[2]] = 1
            else:
                number_game[game.split(';')[2]] += 1
                pat[game.split(';')[2]] +=1
                point[game.split(';')[2]] +=1

for key in  number_game.keys():
    print(key+':'+str(number_game[key]), win[key], pat[key], loss[key], point[key])</pre>           
Ошибка:
<pre>print(number_game[game.split(';')[0]])
<font color=red>KeyError: 'Спартак'</font></pre>
Проблему решил проверкой на вхождение ключа в словарь и в зависимости от результата создавал новую пару или
делал приращение к существующему ключу
<p>
<i>"Иллюстрация, как обращаться к элементу списка, если такой список является значением в словаре:
<pre>example = {'A': [22, 33, 44], 'B': [10, 20]}

print(example['A'][1])</pre>
Будет напечатано: 33"</i>
<p>       
<b>Ещё не мое решение:</b>
<pre>
def command(c, res):
    if not c in dct: dct[c] = [0, 0, 0, 0, 0]
    dct[c] = [dct[c][0] + 1, 
                dct[c][1] + 1 if res == 3 else dct[c][1],
                dct[c][2] + 1 if res == 1 else dct[c][2],
                dct[c][3] + 1 if res == 0 else dct[c][3],
                dct[c][4] + res,]  
dct = {}
for i in range(int(input())):
    c1, g1, c2, g2 = input().split(';')    
    command(c1, 3 if int(g1) > int(g2) else 1 if int(g1) == int(g2) else 0)
    command(c2, 3 if int(g2) > int(g1) else 1 if int(g1) == int(g2) else 0)
for c in dct:
    print('{}:{} {} {} {} {}'.format(c, *dct[c]))</pre>
<b>Ещё:</b>
<pre>
a=[input().split(';') for i in range(int(input()))]
b={i:[] for i in set([i[0] for i in a])|set([i[2] for i in a])}
for i in a:
	b[i[0]].append(1 if i[1]==i[3] else 3 if i[1]&gt;i[3] else 0)
	b[i[2]].append(1 if i[1]==i[3] else 3 if i[1]&lt;i[3] else 0)
for i in b: print('%s:%i %i %i %i %i'%(i,len(b[i]),b[i].count(3),b[i].count(1),b[i].count(0),sum(b[i])))</pre>


<li><br>
Напишите программу, которая умеет шифровать и расшифровывать шифр подстановки. Программа принимает на вход две строки одинаковой длины, на первой строке записаны символы исходного алфавита, на второй строке — символы конечного алфавита, после чего идёт строка, которую нужно зашифровать переданным ключом, и ещё одна строка, которую нужно расшифровать.'''
<pre>
str_zashifr = []
str_shifr = []
shifr_rashifr = []
<b>alfavit = {key:0 for key in input()}</b>
shifr = input()
# сопоставляем ключу alfafit значение из shifr
i = 0
for key in alfavit.keys():
    alfavit[key] = shifr[i]
    i +=1
#print(alfavit)
str = input()
str_shifr = input()
for l in str:
    str_zashifr +=alfavit[l]
# print(*str_zashifr)
for l in str_zashifr:
    print(l, end='')
print()
# Перевернем словарь
<b>inv_alfavit = {v: k for k, v in alfavit.items()}</b>
for l in str_shifr:
    shifr_rashifr += inv_alfavit[l]  
for l in shifr_rashifr:
    print(l, end='')
print()</pre>
Создал словарь через input()<br>
Использовал переворачивание словаря.
<p>
Ещё решение:
<pre>
<b>a,b,c,d=input(),input(),input(),input()</b>
print(''.join(b[a.index(i)] for i in c))
print(''.join(a[b.index(i)] for i in d))</pre>


<li> <b>Словарь</b><br>
Напишите программу, которая прочитает этот файл и подсчитает для каждого класса средний рост учащегося.
<p>
Файл состоит из набора строк, каждая из которых представляет собой три поля:<br>
Класс Фамилия Рост
<p>
Класс обозначается только числом. Буквенные модификаторы не используются. Номер класса может быть от 1 до 11 включительно. В фамилии нет пробелов, а в качестве роста используется натуральное число, но при подсчёте среднего требуется вычислить значение в виде вещественного числа.
<p>
Выводить информацию о среднем росте следует в порядке возрастания номера класса (для классов с первого по одиннадцатый). Если про какой-то класс нет информации, необходимо вывести напротив него прочерк.
<table border=1><tr><td>
<pre>
d = {key:[0, 0] for key in range(1,12)} # создали словарь
with open('/home/dmitriy/Python/mypython/dataset_3380_5.txt') as f:
    for line in f:
        #print(line.split()[0])
        # создадим словарь d, где ключ будет от 1 до 11, а значения сумма ростов и счетчик школьников
        # значение словаря список из двух чисел: d[key][0] и d[key][1]
        d[int(line.split()[0])] = [d[int(line.split()[0])][0] + int(line.split()[2]), d[int(line.split()[0])][1] + 1]
for key in d.keys():
    if d[key][1] == 0:
        print(key, '-')
    else:
        print(key, d[key][0] / d[key][1])</pre>
</td></tr></table>
<b>Другое решение, похоже на мое, но синтаксис грамотный</b>
<pre>
# Делаем словарь {1:[0,0], 2:[0,0]... 11:[0,0]}, где [0:0] = [сумма ростов : кол-во учеников]
tab = {i:[0,0] for i in range(1,12)} 

with open ('dataset_3380_5.txt') as inf:

	# Заполняем словарь:
	for i in inf:
		line = i.strip().split('\t')
		tab [ int(line[0]) ] [0] += int(line[2]) # tab[класс][0] += рост ученика
		tab [ int(line[0]) ] [1] += 1            # tab[класс][1] += 1 (счетчик учеников в классе)
	
	# Распечатка:
	for i in tab.keys():
		if tab[i][1] == 0:
			print (i, '-') # распечатываем класс, в котором нет учеников
		else:
			# считаем и распечатываем средний рост для i-го класса:
			print (i, ( tab[i][0] / tab[i][1] ))</pre>




<li> Реализуйте программу, которая будет эмулировать работу с пространствами имен. Необходимо реализовать поддержку создания пространств имен и добавление в них переменных.
<pre>
n = int(input())
d = {'None':'global'}


def get(ns, var):     #  get namespace var или get ns var
    result = []
    # print('d.values()=', d.values())
    
    # преобразуем список детей d.values() в список элементов result
    for i in d.values():
        if type(i) != list:
            result.append(i)
        else:
            for n in range(len(i)):
                result.append(i[n])
    #print('result=', result)
    
    '''ns может не входить в список ключей (родителей)'''
    if ns in d.keys():
        #print('ns=', ns, ' d[ns]=', d[ns])
        if var in d[ns]:   #  переменная var входит в список родителя ns
            # print('var=', var, 'входит в состав (', d[ns], ') родителя ns=', ns)
            return print(ns)
        elif ns in result: # var не входит в ns, но ns входит в список детей
            if ns == 'global':
                return print('None')
            # print(var, 'не входит в ', ns, ' но ', ns, ' входит в список детей ', result)
            # нужно найти ключ для ns (куда ns входит)
            for key in d.keys():
                if ns in d[key]: 
                    # print(ns, ' находится в ', key, ' снова выполняем функцию')
                    return get(key, var)
        else:
            #print(var, ' не входит в ', ns, ' и ', ns, ' никуда не входит')
            return print('None')  
    else:
        # print(ns, ' не входит в список родителей (d.keys()) ', d.keys())
        if ns in result:
            # print(ns, ' входит в список детей (result) ', result) 
            '''надо найти куда ns входит'''
            for key in d.keys():
                if ns in d[key]: 
                    # print(ns, ' находится в ', key, ' снова выполняем функцию')
                    return get(key, var)
        else:
            # print(ns, ' не входит в список детей result ', result)
            return print('None')
        
for _ in range(n):
    str = input().split()
    
    if str[0] == 'add':
        if str[1] in d.keys():
            if type(d[str[1]]) == list:
                lst = ','.join(d[str[1]]).split(',')
                lst.append(str[2])
                d[str[1]] = lst
            else:
                d[str[1]] = [d[str[1]], str[2]]
        else:
            d[str[1]] = str[2]       
    
    elif str[0] == 'create':
        if str[2] in d.keys():
            if type(d[str[2]]) == list:
                <b><font color=green>lst = ','.join(d[str[2]]).split(',')</font>
                <font color=blue>lst.append(str[1])</font></b>
                d[str[2]] = lst
                #print(d[str[2]])
            else:
                d[str[2]] = [d[str[2]], str[1]]
        else:
            d[str[2]] = str[1]       
            
    elif str[0] == 'get':
        get(str[1], str[2])</pre>
3 дня писал этот код. Замотался с добавлением  элемента в значение словаря, так чтобы все элементы были в одном списке, а не списки в списке.
<ol>
<li> <font color=green><b>Чтобы список разделить на отдельные элементы - строки и потом назад в список</b>, используется конструкция<br>
lst = ','.join(d[str[1]]).split(',')<br>
Здесь с помощью joint преобразуем список ['a, b'] в строку 'a, b' а с помощью split(',') преобразуем назад в список ['a', 'b']</font>

<li> <font color=blue>Если писать lst = lst.append(), то будет возвращаться None. Чтобы нормально метод работал, нужно писать lst.append()</font> Метод не работает со строкой.
</ol>
<p>
<b>Другое решение:</b><br>
<i>Пример решения. Будем храним две структуры:<br>
1) Кто чей родитель<br>
2) Переменные объявленные в данном пространстве имён
<p>
Если команда create -- создаём новое пространство имён (запоминаем родителя и создаём пустое множество переменных, объявленных в этом пространстве имен).
<p>
Если команда add -- то просто помещаем имя переменной в соответствующее множество.
<p>
Если команда get -- то проверяем наличие данной переменной в нашем пространстве имён, если не нашли: проверяем в родителе. 
Если не нашли в родителе, проверяем в родителе родителя и так далее. Как только нашли имя переменной -- вывели на экран 
пространство имён, в котором нашли. Если в процессе поиска мы имя не нашли (fst is None) -- выводим None на экран.</i>
<pre>
n = int(input())

parent = {"global": None}
vs = {"global": set()}

for _ in range(n):
    t, fst, snd = input().split()
    if t == "create":
        parent[fst] = snd
        vs[fst] = set()
    elif t == "add":
        <b>vs[fst].add(snd)</b>
    else:  # t == get
        while fst is not None:
            if snd in vs[fst]:
                break
            fst = parent[fst]
        print(fst)</pre>
<b>Элементы добавлять в значение словаря удобно с помощью метода add().</b>  <i>Это если значение является множеством.</i> 
</ol>     
<p>        
=====================================================================================================
<p>
31.10.2024:<br>
Формат входных данных<br>
В первой строке входных данных содержится целое число n - число классов.
<p>
В следующих n строках содержится описание наследования классов. В i-й строке указано от каких классов наследуется i-й класс. 
Обратите внимание, что класс может ни от кого не наследоваться. Гарантируется, что класс не наследуется сам от себя (прямо или 
косвенно), что класс не наследуется явно от одного класса более одного раза.
<p>
В следующей строке содержится число q - количество запросов.
<p>
В следующих q строках содержится описание запросов в формате <имя класса 1> <имя класса 2>.
Имя класса – строка, состоящая из символов латинского алфавита, длины не более 50.
<p>
Формат выходных данных<br>
Для каждого запроса выведите в отдельной строке слово "Yes", если класс 1 является предком класса 2, и "No", если не является.
<pre>
Sample Input:
4
A
B : A
C : A
D : B C
4
A B
B D
C D
D A
Sample Output:
Yes
Yes
Yes
No
</pre>
<table border=1>
<tr>
<td rowspan=2 valign=top>
<b>Мое решение:</b>
<pre>
d = {}

# Функция перебора родителей
def find(upclass, class2):
    for i in class2:
        if class1 in d[i]:
            res = True
            return res
        else:
            res = find(class1, d[i])
            if res == True:
                return res
            else:
                continue    
    return
    
# Цикл добавления классов в словарь
for _ in range(int(input())):
    s = input().split(' : ')
    if len(s) > 1:
        if s[0] in d.keys():
            <b>d[s[0]] = d[s[0]] + s[1].split()</b>
        else:
            d[s[0]] = s[1].split()
    else:
        d[s[0]] = []

# Отправка запросов    
for _ in range(int(input())):
    lst = input().split()
    if len(lst) == 1:
        print('Yes')
    else:
        class1 = lst[0]
        class2 = lst[1]
        if class1 == class2:
            print('Yes')
        elif class2 not in d.keys() or d[class2] == []:
            print('No')
        elif class1 in d[class2]: 
            print('Yes')
        else:
            res = find(class1, d[class2]) 
            if res == True:
                print('Yes')
            else:
                print('No')
</pre>
<b>Добавление элемента в словарь:</b><br>
В строке <b>d[s[0]] = d[s[0]] + s[1].split()</b> я получаю новое значение словаря: в первоначальный список элементов d[s[0]] 
вкладываю s[1]<br>
Если s[1] добавлять сразу: <b>d[s[0]] = d[s[0]] + s[1]</b>, то получим ошибку:
<br><font color=red>TypeError: can only concatenate list (not "str") to list</font><br>
Ни append(), ни add, update join не приводили к нужному результату
</td>
<td valign=top>
<b>Другое решение:</b>
<pre>
def test(parent, child):
    if parent == child or parent in base[child]:
        return 'Yes'
    for i in base[child]:
        if test(parent, i) == 'Yes':
            return 'Yes'
    return 'No'

base = {}
<font color=brown>for com in [input().split(' ') for i in range(int(input()))]:</font>
    base[com[0]] = com[2:len(com)]
for com in [input().split(' ') for i in range(int(input()))]:
    print (test(com[0], com[1]))
</pre>
<font color=brown>я не могу понять почему вывод идет только после окончания ввода, а не после каждого ввода значений для прове
рки...</font>
<p>
<i>Так происходит потому что в  этой части кода:
<pre>
for com in [input().split(' ') for i in range(int(input()))]:
     print (test(com[0], com[1]))</pre>
мы сначала с помощью генератора списков [input().split(' ') for i in range(int(input()))]
создаём собственно список, вводя все данные, и только потом передаём этот 
список циклу for com in [сформированный список],который прогоняет это список через функцию test.
 Короче говоря, тут два цикла (первый в генераторе списков). В первом - вводим данные, во втором - проверяем.
<p>
Чтобы ответ, как Вы хотите, возвращался сразу после каждого ввода, последние
 две строчки нужно было бы переписать как-то так:
<pre>
for i in range(int(input())):

    com = input().split(' ')

    print (test(com[0], com[1]))</pre>
https://all-python.ru/osnovy/generator-spiska.html
</td></tr>
<tr><td  valign=top>
<p>
<b>Другое решение:</b>
<pre>
n = int(input())

parents = {}
for _ in range(n):
    a = input().split()
    <b>parents[a[0]] = [] if len(a) == 1 else a[2:]</b>

def is_parent(child, parent):
    return child == parent or any(map(lambda p: is_parent(p, parent), parents[child]))

q = int(input())
for _ in range(q):
    a, b = input().split()
    print("Yes" if is_parent(b, a) else "No")
</pre>
<br>
<br>
1. Здесь в <b>parents[a[0]] = [] if len(a) == 1 else a[2:]</b><br>
идет перезапись в значение словаря, но не добавление, как реализовано у меня.
<p>
2. <b>a, b = input().split()</b> вызовет ошибку:
<font color=red>ValueError: not enough values to unpack (expected 2, got 1)</font><br>
если ввести запрос из одного элемента, типа A.
</td></table>
<p>
-----------------------------------------------------------------------------------------------------------
<p>
Еще одна задачка на так называемые графы.
<p>
<table border=1>
<tr>
<td>
<pre>
n = int(input())
d = {}
exceptions = []

def find(ns):
    if ns in d.keys():
        for m in d[ns]:
            if m in exceptions[0 : i]:
                return True
            else:
                if find(m) == True:
                    return True
        return False
    else:
        return False     
        
for _ in range(n):
    s = input().split()
    if len(s) > 1:
        d[s[0]] = s[2:]
    else:
        d[s[0]] = ''
       

for i in range(int(input())):
    s = input()
    if s not in exceptions:
        exceptions.append(s)


for i in range(1, len(exceptions)):
    if exceptions[i] in exceptions[0 : i] or find(exceptions[i]) == True:
        print('Исключить', exceptions[i])</pre>
</td><td>
<pre>
parents = {}
for _ in range(int(input())):
    a = input().split()
    parents[a[0]] = [] if len(a) == 1 else a[2:]

def is_parent(child, parent):
    if child == parent: return True
    for p in parents[child]:
        if is_parent(p, parent ): return True
    return False

exceptions = []
for _ in range(int(input())):
    a = input().strip()
    for i in exceptions:
        if is_parent(a,i):
            print(a)
            break
    exceptions.append(a)
</pre>
</td>
</tr></table>        
        
        

		
</ol>
<h3 align=center>Множество</h3>
<ol>
<li> <b>Преобразование списка в строку и назад в список с целью сделать список из отдельных слов<br>
<font color=blue>Множество из списка.</font></b><br>
<font color=brown>Методы цепочкой</font>
<p>
На вход программе первой строкой передаётся количество 
d известных нам слов, после чего на d строках указываются эти слова. Затем передаётся количество 
l строк текста для проверки, после чего l строк текста.
<p>
Выведите уникальные "ошибки" в произвольном порядке. Работу производите без учёта регистра.
<pre>
list1 = []
list2 = []
d = int(input())
for i in range(d):
    <font color=brown>list1.append(input().lower())</font>
l = int(input())
for i in range(l):
    list2.append(input().lower())
<b>'''print(list2) # список из фраз
list2 = ' '.join(list2) # преобразовали список в одну строку без запятых
list2 = list2.split()   # преобразовали строку назад в список но из отдельных слов
'''
list2 = ' '.join(list2).split()
<font color=blue>list2 = set(list2)</font></b>
print(list2)
for i in list2:
    if i not in list1:
        print(i)
</pre>
<pre>list1 = list1.append(input())
<font color=red>AttributeError: 'NoneType' object has no attribute 'append'</font></pre>
Устранил ошибку, когда изменил выражение list1 = list1.append(input()) на list1.append(input())
<p>
Другое решение:<br>
<font color=green>Способ создания множества/списка из нескольких вводов одной строкой</font>
<pre>
# формируем множество известных слов на основании построчного ввода
<font color=green>dic = {input().lower() for _ in range(int(input()))}</font>

# заводим пустое множество для приема текста
wrd = set()

# т.к. текст построчно подается, а также в каждой строке несколько слов,
# то каждую строку превращаем во множество и добавляем в единое множество wrd
for _ in range(int(input())):
    wrd |= {i.lower() for i in input().split()}

# на вывод отправляем результат вычитания словарного множества dic
# из текстового множества wrd; впереди ставим *, чтобы раскрыть поэлементно
print(*(wrd-dic), sep="\n")</pre>
wrd |= {...} отвечает за добавление множества {...} в единое wrd (аналог метода update)<br>
заменил ненужные символы переменных на _






<p>
<li><br> <b>Множество<br>применение одновременно нескольких методов</b>
<br>
Программа должна считывать одну строку со стандартного ввода и выводить для каждого уникального слова в  этой строке число его повторений (без учёта регистра) в формате "слово количество".<br>
Порядок вывода слов может быть произвольным, каждое уникальное слово﻿ должно выводиться только один раз.
<pre>
<b>str = input().lower().split()</b>
for i in set(str):
    print(i, str.count(i)</pre>

<li><br>
Напишите программу, которая считывает строку с числом n, которое задаёт количество чисел, которые нужно считать. Далее 
считывает n строк с числами xi, по одному числу в каждой строке. Итого будет n+1 строк.
При считывании числа xi программа должна на отдельной строке вывести значение f(xi). Функция f(x) уже реализована и доступна 
для вызова. 
Функция вычисляется достаточно долго и зависит только от переданного аргумента x. Для того, чтобы уложиться в ограничение по времени, нужно избежать повторного вычисления значений.<br>
Моё:
<pre>
n = int(input())
l = []
d = {}
for i in range(n):
    l.append(int(input()))
'''Проходим каждый элемент списка
Вычисляем функцию и добавляем i и f в словарь
Если на следующем элементе уже вычисляли функцию (входит в словарь), то выводим значение для текущего ключа из словаря'''
for i in l:
    if i not in d.keys(): # еще не выполняли функцию по этому числу
        d[i] = f(i)
        print(i, f(i))
    else:
        print(i, d[i])</pre>
Другое:
<pre>
a=[int(input()) for i in range(int(input()))]
b={x:f(x) for x in set(a)}
for i in a:
    print(b[i])</pre>
Ещё:
<pre>
d = {}
for _ in range(int(input())):
    x = int(input())
    if x not in d:
        d[x] = f(x)
    print(d[x])</pre>         
</ol>







<h3 align=center><a name="lambda">lambda-функции</h3>
Лямбда функции предоставляют нам удобный способ создать функцию «прямо на месте».<br>
Но иногда, когда нужно создавать много однотипных лямбда функций, еще удобнее будет создать функцию, которая будет их 
генерировать.
<p>
Реализуйте функцию mod_checker(x, mod=0), которая будет генерировать лямбда функцию от одного аргумента y, которая будет 
возвращать True, если остаток от деления y на x равен mod, и False иначе.
<pre>
def mod_checker(x, mod=0):
    return lambda y: y % x == mod
</pre>








<h3 align=center><a name="file">Файл, методы работы с файлами</h3>
Напишите программу, которая считывает из файла строку, соответствующую тексту, сжатому с помощью кодирования повторов, и
производит обратную операцию, получая исходный текст.
<pre>
with open('/home/dmitriy/Python/mypython/dataset_3363_2 (1).txt') as inf:
  for line in inf:
      line = line.strip()
      # print(line)
  simvol = ''
  num = ''
  str = ''
  for i in range(len(line)):
      ''' если символ является цифрой, тогда запоминаем ее в переменной num строкового типа
      если следующий символ снова цифра, тогда добавляем ее в num
      если же буква, тогда переменную символа simvol умножаем на int(num) и записывает эту строку в новый файл new_file.txt'''
      if '0' <= line[i] <= '9': # цифра
          num = num + line[i]
          if i == len(line) - 1: # последний символ
              str = str + simvol * int(num)
      else:  # буква
          # умножаем предыдущую букву на num и обнуляем num
          # print('simvol=',line[i], 'type(num)=',type(num),'num=',num)
          if i != 0:
              str = str + simvol * int(num)
          # print('stroka=', str)
          simvol = line[i]
          num = '0'
inf.close()
with open('/home/dmitriy/Python/mypython/dataset_3363_2_modify.txt', 'w') as ouf:
    ouf.write(str)</pre>
<b>Не моё:</b>
<pre>
with open('dataset_3363_2.txt', 'r') as f:
    s = f.readline().strip()
i = 0
while i < len(s):
    j = i + 1
    while j < len(s) and s[j].isdigit():
        j += 1
    print(s[i] * int(s[i+1:j]), end='')
    i = j</pre>
Первый символ - гарантированно буква.
Перебираем все последующие, пока они цифровые или пока не достигнут конец строки.<br>
После внутреннего цикла j либо указывает на следующую букву, либо на конец строки. В обоих случаях между s[i] и s[j] - цифры,
 составляющие нужное нам число повторов символа s[i].<br>
Печатаем символ нужное число раз, присваиваем i индекс следующей буквы для новой итерации цикла.    
<p>
<li> <b>Файл</b><br>
Напишите программу, которая считывает текст из файла (в файле может быть больше одной строки) и выводит самое частое слово в 
этом тексте и через пробел то, сколько раз оно встретилось. Если таких слов несколько, вывести лексикографически первое (можно 
использовать оператор < для строк).
<pre>
word = ''
d = {} 
maksimum = 0
spisok_max = {}
maks_word = ''
with open('/home/dmitriy/Python/mypython/dataset_3363_3.txt') as f:
  for line in f:
      line.strip() # удаляем служебные символы
      #print(line)
      for word in line.split():
          # заполняем словарь
          if word in d.keys():
              d[word] += 1
          else:
              d[word] =1 
# ищем максимальное количество слов
for key, value in d.items():
    if value > maksimum:
        spisok_max = {key:value}
        maksimum = value
    elif value == maksimum:
       spisok_max[key] = value
for key in spisok_max.keys():
    if key > maks_word:
        maks_word = key
print(maks_word, spisok_max[maks_word])
# Со строкой метод append не работает, чтобы добавить строку, используем оператор приращения.
# TypeError: can only concatenate str (not "list") to str: 
# TypeError: unsupported operand type(s) for +=: 'set' and 'list'
# for i in stroka переберет строку по буквам, чтобы по словам нужно использовать: for i in stroka.split()
</pre>
Ещё:
<pre>
<b>with open('dataset_3363_3.txt') as inf, open('MostPopularWord.txt','w') as ouf:
    maxc = 0
    s = inf.read().lower().strip().split()</b>
    s.sort()
    for word in s:
        counter = s.count(word)
        if counter > maxc:
            maxc = counter
            result_word = word
    ouf.write(result_word +' ' + str(maxc))</pre>
Без словаря, сразу читаем файл и сортируем список слов, чтобы потом первое найденное было лексиграфически впереди.
<br>
<b>Оказывается конструкция with является циклом.</b>
<p>
====================================================================
<p>
<b>Чтение файла, импорт модуля, конструкция try/except/else</b>
<p>
Алиса зашифровала свою информацию с помощью библиотеки simple-crypt.<br>
Она представила информацию в виде строки, и затем записала в бинарный файл результат работы метода simplecrypt.encrypt.
Вам необходимо установить библиотеку simple-crypt, и с помощью метода simplecrypt.decrypt узнать, какой из паролей служит 
ключом для расшифровки файла с интересной информацией. Ответом для данной задачи служит расшифрованная интересная информация 
Алисы.
<table border=1>
<tr>
<td valign=top>
Моё:
<pre>
from simplecrypt import decrypt

with open('/home/dmitriy/Python/mypython/encrypted.bin', "rb") as inp:
    encrypted = inp.read()
    #print(encrypted)
with open('/home/dmitriy/Python/mypython/passwords.txt') as passw:
    for lst in passw:
        print(lst)
        try:
            s = decrypt(lst.strip(), encrypted)
        except Exception as e:
            print(f'Произошла ошибка: {e}')
            continue
        else:
            print('shifr=', s)</pre>
</td>
<td>
<pre>
import simplecrypt

encrypted = open("encrypted.bin", "rb").read()
passwords = open("passwords.txt").readlines()

for p in passwords:
    p = p.strip()
    try:
        s = simplecrypt.decrypt(p, encrypted)
    except simplecrypt.DecryptionException:
        continue

    print(s.decode("utf-8"))﻿</pre>
</td></tr></table>
<p>
Еще:
<pre>
import urllib
from simplecrypt import decrypt

ciphertext = <b>urllib.urlopen('https://stepik.org/media/attachments/lesson/24466/encrypted.bin').read()</b>
passwords = urllib.urlopen('https://stepik.org/media/attachments/lesson/24466/passwords.txt')

for password in passwords:
    try:
        plaintext = decrypt(password.strip(), ciphertext)
    except:
        pass
    else:
        print(plaintext)</pre>
<p>
1. Здесь в случае возникновения исключения (ошибка программы просто из-за плохого пароля) в блоке try выполнение программы 
переходит в блок except, там continue, то есть выполняется следующий итератор цикла. В случае, если пароль хороший, то 
выполняется блок else.
<p>
2. Функция strip() без аргументов удаляет в начале и в конце строки пробел. На этом примере, когда смотрел пароли, пробелы не 
видел, но был невидимый пернос строки. Возможно его также удаляет.
<p>
===========================================================================================
<p>
Вам дается текстовый файл, содержащий некоторое количество непустых строк.
На основе него сгенерируйте новый текстовый файл, содержащий те же строки в обратном порядке.
<p>
<table border=1><tr><td>
Моё:
<pre>
with open('/home/dmitriy/Python/mypython/1.txt') as f1:
    lst = f1.readlines() # вывели файл в список
    with open('/home/dmitriy/Python/mypython/2.txt', 'w') as f2:
        for i in range(-1, -len(lst) -1, -1):
            f2.write(lst[i].rstrip('\n') + "\n")</pre>
</td><td>
Не моё:
<pre>
with open('dataset_24465_4.txt', 'r') as fr, open('dataset_24465_4_w.txt', 'w') as fw:
    fw.writelines(fr.readlines()[::-1])</pre>
Ещё:
<pre>
lines = open("input.txt").readlines()
with open("output.txt", "w") as out:
    out.writelines(reversed(lines))</pre>
</td></tr></table>



<h3 align=center>Файл, методы, циклы, списки</h3>

19:50 - 21:30 (1 час и 40 минут)<br>
Имеется файл с данными по успеваемости абитуриентов. Он представляет из себя набор строк, где в каждой строке записана следующ
ая информация: <br>
Фамилия;Оценка_по_математике;Оценка_по_физике;Оценка_по_русскому_языку
<p>
Поля внутри строки разделены точкой с запятой, оценки — целые числа.
<p>
Напишите программу, которая считывает исходный файл с подобной структурой и для каждого абитуриента записывает его среднюю оце
нку по трём предметам на отдельной строке, соответствующей этому абитуриенту, в файл с ответом.
<p>
Также вычислите средние баллы по математике, физике и русскому языку по всем абитуриентам и добавьте полученные значения, разд
елённые пробелом, последней строкой в файл с ответом.
<pre>
d = {} # ключ - фамилия, значение - список из оценок
s = ''
num = 0
familia = []
ball = []
mathem = 0
phizik = 0
rus = 0
with open('/home/dmitriy/Python/mypython/dataset_3363_4.txt') as f:
    s = f.read().strip().split()
    for l in s:
        l = l.split(';')
        # print(l)
        for i in range(len(l)):
            if i % 4 == 0:
                familia.append(l[i])
                num = 0
            elif (i - 3) % 4 == 0:
                ball.append((num + int(l[i])) / 3)
                rus = rus + int(l[i])
            else:
                num = num + int(l[i])
                if (i - 1) % 4 == 0:
                    mathem = mathem + int(l[i])
                elif (i - 2) % 4 == 0:
                    phizik = phizik + int(l[i])
for i in ball:
    print(i)            
print(mathem/len(familia), phizik/len(familia), rus/len(familia))</pre>
<b>Ещё:</b>
<pre>
koll, a1, b1, c1 = 0, 0, 0, 0
with open('dataset_3363_4.txt', 'r') as inf:
    for line in inf:
        line = line.strip().split(';')
        a, b, c = int(line[1]), int(line[2]), int(line[3])
        print((a+b+c)/3)
        koll += 1
        a1 += a
        b1 += b
        c1 += c
print((a1/koll), (b1/koll), (c1/koll))</pre>

<li> <a name="modul"><b>Модули</b><br>
Напишите программу, которая подключает модуль math и, используя значение числа π из этого модуля, находит для переданного ей на
стандартный ввод радиуса круга периметр этого круга и выводит его на стандартный вывод.
<pre>
from math import pi
print(float(input()) * pi * 2)</pre>
<p>
<li> Напишите программу, которая запускается из консоли и печатает значения всех переданных аргументов на экран (имя скрипта 
выводить не нужно). Не изменяйте порядок аргументов при выводе.
<p>
Для доступа к аргументам командной строки программы подключите модуль sys и используйте переменную argv из этого модуля.
<pre>
import sys
print(*sys.argv[1::])</pre>
Метод sys.argv выдаст список, где первый элемент - это имя вызвавшей программы, а следующие - это аргументы программы. Посколь
ку нам не нужно имя программы, то к списку применяем срез.
<br><img src="./images/python_example.png"><br>
Первую и вторую команду применили без среза.<br>
3 команду без звездочки внутри print()
<p>
<li>
Скачайте файл. В нём указан адрес другого файла, который нужно скачать с использованием модуля requests и посчитать число строк в нём.
<p>
Используйте функцию get для получения файла.
<p>
После получения файла вы можете проверить результат, обратившись к полю text. Если результат работы скрипта не принимается, проверьте поле url на правильность. Для подсчёта количества строк разбейте текст с помощью метода splitlines.
<pre>
import requests
# Прочитаем url со скачанного файла
with open('/home/dmitriy/Python/mypython/dataset_3378_2.txt') as f:
    s = f.read()
    # print(s)  #  адрес страницы, которую нужно скачать
r = requests.get(s)  # простой get-запрос
#print('Ответ сервера:', '\n', r.text.splitlines()) # вывод ответа от сервера
#print('Ответ сервера:', '\n', r.text)
for i in r.text.splitlines():
    print(i)
print('количество строк=', len(r.text.splitlines()))
</pre>
<font color=red>SyntaxError: unexpected character after line continuation character</font><br>
Данная ошибка означает, что где-то болтается '\'  вне строки. После того, как в print('Ответ сервера:', <font color=red>\n</font>, r.text) <b>\n</b> заключил в кавычки, ошибка исчезла.
<p>
r = requests.get(s).splitline()  # простой get-запрос<br>
<font color=red>AttributeError: 'Response' object has no attribute 'splitline'</font><br>
Ошибку устранил, когда метод splitline() применил к объекту r.text, а не в команде <b>r = requests.get(s).splitline()</b>, которая вызывала ошибку.
<p>
<li><br>
Имеется набор файлов, каждый из которых, кроме последнего, содержит имя следующего файла.
Первое слово в тексте последнего файла: "We".
<p>
Скачайте предложенный файл. В нём содержится ссылка на первый файл из этого набора.
<p>
Все файлы располагаются в каталоге по адресу:
https://stepik.org/media/attachments/course67/3.6.3/
<p>
Загрузите содержимое ﻿последнего файла из набора, как ответ на это задание.
<pre>
url = 'https://stepik.org/media/attachments/course67/3.6.3/'
import requests
with open('/home/dmitriy/Python/mypython/dataset_3378_3.txt') as f:
    u = f.read()
    # u = u[len(url):]  # из файла dataset_3378_3.txt получаем полный url, поэтому чтобы использовать его в цикле обрезаем
    #print('Адрес 1 файла из набора:', url+u)
    print('Адрес 1 файла из набора:', u)
    # u = requests.get(url + u)
    u = requests.get(u)
k = 0 # счетчик файлов
while True:
    if u.text.split()[0] == 'We':
        break
    u = requests.get(url + u.text)
    print('k=', k, 'адрес следующего файла:', url+u.text)
    k +=1
print('Последний файл:\n\n', u.text)
</pre>
<font color=red>u = requests.get(str(url+u))<br>
TypeError: can only concatenate str (not "Response") to str</font><br>
Так и не смог решить проблему, извращенно сначало первый из набора отдельно вытащил url из файла и только к следующим через цикл посылал запрос. Похоже надо было так: <b>u = requests.get(url + u).text</b>

<p>
Не моё:
<pre>
import requests
url, name = 'https://stepik.org/media/attachments/course67/3.6.3/', '699991.txt'
while <b>name[:2] != 'We':</b>
    name = requests.get(url + name).text
print(name)</pre>
Еще:
<pre>
import requests
with open('dataset_3378_3.txt') as txt:
    a = txt.readline().strip()
print(a)
a = str(requests.get(a).text)
b = 'https://stepik.org/media/attachments/course67/3.6.3/'
while 'we' not in a:
    print(a)
    <b>a = requests.get(b + a).text</b>
print(a)</pre>
<p>
===========================================================================================
<p>
<li> В первой строке дано три числа, соответствующие некоторой дате date -- год, месяц и день.<br>
Во второй строке дано одно число days -- число дней.<br>
Вычислите и выведите год, месяц и день даты, которая наступит, когда с момента исходной даты date пройдет число дней, равное 
days.<br>
Примечание: Для решения этой задачи используйте стандартный модуль datetime.
Вам будут полезны класс datetime.date для хранения даты и класс datetime.timedelta﻿ для прибавления дней к дате.
<p>
<table border=1>
<tr><td rowspan=3 valign=top>
Моё:
<pre>
from datetime import datetime as dt, timedelta

first_date=dt.strptime(input(), '%Y %m %d')
end_date = first_date + timedelta(int(input()))
end_date1 = end_date.strftime('%Y %m %d')
date = end_date1.split()
for i in date:
    print(int(i), end=' ')</pre>
</td>
<td>
Другое:
<pre>
import datetime
inp = datetime.datetime.strptime(input(), "%Y %m %d")
inp += datetime.timedelta(days=int(input())) 
print(f'{inp.year} {inp.month} {inp.day}')

</pre>
</td></tr>
<tr><td>
Другое:
<pre>
import datetime
y, m, d = map(int, input().split())
days = int(input())
current = datetime.date(year=y, month=m, day=d)
current += datetime.timedelta(days=days)
print("{} {} {}".format(current.year, current.month, current.day))</pre>
</td></tr>
<tr>
<td>
Ещё:
<pre>
import datetime
<b>(y,m,d) = [int(n) for n in input().split()]</b>
d = datetime.date(y, m, d)+ datetime.timedelta(int(input()))
print(d.year, d.month, d.day)</pre>
</td></tr></table>
<p>
1. Скажите, пожалуйста, почему datetime.datetime...? А если datetime.strptime, то "datetime не имеет атрибута strptime"
<br>
Потому что метод класса datetime, который преобразует строку в datetime, есть операция datetime.strptime(date_string, format). 
То есть, чтобы корректно написать операцию переформатирования введенной строки в формат даты, мы сначала прописываем класс 
datetime, затем через точку метод datetime.strptime().. в скобках - соответствующие аргументы
</ol>
<p>
=====================================================================================================
<p>
<a name='os'><b>Модуль os</b><br>
Вам дана в архиве (ссылка) файловая структура, состоящая из директорий и файлов.
<br>Вам необходимо распаковать этот архив, и затем найти в данной файловой структуре все директории, в которых есть хотя бы 
один файл с расширением ".py". 
<table border=1><tr><td>
Моё:
<pre>
from os import getcwd, walk, chdir

chdir('/home/dmitriy/Python/mypython/main')
lst = set()
for root, directories, filenames in walk(getcwd()):
    for filename in filenames:
        if filename.endswith('.py'):
            lst.add(root[30::])
for x in sorted(lst):
    print(x)</pre>
</td>
<td valign=top>
Другое:
<pre>
import os

for cur_dir, subdirs, files in os.walk("main"):
    for file in files:
        if file.endswith(".py"):
            print(cur_dir)
            break
</pre>
</tr></table>
<p>
1. os.walk() идет по директориям в алфавитном порядке. За счет этого можно не сортировать итоговый список.<br>
2. chdir - переход на нужную папку<br>
getcwd() - текущая папка<br>
walk(dir) - выдает генератор - итератор, где его элемент состоит из строки (каталог), списка входящих каталогов и еще один 
список из файлов. <br>
3. lst.add(root[30::]) - срез, чтобы обрезать лишний путь к каталогу.
<p>
==========================================================================================================
<p>


<h3 align=center><a name="obiekt">Объекты</h3>
<ol>
<li> Реализуйте программу, которая будет вычислять количество различных объектов в списке.
Два объекта a и b считаются различными, если a is b равно False.
<p>
Вашей программе доступна переменная с названием objects, которая ссылается на список, содержащий не более 100 объектов. Выведите количество различных объектов в этом списке.
<pre>
objects = [1, 2, 1, 5, True, False, True, 'false', [], [1,2], [1,2]]
ans = 1
unik = {id(objects[0])}
massiv = [objects[0]]
for obj in objects: # доступная переменная objects
    if id(obj) in unik:
        continue
    else:
        unik.add(id(obj))
        massiv.append(obj)
        ans += 1

print('Список уникальных объектов = ', massiv)
print('Список ID уникальных объектов = ', unik)
print('Количество уникальных объектов = ', ans)</pre>
Вывод:
<pre>
[1, 2, 5, True, False, 'false', [], [1, 2], [1, 2]]
{9776672, 9461728, 9776704, 9464160, 9776800, 139738779320768, 139738778605952, 139738778694720, 139738778694640}</pre>
Дебильное решение, не учел, что свойство множества принимать только уникальное значение.
<p>
Грамотное другое решение:
<pre>
s=set()
for obj in objects:
    s.add(id(obj))
print(len(s))</pre>

</ol>

<h3 align=center><a name="oop">ООП</h3>
<ol>
<li> Реализуйте класс MoneyBox, для работы с виртуальной копилкой.
<p>
Каждая копилка имеет ограниченную вместимость, которая выражается целым числом – количеством монет, которые можно положить в 
копилку. Класс должен поддерживать информацию о количестве монет в копилке, предоставлять возможность добавлять монеты в 
копилку и узнавать, можно ли добавить в копилку ещё какое-то количество монет, не превышая ее вместимость.
<p>
При создании копилки, число монет в ней равно 0.
Примечание: метод add(self, v) будет вызываться только если can_add(self, v) – True﻿.
<pre>
class MoneyBox:
    def __init__(self, capacity):
        self.capacity = capacity
        
    def can_add(self, v):
        # True, если можно добавить v монет, False иначе
        if self.capacity >= v:
            return True
        else:
            return False

    def add(self, v):
        # положить v монет в копилку
        if self.can_add(v):
            self.capacity -= v</pre>
Блок:
<pre>
if self.capacity >= v:
            return True
        else:
            return False</pre>
можно заменить одной строкой: <b>return self.capacity >= v</b>
<p>
<li> Вам дается последовательность целых чисел и вам нужно ее обработать и вывести на экран сумму первой пятерки чисел из этой 
последовательности, затем сумму второй пятерки, и т. д.
<p>
Но последовательность не дается вам сразу целиком. С течением времени к вам поступают её последовательные части. Например, 
сначала первые три элемента, потом следующие шесть, потом следующие два и т. д.
<p>
Реализуйте класс Buffer, который будет накапливать в себе элементы последовательности и выводить сумму пятерок 
последовательных элементов по мере их накопления.
<p>
Одним из требований к классу является то, что он не должен хранить в себе больше элементов, чем ему действительно необходимо, 
т. е. он не должен хранить элементы, которые уже вошли в пятерку, для которой была выведена сумма.
<p>
Обратите внимание, что во время выполнения метода add выводить сумму пятерок может потребоваться несколько раз до тех пор, 
пока в буфере не останется менее пяти элементов.
<table border=1>
<tr><td>
<b>Моё:</b>
<pre>
class Buffer:
    def __init__(self):
        self.lst = []
               
    def add(self, *a):
        for i in a:  # выводим аргументы в список
            self.lst.append(i)
        # print('self.lst=', self.lst)
        if len(self.lst) <5:
            return
        else:
            while len(self.lst) >= 5:
                print(sum(self.lst[:5:1]))
                del self.lst[0:5]
                
    def get_current_part(self):
        return self.lst</pre>
</td>
<td>
<b>Грамотное решение:</b>
<pre>
class Buffer:
    def __init__(self):
        self.part = []

    def add(self, *a):
        for i in a:
            self.part.append(i)
            if len(self.part) == 5:
                print(sum(self.part))
                self.part.clear()

    def get_current_part(self):
        return self.part</pre>
Сразу считал 5 элементов, суммировал, выводил и удалял их, а не как я, запоминал весь ввод и потом считывал первые 5 элементов.
</td></tr></table>
<p>
----------------------------------------------------------------------------------------------
<p>
<b>Задача:</b> Реализуйте структуру данных, представляющую собой расширенную структуру стек. Необходимо поддерживать 
добавление элемента на вершину стека, удаление с вершины стека, и необходимо поддерживать операции сложения, вычитания, 
умножения и целочисленного деления.
<p>
Операция сложения на стеке определяется следующим образом. Со стека снимается верхний элемент (top1), затем снимается 
следующий верхний элемент (top2), и затем как результат операции сложения на вершину стека кладется элемент, равный top1 + 
top2.
<p>
Аналогичным образом определяются операции вычитания (top1 - top2), умножения (top1 * top2) и целочисленного деления (top1 // 
top2).
<p>
Реализуйте эту структуру данных как класс ExtendedStack, отнаследовав его от стандартного класса list.
<pre>
class ExtendedStack(<b>list</b>):
        
    def sum(self):
        # операция сложения
        self.append(self.pop() + self.pop())
           

    def sub(self):
        # операция вычитания
        self.append(self.pop() - self.pop())
        #print(self.lst) 

    def mul(self):
        # операция умножения
        self.append(self.pop() * self.pop())
        

    def div(self):
        # операция целочисленного деления
        self.append(self.pop() // self.pop())</pre>
1. Здесь поскольку ExtendedStack унаследован от класса list, то при создании экземпляра ExtendedStack нужно в аргументе 
указать список:
<br>my_class = ExtendedStack([1, 2, 3])
<p>
2 момент: self будет <b>равен не my_class</b>, а списку, указанному при создании экземпляра.
<p>
---------------------------------------------------------------------------------
<p>
<b>Задача:</b><br>
Одно из применений множественного наследование – расширение встроенного метода за счет одноименного метода класса.<br>
Например, если нам понадобится логировать какую-то информацию при обращении к методам класса.
<p>
Рассмотрим класс Loggable:
<pre>
import time

class Loggable:
    def log(self, msg):
        print(str(time.ctime()) + ": " + str(msg))</pre>
У него есть ровно один метод log, который позволяет выводить в лог (в данном случае в stdout) какое-то сообщение, добавляя при 
этом текущее время.<br>
Реализуйте класс LoggableList, отнаследовав его от классов list и Loggable таким образом, чтобы при добавлении элемента в 
список посредством метода append в лог отправлялось сообщение, состоящее из только что добавленного элемента.
<br>Примечание: Ваша программа не должна содержать класс Loggable. При проверке вашей программе будет доступен этот класс, и 
он будет содержать метод log, описанный выше.
<p>
<b>По существу нужно расширить функционал обычного метода append, чтобы дополнительно еще шла запись в лог.</b>
<p>
<table border=1><tr><td valign=top>
<pre>
#!/usr/bin/env python3
import time

class Loggable:
    def log(self, msg):
        print(str(time.ctime()) + ": " + str(msg))
        
class LoggableList(list, Loggable):
           
    def append(self, elem): 
        <font color=red>list.append(self, elem)</font>
        super().log(elem)
</pre></td>
<td>
<b>Выполнение:</b>
<pre>
dmitriy@945G-M3:~$ python3 -i ~/Python//mypython/1.py
>>> my_class = LoggableList()
>>> my_class.__dict__()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'dict' object is not callable
>>> <font color=red>my_class.__dict__
{}</font>
>>> my_class
[]
>>> my_class.append(5)
Fri Nov  1 13:40:58 2024: 5
>>> my_class
[5]
>>> my_class2 = LoggableList([1, 2, 3, 4])
>>> my_class2
[1, 2, 3, 4]
>>> my_class2.append(5)
Fri Nov  1 13:46:07 2024: 5
>>> my_class2
[1, 2, 3, 4, 5]
>>> <font color=red>self</font>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in <module>
NameError: name 'self' is not defined
>>> my_log.log('hhhh')
Fri Nov  1 15:10:24 2024: hhhh
>>> type(my_log)
&lt;class '__main__.Loggable'&gt;
>>> my_log.__dict__
{}
>>> my_log.append(5)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in <module>
AttributeError: 'Loggable' object has no attribute 'append'
>>> type(my_class)
&lt;class '__main__.LoggableList'&gt;
</pre>
</td></tr></table>
<p>
1. Непонятно, когда нужно создавать конструктор класса, когда нет. В данной задаче с конструктором с аргументом lst stepik 
решение не принимал.<br>
Думал, что только через конструктор можно создать экземпляр с конкретным списком, но нет, в примере выше создал my_class2 со 
списком [1, 2, 3, 4]
<p>
2. Непонятно что с  self
<p>
3. Почему при вызове my_class.__dict__ ответ - пустой словарь {}. Нет скажем атрибута append()
<p>
4. Почему при вызове метода append() его нужно вызывать из класса list.
<br>Если self.append(elem), то возникает бесконечная рекурсия, т.к. интерпретатор ищет append в классе LoggableList.<br>
Но опять же почему в классе LoggableList нет метода append. Если родителем является list, то вроде как экземпляр должен 
унаследовать его методы в том числе append.
<p>
<b>Другое грамотное решение:</b>
<pre>
class LoggableList(list, Loggable):
    def append(self, x):
        list.append(self, x)
        self.log(x)
</pre>
<font color=red>Непонятно почему при вызове метода log() из родительского класса не используется функция super()</font><br>
<i>Полагаю, прямое обращение self.log(x) в данном случае работает просто быстрее и чуть короче в коде, чем super().log(x). 
Другого принципиального отличия не вижу. Исходя из описания вот тут https://docs.python.org/3/library/functions.html?
highlight=super#super﻿ ни что не мешает в этом примере использовать super() для доступа к родительскому методу даже без его 
модификации.</i>
<p>
<b>Почему  в строке: list.append(self, x) метод  append принимает self ?</b><br>
<i>мы обращаемся к методу класса а не его экземпляра, в этом случае нужно передать и значение для self, если бы мы обращались 
к нему как к экземпляру, тогда было бы self.append(x)</i>
<pre>
>>> a = [1, 2]
>>> b = 5
>>> list.append(a, b)
>>> a
[1, 2, 5]
>>> a.append(6)
>>> a
[1, 2, 5, 6]
</pre>
============================================================================================================
<p>
<h3 align=center>Исключения</h3>
Реализуйте класс PositiveList, отнаследовав его от класса list, для хранения положительных целых чисел.
Также реализуйте новое исключение NonPositiveError.
<p>
В классе PositiveList переопределите метод append(self, x) таким образом, чтобы при попытке добавить неположительное целое 
число бросалось исключение NonPositiveError и число не добавлялось, а при попытке добавить положительное целое число, число 
добавлялось бы как в стандартный list.
<br>В данной задаче гарантируется, что в качестве аргумента x метода append всегда будет передаваться целое число.
<br>Примечание: Положительными считаются числа, строго большие нуля.'''
<pre>
class  NonPositiveError(Exception):
    print(x, 'меньше нуля')
    
class PositiveList(list):
    def append(self, x):
        if x <= 0:
                raise NonPositiveError(x)
        else:
            list.append(self, x)</pre>
===============================================================================
<p>
<h3 align=center><a name="iterator">Итерирование классов</h3>
Задача по перебору класса:<br>
На вход класса подаем итерируемый объект. Функция класса - перебрать этот объект и выдать в итоге отфильтрованный объект.
<p>
<table border=1><tr><td>
Моё:
<pre>
class multifilter:
    def judge_half(pos, neg):
        # допускает элемент, если его допускает
        # хотя бы половина фукнций (pos >= neg)
        <font color=red>if pos >= neg:
            return True
        else:
            return False</font>
                
    def judge_any(pos, neg):
        # допускает элемент, если его допускает
        # хотя бы одна функция (pos >= 1)
        if pos >= 1:
            return True
        else:
            return False
            
    def judge_all(pos, neg):
        # допускает элемент, если его 
        # допускают все функции (neg == 0)
        if neg ==0:
            return True
        else:
            return False    

    def __init__(self, iterable, *funcs, judge=judge_any):
        # создаем экземпляр класса multifilter
        self.iterable = iterable
        self.judge = judge
        <font color=red>self.funcs = []
        for i in funcs:
            self.funcs.append(i)</font>
        
    def __iter__(self):
        for i in self.iterable:
            self.pos = 0
            self.neg = 0
            for f in self.funcs:
                if f(i):
                    self.pos += 1
                else:
                    self.neg += 1
            if self.judge(<font color=red>self.pos, self.neg</font>):
                yield i</pre>
</td>
<td valign=top>
Другое:
<pre>
class multifilter:
    def judge_half(pos, neg):
        <font color=green>return pos >= neg</font>

    def judge_any(pos, neg):
        return pos > 0

    def judge_all(pos, neg):
        return neg == 0

    def __init__(self, iterable, *funcs, judge=judge_any):
        self.iterator = iter(iterable)
        <b>self.funcs = funcs</b>
        self.judge = judge

    def __iter__(self):
        return self

    def __next__(self):
        while (True):
            elem = next(self.iterator)
            pos, neg = 0, 0
            for func in self.funcs:
                if func(elem):
                    pos += 1
                else:
                    neg += 1

            if self.judge(pos, neg):
                return elem</pre>
</td></tr></table>
<p>
<b>Выполнение:</b>
<pre>
def mul2(x):
    return x % 2 == 0

def mul3(x):
    return x % 3 == 0

def mul5(x):
    return x % 5 == 0

a = [i for i in range(31)] # [0, 1, 2, ... , 30]

print(list(multifilter(a, mul2, mul3, mul5))) 
# [0, 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28, 30]

print(list(multifilter(a, mul2, mul3, mul5, judge=multifilter.judge_half))) 
# [0, 6, 10, 12, 15, 18, 20, 24, 30]

print(list(multifilter(a, mul2, mul3, mul5, judge=multifilter.judge_all))) 
# [0, 30]</pre>





<h3 align=center><a name="gener">Функции-итераторы</h3>
Реализуйте функцию-генератор primes, которая будет генерировать простые числа в порядке возрастания, начиная с числа 2.
<table border=1><tr>
<td>
Первоначальный вариант:
<pre>
def primes(*args):
    lst = args
    print(lst)
    print(type(lst))
    count = 0
    for i in lst:
        if i < 2:
            continue
        for k in range(2, i + 1):
            if k % i:
                count +=1
        if count == 2:
            yield i
</pre>
</td>
<td valign=top>
Итоговое решение:
<pre>
import itertools
def primes():
    a = 1
    while True:  # просто пример
        count = 0
        a += 1
        for i in range(1, a + 1):
            if a % i == 0:
                count +=1
        if count == 2:
            yield i</pre>
</td>
</tr></table>
1. Как реализовать бесконечный диапазон?<br>
2. Где начнется выполняться функция при повторном ее вызове?<br>
3 lst = [args] <font color=red>not supported between instances of 'tuple' and 'int'</font><br>
4. Первоначальный вариант был ошибочен из-за команды проверки: <i>print(list(itertools.takewhile(lambda x : x <= 31, 
primes())))</i>





</div>
<br><br><br><br></body></html>
