<html><head>
<style>
.menu {
       height: 100%;
       width: 160px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  */color: #818181;
  display: block;
          }     
.content {
           margin-left: 170px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>ROS</title>
<div class="menu">
<a href="index.html">Начальная</a><br>
<a href="ros_set.html">Установка / настройка ROS</a>
<a href="ros_message.html">Сообщения</a>
<a href="ros_service.html">Сервисы (services)</a>
<a href="ros_message.html">Сообщения</a>
<a href="rosparam.html">Сервер параметров (Parameter Server)</a>
<a href="rostutorials.html">Перевод учебника</a>
<a href="ros_rqt.html">Графические утилиты</a>
<a href="ros_launch.html">Команда roslaunch</a>
<a href="ros_control.html">ROS Control</a>
<a href="ros_difficult.html">Средний уровень</a>
<a href="ros2.html">ROS2</a><br>
Основы:
<a href="#ros_file">Файловая система</a>
<a href="#master">Мастер ROS</a>
<a href="#node">Ноды</a>
<a href="#server_param">Сервер параметров</a>
<a href="#services">Сервисы (Services)</a>
<a href="#message">Сообщения (Messages)</a>
<a href="#topics">Топики (Topics)</a>
</div>
<div class="content">
<h2 align=center>Основы ROS</h2>
Ссылки: <a href="https://copter-space.gitbook.io/uchebnik-mashinnoe-zrenie-tom-2/razdel-2/osnovnye-koncepcii-sistemy-ros">Основные концепции системы ROS</a>
<p>
ROS служит для связи между компьютером и роботом. Например, для перемещения рук робота выдается команда ROS, или разработчики роботов пишут сценарии на Python или C++, которые заставляют робота выполнять команды. Сценарии, в свою очередь, могут вызывать различные управляющие программы, которые вызывают фактическое движение рук робота. С помощью ROS также можно спроектировать и смоделировать своего собственного робота. 
<a name="ros_file"><h3 align=center>Файловая система ROS</h3>
<b>Пакеты (Packages)</b>:<br>
Пакет – основная единица файловой системы ROS. Пакет содержит выполняемые процессы ROS (узлы или ноды - nodes), библиотеки на основе ROS, наборы данных, конфигурационные файлы и прочие полезные данные. Пакет – это минимальная единица для компиляции и релиза в ROS.
<h4>Команды для работы с пакетами:</h4>
<ul>
<li> Поиск пакета:
<pre>
 <font color="green">rospack find &lt;package_name></font>
</pre>
<img src="./images/rospack1.png">
<p>
Команда rospack find &lt;имя пакета> возвращает путь к пакету с именем &lt;имя пакета>.
<p>
<font color="green"><b>rospask list</b></font><br>
Выводит список имен пакетов ROS и каталоги.
<p>
<img src="images/ros.png">
<p>
Более 200 пакетов ros в моей системе установлено.
<p>
<li> <b>roscd:</b> переход к указанному пакету.
<pre>
<font color="green">roscd &lt;package-or-stack&gt;[/subdir]</font>
</pre>
<img src="./images/roscd.png">
<p>
<li> Чтобы увидеть список каталогов, где находятся пакеты, служит команда:
<pre>
 <font color="green">echo $ROS_PACKAGE_PATH</font>
</pre>
<p>
<li> <font color="green">roscd log</font><br>
приведет вас к папке, в которой хранятся файлы журнала ROSS. Обратите внимание, что если вы еще не запускали какие-либо программы для ROS, это приведет к ошибке, указывающей на то, что они еще не существуют.
<p>
<li> <font color="green">rosls &lt;package-or-stack&gt;[/subdir]</font><br>
показывает состав пакета, обращаясь к нему по имени, а не по абсолютному пути.
<p>
<pre>
dmitriy@945G-M3:~$ rosls turtlesim
cmake  images  msg  package.xml  srv
</pre>
<font color=red>И где тут нода turtlesim_node?</font>
<p>
Если после <b>rosls</b> несколько раз нажать TAB, то выведет список установленных пакетов. У меня 318
<p>
Если после <b>ros</b> несколько раз нажать TAB, то выведет все доступные команды для ROS .
</ul>
<li> <b>Метапакеты (Metapackages)</b>: Метапакеты – это специализированные Пакеты, используемые для группировки других взаимосвязанных Пакетов. Используются также для обратной совместимости.
<p>
<li> <b><a href="https://wiki.ros.org/catkin/package.xml">Манифесты Пакетов (Package Manifests)</a></b>: Каждый пакет содержит файл package.xml . Это так называемый манифест пакета, он содержит данные о пакете, включая имя, версию, описание, информацию о лицензировании, зависимости и прочую информацию, такую как экспортируемые пакеты.
<p>
<li> <b>Репозитории (Repositories)</b>: набор пакетов, принадлежащих одной и той же версии. Пакеты одной и той же системы контроля версий и одинаковой версии могут выпускаться вместе с помощью инструмента автоматизации релизов bloom (http://wiki.ros.org/bloom). Репозиторий также может содержать только один пакет.

<li> <b>Типы сообщений (Message types)</b>: описание сообщений, хранится в my_package/msg/MyMessageType.msg, определяет структуры данных для сообщений, передаваемых в ROS.

<li> <b>Типы сервисов (Service types)</b>: описание сервисов, хранится в my_package/srv/MyServiceType.srv, определяет структуры данных для запроса и ответа сервисов в ROS.

<li> <b>Рабочая область (Workspace)</b> в ROS — это папка, где разработчики создают, собирают и настраивают свои пакеты и программы. Содержит исходный код, пакеты и сборочные скрипты.<br>
Основная структура:
<ul>
<li> src: директория исходного кода, где хранятся пакеты ROS
<li> build: временная директория, используемая во время сборки пакетов
<li> devel: содержит файлы, необходимые для запуска программ после сборки, включая исполняемые файлы и среду окружения
</ul>
</ul>

<h3 align=center>Граф вычислений ROS</h3>
Граф вычислений ROS – это список программ, запускаемых при запуске робота. Основные программы из графа вычислений – это ноды, Мастер (Master), Сервер Параметров (Parameter Server), сообщения (messages), сервисы (services), топики (topics), контейнеры (bags). Все эти сущности передают данные для вычислительного графа ROS разными способами.
<a name="master"><h4 align=center>Мастер ROS</h4>
При запуске робота первым всегда открывается мастер.
Мастер выполняет роль сервера имен для возможности подключения между собой различных нод. Связь между нодами (обмен сообщениями), невозможна без запущенного мастера. Запускается командой:
<p>
<font color=green>roscore</font>
<p>
Кроме мастера будет запущен <b>сервер параметров</b> и нода rosout, служающая для логирования.
При запуске Мастер будет запущен по адресу URI, установленным в переменной окружения ROS_MASTER_URI. По умолчанию адрес использует IP-адрес локального ПК и номер порта 11311
<p>
<img src="images/ros1.png">
<p>
Видно, что также запустился сервер roslaunch и можно увидеть pid запущенных процессов.
<p>
<i>При выполнении команды roslaunch вызывать отдельно мастера не надо, он вызывается автоматически.</i>
<a name="node"><h4 align=center>Ноды (Nodes)</h4>
Одной из основных задач ROS является взаимодействие между модулями ROS, называемых нодами. Эти ноды представляют собой скрипты, обычно написанные на Python или C++, которые могут находиться полностью на одном компьютере, или могут быть распределены между разными компьютерами или между компьютером и роботом. Преимущество такой распределенной структуры заключается в том, что каждый узел может управлять одним из механизмом робота. Например один узел может захватывать и выводить изображения с камеры, а другой узел может управлять манипулятором робота в ответ на вид с камеры.
<p>
Ноды бывают <b>публикуемые</b>, это которые передают данные и ноды - <b>подписчики</b>, это которые получают данные. Взаимодействие нод осуществляется через <b>топики.</b>
<p>
При запуске нода регистрирует информацию о себе на мастере (название ноды, типы обрабатываемых сообщений). Зарегистрированная нода может взаимодействовать с другими нодами (получать и отправлять запросы). Важно отметить что обмен сообщениями между нодами работает без участия мастера (соединение между нодами происходит напрямую через топик). Мастер обеспечивает только единое пространство имен для решения вопроса куда подключиться к конкретной ноде. Адрес запуска ноды, берётся из переменной окружения ROS_HOSTNAME, которая должна быть определенна до запуска. Порт устанавливается на произвольное уникальное значение.
<p>
<b>Запуск ноды turtlesim</b><br>
Ссылки: <a href="https://se.moevm.info/doku.php/courses:ros:class2">Занятие № 2: Детальное представление о среде</a>
<p>
Прежде чем выполнять запустить ноду и выполнять команды над ней, следует вызвать мастера ROS, команда:
<p>
<font color="green">roscore</font><br>
<p>
И после этого в другом терминале выполнять команды.<br>
Если вы хотите чтобы roscore запустился в фоновом режиме, то запустите его командой:<br>
<p>
<font color=green>roscore &</font>
<p>
<b>Запуск нод</b><br>
Запуск нод в ROS осуществляется при помощи команды <b>rosrun</b>. Общий синтаксис употребления этой команды выглядит так:
<p>
<font color=green>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>rosrun &lt;пакет&gt; &lt;нода&gt; [&lt;имя параметра&gt;:=&lt;значение&gt;]</b></font>
<p>
Причём в графе &lt;нода> указывается не произвольное имя новой ноды, а класс-тип нод, экземпляр которого нужно запустить (<i>что-то питоновское</i>). Непосредственно имя ноды устанавливается через параметры.
<p>
Запустим ноду класса turtlesin_node внутри пакета turtlesim.
<pre>
rosrun turtlesim turtlesim_node
</pre>
<br>
Будет запущена нода типа turtlesim_node из пакета turtlesim. Имя ноды в данном случае не указывалось и оно присвоится автоматически.
<p>
<b>Список запущенных нод:</b>
<pre>
<font size=4 color=green>rosnode list</font>
</pre>
Будет выведено следующее:
<pre>
/rosout   
/turtlesim
</pre>
Таким образом создалась нода с именем /turtlesim и определённая в глобальном поле имён, о чём говорит предшествующий символ слеш “/”. Если в новом терминале вновь будет выполнена команда:<br>
<b>rosrun turtlesim turtlesim_node</b><br>
То создастся новая нода с тем же именем /turtlesim. Это вызовет аварийную остановку уже созданной ноды:
<pre>
[ WARN] [1740472774.740801921]: Shutdown request received.
[ WARN] [1740472774.740992774]: Reason given for shutdown: [[/turtlesim] Reason: new node registered with same name]
</pre>
И первая нода закроется.
<p>                                        
Для того, чтобы указать имя ноды, при её создании необходимо присвоить значение переменной __name (с двумя символами нижнего подчёркивания). Таким образом, чтобы создать ноду с именем “turtle_node” необходимо выполнить команду:<br>
<b>rosrun turtlesim turtlesim_node __name:=turtle_node</b>
<pre>
dmitriy@945G-M3:~$ rosnode list
/rosout
<b>/turtle_node</b>
/turtlesim
</pre>
<b>Пинг ноды:</b><br>
<font color="green">rosnode ping [node_name]</font> - пингуем ноду, чтобы проверить, что она запущена.
<p>
<b>Информация о ноде:</b>
<pre>
<font color=green>rosnode info name_node</font>
</pre>
Например информация о turtle_node:
<pre>
dmitriy@945G-M3:~$ rosnode info /turtle_node
--------------------------------------------------------------------------------
Node [/turtle_node]
Publications: 
 * /rosout [rosgraph_msgs/Log]
 * /turtle1/color_sensor [turtlesim/Color]
 * /turtle1/pose [turtlesim/Pose]

Subscriptions: 
 * /turtle1/cmd_vel [unknown type]

Services: 
 * /clear
 * /kill
 * /reset
 * /spawn
 * /turtle1/set_pen
 * /turtle1/teleport_absolute
 * /turtle1/teleport_relative
 * /turtle_node/get_loggers
 * /turtle_node/set_logger_level


contacting node http://localhost:33307/ ...
Pid: 10018
Connections:
 * topic: /rosout
    * to: /rosout
    * direction: outbound (58135 - 127.0.0.1:51038) [27]
    * transport: TCPROS
</pre>
<pre>

</pre>
<a name="server_param"><h3 align=center>Сервер параметров (Parameter Server)</h3>
Ссылки: <a href="https://wiki.ros.org/Parameter%20Server">Parameter Server</a><br>
<a href="rosparam.html">Подробнее о сервере параметров</a>
<p>
Сервер параметров - это общий словарь параметров к которым ноды обращаются во время своей работы. Сервер Параметров запускается вместе с Мастером.<br>
Параметры в ROS представляют собой глобальные значения, которые можно использовать для настройки поведения нод. rosparam позволяет хранить данные на сервере параметров ROS и манипулировать ими. Сервер параметров может хранить целые числа, значения с плавающей запятой, логические значения, словари и списки. Для синтаксиса rosparam использует язык разметки YAML. В простых случаях YAML выглядит очень естественно: 1 - целое число, 1.0 - число с плавающей точкой, "единица" - строка, true - логическое значение, [1, 2, 3] - список целых чисел, {a: b, c: d} - словарь.
<h4>Команды rosparam:</h4>
Для работы с сервером параметров служит команда rosparam .<br>
<ul>
<li> <b>rosparam list</b><br>
посмотреть список параметров. Например, если запущена нода turtlesin, то:
<pre>
dmitriy@945G-M3:~$ rosparam list
/rosdistro
/roslaunch/uris/host_localhost__38239
/rosversion
/run_id
/turtlesim/background_b
/turtlesim/background_g
/turtlesim/background_r
</pre>
<li> <b>rosparam set &lt;parameter-name&gt; [parameter-value]</b><br>
Установит для параметра значение [parameter-value]. [parameter-value] является обязательным, если не указаны --textfile или --binfile.
<p>
Пример: сделать фон для экрана с черепашкой красным:
<pre>
rosparam set background_b 0
rosparam set background_g 0
rosparam set background_r 255
rosservice call /clear
</pre>
Последняя команда, чтобы экран изменился.
<p>
<li> <b>rosparam get &lt;parameter-name&gt;</b><br>
Получить значение параметра &lt;parameter-name&gt;<br>
-p - Выводится красивым шрифтом. ВНИМАНИЕ: это небезопасно для YAML.<br>
-v - Показывать подробные выходные данные.
<p>
Пример: запущена нода turtlesim, узнать все параметры:
<pre>
<b>rosparam get /</b>
rosdistro: 'noetic

  '
roslaunch:
  uris:
    host_localhost__38239: http://localhost:38239/
rosversion: '1.17.0

  '
run_id: ade22948-f332-11ef-8ab0-fbf970fd87d7
turtlesim:
  background_b: 255
  background_g: 86
  background_r: 250
</pre>
<p>
<li> <b>rosparam load &lt;yaml-file&gt; [namespace]</b><br>
Загрузит параметры из файла YAML в указанное [пространство имен] (по умолчанию /). ПРИМЕЧАНИЕ: это добавит дополнительные значения к текущим.<br>
<b>-v</b> Показывать подробные выходные данные.
<li> <b>rosparam dump &lt;file&gt;</b><br>
Перенесёт содержимое сервера параметров в формате YAML в файл file.yaml.<br>
rosparam dump &lt;file&gt; &lt;namespace&gt;<br>
Выводит только параметры в указанном пространстве имен.<br>
-v Подробный вывод. например:
<pre>
rosparam dump -v gains.yaml /gains
dumping namespace [/gains] to file [gains.yaml]
/gains/i=1.0
/gains/p=1.0
/gains/d=1.0</pre>
<li> <b>rosparam delete &lt;parameter-name&gt;</b><br>
Удалит значение параметра.
</ul>
Аргументы командной строки для команды rosparam соответствуют переменной окружения ROS_NAMESPACE (см. раздел Переменные окружения). Имена параметров, которые не заданы глобально, разрешаются в соответствии с параметром ROS_NAMESPACE.
<br>ПРИМЕЧАНИЕ: get и dump - это, по сути, одна и та же команда, как и set и load, с единственной разницей в том, используется файл или нет.
<p>
<a name="services"><h3 align=center>Сервисы (Services)</h3>
Модель публикации/ подписки является очень гибкой, но её схема односторонней передачи сообщений «многие-многим» не подходит для взаимодействий типа «запрос-ответ», которые часто нужны в распределённой системе. Механизм «запрос-ответ» реализован через Сервисы. Сервис определяется парой структур сообщений – одна для запроса и одна для ответа. Нода предоставляет сервис, используя определённое Имя сервиса, клиент использует сервис, отправляя сообщение-запрос и ожидая ответа. Клиентские библиотеки ROS обычно представляют это взаимодействие для программиста в виде вызова удалённой процедуры.<br>
<b>Некоторые команды с сервисами:</b>
<ul>
    <li> Показать список активных сервисов: <font color=green>rosservice list</font>
    <li> Вызвать сервис с определёнными аргументами: <font color=green>rosservice call</font>
</ul>
Сервисы настраиваются в файлах .srv Файлы .srv описывают типы сервисов в ROS: определяют структуры данных, которые сервис принимает и возвращает. Каждый .srv файл содержит две части: запрос (Request) и ответ (Response), разделённые символом "---"
<ul>
    <li> Показать структуру .srv-файла для заданного типа сервиса: <font color="green">rossrv show [service_type]</font>
</ul>
<a name="message"><h3 align=center><a href="ros_message.html">Сообщения (Messages)</a></h3>
Ноды отправляют и принимают данные между собой по определённому формату через топики. Эти данные называются Сообщениями, а формат сообщений Типом Сообщения. Команды над сообщениями - это rostopic и rosmsg.
<a name="topics"><h3 align=center>Топики (Topics)</h3>
Сообщения передаются через механизм публикации/подписки. Нода отправляет сообщение, публикуя (publish) его в определённом Топике. Топик – это имя, идентифицирующее содержание сообщения. Нода, заинтересованная в определённых данных, осуществляет подписку (subscribe) на соответствующий Топик. Для одного топика может существовать несколько параллельно публикующих/подписанных на него Нод, равно как и одна Нода может публиковать сообщения в и/или подписываться на несколько Топиков. В общес случае, публикаторы/подписчики не оказывают влияния друг на друга. Идея заключается в отделении производства информации от её использования. Логически Топик может быть представлен как строго типизированная шина сообщений. У каждой шины есть наименование, и любой элемент может подсоединиться к шине для получения и отправки сообщений соответствующего типа.
<ul>
    <li> Топик (тема) — это имя для потока сообщений
    <li> Узлы общаются между собой посредством топиков
    <li> Узлы могут публиковать или подписываться на топик
    <li> Как правило, у топика один издатель и n подписчиков
</ul>
<h4>Команды rostopic:</h4>
<ul>
<li> <font color="green">rostopic echo [topic]</font> - показывает данные, публикуемые в топик.
<li> <font color="green">rostopic list</font> - возвращает список всех топиков, на которые в данный момент подписаны и которые публикуют.<br>
Опции этой команды:
<ul>
<li> -h, --help            show this help message and exit
<li> -b BAGFILE, --bag=BAGFILE  список топиков в .bag file
<li> -v, --verbose  дополнительно показывает сколько подписчиков и публицистов на топики завязано.
<li> -p список только публицистов
<li> -s список только подписчиков
</ul>
<img src="images/rostopic_list.png">
<li> <b>Тип сообщений:</b><br>
Ноды общаются между собой с помошью messages (сообщений). Чтобы ноды понимали друг друга, сообщения должны иметь одинаковый тип. Чтобы узнать тип сообщений, служит команда:
<pre>
<font color="green">rostopic type [name_topic]</font>
</pre>
Вернёт тип (имя) сообщений, используемого для топика в формате имя пакета/тип сообщения:
<p>
[package name]/[message type]
</p>
<p>
<img src="images/rostopic_type.png">
<p>
Узнать для конкретного пакета какие он использует типы сообщений, команда:
<pre>
<font color=green>rosmsg list | grep name_package</font>
</pre>
Например:<br>
rosmsg list | grep turtlesim<br>
покажет:
<pre>
turtlesim/Color
turtlesim/Pose
</pre>
<p>
Зная тип (имя) сообщения, можем посмотреть формат этого сообщения, команда:
<pre>
<font color="green">rosmsg show [message_type]</font>
</pre>
Например:
<pre>
dmitriy@945G-M3:~$ rosmsg show turtlesim/Color
uint8 r
uint8 g
uint8 b
</pre>
Формат, обозначающий цвета красный (r), зеленый (g) и синий (b), представляет собой 8-разрядное целое число без знака.
<p>
Чтобы определить сочетание цветов красного, зеленого и синего на фоне нашей черепашки, воспользуйтесь командой:
<pre>
 rostopic echo [name_topic]
</pre>
в следующей форме:<br>
rostopic echo /turtle1/color_sensor
<p>
Получим поток сообщений, публикуемых в топик /turtle1/color_sensor:
<pre>
r: 69
g: 86
b: 255
</pre>
<li> <b>Отправка сообщений в топик:</b><br>
Зная тип (имя) сообщений, мы можем отправлять их ноде через топик, тем самым управлять нодой.<br>
Синтаксис:<br>
<font color="green">rostopic pub [topic] [msg_type] [args]</font><br>
публикует данные по объявленному топику.<br>
<img src="images/rostopic_pub.png">
<ul>
<li> <b>-1</b> Этот параметр приводит к тому, что rostopic публикует только одно сообщение, а затем завершает работу
<li> <b>/turtle1/cmd_vel</b> - это имя топика, в который отправляем (публикуем) сообщение
<li> <b>geometry_msgs/Twist</b> - это тип (имя) сообщения, которое отправляем в топик.
<li> <b>--</b> - этот параметр (двойное тире) указывает анализатору параметров, что ни один из следующих аргументов не является параметром. Это необходимо в тех случаях, когда ваши аргументы начинаются с тире -, например, с отрицательных чисел.
<li> <b>'[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'</b> - сообщение geometry_msgs/Twist содержит два вектора по три элемента с плавающей запятой в каждом: линейный и угловой. В этом случае, '[2.0, 0.0, 0.0]' становится линейным значением при x=2.0, y=0.0 и z=0.0, а '[0.0, 0.0, 1.8]' - угловым значением при x=0.0, y=0.0 и z=1.8. Эти аргументы приведены в синтаксисе YAML.<br>
Чтобы не запоминать формат сообщения, можно после типа сообщения дважды нажать клавишу tab. Это выпишет имена полей и рядом начальные значения, которыми они инициализируются. Далее их можно изменить.
</ul>
<p>
Мы можем опубликовать постоянный поток команд, используя опцию -r:<br>
<img src="./images/ros10.png">
<p>
<font color="green">rostopic hz [topic]</font> - сообщает о скорости публикации данных в [topic].
</ul>
Весь список команд rostopic:
<ul>
<li> rostopic bw     Показать занимаемый сетевой канал
<li> rostopic echo   Вывести сообщения на экран
<li> rostopic find   Поиск топика по типу
<li> rostopic hz     Показать частоту обновления топика
<li> rostopic info   Показать информацию о топике
<li> rostopic list   Показать список существующий топиков
<li> rostopic pub    Опубликовать данные в топик
<li> rostopic type   Показать тип сообщения для топика
</ul>


<h4>Контейнеры (Bags)</h4>
Контейнеры предоставляют форматы для записи и воспроизведения потоков ROS-сообщений. Контейнеры являются важным механизмом для записи данных, например, данных с сенсоров, которые трудно собрать, но необходимо сохранять для разработки и тестирования алгоритмов.
<pre>

</pre>
<h3 align=center><a name="name">Имена</h3>
Ссылки: <a href="https://wiki.ros.org/Names">Names</a>
<p>
Имена ресурсов графа представляют собой иерархическую структуру имен, которая используется для всех ресурсов в графе вычислений ROS, таких как узлы, параметры, разделы и службы. Эти имена очень важны в ROS и играют центральную роль в создании более крупных и сложных систем в ROS, поэтому очень важно понимать, как работают эти имена и как вы можете ими манипулировать.
<p>
Любой топик, сервис или параметр идентифицируется с помощью уникального имени. ROS-имя представляет собой иерархическую структуру с символом / в качестве разделителя (сходно с именами в файловой системе).<br>
Примеры ROS-имен:<br>
/ (глобальное пространство имен)<br>
/foo<br>
/stanford/robot/name<br>
/wg/node1
<p>
Имена разрешаются относительно, поэтому ресурсам не нужно знать, в каком пространстве имен они находятся. Это упрощает программирование, поскольку узлы, которые работают вместе, могут быть записаны так, как если бы все они находились в пространстве имен верхнего уровня. Когда эти узлы интегрируются в более крупную систему, их можно поместить в пространство имен, определяющее их набор кода. Например, можно взять демонстрационную версию Stanford и демонстрационную версию Willow Garage и объединить их в новую демонстрационную версию с подграфами stanford и wg. Если бы у обеих демонстраций был узел с именем "camera", они бы не конфликтовали. Инструменты (например, визуализация графика), а также параметры (например, demo_name), которые должны быть видны всему графику, могут быть созданы узлами верхнего уровня.
<h4>Допустимые имена</h4>
Допустимое имя имеет следующие характеристики:
<ol>
<li> Первый символ - это буквенный знак ([a-z|A-Z]), тильда (~) или косая черта (/)
<li> Последующие символы могут быть буквенно-цифровыми ([0-9|a-z|A-Z]), символами подчеркивания (_) или косой черты (/).
</ol>
<p>
В ROS существует четыре типа имен графических ресурсов: базовые, относительные, глобальные и частные, которые имеют следующий синтаксис:
<ul>
<li> base<br>
Имена без каких-либо определителей пространства имен являются базовыми именами. Базовые имена на самом деле являются подклассом относительных имен и имеют те же правила разрешения. Базовые имена чаще всего используются для инициализации имени узла.
<li> relative/name<br>
По умолчанию разрешение выполняется относительно пространства имен узла. Например, узел /wg/node1 имеет пространство имен /wg, поэтому имя node2 будет преобразовано в /wg/node2.
<li> /global/name<br>
Имена, начинающиеся с "/", являются глобальными - они считаются полностью разрешенными. По возможности следует избегать глобальных имен, поскольку они ограничивают переносимость кода.
<li> ~private/name<br>
Имена, начинающиеся с "~", являются частными. Они преобразуют имя узла в пространство имен. Например, узел 1 в пространстве имен /wg/ имеет частное пространство имен /wg/node1. Личные имена полезны для передачи параметров определенному узлу через сервер параметров.
</ul>
<p>
Вот несколько примеров разрешения имен:<br>
<img src="./images/ros4.png">
<p>
Приватное имя<br>
Каждая нода может использовать собственное приватное пространство имен (соответствующее имени ноды) для своих ресурсов. Например, нода aruco_detect может публиковать такие топики:<br>
/aruco_detect/markers<br>
/aruco_detect/visualization<br>
/aruco_detect/debug<br>
Когда нода ссылается на свой приватный ресурс, вместо пространства имен (/aruco_detect/) используется символ ~, например:<br>
~markers<br>
~visualization<br>
~debug<br>
Таким образом, создание топика foo в приватном пространство имен из Python будет выглядеть так:<br>
private_foo_pub = rospy.Publisher('~foo', String, queue_size=1)
<p>
Относительное имя<br>
Несколько нод также могут объединяться в общее пространство имен (например, при одновременной работе нескольких роботов). Для того, чтобы ссылаться на топики с учетом общего пространства имен, в названии ресурса опускается начальный символ /.
<p>
Пример создание топика foo с учетом общего пространства имен:
<pre>relative_foo_pub = rospy.Publisher('foo', String, queue_size=1)</pre>
<p>
<b>Пример</b>:<br>
для контроля лазерного дальномера мы запускаем драйвер hokuyo_node, который опрашивает лазер и публикует sensor_msgs/LaserScan сообщения в топик scan. Дла обработки этих данных, мы можем написать, используя пакет laser_filters, ноду, которая подписывается на сообщения топика scan. После подписки наш laser_filters автоматически начнёт получать сообщения от лазера.
<p>
Теперь о том, как происходит разделение. Нода hokuyo_node только публикует сообщения, не зная о том, подписан ли на них кто либо. Нода пакета laser_filters только подписывается на сообщения топика, не зная о том, публикует ли кто-то туда сообщения. Обе ноды могут быть запущены, остановлены, перезапущены, в любом порядке, не порождая при этом ошибок.
<p>
Далее мы можем добавить роботу другой лазерный дальномер, поэтому нужно переконфигурировать систему. Всё что нужно при этом – переназначить (remap) используемые имена. При запуске ноды hokuyo_node мы можем вместо имени scan переназначить имя base_scan. B то же самое сделать с нодой – фильтром. Теперь обе эти ноды будут связаны с использованием топика base_scan, и перестанут обрабатывать сообщение тописа scan. После этого мы можем запустить ещё одну ноду hokuyo_node для нового лазерного дальномера.

<h4>Имена ресурсов пакетов</h4>
Имена ресурсов пакетов используются в ROS с концепциями на уровне файловой системы для упрощения процесса обращения к файлам и типам данных на диске. Имена ресурсов пакетов очень просты: это просто название пакета, в котором находится ресурс, плюс название ресурса. Например, имя "std_msgs/String" относится к типу сообщения "String" в пакете "std_msgs".
<p>
Имена ресурсов пакетов очень похожи на пути к файлам, за исключением того, что они намного короче. Это связано со способностью ROS находить пакеты на диске и делать дополнительные предположения об их содержимом. Например, описания сообщений всегда хранятся в подкаталоге msg и имеют расширение .msg, поэтому std_msgs/String - это сокращение от path/to/std_msgs/msg/String.msg. Аналогично, тип узла foo/bar эквивалентен поиску файла с именем bar в пакете foo с правами доступа к исполняемому файлу.
<p>
<b>Допустимые имена</b><br>
Имена ресурсов пакетов имеют строгие правила именования, поскольку они часто используются в автоматически генерируемом коде. По этой причине в пакете ROS не может быть специальных символов, кроме символа подчеркивания, и они должны начинаться с алфавитного знака. Допустимое имя имеет следующие характеристики:
<ul>
<li> Первый символ - это буквенный знак ([a-z|А-Язь])
<li> Последующие символы могут быть буквенно-цифровыми ([0-9|а-язь|А-Язь]), символами подчеркивания (_) или косой черты (/).
<li> Существует не более одной косой черты ('/').
</ul>
<pre>


</pre>
<h3 align="center">Команда rosed</h3>
Синтаксис:
<p>
    <font color="green">rosed [package_name] [filename]</font>
<p>
    Служит для редактирования файла [filename] из пакета [package_name].<br>
    По умолчанию редактором является vim. Чтобы редактором для команды rosed был более простой nano, следует в файл ~/.bashrc добавить строку:<br>
    <b>export EDITOR='nano -w'</b>


<h3>Получение подсказки по команде</h3>
Познакомились с довольно большим количеством инструментов ROS. Иногда бывает сложно отследить, какие аргументы требуются для каждой команды. К счастью, большинство инструментов ROS предоставляют свою собственную помощь. Чтобы получить подсказку по команде, достаточно опции -h:<br>
<img src="./images/rosmsg_h.png">

</div>
<br><br><br><br><br><br></body></html>
