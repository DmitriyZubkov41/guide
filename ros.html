<html><head></head><body>
<title>ROS</title>
<a href="https://wiki.ros.org/ru">ROS Tutorials</a>
<h2 align="center">Основные концепции системы ROS</h2>
Ссылки: <a href="https://copter-space.gitbook.io/uchebnik-mashinnoe-zrenie-tom-2/razdel-2/osnovnye-koncepcii-sistemy-ros">Основные концепции системы ROS</a>

<h3 align=center>Файловая система ROS</h3>

Концепция файловой системы ROS в основном относится к ресурсам ROS, находящимся на диске, таким как:
<ul>
<li> <b>Пакеты (Packages)</b>: Пакет – основная единица файловой системы ROS. В основном пакет содержит выполняемые процессы ROS (узлы или ноды - nodes), библиотеки на основе ROS, наборы данных, конфигурационные файлы и прочие полезные данные. Пакет – это минимальная единица для компиляции и релиза в ROS.<br>
<b>Команды для работы с пакетами:</b>
<ul>
    <li>Поиск пакета: <font color="green">rospack find [package_name]</font><br>
        <img src="./images/rospack1.png">   
    <li><b>roscd:</b> <font color="green">roscd &lt;package-or-stack&gt;[/subdir]</font> переход к указанному пакету.<br>
        <img src="./images/roscd.png">
    <li>Чтобы увидеть список каталогов, где находятся пакеты, служит команда: <font color="green">echo $ROS_PACKAGE_PATH</font>
    <li><font color="green">roscd log</font>  приведет вас к папке, в которой хранятся файлы журнала ROSS. Обратите внимание, что если вы еще не запускали какие-либо программы для ROM, это приведет к ошибке, указывающей на то, что они еще не существуют.
    <li><font color="green">rosls &lt;package-or-stack&gt;[/subdir]</font> показывает состав пакета, обращаясь к нему по имени, а не по абсолютному пути.<br>
        <img src="./images/rosls.png"><br>
    Клавиша TAB выполняет функцию автозаполнения или если дважды, то список вариантов. Например напишем ros и нажмем дважды TAB, выведутся все команды ros'а.<br>
    <b>rosls</b> и дважды TAB, то выведет список установленных пакетов.
</ul>
<li> <b>Метапакеты (Metapackages)</b>: Метапакеты – это специализированные Пакеты, используемые для группировки других взаимосвязанных Пакетов. Используются также для обратной совместимости.

<li> <b><a href="https://wiki.ros.org/catkin/package.xml">Манифесты Пакетов (Package Manifests)</a></b>: Манифест (package.xml) содержит данные о пакете, включая имя, версию, описание, информацию о лицензировании, зависимости и прочую информацию, такую как экспортируемые пакеты.

<li> <b>Репозитории (Repositories)</b>: набор пакетов, принадлежащих одной и той же версии. Пакеты одной и той же системы контроля версий и одинаковой версии могут выпускаться вместе с помощью инструмента автоматизации релизов bloom (http://wiki.ros.org/bloom). Репозиторий также может содержать только один пакет.

<li> <b>Типы сообщений (Message types)</b>: описание сообщений, хранится в my_package/msg/MyMessageType.msg, определяет структуры данных для сообщений, передаваемых в ROS.

<li> <b>Типы сервисов (Service types)</b>: описание сервисов, хранится в my_package/srv/MyServiceType.srv, определяет структуры данных для запроса и ответа сервисов в ROS.

<li> <b>Рабочая область (Workspace)</b> в ROS — это папка, где разработчики создают, собирают и настраивают свои пакеты и программы. Содержит исходный код, пакеты и сборочные скрипты.<br>
Основная структура:
<ul>
    <li> src: директория исходного кода, где хранятся пакеты ROS
<li> build: временная директория, используемая во время сборки пакетов
<li> devel: содержит файлы, необходимые для запуска программ после сборки, включая исполняемые файлы и среду окружения
</ul>
</ul>
    <h3 align=center>Граф вычислений ROS</h3>

Граф вычислений ROS – это одноранговая сеть процессов ROS, обрабатывающих данные. Основные понятия, связанные с графом вычислений – это ноды (nodes), Мастер (Master), Сервер Параметров (Parameter Server), сообщения (messages), сервисы (services), топики (topics), контейнеры (bags). Все эти сущности передают данные для вычислительного графа ROS разными способами.
<ul>
<li> <b>Ноды (Nodes)</b>: Ноды (узлы)– это программы, выполняющие вычисления. Системы использующие ROS состоят из модулей, система управления роботом включает в себя множество нод. Например, одна нода управляет лазерным дальномером, другая – моторами колёс, третья нода определяет положение в пространстве, четвёртая планирует траекторию движения, пятая предоставляет графическое представление системы, и т.д. ROS ноды разрабатывают с использованием клиентских библиотек ROS, таких как roscpp или rospy.
    <br><b>Некоторые команды с узлами:</b>
    <ul>
<li> Запуск узла: <font color="green">rosrun package_name node_name</font><br>
<li> <b>Список запущенных узлов</b>: <font color="green">rosnode list</font><br>
<li> <b>Информация об определённом узле</b>: <font color="green">rosnode info node_name</font>
</ul>
<li> <b>Мастер (Master)</b>: Мастер-процесс ROS обеспечивает регистрацию имён и наблюдение за всем вычислительным графом. Без мастер-процесса ноды не смогли бы найти друг друга, обмениваться сообщениями или вызывать сервисы.

<li> <b>Сервер параметров (Parameter Server)</b>: Сервер параметров позволяет хранить данные с доступом по ключу в централизованном хранилище. В настоящее время Сервер Параметров является частью Мастера.<br>
Параметры в ROS представляют собой глобальные значения, которые можно использовать для настройки поведения узлов (nodes).<br>
Параметры могут быть различных типов: числа (целые и вещественные), строки, булевы значения, массивы и так далее.<br>
<b>Некоторые команды с параметрами:</b>
<ul>
    <li> Показать список всех параметров: <font color="green">rosparam list</font>
    <li> Установить значение параметра: <font color="green">rosparam set</font>
    <li> Получить значение параметра: <font color="green">rrosparam get</font>
    <li> Загрузить параметры из файла YAML: <font color="green">rosparam load</font>
    <li> Сохранить параметры в файл YAML: <font color="green">rosparam dump</font>
</ul>
<li> <b>Сообщения (Messages)</b>: Ноды обмениваются данными посредством передачи Сообщений. Сообщение – это структура данных, состоящая из структурированных полей. Поддерживаются стандартные примитивные типы (integer, floating point, boolean, и т.д.), а также и массивы из них. Сообщение может содержать произвольные вложенные структуры и массивы (очень похоже на структуры в языке С).<br>
Каждое поле состоит из типа и имени, разделённых пробелом.<br>
<b>Типы полей могут быть</b>:
<ul>
    <li> специальный тип Header
    <li> встроенный тип
    <li> другие Message
    <li> массивы (списки)
</ul>
<b>Некоторые команды:</b>
<ul>
    <li> Просмотр типа топика: rostopic type /topic
    <li> Опубликовать сообщение в топике: rostopic pub /topic type args
    <li> Просмотр определения типа сообщения: rosmsg show type
</ul>

<li> <b>Топики (Topics)</b>: Сообщения передаются через механизм публикации/подписки. Нода отправляет сообщение, публикуя (publish) его в определённом Топике. Топик – это имя, идентифицирующее содержание сообщения. Нода, заинтересованная в определённых данных, осуществляет подписку (subscribe) на соответствующий Топик. Для одного топика может существовать несколько параллельно публикующих/подписанных на него Нод, равно как и одна Нода может публиковать сообщения в и/или подписываться на несколько Топиков. В общес случае, публикаторы/подписчики не оказывают влияния друг на друга. Идея заключается в отделении производства информации от её использования. Логически Топик может быть представлен как строго типизированная шина сообщений. У каждой шины есть наименование, и любой элемент может подсоединиться к шине для получения и отправки сообщений соответствующего типа.
<ul>
    <li> Топик (тема) — это имя для потока сообщений
    <li> Узлы общаются между собой посредством топиков
    <li> Узлы могут публиковать или подписываться на топик
    <li> Как правило, у топика один издатель и n подписчиков
</ul>
<b>Некоторые команды с топиками</b>:
<ul>
    <li> Получение списка топиков: <font color=green>rostopic list</font>
    <li> Подписка на топик и вывод сообщений: <font color=green>rostopic echo /topic</font>
    <li> Вывод информации от топике: <font color=green>rostopic info /topic</font>
</ul>
<li> <b>Сервисы (Services)</b>: Модель публикации/ подписки является очень гибкой, но её схема односторонней передачи сообщений «многие-многим» не подходит для взаимодействий типа «запрос-ответ», которые часто нужны в распределённой системе. Механизм «запрос-ответ» реализован через Сервисы. Сервис определяется парой структур сообщений – одна для запроса и одна для ответа. Нода предоставляет сервис, используя определённое Имя сервиса, клиент использует сервис, отправляя сообщение-запрос и ожидая ответа. Клиентские библиотеки ROS обычно представляют это взаимодействие для программиста в виде вызова удалённой процедуры.<br>
    <b>Некоторые команды с сервисами:</b>
    <ul>
        <li> Показать список активных сервисов: <font color=green>rosservice list</font>
        <li> Вызвать сервис с определёнными аргументами: <font color=green>rosservice call</font>
    </ul>
Сервисы настраиваются в файлах .srv Файлы .srv описывают типы сервисов в ROS: определяют структуры данных, которые сервис принимает и возвращает. Каждый .srv файл содержит две части: запрос (Request) и ответ (Response), разделённые символом "---"
<ul>
    <li> Показать структуру .srv-файла для заданного типа сервиса: <font color="green">rossrv show [service_type]</font>
</ul>
<li> <b>Контейнеры (Bags)</b>: Контейнеры предоставляют форматы для записи и воспроизведения потоков ROS-сообщений. Контейнеры являются важным механизмом для записи данных, например, данных с сенсоров, которые трудно собрать, но необходимо сохранять для разработки и тестирования алгоритмов.
</ul>
<b>Мастер ROS</b> играет роль сервера имён в Вычислительном графе ROS. Он хранит информацию о Топиках и Сервисах для ROS-нод. Ноды сообщают Мастеру свою регистрационную информацию. В процессе коммуникации с Мастером Ноды могут получать информацию о других зарегистрированных Нодах, устанавливать с ними связь. Мастер также осуществляет обратные вызовы к Нодам, когда регистрационная информация меняется, что позволяет нодам динамически устанавливать связи по мере запуска новых Нод.
<p>
Ноды связываются с другими Нодами напрямую. Мастер только предоставляет информацию для поиска, подобно DNS серверу. Ноды, которые подписываются на топик, запрашивают связь с Нодами, которые публикуют данные в этот топик, и устанавливают эту связь через соответсвующий согласованный протокол. Наиболее часто используемый протокол – TCPROS, он использует стандартные TCP/IP сокеты.
<p>
Такая архитектура обеспечивает раздельное функционирование системы, в которой посредством распределений имён могут быть построены большие сложные распределённые системы. Имена играют важнейшую роль в ROS: ноды, топики, сервисы и параметры все имеют имена. Каждая клиентская ROS-библиотека поддерживает переназначение (remapping) имён с помощью инструментов командной строки, т.е. скомпилированная программа может быть переконфигурирована во время выполнения для обработки различной топологии Вычислительного графа.
<p>
Например, для контроля лазерного дальномера мы запускаем драйвер hokuyo_node, который опрашивает лазер и публикует sensor_msgs/LaserScan сообщения в топик scan. Дла обработки этих данных, мы можем написать, используя пакет laser_filters, ноду, которая подписывается на сообщения топика scan. После подписки наш фильтр автоматически начнёт получать сообщения от лазера.
<p>
Теперь о том, как происходит разделение. Нода hokuyo_node только публикует сообщения, не зная о том, подписан ли на них кто либо. Нода фильтра только подписывается на сообщения топика, не зная о том, публикует ли кто-то туда сообщения. Обе ноды могут быть запущены, остановлены, перезапущены, в любом порядке, не порождая при этом ошибок.
<p>
Далее мы можем добавить роботу другой лазерный дальномер, поэтому нужно переконфигурировать систему. Всё что нужно при этом – переназначить (remap) используемые имена. При запуске ноды hokuyo_node мы можем вместо имени scan переназначить имя base_scan. B то же самое сделать с нодой – фильтром. Теперь обе эти ноды будут связаны с использованием топика base_scan, и перестанут обрабатывать сообщение тописа scan. После этого мы можем запустить ещё одну ноду hokuyo_node для нового лазерного дальномера.

<h2 align="center"><a href="https://wiki.ros.org/ru/ROS/Tutorials">Из официальной документации</a></h3>
<h3><a href="http://wiki.ros.org/ROS/Tutorials/CreatingPackage">Создание пакетов</a></h3>
<ol>
    <li><h3>Что такое catkin пакет?</h3>
Чтобы catkin пакет считался таким, он должен иметь признаки:
<ul>
    <li> пакет должен содержать файл package.xml
    <li> должен содержать файл  CMakeLists.txt
    <li> У каждого пакета должна быть своя собственная папка. Это означает, что нет ни вложенных пакетов, ни нескольких пакетов, использующих один и тот же каталог.
    </ul>
<li><h3 align="center">Пакеты в catkin workspace</h3>
Обычный catkin workspace:<br>
<img src="./images/catkin_ws.png">
<li>Создание catkin-пакета.<br>
    Общий синтаксис команды создания пакета:<br>
    <font color="green">catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</font><br>
catkin_create_pkg требует, чтобы вы указали ему имя пакета и, возможно, список зависимостей, от которых зависит этот пакет.<br>
Пример:<br>
    <font color="green">cd ~/catkin_ws/src</font> переходим в каталог src<br>
    <font color="green">catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</font><br>
    <img src="./images/catkin_create_pkg.png"><br>
    Создаем пакет beginner_tutorials, который зависит от нод std_msgs, rospy и roscpp.В результате будет создана папка beginner_tutorials, содержащая файлы package.xml и CMakeLists.txt, которые были частично заполнены информацией, которую вы предоставили catkin_create_pkg.
<li><h3>Изменение рабочего пространства catkin (catkin workspace) с учетом нового пакета и исполнение setup файла</h3>
    <font color="green">cd ~/catkin_ws<br>
    catkin_make</font><br>
    После создания рабочей области в подпапке devel будет создана аналогичная структура, которую вы обычно находите в /opt/ros/noetic<br>
    Чтобы добавить переменные, нужно выполнить команду:<br>
    <font color="green">. ~/catkin_ws/devel/setup.bash</font>
<li><b>Пакетные зависимости:</b><br>
    <ul>
    <li> <b>Зависимости первого порядка</b><br>
            При использовании catkin_create_pkg ранее были предоставлены несколько зависимостей от пакетов. Эти зависимости первого порядка теперь можно просмотреть с помощью инструмента rospack:<br>
            <font color="green">rospack depends1 &lt;package_name&gt;</font><br>
           Выдаст список зависимостей, которые были установлены во время выполнения команды catkin_create_pkg. Эти зависимости хранятся в файле package.xml.<br>
        <img src="./images/rospack_depends1.png">
    <li> <b>Косвенные зависимости</b><br>
        Во многих случаях у зависимостей также будут свои собственные зависимости. Например, у rospy есть другие зависимости.<br>
        <img src="./images/rospack_depends2.png"><br>
        Пакет может иметь много косвенных зависимостей:<br>
        <font color="green">rospack depends &lt;package_name&gt;</font> - выведет все зависимости.
    <li> <b>Файл package.xml содержит:</b>
<ul>
<li>тег description<br>
    <img src="./images/description.png">
<li> тег maintainer<br>
    Это обязательный и важный тег для package.xml потому что он позволяет другим пользователям узнать, к кому обратиться по поводу пакета. Требуется как минимум один специалист по сопровождению, но вы можете нанять их много, если хотите. Имя сопровождающего указано в тексте тега, но также есть атрибут электронной почты, который необходимо заполнить<br>
    <img src="./images/maintainer.png">
<li> теги лицензий<br> Обязательный. Наиболее распространенными лицензиями с открытым исходным кодом являются BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1 и LGPLv3. Вы можете прочитать о некоторых из них в разделе Open Source Initiative. В этом руководстве мы будем использовать лицензию BSD, поскольку остальные компоненты core RODS уже используют ее
теги зависимостей<br>
<img src="./images/license.png">
<li> тег зависимостей<br>
    Следующий набор тегов описывает зависимости вашего пакета. Зависимости разделены на build_depend, build tool_depend, exe c_depend, test_depend. Более подробное объяснение этих тегов приведено в документации о зависимостях Catkin. Поскольку мы передали std_msgs, roscpp и rospy в качестве аргументов для catkin_create_pkg, зависимости будут выглядеть следующим образом:
    <img src="./images/tag_depends.png">
<li> тег конца файла <b>&lt;/package&gt;</b>
</ul>
</ul>
</ol>

<h2 align="center">Ноды (узлы)</h2>
Узел на самом деле представляет собой не более чем исполняемый файл в пакете ROS. Узлы ROS используют клиентскую библиотеку ROS для взаимодействия с другими узлами. Узлы могут публиковать топики (opic) или подписываться на них. Узлы также могут предоставлять или использовать службы (service).
<p>
    Клиентские библиотеки ROS позволяют взаимодействовать узлам, написанным на разных языках программирования:<br>
    rospy = клиентская библиотека python<br>
    roscpp = клиентская библиотека c++
<p>
    Прежде чем выполнять команды над нодами, следует вызвать мастера ROS, команда: <font color="green">roscore</font><br>
    И после этого в другом терминале выполнять команды. 
<p>
    <font color="green">rosnode list</font> - выводит список этих активных узлов.<br>
Если не запускали какую-нибудь ноду, то покажет только rosout. Он всегда запущен, поскольку собирает и регистрирует выходные данные отладки узлов.
<p>
    <font color="green">rosnode info &lt;name_node&gt;</font> - покажет информацию о ноде.<br>
    Пример:<br>
    <img src="./images/info_my_turtl.png">
<p>
    <font color="green">rosrun [package_name] [node_name]</font> - позволит выполнить ноду node_name внутри пакета package_name без указания пути к этому пакету.<br>
    Например выполнить turtlesin_node внутри пакета turtlesim.<br>
    <img src="./images/turtlesim_node.png">
<p>
    <font color="green">rosrun [package_name] [node_name] __name:=[new_node_name]</font> - изменили имя ноды node_name на new_node_name.
<p>
    <font color="green">rosnode ping [node_name]</font> - пингуем ноду, чтобы проверить, что она запущена.
<h3>Использование rqt_graph</h3>
Запустили две ноды: turtlesim_node, которая является подписчиком на топик и turtle_teleop_key, которая является публикатором на тот же самый топик. Графически мы можем это увидитеть с помощью утилиты rqt_graph.
<p>
Программа rqt_graph показывает связи между топиками и нодами.<br>
Чтобы установить эту программу:<br>
<font color="green">sudo apt-get install ros-&lt;distro&gt;-rqt</font><br>
<font color="green">sudo apt-get install ros-&lt;distro&gt;-rqt-common-plugins</font><br>
&lt;distro&gt; заменить на название дистрибутива ROS: (noetic, kinetic и т.подобное).
<p>
    Чтобы выполнить эту программу, команда:<br>
    <font color="green">rosrun rqt_graph rqt_graph</font><br>
    <img src="./images/rqt_graf.png">

<h3>Команды rostopic:</h3>
<font color="green">rostopic echo [topic]</font> - показывает данные, публикуемые в топик.
<p>
    <font color="green">rostopic list</font> - возвращает список всех топиков, на которые в данный момент подписаны и которые публикуют.<br>
        Опции этой команды:
        <ul>
            <li>-h, --help            show this help message and exit
            <li>    -b BAGFILE, --bag=BAGFILE  список топиков в .bag file
            <li>    -v, --verbose  дополнительно показывает сколько подписчиков и публицистов на топики завязано.
            <li>    -p                    list only публицистов
            <li>    -s                    list only подписчиков
        </ul>
    <img src="./images/rostopic_list.png">

<h3>Команды с Messages (сообщения)</h3>    
Ноды общаются между собой с помошью messages (сообщений). Чтобы ноды понимали друг друга, сообщения должны иметь одинаковый тип. Чтобы узнать тип сообщений, служит команда:<br>
<font color="green">rostopic type [topic]</font><br>
Вернёт тип (имя) сообщений, используемого для топика.<br>
<img src="./images/rostopic_type.png">
<p>
Чтобы посмотреть детали этого сообщения, используется команда:<br>
<font color="green">rosmsg show [name_meesage]</font><br>
<img src="./images/rosmsg_show.png">
<p>
   Зная тип (имя) сообщений, мы можем отправлять их ноде через топик, тем самым управлять нодой. Синтаксис:<br>
   <font color="green">rostopic pub [topic] [msg_type] [args]</font><br>
     публикует данные по объявленному топику.<br>
     <img src="./images/rostopic_pub.png">
    <ul>
        <li> <b>-1</b> Этот параметр приводит к тому, что rostopic публикует только одно сообщение, а затем завершает работу
    <li> <b>/turtle1/cmd_vel</b> - это имя топика, в который отправляем (публикуем) сообщение
        <li> <b>geometry_msgs/Twist</b> - это тип (имя) сообщения, которое отправляем в топик.
        <li> <b>--</b> - этот параметр (двойное тире) указывает анализатору параметров, что ни один из следующих аргументов не является параметром. Это необходимо в тех случаях, когда ваши аргументы начинаются с тире -, например, с отрицательных чисел.
    <li> <b>'[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'</b> - сообщение geometry_msgs/Twist содержит два вектора по три элемента с плавающей запятой в каждом: линейный и угловой. В этом случае, '[2.0, 0.0, 0.0]' становится линейным значением при x=2.0, y=0.0 и z=0.0, а '[0.0, 0.0, 1.8]' - угловым значением при x=0.0, y=0.0 и z=1.8. Эти аргументы приведены в синтаксисе YAML.
    </ul>
    Мы можем опубликовать постоянный поток команд, используя опцию -r:<br>
    <img src="./images/rostopic_pub1.png">
<p>
    <font color="green">rostopic hz [topic]</font> - сообщает о скорости публикации данных в [topic].
<h3>qt_plot</h3>
    <b>rqt_plot</b> - эта утилита отображает график времени прокрутки данных, опубликованных в топиках.<br>
    Сперва нужно выполнить команду: <font color="green">rosrun rqt_plot rqt_plot</font>

<h3 align="center">Services</h3>
Сервисы - это еще один способ, с помощью которого узлы могут взаимодействовать друг с другом. Сервисы позволяют узлам отправлять запрос и получать ответ.<br>
Команды:
<ul>
    <li> <font color="green">rosservice list</font> - выводит список сервисов<br>
        <img src="./images/rosservice_list.png">
    <li> <font color="green">rosservice type [service]</font> - выводит тип службы<br>
        <img src="./images/rosservice_type.png">
    <li> <font color="green">rosservice call [service] [args]</font> - вызывает службу [service]
        <p>
            Вызовем службу /clear: <i>rosservice call /clear</i><br>
            В результате эта служба очистит поле черепахи от пройденной траектории.<br>
            Другой пример:<br>
            <img src="./images/rosservice_type1.png"><br>
            Здесь мы 1 командой вывели формат сообщения службы, если бы просто как в 3 команде, то выдаст только имя службы. Вторая команда: я вызываю эту службу с заданными аргументами, чтобы она выполнила свою работу. В результате получу новую черепаху с координатами, заданными в аргументах.
</ul>
<h3 align="center">Команды rosparam:</h3>
rosparam позволяет хранить данные на сервере параметров ROS и манипулировать ими. Сервер параметров может хранить целые числа, значения с плавающей запятой, логические значения, словари и списки. Для синтаксиса rosparam использует язык разметки YAML. В простых случаях YAML выглядит очень естественно: 1 - целое число, 1.0 - число с плавающей точкой, "единица" - строка, true - логическое значение, [1, 2, 3] - список целых чисел, {a: b, c: d} - словарь. В rosparam есть множество команд, которые можно использовать для работы с параметрами:
<ul>
    <li> <font color="green">rosparam list</font> - список параметров<br>
        <img src="./images/rosparam_list.png">
    <li> <font color="green">rosparam set [param_name]</font> - устанавливаем значение параметра [param_name]<br>
        Пример: <i>$ rosparam set /turtlesim/background_r 150</i><br>
        <font color="green">rosparam get [param_name]</font> - выводит значение параметра<br>
        <img src="./images/rosparam_set.png"><br>
        Чтобы изменение параметра вступило в силу, нужно вызвать службу чистильщика (/clean).
    <li> Команда <font color="green">rosparam get /</font> выведет значения всех параметров на сервере параметров.<br>
        <img src="./images/rosparam_get.png">
        <p>
            <font color="green">rosparam get name_parametr</font> - выводит значение параметра name_parametr:<br>
            <img src="./images/rosparam_get1.png">
    <li> Если хотим сохранить этот набор параметров, чтобы потом вызвать, то служит команда:<br>
        <font color="green">rosparam dump [file_name] [namespace]</font> - записываем все параметры в файл [file_name]
    <li> Вызвать сохранённый набор параметров [file_name] для [namespace], служит команда:<br>
        <font color="green">rosparam load [file_name] [namespace]</font>
</ul>
<h3>Использование rqt_console и rqt_logger_level</h3>
rqt_console подключается к Ross logging framework, чтобы вывести выходные данные с узлов.<br>
rqt_logger_level позволяет нам изменять уровень детализации (DEBUG, WARN, INFO и ERROR) узлов по мере их запуска.<br>
Чтобы вызвать rqt_console, служит команда:<br>
<font color="green">rosrun rqt_console rqt_console</font>
<p>
    <img src="./images/rqt_console.png">
<p>
    Чтобы вызвать консоль rqt_logger_level, служит команда:<br>
    <font color="green">rosrun rqt_logger_level rqt_logger_level</font>
<p>
    <img src="./images/rqt_logger_level.png">

<h3 align="center">Использование roslaunch</h3>
roslaunch запускает ноды, определённые в launch-файле. Синтаксис:<br>
<font color="green">$ roslaunch [package] [filename.launch]</font>
<p>
файл.launch находится в папке launch, она находится в каталоге пакета.<br>
<i>ПРИМЕЧАНИЕ: Каталог, в котором хранятся файлы launch, необязательно должен называться launch. На самом деле вам даже не нужно сохранять их в каталоге. Команда roslaunch автоматически просматривает переданный пакет и обнаруживает доступные файлы запуска. Однако это считается хорошей практикой.</i>
<h4>Теги файла.launch</h4>
<ul>
    <li> Тег &lt;launch&gt; - первый обязательный тег. Указывает, что файл launch.
    <li> Тег &lt;group  ns=" "&gt; - запускает ноду
    <li> Тег &lt;/launch&gt; - обязательный закрывающий тег.
</ul>
<h3 align="center">Команда rosed</h3>
Синтаксис:
<p>
    <font color="green">rosed [package_name] [filename]</font>
<p>
    Служит для редактирования файла [filename] из пакета [package_name].<br>
    По умолчанию редактором является vim. Чтобы редактором для команды rosed был более простой nano, следует в файл ~/.bashrc добавить строку:<br>
    <b>export EDITOR='nano -w'</b>

<h3 align="center">Знакомство с файлами msg и srv</h3>
msg-файлы - это простые текстовые файлы, которые описывают поля сообщений ROS. Они используются для создания исходного кода сообщений на разных языках. Они хранятся в папке msg каталога пакета. Представляют собой просто текстовые файлы с типом поля и названием поля в каждой строке.<br>
Тип поля:
<ul>
    <li> int8, int16, int32, int64 (plus uint*)
    <li> float32, float64
    <li> string
    <li> time, duration
    <li> other msg files
    <li> variable-length array[] and fixed-length array[C]
</ul>
Существует также тип Header. Header содержит временную метку и информацию о координатной системе, которые обычно используются в ROS. Вы часто увидите, что в первой строке msg-файла есть заголовок Header.
<p>
файл srv описывает службы. Он состоит из двух частей: запроса и ответа. Хранятся в папке srv каталога пакета. Файлы srv похожи на файлы msg, за исключением того, что они состоят из двух частей: запроса и ответа. Эти две части разделены строкой "---". Вот пример файла srv:
<p>
<img src="./images/file.srv.png"><br>
В этом примере A and B - запрос, а Sum - ответ.

<h3>Пример создания файла.msg (Num.msg)</h3>
Команды:
<ul>
<li> Переходим в каталог пакета (roscd или просто cd)<br>
Создаём внутри пакета каталог msg: mkdir msg<br>
Что-то записываем в создаваемый файл, например: echo "int64 num" > msg/Num.msg
<li>
Далее нужно убедиться, что msg-файлы преобразованы в исходный код для C++, Python и других языков. Для этого открыть package.xml и убедитесь, что эти две строки есть в нем и не закомментированы:<br>
<img src="./images/package.xml.png"><br>
<font color=red>Были закомментированы, исправил.</font>
<li>
<h4>Редактирование CMakeLists.txt</h4>
    Во время сборки нужен "message_generation", в время выполнения message_runtime"<br>
    Далее открыть CMakeLists.txt В нем в функцию find_package добавить <b>message_generation</b>, тем самым можем генерировать сообщения.<br>
    <font color="red">Добавил.</font>
<p>
    Вы можете заметить, что иногда ваш проект собирается нормально, даже если вы не вызывали find_package со всеми зависимостями. Это связано с тем, что catkin объединяет все ваши проекты в один, поэтому, если более ранний проект вызывает find_package, ваш более поздний настроен с теми же значениями. Но если вы забудете о вызове, это означает, что ваш проект может легко прерваться при изолированной сборке.
<p>
Также убедитесь, что вы экспортировали зависимость от среды выполнения сообщений:<br>
<img src="./images/message_runtime.png"><br>
Добавил.
<p>
    Исправил блок на:<br>
    <img src="./images/message_file.png">
<p>
    Теперь мы должны убедиться, что функция generate_messages() вызвана (раскомментировал блок):<br>
    <img src="./images/generate_message.png">
</ul>
Теперь вы готовы сгенерировать исходные файлы из вашего определения msg.


<br><br><br><br><br><br></body></html>