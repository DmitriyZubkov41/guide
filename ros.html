<html><head></head><body>
<title>ROS</title>
<a href="https://wiki.ros.org/ru">ROS Tutorials</a>
<h3 align="center">Установка ROS</h3>
<a href="https://wiki.ros.org/Distributions">Список дистрибутивов ROS</a><br>
Страницы установок ROS2: <a href="http://docs.ros.org/en/humble/Installation.html">Humble</a>, <a href="http://docs.ros.org/en/iron/Installation.html">Iron</a>, and <a href="http://docs.ros.org/en/rolling/Installation.html">Rolling</a>.<br>
<a href="https://wiki.ros.org/noetic/Installation">Выбор установки ROS Noetic Ninjemys в зависимости от ОС</a><br>
<a href="https://wiki.ros.org/noetic/Installation/Ubuntu">Установка ROS на ubuntu</a>
<p>
<ol>
<li>Setup your sources.list<br>
    Setup your computer to accept software from packages.ros.org.<p>
    
<font color="green">sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" > /etc/apt/sources.list.d/ros-latest.list'</font>
    
<li>Set up your keys
<p>
<font color="green">sudo apt install curl # if you haven't already installed curl
        curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -</font>
    
<li>Installation<br>
Убедитесь, что ваш индекс пакетов Debian обновлен:
<p><font color="green">sudo apt update</font>
<p>
Выберите в каком комплектации установить:<p>
<b>Desktop-Full Install: (Recommended)</b> : Everything in Desktop plus 2D/3D simulators and 2D/3D perception packages
<ul>   
<li><font color="green">sudo apt install ros-noetic-desktop-full</font>
<li><b>Desktop Install</b>: Everything in <b>ROS-Base</b> plus tools like rqt and rviz
<p>    
<font color="green">sudo apt install ros-noetic-desktop</font>
<li><b>ROS-Base:</b> (Bare Bones) ROS packaging, build, and communication libraries. No GUI tools.
<p>    
<font color="green">sudo apt install ros-noetic-ros-base</font>
</ul>    
В ROS доступно еще больше пакетов. Вы всегда можете установить определенный пакет напрямую.
<p>
<font color="green">sudo apt install ros-noetic-PACKAGE</font>
<p>   
Например:
<p>    
<font color="green">sudo apt install ros-noetic-slam-gmapping</font>
<p>    
To find available packages, see <a href="https://index.ros.org/packages/page/1/time/#noetic">ROS Index</a> or use:
<p>    
<font color="green">apt search ros-noetic</font>
    
<li>Environment setup
<p>    
You must source this script in every bash terminal you use ROS in.
<p>    
<font color="green">source /opt/ros/noetic/setup.bash</font>
<p>    
It can be convenient to automatically source this script every time a new shell is launched. These commands will do that for you.
<p>
<font color="green">echo "source /opt/ros/noetic/setup.bash" >> ~/.bashrc
<p>
    source ~/.bashrc</font>
<li>Dependencies for building packages
<p>    
    На данный момент вы установили все необходимое для запуска основных пакетов ROS. Для создания собственных рабочих пространств ROS и управления ими существуют различные инструменты и требования, которые распространяются отдельно. Например, rosinstall - это часто используемый инструмент командной строки, который позволяет вам легко загружать множество деревьев исходных репозиториев для пакетов ROS с помощью одной команды.<br>

    Чтобы установить этот инструмент и другие зависимости для создания пакетов ROS, запустите:
<p>    
<font color="green">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential</font>
<p>    
Initialize rosdep<br>
Прежде чем вы сможете использовать многие инструменты ROS, вам необходимо инициализировать rosdep. rosdep позволяет легко устанавливать системные зависимости для исходного кода, который вы хотите скомпилировать, и необходим для запуска некоторых основных компонентов в ROS. Если вы еще не установили rosdep, сделайте это следующим образом.
<p>
<font color="green">sudo apt install python3-rosdep</font>
<p>    
With the following, you can initialize rosdep.
<p>    
<font color="green">sudo rosdep init
<p>
rosdep update</font>
<p>Установка закончена.
</ol>

<h3 align=center><b>Настройка ROS:</b></h3>
Пункты 4 и 5 из установки ROS.
<p>
<b>Создание рабочей области catkin:</b><br>
Catkin — это система сборки, используемая в ROS для управления исходным кодом.<br>
Рабочая область catkin представляет собой каталог, в котором вы можете создавать или изменять собственные пакеты ROS.
<p>
<font color="green">mkdir -p ~/catkin_ws/src
    <p>
    cd ~/catkin_ws/</font><p>
    Это создаст новый каталог catkin_ws в вашем домашнем каталоге, а также каталог src внутри catkin_ws.
    <p>
<b>Инициализация рабочей области:</b><p>
<font color="green">catkin_init_workspace src</font><p>
Это создаст ссылку на CMakeLists.txt в каталоге src, который необходим для компиляции исходного кода.
<p>
<b>Сборка рабочей области:</b>
<p>
    <font color="green">catkin_make</font>
<p>
Это создаст два дополнительных каталога в каталоге catkin_ws: build и devel, которые содержат продукты сборки и среды сборки соответственно.
<p>
<b>Добавление рабочей области в .bashrc:</b><br>
Чтобы обеспечить доступ к созданным пакетам, добавьте следующую строку в ваш .bashrc:
<p>
<font color=green>echo "source ~/catkin_ws/devel/setup.bash" >> ~/.bashrc<p>
source ~/.bashrc</font>
<p>
Теперь вы готовы к созданию и управлению вашими собственными пакетами ROS в рабочей области catkin.

<h2 align="center">Основные концепции системы ROS</h2>
Ссылки: <a href="https://copter-space.gitbook.io/uchebnik-mashinnoe-zrenie-tom-2/razdel-2/osnovnye-koncepcii-sistemy-ros">Основные концепции системы ROS</a>

<h3 align=center>Файловая система ROS</h3>

Концепция файловой системы ROS в основном относится к ресурсам ROS, находящимся на диске, таким как:
<ul>
<li> <b>Пакеты (Packages)</b>: Пакет – основная единица файловой системы ROS. В основном пакет содержит выполняемые процессы ROS (узлы или ноды - nodes), библиотеки на основе ROS, наборы данных, конфигурационные файлы и прочие полезные данные. Пакет – это минимальная единица для компиляции и релиза в ROS.<br>
<b>Команды для работы с пакетами:</b>
<ul>
    <li>Поиск пакета: <font color="green">rospack find [package_name]</font>    
    <li><b>roscd:</b> <font color="green">roscd <package-or-stack>[/subdir]</font> переход к указанному пакету.
    <li>Чтобы увидеть список каталогов, где находятся пакеты, служит команда: <font color="green">echo $ROS_PACKAGE_PATH</font>
    <li><font color="green">roscd log</font>  приведет вас к папке, в которой хранятся файлы журнала ROSS. Обратите внимание, что если вы еще не запускали какие-либо программы для ROM, это приведет к ошибке, указывающей на то, что они еще не существуют.
    <li><font color="green">rosls <package-or-stack>[/subdir]</font> показывает состав пакета, обращаясь к нему по имени, а не по абсолютному пути.
</ul>
<li> <b>Метапакеты (Metapackages)</b>: Метапакеты – это специализированные Пакеты, используемые для группировки других взаимосвязанных Пакетов. Используются также для обратной совместимости.

<li> <b><a href="https://wiki.ros.org/catkin/package.xml">Манифесты Пакетов (Package Manifests)</a></b>: Манифест (package.xml) содержит данные о пакете, включая имя, версию, описание, информацию о лицензировании, зависимости и прочую информацию, такую как экспортируемые пакеты.

<li> <b>Репозитории (Repositories)</b>: набор пакетов, принадлежащих одной и той же версии. Пакеты одной и той же системы контроля версий и одинаковой версии могут выпускаться вместе с помощью инструмента автоматизации релизов bloom (http://wiki.ros.org/bloom). Репозиторий также может содержать только один пакет.

<li> <b>Типы сообщений (Message types)</b>: описание сообщений, хранится в my_package/msg/MyMessageType.msg, определяет структуры данных для сообщений, передаваемых в ROS.

<li> <b>Типы сервисов (Service types)</b>: описание сервисов, хранится в my_package/srv/MyServiceType.srv, определяет структуры данных для запроса и ответа сервисов в ROS.

<li> <b>Рабочая область (Workspace)</b> в ROS — это папка, где разработчики создают, собирают и настраивают свои пакеты и программы. Содержит исходный код, пакеты и сборочные скрипты.<br>
Основная структура:
<ul>
    <li> src: директория исходного кода, где хранятся пакеты ROS
<li> build: временная директория, используемая во время сборки пакетов
<li> devel: содержит файлы, необходимые для запуска программ после сборки, включая исполняемые файлы и среду окружения
</ul>
</ul>
    <h3 align=center>Граф вычислений ROS</h3>

Граф вычислений ROS – это одноранговая сеть процессов ROS, обрабатывающих данные. Основные понятия, связанные с графом вычислений – это ноды (nodes), Мастер (Master), Сервер Параметров (Parameter Server), сообщения (messages), сервисы (services), топики (topics), контейнеры (bags). Все эти сущности передают данные для вычислительного графа ROS разными способами.
<ul>
<li> <b>Ноды (Nodes)</b>: Ноды (узлы)– это программы, выполняющие вычисления. Системы использующие ROS состоят из модулей, система управления роботом включает в себя множество нод. Например, одна нода управляет лазерным дальномером, другая – моторами колёс, третья нода определяет положение в пространстве, четвёртая планирует траекторию движения, пятая предоставляет графическое представление системы, и т.д. ROS ноды разрабатывают с использованием клиентских библиотек ROS, таких как roscpp или rospy.
    <br><b>Некоторые команды с узлами:</b>
    <ul>
<li> Запуск узла: <font color="green">rosrun package_name node_name</font><br>
<li> <b>Список запущенных узлов</b>: <font color="green">rosnode list</font><br>
<li> <b>Информация об определённом узле</b>: <font color="green">rosnode info node_name</font>
</ul>
<li> <b>Мастер (Master)</b>: Мастер-процесс ROS обеспечивает регистрацию имён и наблюдение за всем вычислительным графом. Без мастер-процесса ноды не смогли бы найти друг друга, обмениваться сообщениями или вызывать сервисы.

<li> <b>Сервер параметров (Parameter Server)</b>: Сервер параметров позволяет хранить данные с доступом по ключу в централизованном хранилище. В настоящее время Сервер Параметров является частью Мастера.<br>
Параметры в ROS представляют собой глобальные значения, которые можно использовать для настройки поведения узлов (nodes).<br>
Параметры могут быть различных типов: числа (целые и вещественные), строки, булевы значения, массивы и так далее.<br>
<b>Некоторые команды с параметрами:</b>
<ul>
    <li> Показать список всех параметров: <font color="green">rosparam list</font>
    <li> Установить значение параметра: <font color="green">rosparam set</font>
    <li> Получить значение параметра: <font color="green">rrosparam get</font>
    <li> Загрузить параметры из файла YAML: <font color="green">rosparam load</font>
    <li> Сохранить параметры в файл YAML: <font color="green">rosparam dump</font>
</ul>
<li> <b>Сообщения (Messages)</b>: Ноды обмениваются данными посредством передачи Сообщений. Сообщение – это структура данных, состоящая из структурированных полей. Поддерживаются стандартные примитивные типы (integer, floating point, boolean, и т.д.), а также и массивы из них. Сообщение может содержать произвольные вложенные структуры и массивы (очень похоже на структуры в языке С).<br>
Каждое поле состоит из типа и имени, разделённых пробелом.<br>
<b>Типы полей могут быть</b>:
<ul>
    <li> специальный тип Header
    <li> встроенный тип
    <li> другие Message
    <li> массивы (списки)
</ul>
<b>Некоторые команды:</b>
<ul>
    <li> Просмотр типа топика: rostopic type /topic
    <li> Опубликовать сообщение в топике: rostopic pub /topic type args
    <li> Просмотр определения типа сообщения: rosmsg show type
</ul>

<li> <b>Топики (Topics)</b>: Сообщения передаются через механизм публикации/подписки. Нода отправляет сообщение, публикуя (publish) его в определённом Топике. Топик – это имя, идентифицирующее содержание сообщения. Нода, заинтересованная в определённых данных, осуществляет подписку (subscribe) на соответствующий Топик. Для одного топика может существовать несколько параллельно публикующих/подписанных на него Нод, равно как и одна Нода может публиковать сообщения в и/или подписываться на несколько Топиков. В общес случае, публикаторы/подписчики не оказывают влияния друг на друга. Идея заключается в отделении производства информации от её использования. Логически Топик может быть представлен как строго типизированная шина сообщений. У каждой шины есть наименование, и любой элемент может подсоединиться к шине для получения и отправки сообщений соответствующего типа.
<ul>
    <li> Топик (тема) — это имя для потока сообщений
    <li> Узлы общаются между собой посредством топиков
    <li> Узлы могут публиковать или подписываться на топик
    <li> Как правило, у топика один издатель и n подписчиков
</ul>
<b>Некоторые команды с топиками</b>:
<ul>
    <li> Получение списка топиков: <font color=green>rostopic list</font>
    <li> Подписка на топик и вывод сообщений: <font color=green>rostopic echo /topic</font>
    <li> Вывод информации от топике: <font color=green>rostopic info /topic</font>
</ul>
<li> <b>Сервисы (Services)</b>: Модель публикации/ подписки является очень гибкой, но её схема односторонней передачи сообщений «многие-многим» не подходит для взаимодействий типа «запрос-ответ», которые часто нужны в распределённой системе. Механизм «запрос-ответ» реализован через Сервисы. Сервис определяется парой структур сообщений – одна для запроса и одна для ответа. Нода предоставляет сервис, используя определённое Имя сервиса, клиент использует сервис, отправляя сообщение-запрос и ожидая ответа. Клиентские библиотеки ROS обычно представляют это взаимодействие для программиста в виде вызова удалённой процедуры.<br>
    <b>Некоторые команды с сервисами:</b>
    <ul>
        <li> Показать список активных сервисов: <font color=green>rosservice list</font>
        <li> Вызвать сервис с определёнными аргументами: <font color=green>rosservice call</font>
    </ul>
Сервисы настраиваются в файлах .srv Файлы .srv описывают типы сервисов в ROS: определяют структуры данных, которые сервис принимает и возвращает. Каждый .srv файл содержит две части: запрос (Request) и ответ (Response), разделённые символом "---"
<ul>
    <li> Показать структуру .srv-файла для заданного типа сервиса: <font color="green">rossrv show [service_type]</font>
</ul>
<li> <b>Контейнеры (Bags)</b>: Контейнеры предоставляют форматы для записи и воспроизведения потоков ROS-сообщений. Контейнеры являются важным механизмом для записи данных, например, данных с сенсоров, которые трудно собрать, но необходимо сохранять для разработки и тестирования алгоритмов.
</ul>
<b>Мастер ROS</b> играет роль сервера имён в Вычислительном графе ROS. Он хранит информацию о Топиках и Сервисах для ROS-нод. Ноды сообщают Мастеру свою регистрационную информацию. В процессе коммуникации с Мастером Ноды могут получать информацию о других зарегистрированных Нодах, устанавливать с ними связь. Мастер также осуществляет обратные вызовы к Нодам, когда регистрационная информация меняется, что позволяет нодам динамически устанавливать связи по мере запуска новых Нод.
<p>
Ноды связываются с другими Нодами напрямую. Мастер только предоставляет информацию для поиска, подобно DNS серверу. Ноды, которые подписываются на топик, запрашивают связь с Нодами, которые публикуют данные в этот топик, и устанавливают эту связь через соответсвующий согласованный протокол. Наиболее часто используемый протокол – TCPROS, он использует стандартные TCP/IP сокеты.
<p>
Такая архитектура обеспечивает раздельное функционирование системы, в которой посредством распределений имён могут быть построены большие сложные распределённые системы. Имена играют важнейшую роль в ROS: ноды, топики, сервисы и параметры все имеют имена. Каждая клиентская ROS-библиотека поддерживает переназначение (remapping) имён с помощью инструментов командной строки, т.е. скомпилированная программа может быть переконфигурирована во время выполнения для обработки различной топологии Вычислительного графа.
<p>
Например, для контроля лазерного дальномера мы запускаем драйвер hokuyo_node, который опрашивает лазер и публикует sensor_msgs/LaserScan сообщения в топик scan. Дла обработки этих данных, мы можем написать, используя пакет laser_filters, ноду, которая подписывается на сообщения топика scan. После подписки наш фильтр автоматически начнёт получать сообщения от лазера.
<p>
Теперь о том, как происходит разделение. Нода hokuyo_node только публикует сообщения, не зная о том, подписан ли на них кто либо. Нода фильтра только подписывается на сообщения топика, не зная о том, публикует ли кто-то туда сообщения. Обе ноды могут быть запущены, остановлены, перезапущены, в любом порядке, не порождая при этом ошибок.
<p>
Далее мы можем добавить роботу другой лазерный дальномер, поэтому нужно переконфигурировать систему. Всё что нужно при этом – переназначить (remap) используемые имена. При запуске ноды hokuyo_node мы можем вместо имени scan переназначить имя base_scan. B то же самое сделать с нодой – фильтром. Теперь обе эти ноды будут связаны с использованием топика base_scan, и перестанут обрабатывать сообщение тописа scan. После этого мы можем запустить ещё одну ноду hokuyo_node для нового лазерного дальномера.

<h2 align="center"><a href="https://wiki.ros.org/ru/ROS/Tutorials">Из официальной документации</a></h3>
<ul>
    <li> Клавиша TAB выполняет функцию автозаполнения или если дважды, то список вариантов. Например напишем ros и нажмем дважды TAB, выведутся все команды ros'а.<br>
    <b>rosls</b> и дважды TAB, то выведет список установленных пакетов.
</ul>
<h3><a href="http://wiki.ros.org/ROS/Tutorials/CreatingPackage">Создание пакетов</a></h3>
<ol>
    <li><h3>Что такое catkin пакет?</h3>
Чтобы catkin пакет считался таким, он должен иметь признаки:
<ul>
    <li> пакет должен содержать файл package.xml
    <li> должен содержать файл  CMakeLists.txt
    <li> У каждого пакета должна быть своя собственная папка. Это означает, что нет ни вложенных пакетов, ни нескольких пакетов, использующих один и тот же каталог.
    </ul>
<li><h3 align="center">Пакеты в catkin workspace</h3>
Обычный catkin workspace:<br>
<img src="./images/catkin_ws.png">
<li>Создание catkin-пакета.<br>
    Общий синтаксис команды создания пакета:<br>
    <font color="green">catkin_create_pkg <package_name> [depend1] [depend2] [depend3]</font><br>
catkin_create_pkg требует, чтобы вы указали ему имя пакета и, возможно, список зависимостей, от которых зависит этот пакет.<br>
Пример:<br>
    <font color="green">cd ~/catkin_ws/src</font> переходим в каталог src<br>
    <font color="green">catkin_create_pkg my_packet std_msgs rospy roscpp</font><br>
    Создаем пакет my_packet, который зависит от нод std_msgs, rospy и roscpp.В результате будет создана папка my_packet, содержащая файлы package.xml и CMakeLists.txt, которые были частично заполнены информацией, которую вы предоставили catkin_create_pkg.
<li><h3>Построение рабочего пространства catkin (catkin workspace) и исполнение setup файла</h3>
    <font color="green">cd ~/catkin_ws<br>
        $ catkin_make</font><br>
    Будут созданы папки devel и build<br>
    Чтобы добавить переменные, нужно выполнить команду:
    <font color="green">. ~/catkin_ws/devel/setup.bash</font>
<li><b>Пакетные зависимости:</b><br>
    <ul>
    <li> <b>Зависимости первого порядка</b><br>
            При использовании catkin_create_pkg ранее были предоставлены несколько зависимостей от пакетов. Эти зависимости первого порядка теперь можно просмотреть с помощью инструмента rospack:<br>
            <font color="green">rospack depends1 <package_name></font><br>
           Выдаст список зависимостей, которые были установлены во время выполнения команды catkin_create_pkg. Эти зависимости хранятся в файле package.xml.
    <li> <b>Косвенные зависимости</b><br>
            Во многих случаях у зависимостей также будут свои собственные зависимости. Например, у rospy есть другие зависимости.<br>
            <img src="./images/rospack.png">
    <li> <b>Файл package.xml содержит:</b><br>
тег description<br>
теги maintainer<br>
теги лицензии<br>
теги зависимостей<br>
тег конца файла "</package>"
<li> CMakeLists.txt
</ul>
</ol>
<h3>Использование команды catkin_make</h3>
catkin_make - это инструмент объединяет вызовы cmake и make в стандартном рабочем процессе CMake.<br>
Синтаксис:<br>
catkin_make [make_targets] [-DCMAKE_VARIABLES=...]<br>
Для тех, кто не знаком со стандартным рабочим процессом CMake, он выглядит следующим образом:<br>
<img src="./images/cmake.png"><br>
Чтобы выполнить команду catkin_make, сперва переходим в папку src и в ней выполняем catkin_make. В результате в папке catkin_ws будут созданы папки devel и build.<br>
Папка build - это расположение пространства сборки по умолчанию, в котором вызываются cmake и make для настройки и сборки ваших пакетов. Папка devel - это расположение пространства разработки по умолчанию, в которое помещаются исполняемые файлы и библиотеки перед установкой пакетов.

<h2 align="center">Ноды (узлы)</h2>
Узел на самом деле представляет собой не более чем исполняемый файл в пакете ROS. Узлы ROS используют клиентскую библиотеку ROS для взаимодействия с другими узлами. Узлы могут публиковать топики (opic) или подписываться на них. Узлы также могут предоставлять или использовать службы (service).
<p>
    Клиентские библиотеки ROS позволяют взаимодействовать узлам, написанным на разных языках программирования:<br>
    rospy = клиентская библиотека python<br>
    roscpp = клиентская библиотека c++
<p>
    <font color="green">rosnode list</font> - выводит список этих активных узлов.<br>
Если не запускали какую-нибудь ноду, то покажет только rosout. Он всегда запущен, поскольку собирает и регистрирует выходные данные отладки узлов.
<p>
    <font color="green">rosnode info &lt;name_node&gt;</font> - покажет информацию о ноде
<p>
    <font color="green">rosrun [package_name] [node_name]</font> - позволит выполнить ноду node_name внутри пакета package_name без указания пути к этому пакету.
<p>
    <font color="green">rosrun [package_name] [node_name] __name:=[new_node_name]</font> - изменили имя ноды node_name на new_node_name.
<p>
    <font color="green">rosnode ping [node_name]</font> - пингуем ноду, чтобы проверить, что она запущена.
<h3>Использование rqt_graph</h3>
Программа rqt_graph показывает связи между топиками и нодами.<br>
Чтобы установить эту программу:<br>
<font color="green">sudo apt-get install ros-&lt;distro&gt;-rqt</font><br>
<font color="green">sudo apt-get install ros-&lt;distro&gt;-rqt-common-plugins</font><br>
<distro> заменить на название дистрибутива ROS: (noetic, kinetic и т.подобное).
<p>
    Чтобы выполнить эту программу, команда:<br>
    <font color="green">$ rosrun rqt_graph rqt_graph</font>
<h3>>Команды rostopic:</h3>
<ul>
    <li> rostopic bw     display bandwidth used by topic
    <li>  rostopic echo [topic]   - показывает данные, публикуемые в топик.
    <li>  rostopic hz     display publishing rate of topic    
    <li>  rostopic list   - возвращает список всех топиков, на которые в данный момент подписаны и которые опубликованы.<br>
        Опции этой команды:
        <ul>
            <li>-h, --help            show this help message and exit
            <li>    -b BAGFILE, --bag=BAGFILE  список топиков в .bag file
            <li>    -v, --verbose         list full details about each topic
            <li>    -p                    list only публицистов
            <li>    -s                    list only подписчиков
        </ul>
    <li>  rostopic pub    publish data to topic
    <li>  rostopic type   print topic type
</ul>    
Ноды общаются между собой с помошью messages (сообщений). Чтобы ноды понимали друг друга, сообщения должны иметь одинаковый тип. Чтобы узнать тип сообщений, служит команда:<br>
<font color="green">rostopic type [topic]</font><br>
Вернёт тип (имя) сообщений, используемого для топика.
<p>
Чтобы посмотреть детали этого сообщения, используется команда:<br>
<font color="green">$ rosmsg show [name_meesage]</font>
<p>
    <font color="green">rostopic pub [topic] [msg_type] [args]</font><br>
     публикует данные по объявленному топику.<br>
    Пример:<br>
    <i><b>$ rostopic pub -1 /turtle1/cmd_vel geometry_msgs/Twist -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'</b></i>
    <ul>
        <li> <b>-1</b> Этот параметр приводит к тому, что rostopic публикует только одно сообщение, а затем завершает работу
    <li> <b>/turtle1/cmd_vel</b> - это имя топика, в который отправляем (публикуем) сообщение
        <li> <b>geometry_msgs/Twist</b> - это тип (имя) сообщения, которое отправляем в топик.
        <li> <b>--</b> - этот параметр (двойное тире) указывает анализатору параметров, что ни один из следующих аргументов не является параметром. Это необходимо в тех случаях, когда ваши аргументы начинаются с тире -, например, с отрицательных чисел.
    <li> <b>'[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'</b> - сообщение geometry_msgs/Twist содержит два вектора по три элемента с плавающей запятой в каждом: линейный и угловой. В этом случае, '[2.0, 0.0, 0.0]' становится линейным значением при x=2.0, y=0.0 и z=0.0, а '[0.0, 0.0, 1.8]' - угловым значением при x=0.0, y=0.0 и z=1.8. Эти аргументы на самом деле приведены в синтаксисе YAML
    </ul>
    Мы можем опубликовать постоянный поток команд, используя команду rostopic pub -r:<br>
    <i><b>$ rostopic pub /turtle1/cmd_vel geometry_msgs/Twist -r 1 -- '[2.0, 0.0, 0.0]' '[0.0, 0.0, -1.8]</b></i>
<p>
    <font color="green">rostopic hz [topic]</font> - сообщает о скорости публикации данных в [topic].
<p>
    <b>rqt_plot</b> - эта утилита отображает график времени прокрутки данных, опубликованных в топиках.<br>
    Сперва нужно выполнить команду: <font color="green">$ rosrun rqt_plot rqt_plot</font>
<br><br><br><br><br><br></body></html>