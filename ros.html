<html><head>
<style>
.menu {
       height: 100%;
       width: 160px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       /*background-color: #111;  Черный */
      }
 .menu a {
  padding: 6px 8px 6px 16px;
  text-decoration: none;
  font-size: 15px;
  color: #818181;
  display: block;
          }     
.content {
           margin-left: 160px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>ROS</title>
<div class="menu">
<a href="#top">Основные концепции системы ROS</a><br>
<a href="#name">Names</a><br>
<a href="#node">Ноды</a><br>
</div>
<div class="content">
<h2 align="center"><a name="top">Основные концепции системы ROS</h2>
Ссылки: <a href="https://copter-space.gitbook.io/uchebnik-mashinnoe-zrenie-tom-2/razdel-2/osnovnye-koncepcii-sistemy-ros">Основные концепции системы ROS</a>

<h3 align=center>Файловая система ROS</h3>

Концепция файловой системы ROS в основном относится к ресурсам ROS, находящимся на диске, таким как:
<ul>
<li> <b>Пакеты (Packages)</b>: Пакет – основная единица файловой системы ROS. В основном пакет содержит выполняемые процессы ROS (узлы или ноды - nodes), библиотеки на основе ROS, наборы данных, конфигурационные файлы и прочие полезные данные. Пакет – это минимальная единица для компиляции и релиза в ROS.<br>
<b>Команды для работы с пакетами:</b>
<ul>
<li> Поиск пакета: <font color="green">rospack find [package_name]</font><br>
<img src="./images/rospack1.png">   
<li> <b>roscd:</b> <font color="green">roscd &lt;package-or-stack&gt;[/subdir]</font> переход к указанному пакету.<br>
<img src="./images/roscd.png">
<li> Чтобы увидеть список каталогов, где находятся пакеты, служит команда: <font color="green">echo $ROS_PACKAGE_PATH</font>
<li> <font color="green">roscd log</font>  приведет вас к папке, в которой хранятся файлы журнала ROSS. Обратите внимание, что если вы еще не запускали какие-либо программы для ROM, это приведет к ошибке, указывающей на то, что они еще не существуют.
<li> <font color="green">rosls &lt;package-or-stack&gt;[/subdir]</font> показывает состав пакета, обращаясь к нему по имени, а не по абсолютному пути.<br>
 <img src="./images/rosls.png"><br>
Клавиша TAB выполняет функцию автозаполнения или если дважды, то список вариантов. Например напишем ros и нажмем дважды TAB, выведутся все команды ros'а.<br>
<b>rosls</b> и дважды TAB, то выведет список установленных пакетов.
</ul>
<li> <b>Метапакеты (Metapackages)</b>: Метапакеты – это специализированные Пакеты, используемые для группировки других взаимосвязанных Пакетов. Используются также для обратной совместимости.
<li> <b><a href="https://wiki.ros.org/catkin/package.xml">Манифесты Пакетов (Package Manifests)</a></b>: Манифест (package.xml) содержит данные о пакете, включая имя, версию, описание, информацию о лицензировании, зависимости и прочую информацию, такую как экспортируемые пакеты.

<li> <b>Репозитории (Repositories)</b>: набор пакетов, принадлежащих одной и той же версии. Пакеты одной и той же системы контроля версий и одинаковой версии могут выпускаться вместе с помощью инструмента автоматизации релизов bloom (http://wiki.ros.org/bloom). Репозиторий также может содержать только один пакет.

<li> <b>Типы сообщений (Message types)</b>: описание сообщений, хранится в my_package/msg/MyMessageType.msg, определяет структуры данных для сообщений, передаваемых в ROS.

<li> <b>Типы сервисов (Service types)</b>: описание сервисов, хранится в my_package/srv/MyServiceType.srv, определяет структуры данных для запроса и ответа сервисов в ROS.

<li> <b>Рабочая область (Workspace)</b> в ROS — это папка, где разработчики создают, собирают и настраивают свои пакеты и программы. Содержит исходный код, пакеты и сборочные скрипты.<br>
Основная структура:
<ul>
<li> src: директория исходного кода, где хранятся пакеты ROS
<li> build: временная директория, используемая во время сборки пакетов
<li> devel: содержит файлы, необходимые для запуска программ после сборки, включая исполняемые файлы и среду окружения
</ul>
</ul>

<h3 align=center>Граф вычислений ROS</h3>
Граф вычислений ROS – это одноранговая сеть процессов ROS, обрабатывающих данные. Основные понятия, связанные с графом вычислений – это ноды (nodes), Мастер (Master), Сервер Параметров (Parameter Server), сообщения (messages), сервисы (services), топики (topics), контейнеры (bags). Все эти сущности передают данные для вычислительного графа ROS разными способами.
<ul>
<li> <b>Мастер ROS</b><br>
Мастер выполняет роль сервера имен для возможности подключения между собой различных нод. Связь между нодами (обмен сообщениями), невозможна без запущенного мастера. Запускается командой:
<p>
<font color=green>roscore</font>
<p>
При запуске ROS roscore, мастер будет запущен по адресу URI, установленным в переменной окружения ROS_MASTER_URI. По умолчанию адрес использует IP-адрес локального ПК и номер порта 11311
<p>
Ноды связываются с другими Нодами напрямую. Мастер только предоставляет информацию для поиска, подобно DNS серверу. Ноды, которые подписываются на топик, запрашивают связь с Нодами, которые публикуют данные в этот топик, и устанавливают эту связь через соответсвующий согласованный протокол. Наиболее часто используемый протокол – TCPROS, он использует стандартные TCP/IP

<li> <b>Ноды (Nodes)</b>:<br>
Ноды (узлы)– это программы (обычно написанные на Python или C++), которая взаимодействуют с другими нодами посредством ROS-топиков и ROS-сервисов. Одна нода управляет лазерным дальномером, другая – моторами колёс, третья нода определяет положение в пространстве, четвёртая планирует траекторию движения, пятая предоставляет графическое представление системы, и т.д.
<p>
Узлы ROS используют клиентские библиотеки ROS для взаимодействия с другими узлами, написанных на разных языках программирования:<br>
rospy = клиентская библиотека python<br>
roscpp = клиентская библиотека c++
<p>
При запуске нода регистрирует информацию о себе на мастере (название ноды, типы обрабатываемых сообщений). Зарегистрированная нода может взаимодействовать с другими нодами (получать и отправлять запросы). Важно отметить что обмен сообщениями между нодами работает без участия мастера (соединение между нодами происходит напрямую через топик). Мастер обеспечивает только единое пространство имен для решения вопроса куда подключиться к конкретной ноде. Адрес запуска ноды, берётся из переменной окружения ROS_HOSTNAME, которая должна быть определенна до запуска. Порт устанавливается на произвольное уникальное значение.
<li> <b>Сервер параметров (Parameter Server)</b>: Сервер параметров позволяет хранить данные с доступом по ключу в централизованном хранилище. В настоящее время Сервер Параметров является частью Мастера.<br>
Параметры в ROS представляют собой глобальные значения, которые можно использовать для настройки поведения узлов (nodes).<br>
Параметры могут быть различных типов: числа (целые и вещественные), строки, булевы значения, массивы и так далее.<br>
Для того, чтобы ноды могли использовать parameter, используем библиотечные функции либо с терминала команды rosparam.<br>
<b>Некоторые команды с параметрами:</b>
<ul>
    <li> Показать список всех параметров: <font color="green">rosparam list</font>
    <li> Установить значение параметра: <font color="green">rosparam set</font>
    <li> Получить значение параметра: <font color="green">rrosparam get</font>
    <li> Загрузить параметры из файла YAML: <font color="green">rosparam load</font>
    <li> Сохранить параметры в файл YAML: <font color="green">rosparam dump</font>
</ul>
<p>
<font color=brought><b><i>Как я понял ROS Parameter представляет собой массив (словарь) глобальных переменных, которые доступны для всех нод.</i></b></font>

<li> <b><a href="ros_message.html">Сообщения (Messages)</a></b>:<br>
Ноды отправляют и принимают данные между собой, согласно заданного формата. Эти данные называют Сообщения, а описание Типом Сообщения.

<li> <b>Топики (Topics)</b>:<br>
Сообщения передаются через механизм публикации/подписки. Нода отправляет сообщение, публикуя (publish) его в определённом Топике. Топик – это имя, идентифицирующее содержание сообщения. Нода, заинтересованная в определённых данных, осуществляет подписку (subscribe) на соответствующий Топик. Для одного топика может существовать несколько параллельно публикующих/подписанных на него Нод, равно как и одна Нода может публиковать сообщения в и/или подписываться на несколько Топиков. В общес случае, публикаторы/подписчики не оказывают влияния друг на друга. Идея заключается в отделении производства информации от её использования. Логически Топик может быть представлен как строго типизированная шина сообщений. У каждой шины есть наименование, и любой элемент может подсоединиться к шине для получения и отправки сообщений соответствующего типа.
<ul>
    <li> Топик (тема) — это имя для потока сообщений
    <li> Узлы общаются между собой посредством топиков
    <li> Узлы могут публиковать или подписываться на топик
    <li> Как правило, у топика один издатель и n подписчиков
</ul>

<li> <b>Сервисы (Services)</b>: Модель публикации/ подписки является очень гибкой, но её схема односторонней передачи сообщений «многие-многим» не подходит для взаимодействий типа «запрос-ответ», которые часто нужны в распределённой системе. Механизм «запрос-ответ» реализован через Сервисы. Сервис определяется парой структур сообщений – одна для запроса и одна для ответа. Нода предоставляет сервис, используя определённое Имя сервиса, клиент использует сервис, отправляя сообщение-запрос и ожидая ответа. Клиентские библиотеки ROS обычно представляют это взаимодействие для программиста в виде вызова удалённой процедуры.<br>
<b>Некоторые команды с сервисами:</b>
<ul>
    <li> Показать список активных сервисов: <font color=green>rosservice list</font>
    <li> Вызвать сервис с определёнными аргументами: <font color=green>rosservice call</font>
</ul>
Сервисы настраиваются в файлах .srv Файлы .srv описывают типы сервисов в ROS: определяют структуры данных, которые сервис принимает и возвращает. Каждый .srv файл содержит две части: запрос (Request) и ответ (Response), разделённые символом "---"
<ul>
    <li> Показать структуру .srv-файла для заданного типа сервиса: <font color="green">rossrv show [service_type]</font>
</ul>
<li> <b>Контейнеры (Bags)</b>: Контейнеры предоставляют форматы для записи и воспроизведения потоков ROS-сообщений. Контейнеры являются важным механизмом для записи данных, например, данных с сенсоров, которые трудно собрать, но необходимо сохранять для разработки и тестирования алгоритмов.
</ul>

<h3 align=center><a name="name">Имена</h3>
Ссылки: <a href="https://wiki.ros.org/Names">Names</a>
<p>
Имена ресурсов графа представляют собой иерархическую структуру имен, которая используется для всех ресурсов в графе вычислений ROS, таких как узлы, параметры, разделы и службы. Эти имена очень важны в ROS и играют центральную роль в создании более крупных и сложных систем в ROS, поэтому очень важно понимать, как работают эти имена и как вы можете ими манипулировать.
<p>
Любой топик, сервис или параметр идентифицируется с помощью уникального имени. ROS-имя представляет собой иерархическую структуру с символом / в качестве разделителя (сходно с именами в файловой системе).<br>
Примеры ROS-имен:<br>
/ (глобальное пространство имен)<br>
/foo<br>
/stanford/robot/name<br>
/wg/node1
<p>
Имена разрешаются относительно, поэтому ресурсам не нужно знать, в каком пространстве имен они находятся. Это упрощает программирование, поскольку узлы, которые работают вместе, могут быть записаны так, как если бы все они находились в пространстве имен верхнего уровня. Когда эти узлы интегрируются в более крупную систему, их можно поместить в пространство имен, определяющее их набор кода. Например, можно взять демонстрационную версию Stanford и демонстрационную версию Willow Garage и объединить их в новую демонстрационную версию с подграфами stanford и wg. Если бы у обеих демонстраций был узел с именем "camera", они бы не конфликтовали. Инструменты (например, визуализация графика), а также параметры (например, demo_name), которые должны быть видны всему графику, могут быть созданы узлами верхнего уровня.
<h4>Допустимые имена</h4>
Допустимое имя имеет следующие характеристики:
<ol>
<li> Первый символ - это буквенный знак ([a-z|A-Z]), тильда (~) или косая черта (/)
<li> Последующие символы могут быть буквенно-цифровыми ([0-9|a-z|A-Z]), символами подчеркивания (_) или косой черты (/).
</ol>
<p>
В ROS существует четыре типа имен графических ресурсов: базовые, относительные, глобальные и частные, которые имеют следующий синтаксис:
<ul>
<li> base<br>
Имена без каких-либо определителей пространства имен являются базовыми именами. Базовые имена на самом деле являются подклассом относительных имен и имеют те же правила разрешения. Базовые имена чаще всего используются для инициализации имени узла.
<li> relative/name<br>
По умолчанию разрешение выполняется относительно пространства имен узла. Например, узел /wg/node1 имеет пространство имен /wg, поэтому имя node2 будет преобразовано в /wg/node2.
<li> /global/name<br>
Имена, начинающиеся с "/", являются глобальными - они считаются полностью разрешенными. По возможности следует избегать глобальных имен, поскольку они ограничивают переносимость кода.
<li> ~private/name<br>
Имена, начинающиеся с "~", являются частными. Они преобразуют имя узла в пространство имен. Например, узел 1 в пространстве имен /wg/ имеет частное пространство имен /wg/node1. Личные имена полезны для передачи параметров определенному узлу через сервер параметров.
</ul>
<p>
Вот несколько примеров разрешения имен:<br>
<img src="./images/ros4.png">
<p>
Приватное имя<br>
Каждая нода может использовать собственное приватное пространство имен (соответствующее имени ноды) для своих ресурсов. Например, нода aruco_detect может публиковать такие топики:<br>
/aruco_detect/markers<br>
/aruco_detect/visualization<br>
/aruco_detect/debug<br>
Когда нода ссылается на свой приватный ресурс, вместо пространства имен (/aruco_detect/) используется символ ~, например:<br>
~markers<br>
~visualization<br>
~debug<br>
Таким образом, создание топика foo в приватном пространство имен из Python будет выглядеть так:<br>
private_foo_pub = rospy.Publisher('~foo', String, queue_size=1)
<p>
Относительное имя<br>
Несколько нод также могут объединяться в общее пространство имен (например, при одновременной работе нескольких роботов). Для того, чтобы ссылаться на топики с учетом общего пространства имен, в названии ресурса опускается начальный символ /.
<p>
Пример создание топика foo с учетом общего пространства имен:
<pre>relative_foo_pub = rospy.Publisher('foo', String, queue_size=1)</pre>
<p>
<b>Пример</b>:<br>
для контроля лазерного дальномера мы запускаем драйвер hokuyo_node, который опрашивает лазер и публикует sensor_msgs/LaserScan сообщения в топик scan. Дла обработки этих данных, мы можем написать, используя пакет laser_filters, ноду, которая подписывается на сообщения топика scan. После подписки наш laser_filters автоматически начнёт получать сообщения от лазера.
<p>
Теперь о том, как происходит разделение. Нода hokuyo_node только публикует сообщения, не зная о том, подписан ли на них кто либо. Нода пакета laser_filters только подписывается на сообщения топика, не зная о том, публикует ли кто-то туда сообщения. Обе ноды могут быть запущены, остановлены, перезапущены, в любом порядке, не порождая при этом ошибок.
<p>
Далее мы можем добавить роботу другой лазерный дальномер, поэтому нужно переконфигурировать систему. Всё что нужно при этом – переназначить (remap) используемые имена. При запуске ноды hokuyo_node мы можем вместо имени scan переназначить имя base_scan. B то же самое сделать с нодой – фильтром. Теперь обе эти ноды будут связаны с использованием топика base_scan, и перестанут обрабатывать сообщение тописа scan. После этого мы можем запустить ещё одну ноду hokuyo_node для нового лазерного дальномера.

<h4>Имена ресурсов пакетов</h4>
Имена ресурсов пакетов используются в ROS с концепциями на уровне файловой системы для упрощения процесса обращения к файлам и типам данных на диске. Имена ресурсов пакетов очень просты: это просто название пакета, в котором находится ресурс, плюс название ресурса. Например, имя "std_msgs/String" относится к типу сообщения "String" в пакете "std_msgs".
<p>
Имена ресурсов пакетов очень похожи на пути к файлам, за исключением того, что они намного короче. Это связано со способностью ROS находить пакеты на диске и делать дополнительные предположения об их содержимом. Например, описания сообщений всегда хранятся в подкаталоге msg и имеют расширение .msg, поэтому std_msgs/String - это сокращение от path/to/std_msgs/msg/String.msg. Аналогично, тип узла foo/bar эквивалентен поиску файла с именем bar в пакете foo с правами доступа к исполняемому файлу.
<p>
<b>Допустимые имена</b><br>
Имена ресурсов пакетов имеют строгие правила именования, поскольку они часто используются в автоматически генерируемом коде. По этой причине в пакете ROS не может быть специальных символов, кроме символа подчеркивания, и они должны начинаться с алфавитного знака. Допустимое имя имеет следующие характеристики:
<ul>
<li> Первый символ - это буквенный знак ([a-z|А-Язь])
<li> Последующие символы могут быть буквенно-цифровыми ([0-9|а-язь|А-Язь]), символами подчеркивания (_) или косой черты (/).
<li> Существует не более одной косой черты ('/').
</ul>

<h2 align="center"><a name="node">Ноды (узлы)</h2>
Ссылки: <a href="https://se.moevm.info/doku.php/courses:ros:class2">Занятие № 2: Детальное представление о среде</a>
<p>
Прежде чем выполнять команды над нодами, следует вызвать мастера ROS, команда:
<p>
<font color="green">roscore</font><br>
<p>
И после этого в другом терминале выполнять команды.<br>
Если вы хотите чтобы roscore запустился в фоновом режиме, то запустите его командой:<br>
<p>
<font color=green>roscore &</font> 
<h3>Список активных нод:</h3>
<font color="green">rosnode list</font> - выводит список этих активных узлов.
<p>
Если не запускали какую-нибудь ноду, то покажет только rosout. Он всегда запущен, поскольку собирает и регистрирует выходные данные отладки узлов.
<p>
<font color="green">rosnode info &lt;name_node&gt;</font> - покажет информацию о ноде.<br>
Пример:<br>
<img src="./images/info_my_turtl.png">
<h4>Запуск нод</h4>
Запуск нод в ROS осуществляется при помощи команды rosrun. Общий синтаксис употребления этой команды выглядит так:
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>rosrun &lt;пакет&gt; &lt;нода&gt; [&lt;имя параметра&gt;:=&lt;значение&gt;]</b>
<p>
Причём в графе <нода> указывается не произвольное имя новой ноды, а класс-тип нод, экземпляр которого нужно запустить. Непосредственно имя ноды устанавливается через параметры.
<p>
<font color="green">rosrun [package_name] [node_name]</font> - позволит выполнить ноду node_name внутри пакета package_name без указания пути к этому пакету.<br>
Например выполнить turtlesin_node внутри пакета turtlesim.<br>
<img src="./images/ros5.png">
<br>
Будет запущена нода типа turtlesim_node из пакета turtlesim. Имя ноды в данном случае не указывалось и оно присвоится автоматически. Теперь, если в новом терминале ввести команду:<br>
<b>rosnode list</b><br>
в ответ будет получено следующее:<pre>
/rosout   
/turtlesim</pre>
Таким образом создалась ещё одна нода с именем /turtlesim и определённая в глобальном поле имён, о чём говорит предшествующий символ слеш “/”. Если в новом терминале вновь будет выполнена команда:<br>
<b>rosrun turtlesim turtlesim_node</b><br>
То создастся новая нода с тем же именем /turtlesim. Это вызовет аварийную остановку уже созданной ноды:
<pre>
[ WARN] [1471851936.261860979]: Shutdown request received.          
[ WARN] [1471851936.261924457]: Reason given for shutdown: [new node
registered with same name]
</pre>                                          
Для того, чтобы указать имя ноды, при её создании необходимо присвоить значение переменной __name (с двумя символами нижнего подчёркивания). Таким образом, чтобы создать ноду с именем “turtle_node” необходимо выполнить команду:<br>
<b>rosrun turtlesim turtlesim_node __name:=turtle_node</b>
<p>
<b>Пинг ноды:</b><br>
<font color="green">rosnode ping [node_name]</font> - пингуем ноду, чтобы проверить, что она запущена.


<h2 align=center>Команды rostopic:</h2>
<ul>
<li> <font color="green">rostopic echo [topic]</font> - показывает данные, публикуемые в топик.
<li> <font color="green">rostopic list</font> - возвращает список всех топиков, на которые в данный момент подписаны и которые публикуют.<br>
Опции этой команды:
<ul>
<li> -h, --help            show this help message and exit
<li> -b BAGFILE, --bag=BAGFILE  список топиков в .bag file
<li> -v, --verbose  дополнительно показывает сколько подписчиков и публицистов на топики завязано.
<li> -p список только публицистов
<li> -s список только подписчиков
</ul>
<img src="./images/rostopic_list.png">
<li> Тип сообщений:<br>
Ноды общаются между собой с помошью messages (сообщений). Чтобы ноды понимали друг друга, сообщения должны иметь одинаковый тип. Чтобы узнать тип сообщений, служит команда:<br>
<font color="green">rostopic type [topic]</font><br>
Вернёт тип (имя) сообщений, используемого для топика.<br>
<img src="./images/rostopic_type.png">
<p>
Чтобы посмотреть детали этого сообщения, используется команда:<br>
<font color="green">rosmsg show [name_meesage]</font><br>
<img src="./images/rosmsg_show.png">
<li> <b>Отправка сообщений в топик:</b><br>
зная тип (имя) сообщений, мы можем отправлять их ноде через топик, тем самым управлять нодой.<br>
Синтаксис:<br>
<font color="green">rostopic pub [topic] [msg_type] [args]</font><br>
публикует данные по объявленному топику.<br>
<img src="./images/rostopic_pub.png">
<ul>
<li> <b>-1</b> Этот параметр приводит к тому, что rostopic публикует только одно сообщение, а затем завершает работу
<li> <b>/turtle1/cmd_vel</b> - это имя топика, в который отправляем (публикуем) сообщение
<li> <b>geometry_msgs/Twist</b> - это тип (имя) сообщения, которое отправляем в топик.
<li> <b>--</b> - этот параметр (двойное тире) указывает анализатору параметров, что ни один из следующих аргументов не является параметром. Это необходимо в тех случаях, когда ваши аргументы начинаются с тире -, например, с отрицательных чисел.
<li> <b>'[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'</b> - сообщение geometry_msgs/Twist содержит два вектора по три элемента с плавающей запятой в каждом: линейный и угловой. В этом случае, '[2.0, 0.0, 0.0]' становится линейным значением при x=2.0, y=0.0 и z=0.0, а '[0.0, 0.0, 1.8]' - угловым значением при x=0.0, y=0.0 и z=1.8. Эти аргументы приведены в синтаксисе YAML.<br>
Чтобы не запоминать формат сообщения, можно после типа сообщения дважды нажать клавишу tab. Это выпишет имена полей и рядом начальные значения, которыми они инициализируются. Далее их можно изменить.
</ul>
<p>
Мы можем опубликовать постоянный поток команд, используя опцию -r:<br>
<img src="./images/ros10.png">
<p>
<font color="green">rostopic hz [topic]</font> - сообщает о скорости публикации данных в [topic].
</ul>
Весь список команд rostopic:
<ul>
<li> rostopic bw     Показать занимаемый сетевой канал
<li> rostopic echo   Вывести сообщения на экран
<li> rostopic find   Поиск топика по типу
<li> rostopic hz     Показать частоту обновления топика
<li> rostopic info   Показать информацию о топике
<li> rostopic list   Показать список существующий топиков
<li> rostopic pub    Опубликовать данные в топик
<li> rostopic type   Показать тип сообщения для топика
</ul>

<h3 align="center">Команды rosparam:</h3>
rosparam позволяет хранить данные на сервере параметров ROS и манипулировать ими. Сервер параметров может хранить целые числа, значения с плавающей запятой, логические значения, словари и списки. Для синтаксиса rosparam использует язык разметки YAML. В простых случаях YAML выглядит очень естественно: 1 - целое число, 1.0 - число с плавающей точкой, "единица" - строка, true - логическое значение, [1, 2, 3] - список целых чисел, {a: b, c: d} - словарь. В rosparam есть множество команд, которые можно использовать для работы с параметрами:
<ul>
    <li> <font color="green">rosparam list</font> - список параметров<br>
        <img src="./images/rosparam_list.png">
    <li> <font color="green">rosparam set [param_name]</font> - устанавливаем значение параметра [param_name]<br>
        Пример: <i>$ rosparam set /turtlesim/background_r 150</i><br>
        <font color="green">rosparam get [param_name]</font> - выводит значение параметра<br>
        <img src="./images/ros12.png"><br>
        Чтобы изменение параметра вступило в силу, нужно вызвать службу чистильщика (/clean).
    <li> Команда <font color="green">rosparam get /</font> выведет значения всех параметров на сервере параметров.<br>
        <img src="./images/rosparam_get.png">
        <p>
            <font color="green">rosparam get name_parametr</font> - выводит значение параметра name_parametr:<br>
            <img src="./images/rosparam_get1.png">
    <li> Если хотим сохранить этот набор параметров, чтобы потом вызвать, то служит команда:<br>
        <font color="green">rosparam dump [file_name] [namespace]</font> - записываем все параметры в файл [file_name]
    <li> Вызвать сохранённый набор параметров [file_name] для [namespace], служит команда:<br>
        <font color="green">rosparam load [file_name] [namespace]</font>
</ul>



<h3 align="center">Команда rosed</h3>
Синтаксис:
<p>
    <font color="green">rosed [package_name] [filename]</font>
<p>
    Служит для редактирования файла [filename] из пакета [package_name].<br>
    По умолчанию редактором является vim. Чтобы редактором для команды rosed был более простой nano, следует в файл ~/.bashrc добавить строку:<br>
    <b>export EDITOR='nano -w'</b>


<h3>Получение подсказки по команде</h3>
Познакомились с довольно большим количеством инструментов ROS. Иногда бывает сложно отследить, какие аргументы требуются для каждой команды. К счастью, большинство инструментов ROS предоставляют свою собственную помощь. Чтобы получить подсказку по команде, достаточно опции -h:<br>
<img src="./images/rosmsg_h.png">

</div>
<br><br><br><br><br><br></body></html>
