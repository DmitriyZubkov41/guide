<html><head></head><body>
<title>ROS</title>
<a href="https://wiki.ros.org/ru">ROS Tutorials</a>
<h2 align="center">Основные концепции системы ROS</h2>
Ссылки: <a href="https://copter-space.gitbook.io/uchebnik-mashinnoe-zrenie-tom-2/razdel-2/osnovnye-koncepcii-sistemy-ros">Основные концепции системы ROS</a>

<h3 align=center>Файловая система ROS</h3>

Концепция файловой системы ROS в основном относится к ресурсам ROS, находящимся на диске, таким как:
<ul>
<li> <b>Пакеты (Packages)</b>: Пакет – основная единица файловой системы ROS. В основном пакет содержит выполняемые процессы ROS (узлы или ноды - nodes), библиотеки на основе ROS, наборы данных, конфигурационные файлы и прочие полезные данные. Пакет – это минимальная единица для компиляции и релиза в ROS.<br>
<b>Команды для работы с пакетами:</b>
<ul>
    <li>Поиск пакета: <font color="green">rospack find [package_name]</font><br>
        <img src="./images/rospack1.png">   
    <li><b>roscd:</b> <font color="green">roscd &lt;package-or-stack&gt;[/subdir]</font> переход к указанному пакету.<br>
        <img src="./images/roscd.png">
    <li>Чтобы увидеть список каталогов, где находятся пакеты, служит команда: <font color="green">echo $ROS_PACKAGE_PATH</font>
    <li><font color="green">roscd log</font>  приведет вас к папке, в которой хранятся файлы журнала ROSS. Обратите внимание, что если вы еще не запускали какие-либо программы для ROM, это приведет к ошибке, указывающей на то, что они еще не существуют.
    <li><font color="green">rosls &lt;package-or-stack&gt;[/subdir]</font> показывает состав пакета, обращаясь к нему по имени, а не по абсолютному пути.<br>
        <img src="./images/rosls.png"><br>
    Клавиша TAB выполняет функцию автозаполнения или если дважды, то список вариантов. Например напишем ros и нажмем дважды TAB, выведутся все команды ros'а.<br>
    <b>rosls</b> и дважды TAB, то выведет список установленных пакетов.
</ul>
<li> <b>Метапакеты (Metapackages)</b>: Метапакеты – это специализированные Пакеты, используемые для группировки других взаимосвязанных Пакетов. Используются также для обратной совместимости.

<li> <b><a href="https://wiki.ros.org/catkin/package.xml">Манифесты Пакетов (Package Manifests)</a></b>: Манифест (package.xml) содержит данные о пакете, включая имя, версию, описание, информацию о лицензировании, зависимости и прочую информацию, такую как экспортируемые пакеты.

<li> <b>Репозитории (Repositories)</b>: набор пакетов, принадлежащих одной и той же версии. Пакеты одной и той же системы контроля версий и одинаковой версии могут выпускаться вместе с помощью инструмента автоматизации релизов bloom (http://wiki.ros.org/bloom). Репозиторий также может содержать только один пакет.

<li> <b>Типы сообщений (Message types)</b>: описание сообщений, хранится в my_package/msg/MyMessageType.msg, определяет структуры данных для сообщений, передаваемых в ROS.

<li> <b>Типы сервисов (Service types)</b>: описание сервисов, хранится в my_package/srv/MyServiceType.srv, определяет структуры данных для запроса и ответа сервисов в ROS.

<li> <b>Рабочая область (Workspace)</b> в ROS — это папка, где разработчики создают, собирают и настраивают свои пакеты и программы. Содержит исходный код, пакеты и сборочные скрипты.<br>
Основная структура:
<ul>
    <li> src: директория исходного кода, где хранятся пакеты ROS
<li> build: временная директория, используемая во время сборки пакетов
<li> devel: содержит файлы, необходимые для запуска программ после сборки, включая исполняемые файлы и среду окружения
</ul>
</ul>
    <h3 align=center>Граф вычислений ROS</h3>

Граф вычислений ROS – это одноранговая сеть процессов ROS, обрабатывающих данные. Основные понятия, связанные с графом вычислений – это ноды (nodes), Мастер (Master), Сервер Параметров (Parameter Server), сообщения (messages), сервисы (services), топики (topics), контейнеры (bags). Все эти сущности передают данные для вычислительного графа ROS разными способами.
<ul>
<li> <b>Ноды (Nodes)</b>: Ноды (узлы)– это программы, выполняющие вычисления. Системы использующие ROS состоят из модулей, система управления роботом включает в себя множество нод. Например, одна нода управляет лазерным дальномером, другая – моторами колёс, третья нода определяет положение в пространстве, четвёртая планирует траекторию движения, пятая предоставляет графическое представление системы, и т.д. ROS ноды разрабатывают с использованием клиентских библиотек ROS, таких как roscpp или rospy.
    <br><b>Некоторые команды с узлами:</b>
    <ul>
<li> Запуск узла: <font color="green">rosrun package_name node_name</font><br>
<li> <b>Список запущенных узлов</b>: <font color="green">rosnode list</font><br>
<li> <b>Информация об определённом узле</b>: <font color="green">rosnode info node_name</font>
</ul>
<li> <b>Мастер (Master)</b>: Мастер-процесс ROS обеспечивает регистрацию имён и наблюдение за всем вычислительным графом. Без мастер-процесса ноды не смогли бы найти друг друга, обмениваться сообщениями или вызывать сервисы.

<li> <b>Сервер параметров (Parameter Server)</b>: Сервер параметров позволяет хранить данные с доступом по ключу в централизованном хранилище. В настоящее время Сервер Параметров является частью Мастера.<br>
Параметры в ROS представляют собой глобальные значения, которые можно использовать для настройки поведения узлов (nodes).<br>
Параметры могут быть различных типов: числа (целые и вещественные), строки, булевы значения, массивы и так далее.<br>
<b>Некоторые команды с параметрами:</b>
<ul>
    <li> Показать список всех параметров: <font color="green">rosparam list</font>
    <li> Установить значение параметра: <font color="green">rosparam set</font>
    <li> Получить значение параметра: <font color="green">rrosparam get</font>
    <li> Загрузить параметры из файла YAML: <font color="green">rosparam load</font>
    <li> Сохранить параметры в файл YAML: <font color="green">rosparam dump</font>
</ul>
<li> <b>Сообщения (Messages)</b>: Ноды обмениваются данными посредством передачи Сообщений. Сообщение – это структура данных, состоящая из структурированных полей. Поддерживаются стандартные примитивные типы (integer, floating point, boolean, и т.д.), а также и массивы из них. Сообщение может содержать произвольные вложенные структуры и массивы (очень похоже на структуры в языке С).<br>
Каждое поле состоит из типа и имени, разделённых пробелом.<br>
<b>Типы полей могут быть</b>:
<ul>
    <li> специальный тип Header
    <li> встроенный тип
    <li> другие Message
    <li> массивы (списки)
</ul>
<b>Некоторые команды:</b>
<ul>
    <li> Просмотр типа топика: rostopic type /topic
    <li> Опубликовать сообщение в топике: rostopic pub /topic type args
    <li> Просмотр определения типа сообщения: rosmsg show type
</ul>

<li> <b>Топики (Topics)</b>: Сообщения передаются через механизм публикации/подписки. Нода отправляет сообщение, публикуя (publish) его в определённом Топике. Топик – это имя, идентифицирующее содержание сообщения. Нода, заинтересованная в определённых данных, осуществляет подписку (subscribe) на соответствующий Топик. Для одного топика может существовать несколько параллельно публикующих/подписанных на него Нод, равно как и одна Нода может публиковать сообщения в и/или подписываться на несколько Топиков. В общес случае, публикаторы/подписчики не оказывают влияния друг на друга. Идея заключается в отделении производства информации от её использования. Логически Топик может быть представлен как строго типизированная шина сообщений. У каждой шины есть наименование, и любой элемент может подсоединиться к шине для получения и отправки сообщений соответствующего типа.
<ul>
    <li> Топик (тема) — это имя для потока сообщений
    <li> Узлы общаются между собой посредством топиков
    <li> Узлы могут публиковать или подписываться на топик
    <li> Как правило, у топика один издатель и n подписчиков
</ul>
<b>Некоторые команды с топиками</b>:
<ul>
    <li> Получение списка топиков: <font color=green>rostopic list</font>
    <li> Подписка на топик и вывод сообщений: <font color=green>rostopic echo /topic</font>
    <li> Вывод информации от топике: <font color=green>rostopic info /topic</font>
</ul>
<li> <b>Сервисы (Services)</b>: Модель публикации/ подписки является очень гибкой, но её схема односторонней передачи сообщений «многие-многим» не подходит для взаимодействий типа «запрос-ответ», которые часто нужны в распределённой системе. Механизм «запрос-ответ» реализован через Сервисы. Сервис определяется парой структур сообщений – одна для запроса и одна для ответа. Нода предоставляет сервис, используя определённое Имя сервиса, клиент использует сервис, отправляя сообщение-запрос и ожидая ответа. Клиентские библиотеки ROS обычно представляют это взаимодействие для программиста в виде вызова удалённой процедуры.<br>
    <b>Некоторые команды с сервисами:</b>
    <ul>
        <li> Показать список активных сервисов: <font color=green>rosservice list</font>
        <li> Вызвать сервис с определёнными аргументами: <font color=green>rosservice call</font>
    </ul>
Сервисы настраиваются в файлах .srv Файлы .srv описывают типы сервисов в ROS: определяют структуры данных, которые сервис принимает и возвращает. Каждый .srv файл содержит две части: запрос (Request) и ответ (Response), разделённые символом "---"
<ul>
    <li> Показать структуру .srv-файла для заданного типа сервиса: <font color="green">rossrv show [service_type]</font>
</ul>
<li> <b>Контейнеры (Bags)</b>: Контейнеры предоставляют форматы для записи и воспроизведения потоков ROS-сообщений. Контейнеры являются важным механизмом для записи данных, например, данных с сенсоров, которые трудно собрать, но необходимо сохранять для разработки и тестирования алгоритмов.
</ul>
<b>Мастер ROS</b> играет роль сервера имён в Вычислительном графе ROS. Он хранит информацию о Топиках и Сервисах для ROS-нод. Ноды сообщают Мастеру свою регистрационную информацию. В процессе коммуникации с Мастером Ноды могут получать информацию о других зарегистрированных Нодах, устанавливать с ними связь. Мастер также осуществляет обратные вызовы к Нодам, когда регистрационная информация меняется, что позволяет нодам динамически устанавливать связи по мере запуска новых Нод.
<p>
Ноды связываются с другими Нодами напрямую. Мастер только предоставляет информацию для поиска, подобно DNS серверу. Ноды, которые подписываются на топик, запрашивают связь с Нодами, которые публикуют данные в этот топик, и устанавливают эту связь через соответсвующий согласованный протокол. Наиболее часто используемый протокол – TCPROS, он использует стандартные TCP/IP сокеты.
<p>
Такая архитектура обеспечивает раздельное функционирование системы, в которой посредством распределений имён могут быть построены большие сложные распределённые системы. Имена играют важнейшую роль в ROS: ноды, топики, сервисы и параметры все имеют имена. Каждая клиентская ROS-библиотека поддерживает переназначение (remapping) имён с помощью инструментов командной строки, т.е. скомпилированная программа может быть переконфигурирована во время выполнения для обработки различной топологии Вычислительного графа.
<p>
Например, для контроля лазерного дальномера мы запускаем драйвер hokuyo_node, который опрашивает лазер и публикует sensor_msgs/LaserScan сообщения в топик scan. Дла обработки этих данных, мы можем написать, используя пакет laser_filters, ноду, которая подписывается на сообщения топика scan. После подписки наш фильтр автоматически начнёт получать сообщения от лазера.
<p>
Теперь о том, как происходит разделение. Нода hokuyo_node только публикует сообщения, не зная о том, подписан ли на них кто либо. Нода фильтра только подписывается на сообщения топика, не зная о том, публикует ли кто-то туда сообщения. Обе ноды могут быть запущены, остановлены, перезапущены, в любом порядке, не порождая при этом ошибок.
<p>
Далее мы можем добавить роботу другой лазерный дальномер, поэтому нужно переконфигурировать систему. Всё что нужно при этом – переназначить (remap) используемые имена. При запуске ноды hokuyo_node мы можем вместо имени scan переназначить имя base_scan. B то же самое сделать с нодой – фильтром. Теперь обе эти ноды будут связаны с использованием топика base_scan, и перестанут обрабатывать сообщение тописа scan. После этого мы можем запустить ещё одну ноду hokuyo_node для нового лазерного дальномера.

<h2 align="center"><a href="https://wiki.ros.org/ru/ROS/Tutorials">Из официальной документации</a></h3>
<h3><a href="http://wiki.ros.org/ROS/Tutorials/CreatingPackage">Создание пакетов</a></h3>
<ol>
    <li><h3>Что такое catkin пакет?</h3>
Чтобы catkin пакет считался таким, он должен иметь признаки:
<ul>
    <li> пакет должен содержать файл package.xml
    <li> должен содержать файл  CMakeLists.txt
    <li> У каждого пакета должна быть своя собственная папка. Это означает, что нет ни вложенных пакетов, ни нескольких пакетов, использующих один и тот же каталог.
    </ul>
<li><h3 align="center">Пакеты в catkin workspace</h3>
Обычный catkin workspace:<br>
<img src="./images/catkin_ws.png">
<li>Создание catkin-пакета.<br>
    Общий синтаксис команды создания пакета:<br>
    <font color="green">catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</font><br>
catkin_create_pkg требует, чтобы вы указали ему имя пакета и, возможно, список зависимостей, от которых зависит этот пакет.<br>
Пример:<br>
    <font color="green">cd ~/catkin_ws/src</font> переходим в каталог src<br>
    <font color="green">catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</font><br>
    <img src="./images/catkin_create_pkg.png"><br>
    Создаем пакет beginner_tutorials, который зависит от нод std_msgs, rospy и roscpp.В результате будет создана папка beginner_tutorials, содержащая файлы package.xml и CMakeLists.txt, которые были частично заполнены информацией, которую вы предоставили catkin_create_pkg.
<li><h3>Изменение рабочего пространства catkin (catkin workspace) с учетом нового пакета и исполнение setup файла</h3>
    <font color="green">cd ~/catkin_ws<br>
    catkin_make</font><br>
    После создания рабочей области в подпапке devel будет создана аналогичная структура, которую вы обычно находите в /opt/ros/noetic<br>
    Чтобы добавить переменные, нужно выполнить команду:<br>
    <font color="green">. ~/catkin_ws/devel/setup.bash</font>
<li><b>Пакетные зависимости:</b><br>
    <ul>
    <li> <b>Зависимости первого порядка</b><br>
            При использовании catkin_create_pkg ранее были предоставлены несколько зависимостей от пакетов. Эти зависимости первого порядка теперь можно просмотреть с помощью инструмента rospack:<br>
            <font color="green">rospack depends1 &lt;package_name&gt;</font><br>
           Выдаст список зависимостей, которые были установлены во время выполнения команды catkin_create_pkg. Эти зависимости хранятся в файле package.xml.<br>
        <img src="./images/rospack_depends1.png">
    <li> <b>Косвенные зависимости</b><br>
        Во многих случаях у зависимостей также будут свои собственные зависимости. Например, у rospy есть другие зависимости.<br>
        <img src="./images/rospack_depends2.png"><br>
        Пакет может иметь много косвенных зависимостей:<br>
        <font color="green">rospack depends &lt;package_name&gt;</font> - выведет все зависимости.
    <li> <b>Файл package.xml содержит:</b>
<ul>
<li>тег description<br>
    <img src="./images/description.png">
<li> тег maintainer<br>
    Это обязательный и важный тег для package.xml потому что он позволяет другим пользователям узнать, к кому обратиться по поводу пакета. Требуется как минимум один специалист по сопровождению, но вы можете нанять их много, если хотите. Имя сопровождающего указано в тексте тега, но также есть атрибут электронной почты, который необходимо заполнить<br>
    <img src="./images/maintainer.png">
<li> теги лицензий<br> Обязательный. Наиболее распространенными лицензиями с открытым исходным кодом являются BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1 и LGPLv3. Вы можете прочитать о некоторых из них в разделе Open Source Initiative. В этом руководстве мы будем использовать лицензию BSD, поскольку остальные компоненты core RODS уже используют ее
теги зависимостей<br>
<img src="./images/license.png">
<li> тег зависимостей<br>
    Следующий набор тегов описывает зависимости вашего пакета. Зависимости разделены на build_depend, build tool_depend, exe c_depend, test_depend. Более подробное объяснение этих тегов приведено в документации о зависимостях Catkin. Поскольку мы передали std_msgs, roscpp и rospy в качестве аргументов для catkin_create_pkg, зависимости будут выглядеть следующим образом:
    <img src="./images/tag_depends.png">
<li> тег конца файла <b>&lt;/package&gt;</b>
</ul>
</ul>
</ol>

<h2 align="center">Ноды (узлы)</h2>
Узел на самом деле представляет собой не более чем исполняемый файл в пакете ROS. Узлы ROS используют клиентскую библиотеку ROS для взаимодействия с другими узлами. Узлы могут публиковать топики (opic) или подписываться на них. Узлы также могут предоставлять или использовать службы (service).
<p>
    Клиентские библиотеки ROS позволяют взаимодействовать узлам, написанным на разных языках программирования:<br>
    rospy = клиентская библиотека python<br>
    roscpp = клиентская библиотека c++
<p>
    Прежде чем выполнять команды над нодами, следует вызвать мастера ROS, команда: <font color="green">roscore</font><br>
    И после этого в другом терминале выполнять команды. 
<p>
    <font color="green">rosnode list</font> - выводит список этих активных узлов.<br>
Если не запускали какую-нибудь ноду, то покажет только rosout. Он всегда запущен, поскольку собирает и регистрирует выходные данные отладки узлов.
<p>
    <font color="green">rosnode info &lt;name_node&gt;</font> - покажет информацию о ноде.<br>
    Пример:<br>
    <img src="./images/info_my_turtl.png">
<p>
    <font color="green">rosrun [package_name] [node_name]</font> - позволит выполнить ноду node_name внутри пакета package_name без указания пути к этому пакету.<br>
    Например выполнить turtlesin_node внутри пакета turtlesim.<br>
    <img src="./images/turtlesim_node.png">
<p>
    <font color="green">rosrun [package_name] [node_name] __name:=[new_node_name]</font> - изменили имя ноды node_name на new_node_name.
<p>
    <font color="green">rosnode ping [node_name]</font> - пингуем ноду, чтобы проверить, что она запущена.
<h3>Использование rqt_graph</h3>
Запустили две ноды: turtlesim_node, которая является подписчиком на топик и turtle_teleop_key, которая является публикатором на тот же самый топик. Графически мы можем это увидитеть с помощью утилиты rqt_graph.
<p>
Программа rqt_graph показывает связи между топиками и нодами.<br>
Чтобы установить эту программу:<br>
<font color="green">sudo apt-get install ros-&lt;distro&gt;-rqt</font><br>
<font color="green">sudo apt-get install ros-&lt;distro&gt;-rqt-common-plugins</font><br>
&lt;distro&gt; заменить на название дистрибутива ROS: (noetic, kinetic и т.подобное).
<p>
    Чтобы выполнить эту программу, команда:<br>
    <font color="green">rosrun rqt_graph rqt_graph</font><br>
    <img src="./images/rqt_graf.png">

<h3>Команды rostopic:</h3>
<font color="green">rostopic echo [topic]</font> - показывает данные, публикуемые в топик.
<p>
    <font color="green">rostopic list</font> - возвращает список всех топиков, на которые в данный момент подписаны и которые публикуют.<br>
        Опции этой команды:
        <ul>
            <li>-h, --help            show this help message and exit
            <li>    -b BAGFILE, --bag=BAGFILE  список топиков в .bag file
            <li>    -v, --verbose  дополнительно показывает сколько подписчиков и публицистов на топики завязано.
            <li>    -p                    list only публицистов
            <li>    -s                    list only подписчиков
        </ul>
    <img src="./images/rostopic_list.png">

<p>   
Ноды общаются между собой с помошью messages (сообщений). Чтобы ноды понимали друг друга, сообщения должны иметь одинаковый тип. Чтобы узнать тип сообщений, служит команда:<br>
<font color="green">rostopic type [topic]</font><br>
Вернёт тип (имя) сообщений, используемого для топика.<br>
<img src="./images/rostopic_type.png">
<p>
Чтобы посмотреть детали этого сообщения, используется команда:<br>
<font color="green">rosmsg show [name_meesage]</font><br>
<img src="./images/rosmsg_show.png">
<p>
   Зная тип (имя) сообщений, мы можем отправлять их ноде через топик, тем самым управлять нодой. Синтаксис:<br>
   <font color="green">rostopic pub [topic] [msg_type] [args]</font><br>
     публикует данные по объявленному топику.<br>
     <img src="./images/rostopic_pub.png">
    <ul>
        <li> <b>-1</b> Этот параметр приводит к тому, что rostopic публикует только одно сообщение, а затем завершает работу
    <li> <b>/turtle1/cmd_vel</b> - это имя топика, в который отправляем (публикуем) сообщение
        <li> <b>geometry_msgs/Twist</b> - это тип (имя) сообщения, которое отправляем в топик.
        <li> <b>--</b> - этот параметр (двойное тире) указывает анализатору параметров, что ни один из следующих аргументов не является параметром. Это необходимо в тех случаях, когда ваши аргументы начинаются с тире -, например, с отрицательных чисел.
    <li> <b>'[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'</b> - сообщение geometry_msgs/Twist содержит два вектора по три элемента с плавающей запятой в каждом: линейный и угловой. В этом случае, '[2.0, 0.0, 0.0]' становится линейным значением при x=2.0, y=0.0 и z=0.0, а '[0.0, 0.0, 1.8]' - угловым значением при x=0.0, y=0.0 и z=1.8. Эти аргументы приведены в синтаксисе YAML.
    </ul>
    Мы можем опубликовать постоянный поток команд, используя опцию -r:<br>
    <img src="./images/rostopic_pub1.png">
<p>
    <font color="green">rostopic hz [topic]</font> - сообщает о скорости публикации данных в [topic].
<h3>qt_plot</h3>
    <b>rqt_plot</b> - эта утилита отображает график времени прокрутки данных, опубликованных в топиках.<br>
    Сперва нужно выполнить команду: <font color="green">rosrun rqt_plot rqt_plot</font>

<h3 align="center">Services</h3>
Сервисы - это еще один способ, с помощью которого узлы могут взаимодействовать друг с другом. Сервисы позволяют узлам отправлять запрос и получать ответ.<br>
Команды:
<ul>
    <li> <font color="green">rosservice list</font> - выводит список сервисов<br>
        <img src="./images/rosservice_list.png">
    <li> <font color="green">rosservice type [service]</font> - выводит тип службы<br>
        <img src="./images/rosservice_type.png">
    <li> <font color="green">rosservice call [service] [args]</font> - вызывает службу [service]
        <p>
            Вызовем службу /clear: <i>rosservice call /clear</i><br>
            В результате эта служба очистит поле черепахи от пройденной траектории.<br>
            Другой пример:<br>
            <img src="./images/rosservice_type1.png"><br>
            Здесь мы 1 командой вывели формат сообщения службы, если бы просто как в 3 команде, то выдаст только имя службы. Вторая команда: я вызываю эту службу с заданными аргументами, чтобы она выполнила свою работу. В результате получу новую черепаху с координатами, заданными в аргументах.
</ul>
<h3 align="center">Команды rosparam:</h3>
rosparam позволяет хранить данные на сервере параметров ROS и манипулировать ими. Сервер параметров может хранить целые числа, значения с плавающей запятой, логические значения, словари и списки. Для синтаксиса rosparam использует язык разметки YAML. В простых случаях YAML выглядит очень естественно: 1 - целое число, 1.0 - число с плавающей точкой, "единица" - строка, true - логическое значение, [1, 2, 3] - список целых чисел, {a: b, c: d} - словарь. В rosparam есть множество команд, которые можно использовать для работы с параметрами:
<ul>
    <li> <font color="green">rosparam list</font> - список параметров<br>
        <img src="./images/rosparam_list.png">
    <li> <font color="green">rosparam set [param_name]</font> - устанавливаем значение параметра [param_name]<br>
        Пример: <i>$ rosparam set /turtlesim/background_r 150</i><br>
        <font color="green">rosparam get [param_name]</font> - выводит значение параметра<br>
        <img src="./images/rosparam_set.png"><br>
        Чтобы изменение параметра вступило в силу, нужно вызвать службу чистильщика (/clean).
    <li> Команда <font color="green">rosparam get /</font> выведет значения всех параметров на сервере параметров.<br>
        <img src="./images/rosparam_get.png">
        <p>
            <font color="green">rosparam get name_parametr</font> - выводит значение параметра name_parametr:<br>
            <img src="./images/rosparam_get1.png">
    <li> Если хотим сохранить этот набор параметров, чтобы потом вызвать, то служит команда:<br>
        <font color="green">rosparam dump [file_name] [namespace]</font> - записываем все параметры в файл [file_name]
    <li> Вызвать сохранённый набор параметров [file_name] для [namespace], служит команда:<br>
        <font color="green">rosparam load [file_name] [namespace]</font>
</ul>
<h3>Использование rqt_console и rqt_logger_level</h3>
rqt_console подключается к Ross logging framework, чтобы вывести выходные данные с узлов.<br>
rqt_logger_level позволяет нам изменять уровень детализации (DEBUG, WARN, INFO и ERROR) узлов по мере их запуска.<br>
Чтобы вызвать rqt_console, служит команда:<br>
<font color="green">rosrun rqt_console rqt_console</font>
<p>
    <img src="./images/rqt_console.png">
<p>
    Чтобы вызвать консоль rqt_logger_level, служит команда:<br>
    <font color="green">rosrun rqt_logger_level rqt_logger_level</font>
<p>
    <img src="./images/rqt_logger_level.png">

<h3 align="center">Использование roslaunch</h3>
roslaunch запускает ноды, определённые в launch-файле. Синтаксис:<br>
<font color="green">$ roslaunch [package] [filename.launch]</font>
<p>
файл.launch находится в папке launch, она находится в каталоге пакета.<br>
<i>ПРИМЕЧАНИЕ: Каталог, в котором хранятся файлы launch, необязательно должен называться launch. На самом деле вам даже не нужно сохранять их в каталоге. Команда roslaunch автоматически просматривает переданный пакет и обнаруживает доступные файлы запуска. Однако это считается хорошей практикой.</i>
<h4>Теги файла.launch</h4>
<ul>
    <li> Тег &lt;launch&gt; - первый обязательный тег. Указывает, что файл launch.
    <li> Тег &lt;group  ns=" "&gt; - запускает ноду
    <li> Тег &lt;/launch&gt; - обязательный закрывающий тег.
</ul>
<h3 align="center">Команда rosed</h3>
Синтаксис:
<p>
    <font color="green">rosed [package_name] [filename]</font>
<p>
    Служит для редактирования файла [filename] из пакета [package_name].<br>
    По умолчанию редактором является vim. Чтобы редактором для команды rosed был более простой nano, следует в файл ~/.bashrc добавить строку:<br>
    <b>export EDITOR='nano -w'</b>

<h3 align="center">Знакомство с файлами msg и srv</h3>
msg-файлы - это простые текстовые файлы, которые описывают поля сообщений ROS. Они используются для создания исходного кода сообщений на разных языках. Они хранятся в папке msg каталога пакета. Представляют собой просто текстовые файлы с типом поля и названием поля в каждой строке.<br>
Тип поля:
<ul>
    <li> int8, int16, int32, int64 (plus uint*)
    <li> float32, float64
    <li> string
    <li> time, duration
    <li> other msg files
    <li> variable-length array[] and fixed-length array[C]
</ul>
Существует также тип Header. Header содержит временную метку и информацию о координатной системе, которые обычно используются в ROS. Вы часто увидите, что в первой строке msg-файла есть заголовок Header.
<p>
файл srv описывает службы. Он состоит из двух частей: запроса и ответа. Хранятся в папке srv каталога пакета. Файлы srv похожи на файлы msg, за исключением того, что они состоят из двух частей: запроса и ответа. Эти две части разделены строкой "---". Вот пример файла srv:
<p>
<img src="./images/file.srv.png"><br>
В этом примере A and B - запрос, а Sum - ответ.

<h3>Пример создания файла.msg (Num.msg)</h3>
<ol>
<li> Переходим в каталог пакета (roscd или просто cd)<br>
Создаём внутри пакета каталог msg: mkdir msg<br>
Что-то записываем в создаваемый файл, например: echo "int64 num" > msg/Num.msg
<li>
Далее нужно убедиться, что msg-файлы преобразованы в исходный код для C++, Python и других языков. Для этого открыть package.xml и убедитесь, что эти две строки есть в нем и не закомментированы:<br>
<img src="./images/package.xml.png"><br>
<font color=red>Были закомментированы, исправил.</font>
<li>
<h4>Редактирование CMakeLists.txt</h4>
<ol>
<li> Во время сборки нужен "message_generation", в время выполнения "message_runtime"<br>
<li> Далее открыть CMakeLists.txt В нем в функцию find_package добавить <b>message_generation</b>, тем самым можем генерировать сообщения.<br>
    <font color="red">Добавил.</font><br>
    <img src="./images/find_package.png">
<p>
    Вы можете заметить, что иногда ваш проект собирается нормально, даже если вы не вызывали find_package со всеми зависимостями. Это связано с тем, что catkin объединяет все ваши проекты в один, поэтому, если более ранний проект вызывает find_package, ваш более поздний настроен с теми же значениями. Но если вы забудете о вызове, это означает, что ваш проект может легко прерваться при изолированной сборке.
<li> Также убедитесь, что вы экспортировали зависимость от среды выполнения сообщений:<br>
<img src="./images/message_runtime.png"><br>
Добавил.
<p>
<li> Исправил блок:<br>
    <img src="./images/message_file.png">
<li> Теперь мы должны убедиться, что функция generate_messages() вызвана (раскомментировал блок):<br>
    <img src="./images/generate_message.png">
   </ol>
</ol>
Теперь вы готовы сгенерировать исходные файлы из вашего определения msg.
<h4>Команда rosmsg show</h4>
<font color="green">rosmsg show [message type]</font><p>
message type состоит из имени пакета, где определён файл сообщения и файла.msg
<br>
<img src="./images/rosmsg_show1.png">
<p>
Если не помним название пакета, то можно без него показать тип сообщения:
<br>
<img src="./images/rosmsg_show2.png">

<h3 align="center">Создание файла srv</h3>
<ol>
<li> Переходим в папку пакета. В ней создаём каталог srv.
<li> Вместо того, чтобы создавать новый файл.srv вручную, мы скопируем существующий из другого пакета.<br>
Для этого есть <b>roscp</b> - полезный инструмент командной строки для копирования файлов из одного пакета в другой:
<p>
<font color="green">roscp [package_name] [file_to_copy_path] [copy_path]</font>
<p>
мы можем скопировать сервис из пакета rospy_tutorials:
<br>
<img src="./images/roscp.png"><br>
В результате в папке srv появился файл AddTwoInts.srv
<li> Теперь нужно убедиться, что файлы srv преобразованы в исходный код для C++, Python и других языков. Для этого открыть package.xml и убедитесь, что эти две строки есть в нем и не закомментированы:<br>
 &lt;build_depend&gt;message_generation&lt;/build_depend&gt;<br>
 &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;<br>
 Этот шаг, я выполнил при создании файла.msg
 <li> Изменения в CMakeLists.txt<br>
 Если бы не выполнил этот шаг на этапе создания файла.msg, то добавить <b>message_generation</b> в функцию find_package<br>
 Несмотря на свое название, message_generation работает как для msg, так и для srv.
 <p>
 Изменить блок (раскомментировать и написать имя файла.srv):<br>
 <img src="./images/add_service.png">

<h3>Использование команды rossrv</h3>
Служит для создания файла.srv (службы).<br>
Синтаксис:<br>
<font color="green">rossrv show &lt;service type&gt;</font><br>
<img src="./images/rossrv.png"><br>
Показывает содержимое файла.<br>
Можно также как и для msg без названия пакета:<br>
<img src="./images/rossrv1.png"><br>
Только в этом случае будут показаны 2 службы.
<p>
<li> Раскомментировать функцию generate messages() в CMakeLists.txt. Выполнил это на 5 шаге при создании файла msg.
</ol>
Теперь когда файлы создали, записали настройки, нужно чтобы изменения вступили в силу, снова выполнить команду <b>catkin_make</b>:
<ol>
<li> <font color=green>roscd beginner_tutorials</font> -переходим в каталог пакета beginner_tutorials
<li> <font color=green>cd ../..</font> - переходим в корневой каталог пакетов catkin_ws
<li> <font color=green>catkin_make</font> - перенастраиваем наши пакеты. 
<li> <font color=green>cd -</font> - возвращаемся в наш пакет beginner_tutorials
</ol>
Вместо catkin_make можно выполнить команду <b>catkin build</b><br>
Любой msg-файл в каталоге msg будет генерировать код для использования на всех поддерживаемых языках.<br>
Файл заголовка сообщения на C++ будет сгенерирован в ~/catkin_ws/devel/include/beginner_tutorials/.<br>
Скрипт на Python будет создан в ~/catkin_ws/devel/lib/python2.7/dist-packages/beginner_tutorials/msg.<br>
Файл lisp находится в ~/catkin_ws/devel/share/common-lisp/ros/beginner_tutorials/msg/.
<p>
Аналогично, все файлы .srv в каталоге srv будут содержать сгенерированный код на поддерживаемых языках. Для C++ это приведет к созданию файлов заголовков в том же каталоге, что и файлы заголовков сообщений. Для Python и Lisp рядом с папками "msg" будет папка "srv".
<h3>Получение подсказки по команде</h3>
Познакомились с довольно большим количеством инструментов ROS. Иногда бывает сложно отследить, какие аргументы требуются для каждой команды. К счастью, большинство инструментов ROS предоставляют свою собственную помощь. Чтобы получить подсказку по команде, достаточно опции -h:<br>
<img src="./images/rosmsg_h.png">


<h2 align=center>Создание publisher-ноды talker.cpp на языке C++ для пакета beginner_tutorials</h2>
<a href="https://github.com/ros/ros_tutorials/tree/noetic-devel/ros_tutorials">Репозиторий ROS, откуда берутся коды нод.</a>
<ol>
<li> Перейдем в каталог пакета: <b>roscd beginner_tutorials</b>
<li> Создадим внутри каталог src: <b>mkdir -p src</b><br>
Этот каталог будет содержать все исходные файлы (ноды) для нашего пакета beginner_tutorials.
<li> Внутри этого созданного каталога создадим файл talker.cpp, код скопируем с https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp:<br>
<b>nano src/talker.cpp</b><br>
<img src="./images/talker.cpp.png">
<p>
Разберем код по пунктам:
 <ol>
   <li> <img src="./images/ros.h.png"><br>
   ros/ros.h - это раздел, который включает в себя все заголовки, необходимые для использования наиболее распространенных элементов системы ROS.
   <li> <img src="./images/std_msgs.png"><br>
   включает в себя сообщение std_msgs/String, которое находится в пакете std_msgs. Это заголовок, автоматически генерируемый из файла String.msg в этом пакете.
 <li> <img src="./images/ros_init.png"><br>
 Инициализируем (вызываем) ROS. Позволяет ROS выполнять переназначение имен через командную строку - сейчас это не важно. Здесь мы также указываем имя нашего узла (ноды). Имена узлов должны быть уникальными в запущенной системе. Используемое имя должно быть базовым, т.е. в нем не может быть символа /.
 <li> <img src="./images/ros_handle.png"><br>
 NodeHandle является основной точкой доступа для обмена данными с системой ROS. Первый созданный NodeHandle полностью инициализирует этот узел, а последний уничтоженный NodeHandle закроет узел.
 <li> <img src="./images/publisher.png"><br>
 Сообщите мастеру ROS, что мы собираемся опубликовать сообщение типа std_msgs/String в топик chatter. Это позволяет мастеру сообщить любым узлам, прослушивающим chatter, что мы собираемся опубликовать данные в этот топик. Вторым аргументом является размер нашей очереди публикации. В этом случае, если мы публикуем слишком быстро, в буфере будет храниться максимум 1000 сообщений, прежде чем мы начнем выбрасывать старые.
 <li> <img src="./images/loop_rate.png"><br>
 Объект ros::Rate позволяет вам указать частоту, с которой вы хотели бы выполнять цикл. Он будет отслеживать, сколько времени прошло с момента последнего вызова функции Rate::sleep(), и будет находиться в режиме ожидания в течение необходимого периода времени. Сейчас мы говорим, что хотим работать на частоте 10 Гц.
 <li> <img src="./images/ros_ok.png"><br>
 По умолчанию roscpp установит обработчик SIGINT, который обеспечивает обработку Ctrl-C, что приведет к тому, что ros::ok() вернет значение false, если это произойдет.<br>
ros::ok() вернет значение false, если:
<ul>
<li> получено значение SIGINT (Ctrl-C)
<li> мы были отключены от сети другим узлом с таким же именем
<li> функция ros::shutdown() была вызвана другой частью приложения.
<li> все функции ros::Nodehandle были уничтожены
</ul>
Как только функция ros::ok() вернет значение false, все вызовы ROS завершатся ошибкой.
<li> <p><img src="./images/fill_messages.png"><br>
Мы передаем сообщение в ROS, используя класс, адаптированный для сообщений, который обычно генерируется из msg-файла. Возможны более сложные типы данных, но пока мы будем использовать стандартное строковое сообщение, которое состоит из одного элемента: "данные".
<li><p><img src="./images/chatter_pub.png"><br>
Функция publish() - это способ отправки сообщений. Параметр в скобках - это объект message. Тип этого объекта должен совпадать с типом, заданным в качестве параметра шаблона для вызова advertise().
<li><p><img src="./images/ros_console.png"><br>
ROS_INFO и friends - это наша замена printf/cout. Дополнительную информацию смотрите в <a hre="https://wiki.ros.org/rosconsole">документации rosconsole</a>.
<li><p><img src="./images/spin_once.png"><br>
Вызов ros::spinOnce() здесь не требуется для этой простой программы, потому что мы не получаем никаких обратных вызовов. Однако, если бы вы добавили подписку в это приложение и у вас не было бы функции ros::spinOnce(), ваши обратные вызовы никогда бы не были вызваны. Так что добавьте это для пущей убедительности.
<li><p><img src="./images/rate_sleep.png"><br>
Используем объект ros::Rate для перехода в спящий режим на оставшееся время, чтобы достичь скорости публикации 10 Гц.
 </ol>
 Краткая версия того, что делаем в talker.cpp:<br>
Инициализируем систему ROS<br>
Объявляем, что мы собираемся публиковать сообщения std_msgs/String в топик chatter для master ROS<br>
Цикл публикации сообщений в chatter выполняется 10 раз в секунду
</ol>


<h2 align=center>Создание ноды-подписчика listener.cpp на языке C++</h2>
<b>nano src/listener.cpp</b>
<br>Код скопировал с https://raw.githubusercontent.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp
<p>
Разбор кода по пунктам:
<ol>
<li><p><img src="./images/callback.png"><br>
Это функция обратного вызова callback(), которая будет вызываться при поступлении нового сообщения в топик chatter. Сообщение передается с помощью boost shared_ptr, что означает, что вы можете сохранить его, если хотите, не беспокоясь о том, что оно будет удалено под вами, и не копируя исходные данные.
<li><p><img src="./images/subskriber.png"><br>
Подписывается на топик chatter с мастером. ROS будет вызывать функцию chatterCallback() всякий раз, когда поступает новое сообщение. Второй аргумент - это размер очереди, на случай, если мы не сможем обрабатывать сообщения достаточно быстро. В этом случае, если очередь достигнет 1000 сообщений, мы начнем отбрасывать старые сообщения по мере поступления новых.
<p>
Функция NodeHandle::subscribe() возвращает объект ros::Subscriber, который вы должны сохранить, пока не захотите отказаться от подписки. Когда объект Подписчика будет уничтожен, он автоматически отпишется от темы chatter.
<p>
Существуют версии функции NodeHandle::subscribe(), которые позволяют указать функцию-член класса или даже что-либо, вызываемое с помощью Boost.Функциональный объект. Более подробная информация содержится в обзоре roscpp.
<li><p><img src="./images/ros_spin.png"><br>
функция ros::spin() переходит в цикл, вызывая обратные вызовы сообщений как можно быстрее. Но не волнуйтесь, если ей нечего делать, она не будет использовать много ресурсов процессора. функция ros::spin() завершит работу, как только функция ros::ok() вернет значение false, что означает, что функция ros::shutdown() была вызвана либо обработчиком Ctrl-C по умолчанию, либо мастером, сообщающим нам о завершении работы, либо вызвана вручную.
<p>
Существуют и другие способы обработки обратных вызовов, но мы не будем здесь о них беспокоиться. В пакете roscpp_tutorials есть несколько демонстрационных приложений, которые это демонстрируют. В обзоре roscpp также содержится дополнительная информация.
</ol>
Краткая версия того, что происходит в listener.cpp:<br>
Инициализируем систему ROS<br>
Подписываемся на топик chatter<br>
Запускаем, ожидая поступления сообщений<br>
Когда приходит сообщение, вызывается функция chatterCallback()
<h3>Building нод</h3>
<ol>
<li> Редактируем CMakeLists.txt, добавляем эти строки:<br>
<pre>
add_executable(talker src/talker.cpp)
target_link_libraries(talker ${catkin_LIBRARIES})
add_dependencies(talker beginner_tutorials_generate_messages_cpp)

add_executable(listener src/listener.cpp)
target_link_libraries(listener ${catkin_LIBRARIES})
add_dependencies(listener beginner_tutorials_generate_messages_cpp)
</pre>
<p>
Это создаст два исполняемых файла, talker и listener, которые по умолчанию будут помещены в каталог пакетов вашего пространства разработки, расположенный по умолчанию по адресу ~/catkin_ws/devel/lib/&lt;package name&gt;.
<p>
Строка из CMakeLists.txt: <b>add_dependencies(talker beginner_tutorials_generate_messages_cpp)</b> гарантирует, что заголовки сообщений (Headers) этого пакета будут сгенерированы перед использованием. Если вы используете сообщения из других пакетов в своем рабочем пространстве catkin, вам также необходимо добавить зависимости к их соответствующим целям генерации, поскольку catkin создает все проекты параллельно. Начиная с *Groovy*, вы можете использовать следующую переменную для определения всех необходимых целей:<br>
<b>target_link_libraries(talker ${catkin_LIBRARIES})</b>
<p>
Переформируем наши пакеты настройки:<br>
<font color=green>cd ~/catkin_ws<br>
catkin_make</font>


<h2 align=center>Написание простых Publisher and Subscriber на Python</h2>
<h3>Создадим узел (ноду) publisher ("talker"), который будет постоянно транслировать сообщение.</h3>
<ol>
<li> <b>roscd beginner_tutorials</b><br>
Создадим папку scripts, которая будет хранить файлы.py<br>
<b>mkdir scripts</b><br>
В эту папку скачаем готовый talker.py из гитхаба:<br>
<b>wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/talker.py</b><br>
Сделаем его исполняемым:<br>
<b>chmod +x talker.py</b>
<p>
<img src="./images/talker.py.png">
<p>
Код talker.py:
<p>
<img src="./images/code_talker.png">
<p>Разъяснение кода:
<ul>
<li> <b>#!/usr/bin/env python</b> с этой строки начинается каждая нода (скрипт) на python.</li>
<li><p><img src="./images/rospy.png"><br>
Вам необходимо импортировать rospy, если вы пишете ROS-узел. Импорт std_msgs.msg необходим для того, чтобы мы могли повторно использовать тип сообщения std_msgs/String (простой строковый контейнер) для публикации.</li>
<li><p><img src="./images/pub_rospy.png"><br>
Этот раздел кода определяет интерфейс talker для остальной части ROS. pub = rospy.Издатель("chatter", String, queue_size=10) объявляет, что ваш узел публикует в топике chatter, используя тип сообщения String. String здесь на самом деле является классом std_msgs.msg.String. Аргумент queue_size является новым в ROS hydro и ограничивает количество сообщений в очереди, если какой-либо подписчик не получает их достаточно быстро. В старых дистрибутивах ROS этот аргумент просто не используется.
<p>
Следующая строка, rospy.init_node(NAME, ...), очень важна, поскольку она сообщает rospy имя вашего узла - пока у rospy не будет этой информации, он не сможет начать взаимодействие с мастером ROS. В этом случае ваш узел получит имя talker. ПРИМЕЧАНИЕ: имя должно быть базовым, т.е. оно не должно содержать никаких косых черт "/".
<p>
anonymous = True гарантирует, что ваш узел будет иметь уникальное имя, добавляя случайные числа в конец имени. Обратитесь к разделу Инициализация и завершение работы - Инициализация вашего узла ROS в документации rospy для получения дополнительной информации о параметрах инициализации узла.
<li><p><img src="./images/rate_rospy.png"><br>
Эта строка создает объект Rate rate. С помощью своего метода sleep() он предлагает удобный способ зацикливания с желаемой скоростью. С его аргументом 10 мы должны ожидать, что цикл будет выполняться 10 раз в секунду (до тех пор, пока наше время обработки не превысит 1/10 секунды!).
<li><p><img src="./images/whail_not.png"><br>
Этот цикл представляет собой довольно стандартную конструкцию rospy: проверка флага rospy.is_shutdown() и последующее выполнение работы. Вы должны проверить is_shutdown(), чтобы проверить, должна ли ваша программа завершаться (например, при наличии комбинации клавиш Ctrl-C или иным образом). В данном случае "работа" - это вызов pub.publish(hello_str), который публикует строку в нашей теме chatter. Цикл вызывает функцию rate.sleep(), которая находится в режиме ожидания, достаточном для поддержания желаемой скорости в цикле.
<p>
(Вы также можете столкнуться с функцией rospy.sleep(), которая похожа на функцию time.sleep(), за исключением того, что она также работает с имитируемым временем (см. Часы).)
<p>
Этот цикл также вызывает rospy.loginfo(str), который выполняет тройную функцию: сообщения выводятся на экран, записываются в файл журнала узла и записываются в rosout. rosout - это удобный инструмент для отладки: вы можете извлекать сообщения с помощью rqt_console вместо того, чтобы искать окно консоли с выводом вашего узла.
<p>
std_msgs.msg.String - это очень простой тип сообщения, поэтому вам может быть интересно, как выглядит публикация более сложных типов. Общее правило заключается в том, что аргументы конструктора располагаются в том же порядке, что и в файле .msg. Вы также можете не вводить никаких аргументов и инициализировать поля напрямую, например:<br>
<b>msg = String()<br>
msg.data = str</b><br>
или же вы можете инициализировать некоторые поля, а для остальных оставить значения по умолчанию:<br>
<b>String(data=str)</b>
<li><p><img src="./images/try_pass.png"><br>
В дополнение к стандартной проверке Python __main__check, при этом обнаруживается ошибка rospy.Исключение ROSInterruptException, которое может быть вызвано методами rospy.sleep() и rospy.Rate.sleep() при нажатии Ctrl-C или при выключении вашего узла иным образом. Причина, по которой возникает это исключение, заключается в том, что вы случайно не продолжаете выполнение кода после sleep().
</ul>

<li> В CMakeLists.txt добавить строки:
<p><pre>
catkin_install_python(PROGRAMS scripts/talker.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
</pre>
</ol>
<h3>Написание ноды subscriber</h3>
<ul>
<li>
<ul>
<li> roscd beginner_tutorials/scripts/
<li> wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/listener.py
<li> chmod +x listener.py
</ul>
<img src="./images/listener.py.png">
<li><p>
Код:
<br><img src="./images/code_listener.png">
<li><p>
В CMakeLists.txt добавляем строки:
<p>
<pre>
catkin_install_python(PROGRAMS scripts/talker.py scripts/listener.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
</pre>
<li><p><img src="./images/rospy_init.png"><br>
Это означает, что ваш узел подписан на тему chatter, которая имеет тип std_msgs.msgs.Строка. При получении новых сообщений вызывается обратный вызов с этим сообщением в качестве первого аргумента.
<p>
Мы также немного изменили вызов rospy.init_node(). Мы добавили аргумент ключевого слова anonymous=True. ROS требует, чтобы у каждого узла было уникальное имя. Если появляется узел с таким же именем, он повторяет предыдущий. Это значит, что неисправные узлы могут легко быть выкинут из сети. Анонимные=флаг True рассказывает rospy чтобы создать уникальное имя для узла, так что вы можете иметь несколько узлов listener.py легко работать.
<p>
Последнее дополнение: функция rospy.spin() просто не позволяет вашему узлу завершать работу до тех пор, пока он не будет выключен. В отличие от roscpp, функция rospy.spin() не влияет на функции обратного вызова абонента, поскольку у них есть свои собственные потоки.
<li>Мы используем CMake в качестве нашей системы сборки, и, да, вы должны использовать ее даже для узлов Python. Это необходимо для того, чтобы убедиться, что автоматически сгенерированный код Python для сообщений и служб создан.
<br>Перейдите в свое рабочее пространство catkin и запустите catkin_make:<br>
<b>cd ~/catkin_ws<br>
catkin_make</b>
</ul>


<h2 align=center><a href="https://wiki.ros.org/ROS/Tutorials/ExaminingPublisherSubscriber">Выполнение publisher</a></h2>
Первой командой вызовем мастера:<br>
<b>roscore</b><br>
Еесли вы используете catkin, убедитесь, что у вас есть исходный код для вашего рабочего пространства setup.sh файл после вызова catkin_make, но перед выполнением нашего публишера:<br>
<b>cd ~/catkin_ws<br>
source ./devel/setup.bash</b><br>
Выполним нашего созданного публишера на python:<br>
<b>rosrun beginner_tutorials talker.py</b><br>
или <b>rosrun beginner_tutorials talker</b> (C++)<br>
Работает:<br>
<img src="./images/hello_world.png">
<h3 align=center><a href="https://wiki.ros.org/ROS/Tutorials/ExaminingPublisherSubscriber">Теперь выполнение подписчика listener.py</a></h3>
<b>rosrun beginner_tutorials listener.py</b> или <b>rosrun beginner_tutorials listener</b> на языке C++<br>
Работает.


<h2 align=center><a href="https://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28c%2B%2B%29">Создание простого сервера и клиента на C++</a></h2>
Здесь мы создадим узел service ("add_two_ints_server"), который будет получать два целых числа и возвращать сумму.<br>
Сначало перейдём в каталог пакета, где будут наши службы:<br>
<b>roscd beginner_tutorials</b><br>
Пожалуйста, убедитесь, что вы следовали инструкциям из предыдущего руководства по созданию сервиса, необходимого в этом руководстве, создав AddTwoInts.srv<br>
Создаём файл src/add_two_ints_server.cpp:<br>
<b>nano src/add_two_ints_server.cpp</b><br>
Код:<br>
<pre>
#include "ros/ros.h"
#include "beginner_tutorials/AddTwoInts.h"

bool add(beginner_tutorials::AddTwoInts::Request  &req,
         beginner_tutorials::AddTwoInts::Response &res)
{
  res.sum = req.a + req.b;
  ROS_INFO("request: x=%ld, y=%ld", (long int)req.a, (long int)req.b);
  ROS_INFO("sending back response: [%ld]", (long int)res.sum);
  return true;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, "add_two_ints_server");
  ros::NodeHandle n;

  ros::ServiceServer service = n.advertiseService("add_two_ints", add);
  ROS_INFO("Ready to add two ints.");
  ros::spin();

  return 0;
}
</pre><br>
Разбор кода:
<ul>
<li> <b>
<pre>
#include "ros/ros.h"
#include "beginner_tutorials/AddTwoInts.h"
</pre></b>
beginner_tutorials/AddTwoInts.h - это заголовочный файл, созданный на основе файла srv, который мы создали ранее.
<li>
<b>
<pre>
bool add(beginner_tutorials::AddTwoInts::Request  &req,
         beginner_tutorials::AddTwoInts::Response &res)
</pre></b>
Эта функция предоставляет услугу добавления двух целых чисел, она принимает тип запроса и ответа, определенный в файле srv, и возвращает логическое значение.
<li>
<b><pre>
{
  res.sum = req.a + req.b;
  ROS_INFO("request: x=%ld, y=%ld", (long int)req.a, (long int)req.b);
  ROS_INFO("sending back response: [%ld]", (long int)res.sum);
  return true;
}
</pre></b>
Здесь два целых числа добавляются и сохраняются в ответе. Затем регистрируется некоторая информация о запросе и ответе. Наконец, по завершении работы служба возвращает значение true.
<li><b><pre>
ros::ServiceServer service = n.advertiseService("add_two_ints", add);
</pre></b>
Здесь сервис создается и объявляется через ROS.
</ul>
<h3>Создание ноды клиента</h3>
Создаём файл клиента в каталоге пакета:<br>
<b>nano src/add_two_ints_client.cpp</b><br>
Код:
<pre>
#include "ros/ros.h"
#include "beginner_tutorials/AddTwoInts.h"
#include <cstdlib>

int main(int argc, char **argv)
{
  ros::init(argc, argv, "add_two_ints_client");
  if (argc != 3)
  {
    ROS_INFO("usage: add_two_ints_client X Y");
    return 1;
  }

  ros::NodeHandle n;
  ros::ServiceClient client = n.serviceClient<beginner_tutorials::AddTwoInts>("add_two_ints");
  beginner_tutorials::AddTwoInts srv;
  srv.request.a = atoll(argv[1]);
  srv.request.b = atoll(argv[2]);
  if (client.call(srv))
  {
    ROS_INFO("Sum: %ld", (long int)srv.response.sum);
  }
  else
  {
    ROS_ERROR("Failed to call service add_two_ints");
    return 1;
  }

  return 0;
}
</pre>
Разбор:
<ul>
<li> <b>ros::ServiceClient client = n.serviceClient<beginner_tutorials::AddTwoInts>("add_two_ints");</b><br>
Создается клиент для службы add_two_ints. Объект ros::ServiceClient используется для последующего вызова службы.
<li><b><pre
beginner_tutorials::AddTwoInts srv;
srv.request.a = atoll(argv[1]);
srv.request.b = atoll(argv[2]);
</pre></b>
Создаем экземпляр автоматически сгенерированного класса service и присваиваем значения его элементу request. Класс service содержит два элемента, request и response. Он также содержит два определения класса, Request и Response.
<li> <b>if (client.call(srv))</b><br>
Фактически вызывает службу. Поскольку вызовы службы блокируются, функция вернется после завершения вызова. Если вызов службы завершился успешно, функция call() вернет значение true и значение в srv.response будет действительным. Если вызов не увенчался успехом, функция call() вернет значение false, а значение в srv.response будет недействительным.
</ul>
<h3>Building сервисов</h3>
<ul>
<li> Редактируем ~/catkin_ws/src/beginner_tutorials/CMakeLists.txt, добавляем строки:
<pre>
add_executable(add_two_ints_server src/add_two_ints_server.cpp)
target_link_libraries(add_two_ints_server ${catkin_LIBRARIES})
add_dependencies(add_two_ints_server beginner_tutorials_gencpp)

add_executable(add_two_ints_client src/add_two_ints_client.cpp)
target_link_libraries(add_two_ints_client ${catkin_LIBRARIES})
add_dependencies(add_two_ints_client beginner_tutorials_gencpp)
</pre>
Это создаст два исполняемых файла, add_two_ints_server и add_two_ints_client, которые по умолчанию будут помещены в каталог пакетов вашего пространства разработки, расположенный по умолчанию по адресу ~/catkin_ws/devel/lib/<имя пакета>. Вы можете вызывать исполняемые файлы напрямую или использовать rosrun для их вызова. Они не помещаются в "<prefix>/bin", потому что это приведет к загрязнению ПУТИ при установке вашего пакета в систему. Если вы хотите, чтобы ваш исполняемый файл был указан в пути во время установки, вы можете настроить цель установки, см.: catkin/CMakeLists.txt
<li> Теперь:
<b>cd ~/catkin_ws<br>
catkin_make</b>
</ul>

<h2 align=center>Выполнение нод сервиса и клиента</h2>
Сервер:<p>
Вызов мастера:<br>
<b>roscore</b><br>
В новом терминале запускаем сервер:<br>
<b>rosrun beginner_tutorials add_two_ints_server</b><br>
<img src="./images/rosrun_server.png">
<p>
Клиент:<br>
В новом терминале:
<br><b>rosrun beginner_tutorials add_two_ints_client 1 3</b><br>
<img src="./images/rosrun_client.png">

<h3 align=center>Создание простых сервера и клиента на python</h3>
Сервер:<br>
<b>roscd beginner_tutorials</b><br>
<b>nano scripts/add_two_ints_server.py</b><br>
Код:
<pre>
#!/usr/bin/env python

from __future__ import print_function

from beginner_tutorials.srv import AddTwoInts,AddTwoIntsResponse
import rospy

def handle_add_two_ints(req):
    print("Returning [%s + %s = %s]"%(req.a, req.b, (req.a + req.b)))
    return AddTwoIntsResponse(req.a + req.b)

def add_two_ints_server():
    rospy.init_node('add_two_ints_server')
    s = rospy.Service('add_two_ints', AddTwoInts, handle_add_two_ints)
    print("Ready to add two ints.")
    rospy.spin()

if __name__ == "__main__":
    add_two_ints_server()
 </pre>
 <b>chmod +x scripts/add_two_ints_server.py</b><br>
 <b>nano CMakeLists.txt</b><br>
 Добавляем строки:
 <pre>
 catkin_install_python(PROGRAMS scripts/add_two_ints_server.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
</pre>
Строка <b>s = rospy.Service('add_two_ints', AddTwoInts, handle_add_two_ints)</b><br>
При этом объявляется новая служба с именем add_two_ints и типом службы AddTwoInts. Все запросы передаются в функцию handle_add_two_ints. функция handle_add_two_ints вызывается с экземплярами AddTwoIntsRequest и возвращает экземпляры AddTwoIntsResponse.
<p>
Как и в примере с подписчиком, функция rospy.spin() не позволяет вашему коду завершать работу до завершения работы службы. 
<p>
Клиент:
<br><b>nano scripts/add_two_ints_client.py</b><br>
Код:
<pre>
#!/usr/bin/env python

from __future__ import print_function

import sys
import rospy
from beginner_tutorials.srv import *

def add_two_ints_client(x, y):
    rospy.wait_for_service('add_two_ints')
    try:
        add_two_ints = rospy.ServiceProxy('add_two_ints', AddTwoInts)
        resp1 = add_two_ints(x, y)
        return resp1.sum
    except rospy.ServiceException as e:
        print("Service call failed: %s"%e)

def usage():
    return "%s [x y]"%sys.argv[0]

if __name__ == "__main__":
    if len(sys.argv) == 3:
        x = int(sys.argv[1])
        y = int(sys.argv[2])
    else:
        print(usage())
        sys.exit(1)
    print("Requesting %s+%s"%(x, y))
    print("%s + %s = %s"%(x, y, add_two_ints_client(x, y)))
</pre>
<b>chmod +x scripts/add_two_ints_client.py</b><br>
Добавляем в CMakeLists.txt:<br>
<b>nano CMakeLists.txt</b><br>
строки:
<pre>
catkin_install_python(PROGRAMS scripts/add_two_ints_server.py scripts/add_two_ints_client.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
</pre>
Разбор кода:<br>
Для клиентов вам не нужно вызывать init_node(). Сначала мы вызываем:<br>
<b>rospy.wait_for_service('add_two_ints')</b><br>
Это удобный метод, который блокируется до тех пор, пока не будет доступна служба с именем add_two_ints.
<p>
Далее мы создаем дескриптор для вызова службы:<br>
<b>add_two_ints = rospy.ServiceProxy('add_two_ints', AddTwoInts)</b>
<p>
Мы можем использовать этот дескриптор так же, как обычную функцию, и вызывать его:<br>
<b>resp1 = add_two_ints(x, y)<br>
  return resp1.sum</b><br>
Поскольку мы указали тип сервиса как AddTwoInts, он выполняет работу по созданию объекта запроса AddTwoInts за вас (вместо этого вы можете ввести свой собственный). Возвращаемое значение - это объект ответа AddTwoInts. Если вызов завершается неудачей, может возникнуть ошибка rospy.ServiceException, поэтому вам следует настроить соответствующий блок try/except.
<h3>Building сервера и клиента</h3>
<b>cd ~/catkin_ws<br>
catkin_make</b>
<h2 align=center>Выполнение сервера и клиента</h2>
Сервер:<br>
<b>roscore</b> вызвали мастера<br>
В другом терминале:<br>
<b>rosrun beginner_tutorials add_two_ints_server</b>     (C++)<br>
или<br>
<b>rosrun beginner_tutorials add_two_ints_server.py</b>  (Python)
<p>
Клиент:
В другом клиенте:<br>
<b>rosrun beginner_tutorials add_two_ints_client 1 3</b>     (C++)<br>
или<br>
<b>rosrun beginner_tutorials add_two_ints_client.py 1 3</b>  (Python)<br>
<img src="./images/rosrun_client1.png">


<h2 align=center>Recording data (creating a bag file) Запись данных (создание bag файла)</h2>
В этом разделе руководства вы узнаете, как записывать данные по топикам из запущенной системы ROS. Данные по топикам будут накапливаться в файле bag.
<p>
Сначала выполните следующие команды в отдельных терминалах:
<br>
<b>roscore</b> - первый терминал<br>
2 терминал - <b>rosrun turtlesim turtlesim_node</b><br>
3 терминал - <b>rosrun turtlesim turtle_teleop_key</b>
<p>
Это запустит два узла - визуализатор turtlesim и узел turtle_teleop_key, который позволяет управлять turtlesim с клавиатуры с помощью клавиш со стрелками на клавиатуре.
<p>
<b>rostopic list -v</b> - в 4 терминале, выведем список запущенных в данный момент топиков.<br>
<img src="./images/rostopic_list_v.png"><br>
Список published (публикуемых) топиков - это единственные типы сообщений, которые потенциально могут быть занесены в файл журнала данных, поскольку в журнал записываются только публикуемые сообщения. Топик /turtle 1/cmd_vel - это командное сообщение, опубликованное teleop_turtle, которое принимается в качестве входных данных программой turtlesim. Сообщения /turtle1/color_sensor и /turtle1/pose являются выходными сообщениями, опубликованными turtlesim.
<p>
Теперь мы запишем публикуемые данные. Откройте новое окно терминала. В этом окне выполните следующие команды:<br>
<b>mkdir ~/bagfiles<br>
cd ~/bagfiles<br>
rosbag record -a</b><br>
<img src="./images/rosbag.png"><br>
Создаем временный каталог для записи данных, а затем запускаем rosbag record с параметром -a, указывающим, что все публикуемые топики должны быть собраны в файле bag.
<p>
Примерно 10 секунд двигаем черепаху.<br>
В окне, где запустили rosbag нажать Ctrl-C. Теперь изучите содержимое каталога ~/bagfiles. Должны увидеть файл с именем, которое начинается с года, даты и времени и суффикса .bag. Это файл пакета, содержащий все топики, опубликованные любым узлом за время работы rosbag record.<br>
еперь, когда мы записали файл bag с помощью rosbag record, мы можем просмотреть его и воспроизвести с помощью команд rosbag info и rosbag play. Сначала мы посмотрим, что записано в файле bag. Мы можем выполнить команду info - эта команда проверяет содержимое файла bag без его воспроизведения. Выполните следующую команду из каталога файлов bag:<br>
<font color=green>rosbag info &lt;your bagfile&gt;</font>
<p>
<img src="./images/rosbag_info.png">
<p>
Следующим шагом в этом руководстве будет воспроизведение файла bag, чтобы воспроизвести поведение в запущенной системе. Сначала завершите работу программы teleop, которая, возможно, все еще запущена из предыдущего раздела - нажмите Ctrl-C в терминале, где вы запустили turtle_teleop_key. Оставьте turtlesim запущенным. В окне терминала запустите следующую команду в каталоге, из которого смотрели инфо о бэгфайле:<br>
<font color=green>rosbag play &lt;your bagfile&gt;</font>
<p>
<img src="./images/rosbag_play.png">
<p>
В режиме по умолчанию rosbag play будет ждать в течение определенного периода времени (0,2 секунды) после объявления каждого сообщения, прежде чем начнет публиковать содержимое файла пакета. Некоторое время ожидания позволяет любому подписчику сообщения получать уведомления о том, что сообщение было объявлено и что за ним могут последовать другие сообщения. Если rosbag play публикует сообщения сразу после публикации рекламы, подписчики могут не получить первые несколько опубликованных сообщений. Период ожидания можно указать с помощью параметра -d.
<p>
В конечном итоге тема /turtle 1/cmd_vel будет опубликована, и черепаха должна начать перемещаться в turtlesim по схеме, аналогичной той, которую вы выполнили из программы teleop. Время между запуском rosbag play и перемещением черепашки должно быть примерно равно времени между запуском оригинальной записи rosbag и вводом команд с клавиатуры в начальной части руководства. Вы можете сделать так, чтобы воспроизведение rosbag не начиналось с начала файла bag, а начиналось на некоторое время позже начала, используя аргумент -s. Последним параметром, который может представлять интерес, является параметр -r, который позволяет вам изменять скорость публикации на определенный коэффициент. Если вы выполните:<br>
<b>rosbag play -r 2 &lt;your bagfile&gt;</b><br>
вы должны увидеть, как черепаха совершает несколько иную траекторию - это траектория, которая получилась бы, если бы вы вводили команды с клавиатуры в два раза быстрее.

<h3 align=center>Запись подмножества данных</h3>
При запуске сложной системы, такой как программный комплекс pr2, могут публиковаться сотни разделов, а в некоторых разделах, таких как потоки изображений с камер, потенциально публикуются огромные объемы данных. В такой системе часто нецелесообразно записывать лог-файлы, содержащие все темы, на диск в виде одного файла bag. Команда rosbag record поддерживает запись только определенных тем в файл bag, позволяя пользователям записывать только те темы, которые их интересуют.
<p>
Если какие-либо узлы turtlesim запущены, закройте их и перезапустите файл запуска keyboard teleop:<br>
<b>rosrun turtlesim turtlesim_node<br>
rosrun turtlesim turtle_teleop_key</b><br>
В вашем каталоге bagfiles выполните следующую команду:<br>
<b>rosbag record -O subset /turtle1/cmd_vel /turtle1/pose</b>
<p>
<img src="./images/rosbag_subset.png">
<p>
Аргумент -O указывает rosbag record на доступ к файлу с именем subset.bag, а аргументы topic указывают на то, что rosbag record подписывается только на эти две темы. Перемещайте черепашку в течение нескольких секунд, используя команды со стрелками на клавиатуре, а затем нажмите Ctrl-C на записи rosbag.<p>
Теперь проверьте содержимое файла bag (rosbag info subset.bag). Вы должны увидеть что-то вроде этого, только с указанными темами: <b>rosbag info subset.bag</b>
<p>
<img src="./images/rosbag_info_subnet.png">


<h2 align=center>Чтение сообщений из bag файла</h2>
Ссылки: <a href="https://habr.com/ru/articles/393811/">ROS на Raspberry Pi: Использование rosbag для сохранения данных топиков</a><br>
<a href="https://wiki.ros.org/ROS/Tutorials/reading%20msgs%20from%20a%20bag%20file">Reading messages from a bag file</a>
<p>
Предполагая, что вы используете систему с уже запущенным ROS, вот быстрая команда для записи 30-секундного фрагмента данных в файл пакета только для интересующих вас тем, например: /topic1, /topic2 и /topic3. Поскольку мы устанавливаем продолжительность в 30 секунд, по истечении этого времени запись автоматически остановится:<br>
<b>rosbag record --duration=30 --output-name=/tmp/mybagfile.bag \<br>
    /topic1 /topic2 /topic3</b><br>
<p>
Остальная часть этого руководства будет выполнена при условии, что скачали с помощью команды:<br>
<b>wget https://open-source-webviz-ui.s3.amazonaws.com/demo.bag</b><br>
<font color=red>У меня не удаётся скачать, выдаёт ошибку 403</font>
<p>
 У вас будет два варианта чтения/извлечения сообщений из файла bag.
<p>
<i>Обратите внимание, что в любой из приведенных ниже команд команда time добавляется перед началом просто потому, что она выводит время выполнения каждой команды, а поскольку иногда эти команды могут занимать много времени, полезно использовать команду time, чтобы получить представление о том, сколько времени должна занять данная команда. Если вы не хотите его использовать, вы можете удалить временную часть любой из приведенных ниже команд.</i>
<h3>Вариант 1: немедленно воспроизвести сообщения и просмотреть выходные данные на нескольких терминалах.</h3>
Вам нужно знать точные названия тем, которые вы хотели бы прочитать в файле bag. Итак, давайте посмотрим, что находится в файле bag. В любом терминале вручную проверьте все опубликованные темы и количество сообщений, опубликованных в каждой теме, с помощью этой команды:<br>
<b>time rosbag info /tmp/mybagfile.bag</b><br>  
или если знаете имена нужных топиков:<br>
<b>time rosbag info /tmp/mybagfile.bag | grep -E "(topic1|topic2|topic3)"</b>
<p>
<img src="./images/rosbag_record.png">

<h3 align=center>Вариант 2: используем скрипт ros_readbagfile, чтобы извлечь интересующие темы</h3>
<b>Установка команды ros_readbagfile:</b>
<ul>
<li> Скачал <b>wget https://raw.githubusercontent.com/ElectricRCAircraftGuy/eRCaGuy_dotfiles/master/useful_scripts/ros_readbagfile.py</b>
<li> Выполнил: <b>chmod +x ros_readbagfile.py</b>
<li> Убедититься, что есть каталог ~/bin для личных двоичных файлов: <b>mkdir -p ~/bin</b>
<li> Переместить этот файл в ~/bin: <b>mv ros_readbagfile.py ~/bin/ros_readbagfile</b>
<li> Переустановите свой файл ~/.profile, чтобы убедиться, что ~/bin находится на вашем пути и вы можете использовать эту новую команду `ros_readbag file`, которую вы только что установили.<br>
Команда: <b>. ~/.profile</b><br>
Выполнил.
<li> Установка python-зависимостей:<br>
<b>sudo apt install python3-rosbag</b><br>
<b>ln -si "${PWD}/ros_readbagfile.py" ~/bin/gs_ros_readbagfile<br>
ln -si "${PWD}/ros_readbagfile.py" ~/bin/ros_readbagfile<br>
. ~/.profile</b><br>
Теперь можем выполнять команды: `gs_ros_readbagfile` или `ros_readbagfile`
<p>
Примечание: если ваш терминал по-прежнему сообщает, что не может найти команду при попытке ее запуска, возможно, вам потребуется убедиться, что ~/bin является частью вашей переменной PATH.
</ul>

<b>Работа с командой ros_readbagfile.py:</b><br>
Использовать команду буду на bag.файле /home/dmitriy/bagfiles/2024-07-21-19-21-13.bag
<ul>
<li> Определим точные имена тем, которые вы хотели бы прочитать в файле bag:<br>
<b>time rosbag info 2024-07-21-19-21-13.bag</b><br> 
<img src="./images/rosbag_info_file.png">
<li> Общий синтаксис команды readbagfile:<br>
<font color=green>time ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...]</font><br>
Выведу только 1 топик /turtle1/cmd_vel:<br>
<b>time ros_readbagfile 2024-07-21-19-21-13.bag /turtle1/cmd_vel</b><br>
<img src="./images/time_ros_readbagfile.png">
<li> Запишем сообщения 2024-07-21-19-21-13.bag /turtle1/cmd_vel в файл topics.yaml без вывода в терминал:<br>
 <b>time ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...] > topics.yaml</b><br>
 <img src="./images/topics.yml.png">
 <p>
 Если хотим одновременно записывать в файл и выводить на экран, то использовать команду такого формата:
 <p>
 <font color=green>time ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...] | tee topics.yaml</font>
 <p>
 <img src="./images/time_ros_readbagfile1.png">
<p>
При желании, чтобы увидеть "прогресс", наблюдая, как увеличивается размер файла yaml, в новом терминале запустить команду:<br>
<b>watch -n 1 'du -sk topics.yaml | awk '\''{printf "%.3f MiB %s\n", $1/1024, $2}'\'''</b>
<p>
Теперь просмотрите topics.yaml в вашем предпочтительном текстовом редакторе, чтобы просмотреть все сообщения, извлеченные из файла bag.
<h3 align=center>Анализ topics.yaml</h3>
Имеем файл topics.yaml, созданный на основе файла.bag. Теперь научимся извлекать из него нужную нам информацию.<br>
Для начала установим: <b>sudo apt update && sudo apt install ripgrep</b>
<p>
Допустим хотим найти список всех ключевых элементов, которые начинаются с "piksi_". Вы можете сделать это, выполнив поиск по строке "ключ: "piksi_" следующим образом:<br>
<b>time rg 'key: "piksi_' topics.yaml | sort -V | awk '!seen[$0]++'</b><br>
Часть rg 'key: "piksi_" topics.yaml выполняет поиск в текстовом файле "topics.yaml" строки : "piksi_",<br>
 часть sort -V сортирует все выходные строки,<br>
  а часть awk '!seen[$0]++" удаляет повторяющиеся записи, так что вы видите только одну строку каждого совпадения.
<p>
Другое применение:<br>
Давайте выполним поиск по всем ключевым элементам данных, которые начинаются с "GPS", "Duration" или "Minimum". Поиск по регулярным выражениям типа "OR" выполняется в общем формате: (str1|str2|str3|и т.д.), где | в данном случае читается как "or". Итак, поиск "GPS", "Duration" или "Minimum" может быть выполнен с помощью следующей строки поиска по регулярному выражению:<br>
'(key: "GPS|key: "Duration|key: "Minimum)'.<br>
Команда: <b>time rg '(key: "GPS|key: "Duration|key: "Minimum)' topics.yaml | sort -V | awk '!seen[$0]++'</b>
<p>
<h3 align=center>Зачем использовать для этой цели "ros_readbag file" вместо `rostopic echo -b`?</h3>
<ul>
<li> Потому что rostopic работает очень медленно! Например, выполнение этой команды на быстродействующем компьютере (4-ядерный/8-поточный Pentium i7 с SSD-накопителем m.2) занимает 11,5 минут для чтения файла bag объемом 18 ГБ!<br>
Однако скрипту ros_readbagfile требуется всего 1 минута 37 секунд на том же компьютере, чтобы прочитать ту же тему из того же файла bag объемом 18 ГБ! Таким образом, ros_readbagfile работает в 11,5/(1+37/60) = ~в 7 раз быстрее!
<li> Потому что rostopic может одновременно читать только одну тему, в то время как ros_readbagfile может читать любое количество тем одновременно!
</ul>


<br><br><br><br><br><br></body></html>
