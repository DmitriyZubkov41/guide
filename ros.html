<html><head></head><body>
<title>ROS</title>
<a href="https://wiki.ros.org/ru">ROS Tutorials</a>
<h2 align="center">Основные концепции системы ROS</h2>
Ссылки: <a href="https://copter-space.gitbook.io/uchebnik-mashinnoe-zrenie-tom-2/razdel-2/osnovnye-koncepcii-sistemy-ros">Основные концепции системы ROS</a>

<h3 align=center>Файловая система ROS</h3>

Концепция файловой системы ROS в основном относится к ресурсам ROS, находящимся на диске, таким как:
<ul>
<li> <b>Пакеты (Packages)</b>: Пакет – основная единица файловой системы ROS. В основном пакет содержит выполняемые процессы ROS (узлы или ноды - nodes), библиотеки на основе ROS, наборы данных, конфигурационные файлы и прочие полезные данные. Пакет – это минимальная единица для компиляции и релиза в ROS.<br>
<b>Команды для работы с пакетами:</b>
<ul>
<li> Поиск пакета: <font color="green">rospack find [package_name]</font><br>
<img src="./images/rospack1.png">   
<li> <b>roscd:</b> <font color="green">roscd &lt;package-or-stack&gt;[/subdir]</font> переход к указанному пакету.<br>
<img src="./images/roscd.png">
<li> Чтобы увидеть список каталогов, где находятся пакеты, служит команда: <font color="green">echo $ROS_PACKAGE_PATH</font>
<li> <font color="green">roscd log</font>  приведет вас к папке, в которой хранятся файлы журнала ROSS. Обратите внимание, что если вы еще не запускали какие-либо программы для ROM, это приведет к ошибке, указывающей на то, что они еще не существуют.
<li> <font color="green">rosls &lt;package-or-stack&gt;[/subdir]</font> показывает состав пакета, обращаясь к нему по имени, а не по абсолютному пути.<br>
 <img src="./images/rosls.png"><br>
Клавиша TAB выполняет функцию автозаполнения или если дважды, то список вариантов. Например напишем ros и нажмем дважды TAB, выведутся все команды ros'а.<br>
<b>rosls</b> и дважды TAB, то выведет список установленных пакетов.
</ul>
<li> <b>Метапакеты (Metapackages)</b>: Метапакеты – это специализированные Пакеты, используемые для группировки других взаимосвязанных Пакетов. Используются также для обратной совместимости.
<li> <b><a href="https://wiki.ros.org/catkin/package.xml">Манифесты Пакетов (Package Manifests)</a></b>: Манифест (package.xml) содержит данные о пакете, включая имя, версию, описание, информацию о лицензировании, зависимости и прочую информацию, такую как экспортируемые пакеты.

<li> <b>Репозитории (Repositories)</b>: набор пакетов, принадлежащих одной и той же версии. Пакеты одной и той же системы контроля версий и одинаковой версии могут выпускаться вместе с помощью инструмента автоматизации релизов bloom (http://wiki.ros.org/bloom). Репозиторий также может содержать только один пакет.

<li> <b>Типы сообщений (Message types)</b>: описание сообщений, хранится в my_package/msg/MyMessageType.msg, определяет структуры данных для сообщений, передаваемых в ROS.

<li> <b>Типы сервисов (Service types)</b>: описание сервисов, хранится в my_package/srv/MyServiceType.srv, определяет структуры данных для запроса и ответа сервисов в ROS.

<li> <b>Рабочая область (Workspace)</b> в ROS — это папка, где разработчики создают, собирают и настраивают свои пакеты и программы. Содержит исходный код, пакеты и сборочные скрипты.<br>
Основная структура:
<ul>
<li> src: директория исходного кода, где хранятся пакеты ROS
<li> build: временная директория, используемая во время сборки пакетов
<li> devel: содержит файлы, необходимые для запуска программ после сборки, включая исполняемые файлы и среду окружения
</ul>
</ul>

<h3 align=center>Граф вычислений ROS</h3>
Граф вычислений ROS – это одноранговая сеть процессов ROS, обрабатывающих данные. Основные понятия, связанные с графом вычислений – это ноды (nodes), Мастер (Master), Сервер Параметров (Parameter Server), сообщения (messages), сервисы (services), топики (topics), контейнеры (bags). Все эти сущности передают данные для вычислительного графа ROS разными способами.
<ul>
<li> <b>Мастер ROS</b><br>
Мастер выполняет роль сервера имен для возможности подключения между собой различных нод. Связь между нодами (обмен сообщениями), невозможна без запущенного мастера. Запускается командой:
<p>
<font color=green>roscore</font>
<p>
При запуске ROS roscore, мастер будет запущен по адресу URI, установленным в переменной окружения ROS_MASTER_URI. По умолчанию адрес использует IP-адрес локального ПК и номер порта 11311
<p>
Ноды связываются с другими Нодами напрямую. Мастер только предоставляет информацию для поиска, подобно DNS серверу. Ноды, которые подписываются на топик, запрашивают связь с Нодами, которые публикуют данные в этот топик, и устанавливают эту связь через соответсвующий согласованный протокол. Наиболее часто используемый протокол – TCPROS, он использует стандартные TCP/IP

<li> <b>Ноды (Nodes)</b>:<br>
Ноды (узлы)– это программы (обычно написанные на Python или C++), которая взаимодействуют с другими нодами посредством ROS-топиков и ROS-сервисов. Одна нода управляет лазерным дальномером, другая – моторами колёс, третья нода определяет положение в пространстве, четвёртая планирует траекторию движения, пятая предоставляет графическое представление системы, и т.д.
<p>
Узлы ROS используют клиентские библиотеки ROS для взаимодействия с другими узлами, написанных на разных языках программирования:<br>
rospy = клиентская библиотека python<br>
roscpp = клиентская библиотека c++
<p>
При запуске нода регистрирует информацию о себе на мастере (название ноды, типы обрабатываемых сообщений). Зарегистрированная нода может взаимодействовать с другими нодами (получать и отправлять запросы). Важно отметить что обмен сообщениями между нодами работает без участия мастера (соединение между нодами происходит напрямую через топик). Мастер обеспечивает только единое пространство имен для решения вопроса куда подключиться к конкретной ноде. Адрес запуска ноды, берётся из переменной окружения ROS_HOSTNAME, которая должна быть определенна до запуска. Порт устанавливается на произвольное уникальное значение.
<li> <b>Сервер параметров (Parameter Server)</b>: Сервер параметров позволяет хранить данные с доступом по ключу в централизованном хранилище. В настоящее время Сервер Параметров является частью Мастера.<br>
Параметры в ROS представляют собой глобальные значения, которые можно использовать для настройки поведения узлов (nodes).<br>
Параметры могут быть различных типов: числа (целые и вещественные), строки, булевы значения, массивы и так далее.<br>
Для того, чтобы ноды могли использовать parameter, используем библиотечные функции либо с терминала команды rosparam.<br>
<b>Некоторые команды с параметрами:</b>
<ul>
    <li> Показать список всех параметров: <font color="green">rosparam list</font>
    <li> Установить значение параметра: <font color="green">rosparam set</font>
    <li> Получить значение параметра: <font color="green">rrosparam get</font>
    <li> Загрузить параметры из файла YAML: <font color="green">rosparam load</font>
    <li> Сохранить параметры в файл YAML: <font color="green">rosparam dump</font>
</ul>
<p>
<font color=brought><b><i>Как я понял ROS Parameter представляет собой массив (словарь) глобальных переменных, которые доступны для всех нод.</i></b></font>

<li> <b><a href="ros_message.html">Сообщения (Messages)</a></b>:<br>
Ноды отправляют и принимают данные между собой, согласно заданного формата. Эти данные называют Сообщения, а описание Типом Сообщения.

<li> <b>Топики (Topics)</b>:<br>
Сообщения передаются через механизм публикации/подписки. Нода отправляет сообщение, публикуя (publish) его в определённом Топике. Топик – это имя, идентифицирующее содержание сообщения. Нода, заинтересованная в определённых данных, осуществляет подписку (subscribe) на соответствующий Топик. Для одного топика может существовать несколько параллельно публикующих/подписанных на него Нод, равно как и одна Нода может публиковать сообщения в и/или подписываться на несколько Топиков. В общес случае, публикаторы/подписчики не оказывают влияния друг на друга. Идея заключается в отделении производства информации от её использования. Логически Топик может быть представлен как строго типизированная шина сообщений. У каждой шины есть наименование, и любой элемент может подсоединиться к шине для получения и отправки сообщений соответствующего типа.
<ul>
    <li> Топик (тема) — это имя для потока сообщений
    <li> Узлы общаются между собой посредством топиков
    <li> Узлы могут публиковать или подписываться на топик
    <li> Как правило, у топика один издатель и n подписчиков
</ul>

<li> <b>Сервисы (Services)</b>: Модель публикации/ подписки является очень гибкой, но её схема односторонней передачи сообщений «многие-многим» не подходит для взаимодействий типа «запрос-ответ», которые часто нужны в распределённой системе. Механизм «запрос-ответ» реализован через Сервисы. Сервис определяется парой структур сообщений – одна для запроса и одна для ответа. Нода предоставляет сервис, используя определённое Имя сервиса, клиент использует сервис, отправляя сообщение-запрос и ожидая ответа. Клиентские библиотеки ROS обычно представляют это взаимодействие для программиста в виде вызова удалённой процедуры.<br>
<b>Некоторые команды с сервисами:</b>
<ul>
    <li> Показать список активных сервисов: <font color=green>rosservice list</font>
    <li> Вызвать сервис с определёнными аргументами: <font color=green>rosservice call</font>
</ul>
Сервисы настраиваются в файлах .srv Файлы .srv описывают типы сервисов в ROS: определяют структуры данных, которые сервис принимает и возвращает. Каждый .srv файл содержит две части: запрос (Request) и ответ (Response), разделённые символом "---"
<ul>
    <li> Показать структуру .srv-файла для заданного типа сервиса: <font color="green">rossrv show [service_type]</font>
</ul>
<li> <b>Контейнеры (Bags)</b>: Контейнеры предоставляют форматы для записи и воспроизведения потоков ROS-сообщений. Контейнеры являются важным механизмом для записи данных, например, данных с сенсоров, которые трудно собрать, но необходимо сохранять для разработки и тестирования алгоритмов.
</ul>
 сокеты.
<h3>Имена</h3>
Ссылки: <a href="https://wiki.ros.org/Names">Names</a>
Любой топик, сервис или параметр идентифицируется с помощью уникального имени. ROS-имя представляет собой иерархическую структуру с символом / в качестве разделителя (сходно с именами в файловой системе).<br>
Примеры ROS-имен:<br>
/ (глобальное пространство имен)<br>
/foo<br>
/stanford/robot/name<br>
/wg/node1<br>
Эти имена является глобальными (аналогично полному пути в файлу в файловой системе). На практике рекомендуется использование приватных или относительных имен.
<p>
Приватное имя<br>
Каждая нода может использовать собственное приватное пространство имен (соответствующее имени ноды) для своих ресурсов. Например, нода aruco_detect может публиковать такие топики:<br>
/aruco_detect/markers<br>
/aruco_detect/visualization<br>
/aruco_detect/debug<br>
Когда нода ссылается на свой приватный ресурс, вместо пространства имен (/aruco_detect/) используется символ ~, например:<br>
~markers<br>
~visualization<br>
~debug<br>
Таким образом, создание топика foo в приватном пространство имен из Python будет выглядеть так:<br>
private_foo_pub = rospy.Publisher('~foo', String, queue_size=1)
<p>
Относительное имя<br>
Несколько нод также могут объединяться в общее пространство имен (например, при одновременной работе нескольких роботов). Для того, чтобы ссылаться на топики с учетом общего пространства имен, в названии ресурса опускается начальный символ /.

Пример создание топика foo с учетом общего пространства имен:

relative_foo_pub = rospy.Publisher('foo', String, queue_size=1)
<p>
Такая архитектура обеспечивает раздельное функционирование системы, в которой посредством распределений имён могут быть построены большие сложные распределённые системы. Имена играют важнейшую роль в ROS: ноды, топики, сервисы и параметры все имеют имена. Каждая клиентская ROS-библиотека поддерживает переназначение (remapping) имён с помощью инструментов командной строки, т.е. скомпилированная программа может быть переконфигурирована во время выполнения для обработки различной топологии Вычислительного графа.
<p>
Например, для контроля лазерного дальномера мы запускаем драйвер hokuyo_node, который опрашивает лазер и публикует sensor_msgs/LaserScan сообщения в топик scan. Дла обработки этих данных, мы можем написать, используя пакет laser_filters, ноду, которая подписывается на сообщения топика scan. После подписки наш фильтр автоматически начнёт получать сообщения от лазера.
<p>
Теперь о том, как происходит разделение. Нода hokuyo_node только публикует сообщения, не зная о том, подписан ли на них кто либо. Нода фильтра только подписывается на сообщения топика, не зная о том, публикует ли кто-то туда сообщения. Обе ноды могут быть запущены, остановлены, перезапущены, в любом порядке, не порождая при этом ошибок.
<p>
Далее мы можем добавить роботу другой лазерный дальномер, поэтому нужно переконфигурировать систему. Всё что нужно при этом – переназначить (remap) используемые имена. При запуске ноды hokuyo_node мы можем вместо имени scan переназначить имя base_scan. B то же самое сделать с нодой – фильтром. Теперь обе эти ноды будут связаны с использованием топика base_scan, и перестанут обрабатывать сообщение тописа scan. После этого мы можем запустить ещё одну ноду hokuyo_node для нового лазерного дальномера.



<h2 align="center"><a href="https://wiki.ros.org/ru/ROS/Tutorials">Из официальной документации</a></h3>
<h2><a href="http://wiki.ros.org/ROS/Tutorials/CreatingPackage">Создание пакетов</a></h2>
<ol>
    <li><h3>Что такое catkin пакет?</h3>
Чтобы catkin пакет считался таким, он должен иметь признаки:
<ul>
    <li> пакет должен содержать файл package.xml
    <li> должен содержать файл  CMakeLists.txt
    <li> У каждого пакета должна быть своя собственная папка. Это означает, что нет ни вложенных пакетов, ни нескольких пакетов, использующих один и тот же каталог.
    </ul>
<li><h3 align="center">Пакеты в catkin workspace</h3>
Обычный catkin workspace:<br>
<img src="./images/catkin_ws.png">
<li>Создание catkin-пакета.<br>
    Общий синтаксис команды создания пакета:<br>
    <font color="green">catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]</font><br>
catkin_create_pkg требует, чтобы вы указали ему имя пакета и, возможно, список зависимостей, от которых зависит этот пакет.<br>
Пример:<br>
    <font color="green">cd ~/catkin_ws/src</font> переходим в каталог src<br>
    <font color="green">catkin_create_pkg beginner_tutorials std_msgs rospy roscpp</font><br>
    <img src="./images/catkin_create_pkg.png"><br>
    Создаем пакет beginner_tutorials, который зависит от нод std_msgs, rospy и roscpp.В результате будет создана папка beginner_tutorials, содержащая файлы package.xml и CMakeLists.txt, которые были частично заполнены информацией, которую вы предоставили catkin_create_pkg.
<p>
<b>CMakeLists.txt</b> - файл сборки, где описано какие библиотеки добавлять в пакет, какие ноды входят в пакет.
<p>
<b>package.xml</b> - файл, где с помощью тегов описаны зависимости.
<p>
Еще стандартной папкой в пакете является папка <b>include</b>.
<p>
Папка <b>launch</b> содержит файлы.launch, которые позволяют запускать одновременно несколько нод либо одну ноду с какими-то параметрами.
<p>
<b>src</b> - папка, где лежат скрипты наших нод. Возможно будет папка scripts, выполняющая аналогичные функции.
<li><h3>Изменение рабочего пространства catkin (catkin workspace) с учетом нового пакета и исполнение setup файла</h3>
    <font color="green">cd ~/catkin_ws<br>
    catkin_make</font><br>
    После создания рабочей области в подпапке devel будет создана аналогичная структура, которую вы обычно находите в /opt/ros/noetic<br>
    Чтобы добавить переменные, нужно выполнить команду:<br>
    <font color="green">. ~/catkin_ws/devel/setup.bash</font>
<li><b>Пакетные зависимости:</b><br>
    <ul>
    <li> <b>Зависимости первого порядка</b><br>
            При использовании catkin_create_pkg ранее были предоставлены несколько зависимостей от пакетов. Эти зависимости первого порядка теперь можно просмотреть с помощью инструмента rospack:<br>
            <font color="green">rospack depends1 &lt;package_name&gt;</font><br>
           Выдаст список зависимостей, которые были установлены во время выполнения команды catkin_create_pkg. Эти зависимости хранятся в файле package.xml.<br>
        <img src="./images/rospack_depends1.png">
    <li> <b>Косвенные зависимости</b><br>
        Во многих случаях у зависимостей также будут свои собственные зависимости. Например, у rospy есть другие зависимости.<br>
        <img src="./images/rospack_depends2.png"><br>
        Пакет может иметь много косвенных зависимостей:<br>
        <font color="green">rospack depends &lt;package_name&gt;</font> - выведет все зависимости.
    <li> <b>Файл package.xml содержит:</b>
<ul>
<li>тег description<br>
    <img src="./images/description.png">
<li> тег maintainer<br>
    Это обязательный и важный тег для package.xml потому что он позволяет другим пользователям узнать, к кому обратиться по поводу пакета. Требуется как минимум один специалист по сопровождению, но вы можете нанять их много, если хотите. Имя сопровождающего указано в тексте тега, но также есть атрибут электронной почты, который необходимо заполнить<br>
    <img src="./images/maintainer.png">
<li> теги лицензий<br> Обязательный. Наиболее распространенными лицензиями с открытым исходным кодом являются BSD, MIT, Boost Software License, GPLv2, GPLv3, LGPLv2.1 и LGPLv3. Вы можете прочитать о некоторых из них в разделе Open Source Initiative. В этом руководстве мы будем использовать лицензию BSD, поскольку остальные компоненты core RODS уже используют ее
теги зависимостей<br>
<img src="./images/license.png">
<li> <b>теги зависимостей:</b><br>
Следующий набор тегов описывает зависимости вашего пакета. Зависимости разделены на:<br>
build_depend<br>
buildtool_depend<br>
exec_depend<br>
test_depend<br>
Более подробное объяснение этих тегов приведено в документации о зависимостях Catkin. Поскольку мы передали std_msgs, roscpp и rospy в качестве аргументов для catkin_create_pkg, зависимости будут выглядеть следующим образом:
<img src="./images/tag_depends.png">
<li> тег конца файла <b>&lt;/package&gt;</b>
</ul>
</ul>
</ol>


<h2 align="center">Ноды (узлы)</h2>
Ссылки: <a href="https://se.moevm.info/doku.php/courses:ros:class2">Занятие № 2: Детальное представление о среде</a>
<p>
Прежде чем выполнять команды над нодами, следует вызвать мастера ROS, команда:
<p>
<font color="green">roscore</font><br>
<p>
И после этого в другом терминале выполнять команды.<br>
Если вы хотите чтобы roscore запустился в фоновом режиме, то запустите его командой:<br>
<p>
<font color=green>roscore &</font> 
<h3>Список активных нод:</h3>
<font color="green">rosnode list</font> - выводит список этих активных узлов.
<p>
Если не запускали какую-нибудь ноду, то покажет только rosout. Он всегда запущен, поскольку собирает и регистрирует выходные данные отладки узлов.
<p>
<font color="green">rosnode info &lt;name_node&gt;</font> - покажет информацию о ноде.<br>
Пример:<br>
<img src="./images/info_my_turtl.png">
<h4>Запуск нод</h4>
Запуск нод в ROS осуществляется при помощи команды rosrun. Общий синтаксис употребления этой команды выглядит так:
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>rosrun &lt;пакет&gt; &lt;нода&gt; [&lt;имя параметра&gt;:=&lt;значение&gt;]</b>
<p>
Причём в графе <нода> указывается не произвольное имя новой ноды, а класс-тип нод, экземпляр которого нужно запустить. Непосредственно имя ноды устанавливается через параметры.
<p>
<font color="green">rosrun [package_name] [node_name]</font> - позволит выполнить ноду node_name внутри пакета package_name без указания пути к этому пакету.<br>
Например выполнить turtlesin_node внутри пакета turtlesim.<br>
<img src="./images/ros_turtlesim.png">
<br>
Будет запущена нода типа turtlesim_node из пакета turtlesim. Имя ноды в данном случае не указывалось и оно присвоится автоматически. Теперь, если в новом терминале ввести команду:<br>
<b>rosnode list</b><br>
в ответ будет получено следующее:<pre>
/rosout   
/turtlesim</pre>
Таким образом создалась ещё одна нода с именем /turtlesim и определённая в глобальном поле имён, о чём говорит предшествующий символ слеш “/”. Если в новом терминале вновь будет выполнена команда:<br>
<b>rosrun turtlesim turtlesim_node</b><br>
То создастся новая нода с тем же именем /turtlesim. Это вызовет аварийную остановку уже созданной ноды:
<pre>
[ WARN] [1471851936.261860979]: Shutdown request received.          
[ WARN] [1471851936.261924457]: Reason given for shutdown: [new node
registered with same name]
</pre>                                          
Для того, чтобы указать имя ноды, при её создании необходимо присвоить значение переменной __name (с двумя символами нижнего подчёркивания). Таким образом, чтобы создать ноду с именем “turtle_node” необходимо выполнить команду:<br>
<b>rosrun turtlesim turtlesim_node __name:=turtle_node</b>
<p>
<b>Пинг ноды:</b><br>
<font color="green">rosnode ping [node_name]</font> - пингуем ноду, чтобы проверить, что она запущена.


<h2 align=center>Команды rostopic:</h2>
<ul>
<li> <font color="green">rostopic echo [topic]</font> - показывает данные, публикуемые в топик.
<li> <font color="green">rostopic list</font> - возвращает список всех топиков, на которые в данный момент подписаны и которые публикуют.<br>
Опции этой команды:
<ul>
<li> -h, --help            show this help message and exit
<li> -b BAGFILE, --bag=BAGFILE  список топиков в .bag file
<li> -v, --verbose  дополнительно показывает сколько подписчиков и публицистов на топики завязано.
<li> -p список только публицистов
<li> -s список только подписчиков
</ul>
<img src="./images/rostopic_list.png">
<li> Тип сообщений:<br>
Ноды общаются между собой с помошью messages (сообщений). Чтобы ноды понимали друг друга, сообщения должны иметь одинаковый тип. Чтобы узнать тип сообщений, служит команда:<br>
<font color="green">rostopic type [topic]</font><br>
Вернёт тип (имя) сообщений, используемого для топика.<br>
<img src="./images/rostopic_type.png">
<p>
Чтобы посмотреть детали этого сообщения, используется команда:<br>
<font color="green">rosmsg show [name_meesage]</font><br>
<img src="./images/rosmsg_show.png">
<li> <b>Отправка сообщений в топик:</b><br>
зная тип (имя) сообщений, мы можем отправлять их ноде через топик, тем самым управлять нодой.<br>
Синтаксис:<br>
<font color="green">rostopic pub [topic] [msg_type] [args]</font><br>
публикует данные по объявленному топику.<br>
<img src="./images/rostopic_pub.png">
<ul>
<li> <b>-1</b> Этот параметр приводит к тому, что rostopic публикует только одно сообщение, а затем завершает работу
<li> <b>/turtle1/cmd_vel</b> - это имя топика, в который отправляем (публикуем) сообщение
<li> <b>geometry_msgs/Twist</b> - это тип (имя) сообщения, которое отправляем в топик.
<li> <b>--</b> - этот параметр (двойное тире) указывает анализатору параметров, что ни один из следующих аргументов не является параметром. Это необходимо в тех случаях, когда ваши аргументы начинаются с тире -, например, с отрицательных чисел.
<li> <b>'[2.0, 0.0, 0.0]' '[0.0, 0.0, 1.8]'</b> - сообщение geometry_msgs/Twist содержит два вектора по три элемента с плавающей запятой в каждом: линейный и угловой. В этом случае, '[2.0, 0.0, 0.0]' становится линейным значением при x=2.0, y=0.0 и z=0.0, а '[0.0, 0.0, 1.8]' - угловым значением при x=0.0, y=0.0 и z=1.8. Эти аргументы приведены в синтаксисе YAML.<br>
Чтобы не запоминать формат сообщения, можно после типа сообщения дважды нажать клавишу tab. Это выпишет имена полей и рядом начальные значения, которыми они инициализируются. Далее их можно изменить.
</ul>
<p>
Мы можем опубликовать постоянный поток команд, используя опцию -r:<br>
<img src="./images/rostopic_pub1.png">
<p>
<font color="green">rostopic hz [topic]</font> - сообщает о скорости публикации данных в [topic].
</ul>
Весь список команд rostopic:
<ul>
<li> rostopic bw     Показать занимаемый сетевой канал
<li> rostopic echo   Вывести сообщения на экран
<li> rostopic find   Поиск топика по типу
<li> rostopic hz     Показать частоту обновления топика
<li> rostopic info   Показать информацию о топике
<li> rostopic list   Показать список существующий топиков
<li> rostopic pub    Опубликовать данные в топик
<li> rostopic type   Показать тип сообщения для топика
</ul>

<h3 align="center">Команды rosparam:</h3>
rosparam позволяет хранить данные на сервере параметров ROS и манипулировать ими. Сервер параметров может хранить целые числа, значения с плавающей запятой, логические значения, словари и списки. Для синтаксиса rosparam использует язык разметки YAML. В простых случаях YAML выглядит очень естественно: 1 - целое число, 1.0 - число с плавающей точкой, "единица" - строка, true - логическое значение, [1, 2, 3] - список целых чисел, {a: b, c: d} - словарь. В rosparam есть множество команд, которые можно использовать для работы с параметрами:
<ul>
    <li> <font color="green">rosparam list</font> - список параметров<br>
        <img src="./images/rosparam_list.png">
    <li> <font color="green">rosparam set [param_name]</font> - устанавливаем значение параметра [param_name]<br>
        Пример: <i>$ rosparam set /turtlesim/background_r 150</i><br>
        <font color="green">rosparam get [param_name]</font> - выводит значение параметра<br>
        <img src="./images/rosparam_set.png"><br>
        Чтобы изменение параметра вступило в силу, нужно вызвать службу чистильщика (/clean).
    <li> Команда <font color="green">rosparam get /</font> выведет значения всех параметров на сервере параметров.<br>
        <img src="./images/rosparam_get.png">
        <p>
            <font color="green">rosparam get name_parametr</font> - выводит значение параметра name_parametr:<br>
            <img src="./images/rosparam_get1.png">
    <li> Если хотим сохранить этот набор параметров, чтобы потом вызвать, то служит команда:<br>
        <font color="green">rosparam dump [file_name] [namespace]</font> - записываем все параметры в файл [file_name]
    <li> Вызвать сохранённый набор параметров [file_name] для [namespace], служит команда:<br>
        <font color="green">rosparam load [file_name] [namespace]</font>
</ul>



<h3 align="center">Команда rosed</h3>
Синтаксис:
<p>
    <font color="green">rosed [package_name] [filename]</font>
<p>
    Служит для редактирования файла [filename] из пакета [package_name].<br>
    По умолчанию редактором является vim. Чтобы редактором для команды rosed был более простой nano, следует в файл ~/.bashrc добавить строку:<br>
    <b>export EDITOR='nano -w'</b>


<h3>Получение подсказки по команде</h3>
Познакомились с довольно большим количеством инструментов ROS. Иногда бывает сложно отследить, какие аргументы требуются для каждой команды. К счастью, большинство инструментов ROS предоставляют свою собственную помощь. Чтобы получить подсказку по команде, достаточно опции -h:<br>
<img src="./images/rosmsg_h.png">




<h2 align=center>Создание publisher-ноды talker.cpp на языке C++ для пакета beginner_tutorials</h2>
<a href="https://github.com/ros/ros_tutorials/tree/noetic-devel/ros_tutorials">Репозиторий ROS, откуда берутся коды нод.</a>
<ol>
<li> Перейдем в каталог пакета: <b>roscd beginner_tutorials</b>
<li> Создадим внутри каталог src: <b>mkdir -p src</b><br>
Этот каталог будет содержать все исходные файлы (ноды) для нашего пакета beginner_tutorials.
<li> Внутри этого созданного каталога создадим файл talker.cpp, код скопируем с https://raw.github.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/talker/talker.cpp:<br>
<b>nano src/talker.cpp</b><br>
<img src="./images/talker.cpp.png">
<p>
Разберем код по пунктам:
 <ol>
   <li> <img src="./images/ros.h.png"><br>
   ros/ros.h - это раздел, который включает в себя все заголовки, необходимые для использования наиболее распространенных элементов системы ROS.
   <li> <img src="./images/std_msgs.png"><br>
   включает в себя сообщение std_msgs/String, которое находится в пакете std_msgs. Это заголовок, автоматически генерируемый из файла String.msg в этом пакете.
 <li> <img src="./images/ros_init.png"><br>
 Инициализируем (вызываем) ROS. Позволяет ROS выполнять переназначение имен через командную строку - сейчас это не важно. Здесь мы также указываем имя нашего узла (ноды). Имена узлов должны быть уникальными в запущенной системе. Используемое имя должно быть базовым, т.е. в нем не может быть символа /.
 <li> <img src="./images/ros_handle.png"><br>
 NodeHandle является основной точкой доступа для обмена данными с системой ROS. Первый созданный NodeHandle полностью инициализирует этот узел, а последний уничтоженный NodeHandle закроет узел.
 <li> <img src="./images/publisher.png"><br>
 Сообщите мастеру ROS, что мы собираемся опубликовать сообщение типа std_msgs/String в топик chatter. Это позволяет мастеру сообщить любым узлам, прослушивающим chatter, что мы собираемся опубликовать данные в этот топик. Вторым аргументом является размер нашей очереди публикации. В этом случае, если мы публикуем слишком быстро, в буфере будет храниться максимум 1000 сообщений, прежде чем мы начнем выбрасывать старые.
 <li> <img src="./images/loop_rate.png"><br>
 Объект ros::Rate позволяет вам указать частоту, с которой вы хотели бы выполнять цикл. Он будет отслеживать, сколько времени прошло с момента последнего вызова функции Rate::sleep(), и будет находиться в режиме ожидания в течение необходимого периода времени. Сейчас мы говорим, что хотим работать на частоте 10 Гц.
 <li> <img src="./images/ros_ok.png"><br>
 По умолчанию roscpp установит обработчик SIGINT, который обеспечивает обработку Ctrl-C, что приведет к тому, что ros::ok() вернет значение false, если это произойдет.<br>
ros::ok() вернет значение false, если:
<ul>
<li> получено значение SIGINT (Ctrl-C)
<li> мы были отключены от сети другим узлом с таким же именем
<li> функция ros::shutdown() была вызвана другой частью приложения.
<li> все функции ros::Nodehandle были уничтожены
</ul>
Как только функция ros::ok() вернет значение false, все вызовы ROS завершатся ошибкой.
<li> <p><img src="./images/fill_messages.png"><br>
Мы передаем сообщение в ROS, используя класс, адаптированный для сообщений, который обычно генерируется из msg-файла. Возможны более сложные типы данных, но пока мы будем использовать стандартное строковое сообщение, которое состоит из одного элемента: "данные".
<li><p><img src="./images/chatter_pub.png"><br>
Функция publish() - это способ отправки сообщений. Параметр в скобках - это объект message. Тип этого объекта должен совпадать с типом, заданным в качестве параметра шаблона для вызова advertise().
<li><p><img src="./images/ros_console.png"><br>
ROS_INFO и friends - это наша замена printf/cout. Дополнительную информацию смотрите в <a hre="https://wiki.ros.org/rosconsole">документации rosconsole</a>.
<li><p><img src="./images/spin_once.png"><br>
Вызов ros::spinOnce() здесь не требуется для этой простой программы, потому что мы не получаем никаких обратных вызовов. Однако, если бы вы добавили подписку в это приложение и у вас не было бы функции ros::spinOnce(), ваши обратные вызовы никогда бы не были вызваны. Так что добавьте это для пущей убедительности.
<li><p><img src="./images/rate_sleep.png"><br>
Используем объект ros::Rate для перехода в спящий режим на оставшееся время, чтобы достичь скорости публикации 10 Гц.
 </ol>
 Краткая версия того, что делаем в talker.cpp:<br>
Инициализируем систему ROS<br>
Объявляем, что мы собираемся публиковать сообщения std_msgs/String в топик chatter для master ROS<br>
Цикл публикации сообщений в chatter выполняется 10 раз в секунду
</ol>




<h2 align=center>Создание ноды-подписчика listener.cpp на языке C++</h2>
<b>nano src/listener.cpp</b>
<br>Код скопировал с https://raw.githubusercontent.com/ros/ros_tutorials/kinetic-devel/roscpp_tutorials/listener/listener.cpp
<p>
Разбор кода по пунктам:
<ol>
<li><p><img src="./images/callback.png"><br>
Это функция обратного вызова callback(), которая будет вызываться при поступлении нового сообщения в топик chatter. Сообщение передается с помощью boost shared_ptr, что означает, что вы можете сохранить его, если хотите, не беспокоясь о том, что оно будет удалено под вами, и не копируя исходные данные.
<li><p><img src="./images/subskriber.png"><br>
Подписывается на топик chatter с мастером. ROS будет вызывать функцию chatterCallback() всякий раз, когда поступает новое сообщение. Второй аргумент - это размер очереди, на случай, если мы не сможем обрабатывать сообщения достаточно быстро. В этом случае, если очередь достигнет 1000 сообщений, мы начнем отбрасывать старые сообщения по мере поступления новых.
<p>
Функция NodeHandle::subscribe() возвращает объект ros::Subscriber, который вы должны сохранить, пока не захотите отказаться от подписки. Когда объект Подписчика будет уничтожен, он автоматически отпишется от темы chatter.
<p>
Существуют версии функции NodeHandle::subscribe(), которые позволяют указать функцию-член класса или даже что-либо, вызываемое с помощью Boost.Функциональный объект. Более подробная информация содержится в обзоре roscpp.
<li><p><img src="./images/ros_spin.png"><br>
функция ros::spin() переходит в цикл, вызывая обратные вызовы сообщений как можно быстрее. Но не волнуйтесь, если ей нечего делать, она не будет использовать много ресурсов процессора. функция ros::spin() завершит работу, как только функция ros::ok() вернет значение false, что означает, что функция ros::shutdown() была вызвана либо обработчиком Ctrl-C по умолчанию, либо мастером, сообщающим нам о завершении работы, либо вызвана вручную.
<p>
Существуют и другие способы обработки обратных вызовов, но мы не будем здесь о них беспокоиться. В пакете roscpp_tutorials есть несколько демонстрационных приложений, которые это демонстрируют. В обзоре roscpp также содержится дополнительная информация.
</ol>
Краткая версия того, что происходит в listener.cpp:<br>
Инициализируем систему ROS<br>
Подписываемся на топик chatter<br>
Запускаем, ожидая поступления сообщений<br>
Когда приходит сообщение, вызывается функция chatterCallback()
<h3>Building нод</h3>
<ol>
<li> Редактируем CMakeLists.txt, добавляем эти строки:<br>
<pre>
add_executable(talker src/talker.cpp)
target_link_libraries(talker ${catkin_LIBRARIES})
add_dependencies(talker beginner_tutorials_generate_messages_cpp)

add_executable(listener src/listener.cpp)
target_link_libraries(listener ${catkin_LIBRARIES})
add_dependencies(listener beginner_tutorials_generate_messages_cpp)
</pre>
<p>
Это создаст два исполняемых файла, talker и listener, которые по умолчанию будут помещены в каталог пакетов вашего пространства разработки, расположенный по умолчанию по адресу ~/catkin_ws/devel/lib/&lt;package name&gt;.
<p>
Строка из CMakeLists.txt: <b>add_dependencies(talker beginner_tutorials_generate_messages_cpp)</b> гарантирует, что заголовки сообщений (Headers) этого пакета будут сгенерированы перед использованием. Если вы используете сообщения из других пакетов в своем рабочем пространстве catkin, вам также необходимо добавить зависимости к их соответствующим целям генерации, поскольку catkin создает все проекты параллельно. Начиная с *Groovy*, вы можете использовать следующую переменную для определения всех необходимых целей:<br>
<b>target_link_libraries(talker ${catkin_LIBRARIES})</b>
<p>
Переформируем наши пакеты настройки:<br>
<font color=green>cd ~/catkin_ws<br>
catkin_make</font>



<h2 align=center>Написание простых Publisher and Subscriber на Python</h2>
<h3>Создадим узел (ноду) publisher ("talker"), который будет постоянно транслировать сообщение.</h3>
<ol>
<li> <b>roscd beginner_tutorials</b><br>
Создадим папку scripts, которая будет хранить файлы.py<br>
<b>mkdir scripts</b><br>
В эту папку скачаем готовый talker.py из гитхаба:<br>
<b>wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/talker.py</b><br>
Сделаем его исполняемым:<br>
<b>chmod +x talker.py</b>
<p>
<img src="./images/ros_talker.png">
<p>
Код talker.py:
<p>
<img src="./images/code_talker.png">
<p>Разъяснение кода:
<ul>
<li> <b>#!/usr/bin/env python</b> с этой строки начинается каждая нода (скрипт) на python.</li>
<li><p><img src="./images/rospy.png"><br>
Вам необходимо импортировать rospy, если вы пишете ROS-узел. Импорт std_msgs.msg необходим для того, чтобы мы могли повторно использовать тип сообщения std_msgs/String (простой строковый контейнер) для публикации.</li>
<li><p><img src="./images/pub_rospy.png"><br>
Этот раздел кода определяет интерфейс talker для остальной части ROS. pub = rospy.Издатель("chatter", String, queue_size=10) объявляет, что ваш узел публикует в топике chatter, используя тип сообщения String. String здесь на самом деле является классом std_msgs.msg.String. Аргумент queue_size является новым в ROS hydro и ограничивает количество сообщений в очереди, если какой-либо подписчик не получает их достаточно быстро. В старых дистрибутивах ROS этот аргумент просто не используется.
<p>
Следующая строка, rospy.init_node(NAME, ...), очень важна, поскольку она сообщает rospy имя вашего узла - пока у rospy не будет этой информации, он не сможет начать взаимодействие с мастером ROS. В этом случае ваш узел получит имя talker. ПРИМЕЧАНИЕ: имя должно быть базовым, т.е. оно не должно содержать никаких косых черт "/".
<p>
anonymous = True гарантирует, что ваш узел будет иметь уникальное имя, добавляя случайные числа в конец имени. Обратитесь к разделу Инициализация и завершение работы - Инициализация вашего узла ROS в документации rospy для получения дополнительной информации о параметрах инициализации узла.
<li><p><img src="./images/rate_rospy.png"><br>
Эта строка создает объект Rate rate. С помощью своего метода sleep() он предлагает удобный способ зацикливания с желаемой скоростью. С его аргументом 10 мы должны ожидать, что цикл будет выполняться 10 раз в секунду (до тех пор, пока наше время обработки не превысит 1/10 секунды!).
<li><p><img src="./images/whail_not.png"><br>
Этот цикл представляет собой довольно стандартную конструкцию rospy: проверка флага rospy.is_shutdown() и последующее выполнение работы. Вы должны проверить is_shutdown(), чтобы проверить, должна ли ваша программа завершаться (например, при наличии комбинации клавиш Ctrl-C или иным образом). В данном случае "работа" - это вызов pub.publish(hello_str), который публикует строку в нашей теме chatter. Цикл вызывает функцию rate.sleep(), которая находится в режиме ожидания, достаточном для поддержания желаемой скорости в цикле.
<p>
(Вы также можете столкнуться с функцией rospy.sleep(), которая похожа на функцию time.sleep(), за исключением того, что она также работает с имитируемым временем (см. Часы).)
<p>
Этот цикл также вызывает rospy.loginfo(str), который выполняет тройную функцию: сообщения выводятся на экран, записываются в файл журнала узла и записываются в rosout. rosout - это удобный инструмент для отладки: вы можете извлекать сообщения с помощью rqt_console вместо того, чтобы искать окно консоли с выводом вашего узла.
<p>
std_msgs.msg.String - это очень простой тип сообщения, поэтому вам может быть интересно, как выглядит публикация более сложных типов. Общее правило заключается в том, что аргументы конструктора располагаются в том же порядке, что и в файле .msg. Вы также можете не вводить никаких аргументов и инициализировать поля напрямую, например:<br>
<b>msg = String()<br>
msg.data = str</b><br>
или же вы можете инициализировать некоторые поля, а для остальных оставить значения по умолчанию:<br>
<b>String(data=str)</b>
<li><p><img src="./images/try_pass.png"><br>
В дополнение к стандартной проверке Python __main__check, при этом обнаруживается ошибка rospy.Исключение ROSInterruptException, которое может быть вызвано методами rospy.sleep() и rospy.Rate.sleep() при нажатии Ctrl-C или при выключении вашего узла иным образом. Причина, по которой возникает это исключение, заключается в том, что вы случайно не продолжаете выполнение кода после sleep().
</ul>

<li> В CMakeLists.txt добавить строки:
<p><pre>
catkin_install_python(PROGRAMS scripts/talker.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
</pre>
</ol>
<h3>Написание ноды subscriber:</h3>
<ul>
<li>
<ul>
<li> roscd beginner_tutorials/scripts/
<li> wget https://raw.github.com/ros/ros_tutorials/kinetic-devel/rospy_tutorials/001_talker_listener/listener.py
<li> chmod +x listener.py
</ul>
<img src="./images/ros_listener.png">
<li><p>
Код:
<br><img src="./images/code_listener.png">
<li><p>
В CMakeLists.txt добавляем строки:
<p>
<pre>
catkin_install_python(PROGRAMS scripts/talker.py scripts/listener.py
  DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION}
)
</pre>
<li><p><img src="./images/rospy_init.png"><br>
Это означает, что ваш узел подписан на тему chatter, которая имеет тип std_msgs.msgs.Строка. При получении новых сообщений вызывается обратный вызов с этим сообщением в качестве первого аргумента.
<p>
Мы также немного изменили вызов rospy.init_node(). Мы добавили аргумент ключевого слова anonymous=True. ROS требует, чтобы у каждого узла было уникальное имя. Если появляется узел с таким же именем, он повторяет предыдущий. Это значит, что неисправные узлы могут легко быть выкинут из сети. Анонимные=флаг True рассказывает rospy чтобы создать уникальное имя для узла, так что вы можете иметь несколько узлов listener.py легко работать.
<p>
Последнее дополнение: функция rospy.spin() просто не позволяет вашему узлу завершать работу до тех пор, пока он не будет выключен. В отличие от roscpp, функция rospy.spin() не влияет на функции обратного вызова абонента, поскольку у них есть свои собственные потоки.
<li>Мы используем CMake в качестве нашей системы сборки, и, да, вы должны использовать ее даже для узлов Python. Это необходимо для того, чтобы убедиться, что автоматически сгенерированный код Python для сообщений и служб создан.
<br>Перейдите в свое рабочее пространство catkin и запустите catkin_make:<br>
<b>cd ~/catkin_ws<br>
catkin_make</b>
</ul>


<h2 align=center><a href="https://wiki.ros.org/ROS/Tutorials/ExaminingPublisherSubscriber">Выполнение publisher</a></h2>
Первой командой вызовем мастера:<br>
<b>roscore</b><br>
Еесли вы используете catkin, убедитесь, что у вас есть исходный код для вашего рабочего пространства setup.sh файл после вызова catkin_make, но перед выполнением нашего публишера:<br>
<b>cd ~/catkin_ws<br>
source ./devel/setup.bash</b><br>
Выполним нашего созданного публишера на python:<br>
<b>rosrun beginner_tutorials talker.py</b><br>
или <b>rosrun beginner_tutorials talker</b> (C++)<br>
Работает:<br>
<img src="./images/hello_world.png">
<h3 align=center><a href="https://wiki.ros.org/ROS/Tutorials/ExaminingPublisherSubscriber">Теперь выполнение подписчика listener.py</a></h3>
<b>rosrun beginner_tutorials listener.py</b> или <b>rosrun beginner_tutorials listener</b> на языке C++<br>
Работает.


<h2 align=center>Recording data (creating a bag file) Запись данных (создание bag файла)</h2>
В этом разделе руководства вы узнаете, как записывать данные по топикам из запущенной системы ROS. Данные по топикам будут накапливаться в файле bag.
<p>
Сначала выполните следующие команды в отдельных терминалах:
<br>
<b>roscore</b> - первый терминал<br>
2 терминал - <b>rosrun turtlesim turtlesim_node</b><br>
3 терминал - <b>rosrun turtlesim turtle_teleop_key</b>
<p>
Это запустит два узла - визуализатор turtlesim и узел turtle_teleop_key, который позволяет управлять turtlesim с клавиатуры с помощью клавиш со стрелками на клавиатуре.
<p>
<b>rostopic list -v</b> - в 4 терминале, выведем список запущенных в данный момент топиков.<br>
<img src="./images/rostopic_list_v.png"><br>
Список published (публикуемых) топиков - это единственные типы сообщений, которые потенциально могут быть занесены в файл журнала данных, поскольку в журнал записываются только публикуемые сообщения. Топик /turtle 1/cmd_vel - это командное сообщение, опубликованное teleop_turtle, которое принимается в качестве входных данных программой turtlesim. Сообщения /turtle1/color_sensor и /turtle1/pose являются выходными сообщениями, опубликованными turtlesim.
<p>
Теперь мы запишем публикуемые данные. Откройте новое окно терминала. В этом окне выполните следующие команды:<br>
<b>mkdir ~/bagfiles<br>
cd ~/bagfiles<br>
rosbag record -a</b><br>
<img src="./images/rosbag.png"><br>
Создаем временный каталог для записи данных, а затем запускаем rosbag record с параметром -a, указывающим, что все публикуемые топики должны быть собраны в файле bag.
<p>
Примерно 10 секунд двигаем черепаху.<br>
В окне, где запустили rosbag нажать Ctrl-C. Теперь изучите содержимое каталога ~/bagfiles. Должны увидеть файл с именем, которое начинается с года, даты и времени и суффикса .bag. Это файл пакета, содержащий все топики, опубликованные любым узлом за время работы rosbag record.<br>
еперь, когда мы записали файл bag с помощью rosbag record, мы можем просмотреть его и воспроизвести с помощью команд rosbag info и rosbag play. Сначала мы посмотрим, что записано в файле bag. Мы можем выполнить команду info - эта команда проверяет содержимое файла bag без его воспроизведения. Выполните следующую команду из каталога файлов bag:<br>
<font color=green>rosbag info &lt;your bagfile&gt;</font>
<p>
<img src="./images/rosbag_info.png">
<p>
Следующим шагом в этом руководстве будет воспроизведение файла bag, чтобы воспроизвести поведение в запущенной системе. Сначала завершите работу программы teleop, которая, возможно, все еще запущена из предыдущего раздела - нажмите Ctrl-C в терминале, где вы запустили turtle_teleop_key. Оставьте turtlesim запущенным. В окне терминала запустите следующую команду в каталоге, из которого смотрели инфо о бэгфайле:<br>
<font color=green>rosbag play &lt;your bagfile&gt;</font>
<p>
<img src="./images/rosbag_play.png">
<p>
В режиме по умолчанию rosbag play будет ждать в течение определенного периода времени (0,2 секунды) после объявления каждого сообщения, прежде чем начнет публиковать содержимое файла пакета. Некоторое время ожидания позволяет любому подписчику сообщения получать уведомления о том, что сообщение было объявлено и что за ним могут последовать другие сообщения. Если rosbag play публикует сообщения сразу после публикации рекламы, подписчики могут не получить первые несколько опубликованных сообщений. Период ожидания можно указать с помощью параметра -d.
<p>
В конечном итоге тема /turtle 1/cmd_vel будет опубликована, и черепаха должна начать перемещаться в turtlesim по схеме, аналогичной той, которую вы выполнили из программы teleop. Время между запуском rosbag play и перемещением черепашки должно быть примерно равно времени между запуском оригинальной записи rosbag и вводом команд с клавиатуры в начальной части руководства. Вы можете сделать так, чтобы воспроизведение rosbag не начиналось с начала файла bag, а начиналось на некоторое время позже начала, используя аргумент -s. Последним параметром, который может представлять интерес, является параметр -r, который позволяет вам изменять скорость публикации на определенный коэффициент. Если вы выполните:<br>
<b>rosbag play -r 2 &lt;your bagfile&gt;</b><br>
вы должны увидеть, как черепаха совершает несколько иную траекторию - это траектория, которая получилась бы, если бы вы вводили команды с клавиатуры в два раза быстрее.

<h3 align=center>Запись подмножества данных</h3>
При запуске сложной системы, такой как программный комплекс pr2, могут публиковаться сотни разделов, а в некоторых разделах, таких как потоки изображений с камер, потенциально публикуются огромные объемы данных. В такой системе часто нецелесообразно записывать лог-файлы, содержащие все темы, на диск в виде одного файла bag. Команда rosbag record поддерживает запись только определенных тем в файл bag, позволяя пользователям записывать только те темы, которые их интересуют.
<p>
Если какие-либо узлы turtlesim запущены, закройте их и перезапустите файл запуска keyboard teleop:<br>
<b>rosrun turtlesim turtlesim_node<br>
rosrun turtlesim turtle_teleop_key</b><br>
В вашем каталоге bagfiles выполните следующую команду:<br>
<b>rosbag record -O subset /turtle1/cmd_vel /turtle1/pose</b>
<p>
<img src="./images/rosbag_subset.png">
<p>
Аргумент -O указывает rosbag record на доступ к файлу с именем subset.bag, а аргументы topic указывают на то, что rosbag record подписывается только на эти две темы. Перемещайте черепашку в течение нескольких секунд, используя команды со стрелками на клавиатуре, а затем нажмите Ctrl-C на записи rosbag.<p>
Теперь проверьте содержимое файла bag (rosbag info subset.bag). Вы должны увидеть что-то вроде этого, только с указанными темами: <b>rosbag info subset.bag</b>
<p>
<img src="./images/rosbag_info_subnet.png">


<h2 align=center>Чтение сообщений из bag файла</h2>
Ссылки: <a href="https://habr.com/ru/articles/393811/">ROS на Raspberry Pi: Использование rosbag для сохранения данных топиков</a><br>
<a href="https://wiki.ros.org/ROS/Tutorials/reading%20msgs%20from%20a%20bag%20file">Reading messages from a bag file</a>
<p>
Предполагая, что вы используете систему с уже запущенным ROS, вот быстрая команда для записи 30-секундного фрагмента данных в файл пакета только для интересующих вас тем, например: /topic1, /topic2 и /topic3. Поскольку мы устанавливаем продолжительность в 30 секунд, по истечении этого времени запись автоматически остановится:<br>
<b>rosbag record --duration=30 --output-name=/tmp/mybagfile.bag \<br>
    /topic1 /topic2 /topic3</b><br>
<p>
Остальная часть этого руководства будет выполнена при условии, что скачали с помощью команды:<br>
<b>wget https://open-source-webviz-ui.s3.amazonaws.com/demo.bag</b><br>
<font color=red>У меня не удаётся скачать, выдаёт ошибку 403</font>
<p>
 У вас будет два варианта чтения/извлечения сообщений из файла bag.
<p>
<i>Обратите внимание, что в любой из приведенных ниже команд команда time добавляется перед началом просто потому, что она выводит время выполнения каждой команды, а поскольку иногда эти команды могут занимать много времени, полезно использовать команду time, чтобы получить представление о том, сколько времени должна занять данная команда. Если вы не хотите его использовать, вы можете удалить временную часть любой из приведенных ниже команд.</i>
<h3>Вариант 1: немедленно воспроизвести сообщения и просмотреть выходные данные на нескольких терминалах.</h3>
Вам нужно знать точные названия тем, которые вы хотели бы прочитать в файле bag. Итак, давайте посмотрим, что находится в файле bag. В любом терминале вручную проверьте все опубликованные темы и количество сообщений, опубликованных в каждой теме, с помощью этой команды:<br>
<b>time rosbag info /tmp/mybagfile.bag</b><br>  
или если знаете имена нужных топиков:<br>
<b>time rosbag info /tmp/mybagfile.bag | grep -E "(topic1|topic2|topic3)"</b>
<p>
<img src="./images/rosbag_record.png">

<h3 align=center>Вариант 2: используем скрипт ros_readbagfile, чтобы извлечь интересующие темы</h3>
<b>Установка команды ros_readbagfile:</b>
<ul>
<li> Скачал <b>wget https://raw.githubusercontent.com/ElectricRCAircraftGuy/eRCaGuy_dotfiles/master/useful_scripts/ros_readbagfile.py</b>
<li> Выполнил: <b>chmod +x ros_readbagfile.py</b>
<li> Убедититься, что есть каталог ~/bin для личных двоичных файлов: <b>mkdir -p ~/bin</b>
<li> Переместить этот файл в ~/bin: <b>mv ros_readbagfile.py ~/bin/ros_readbagfile</b>
<li> Переустановите свой файл ~/.profile, чтобы убедиться, что ~/bin находится на вашем пути и вы можете использовать эту новую команду `ros_readbag file`, которую вы только что установили.<br>
Команда: <b>. ~/.profile</b><br>
Выполнил.
<li> Установка python-зависимостей:<br>
<b>sudo apt install python3-rosbag</b><br>
<b>ln -si "${PWD}/ros_readbagfile.py" ~/bin/gs_ros_readbagfile<br>
ln -si "${PWD}/ros_readbagfile.py" ~/bin/ros_readbagfile<br>
. ~/.profile</b><br>
Теперь можем выполнять команды: `gs_ros_readbagfile` или `ros_readbagfile`
<p>
Примечание: если ваш терминал по-прежнему сообщает, что не может найти команду при попытке ее запуска, возможно, вам потребуется убедиться, что ~/bin является частью вашей переменной PATH.
</ul>

<b>Работа с командой ros_readbagfile.py:</b><br>
Использовать команду буду на bag.файле /home/dmitriy/bagfiles/2024-07-21-19-21-13.bag
<ul>
<li> Определим точные имена тем, которые вы хотели бы прочитать в файле bag:<br>
<b>time rosbag info 2024-07-21-19-21-13.bag</b><br> 
<img src="./images/rosbag_info_file.png">
<li> Общий синтаксис команды readbagfile:<br>
<font color=green>time ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...]</font><br>
Выведу только 1 топик /turtle1/cmd_vel:<br>
<b>time ros_readbagfile 2024-07-21-19-21-13.bag /turtle1/cmd_vel</b><br>
<img src="./images/time_ros_readbagfile.png">
<li> Запишем сообщения 2024-07-21-19-21-13.bag /turtle1/cmd_vel в файл topics.yaml без вывода в терминал:<br>
 <b>time ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...] > topics.yaml</b><br>
 <img src="./images/ros_yml.png">
 <p>
 Если хотим одновременно записывать в файл и выводить на экран, то использовать команду такого формата:
 <p>
 <font color=green>time ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...] | tee topics.yaml</font>
 <p>
 <img src="./images/time_ros_readbagfile1.png">
<p>
При желании, чтобы увидеть "прогресс", наблюдая, как увеличивается размер файла yaml, в новом терминале запустить команду:<br>
<b>watch -n 1 'du -sk topics.yaml | awk '\''{printf "%.3f MiB %s\n", $1/1024, $2}'\'''</b>
<p>
Теперь просмотрите topics.yaml в вашем предпочтительном текстовом редакторе, чтобы просмотреть все сообщения, извлеченные из файла bag.
<h3 align=center>Анализ topics.yaml</h3>
Имеем файл topics.yaml, созданный на основе файла.bag. Теперь научимся извлекать из него нужную нам информацию.<br>
Для начала установим: <b>sudo apt update && sudo apt install ripgrep</b>
<p>
Допустим хотим найти список всех ключевых элементов, которые начинаются с "piksi_". Вы можете сделать это, выполнив поиск по строке "ключ: "piksi_" следующим образом:<br>
<b>time rg 'key: "piksi_' topics.yaml | sort -V | awk '!seen[$0]++'</b><br>
Часть rg 'key: "piksi_" topics.yaml выполняет поиск в текстовом файле "topics.yaml" строки : "piksi_",<br>
 часть sort -V сортирует все выходные строки,<br>
  а часть awk '!seen[$0]++" удаляет повторяющиеся записи, так что вы видите только одну строку каждого совпадения.
<p>
Другое применение:<br>
Давайте выполним поиск по всем ключевым элементам данных, которые начинаются с "GPS", "Duration" или "Minimum". Поиск по регулярным выражениям типа "OR" выполняется в общем формате: (str1|str2|str3|и т.д.), где | в данном случае читается как "or". Итак, поиск "GPS", "Duration" или "Minimum" может быть выполнен с помощью следующей строки поиска по регулярному выражению:<br>
'(key: "GPS|key: "Duration|key: "Minimum)'.<br>
Команда: <b>time rg '(key: "GPS|key: "Duration|key: "Minimum)' topics.yaml | sort -V | awk '!seen[$0]++'</b>
<p>
<h3 align=center>Зачем использовать для этой цели "ros_readbag file" вместо `rostopic echo -b`?</h3>
<ul>
<li> Потому что rostopic работает очень медленно! Например, выполнение этой команды на быстродействующем компьютере (4-ядерный/8-поточный Pentium i7 с SSD-накопителем m.2) занимает 11,5 минут для чтения файла bag объемом 18 ГБ!<br>
Однако скрипту ros_readbagfile требуется всего 1 минута 37 секунд на том же компьютере, чтобы прочитать ту же тему из того же файла bag объемом 18 ГБ! Таким образом, ros_readbagfile работает в 11,5/(1+37/60) = ~в 7 раз быстрее!
<li> Потому что rostopic может одновременно читать только одну тему, в то время как ros_readbagfile может читать любое количество тем одновременно!
</ul>


<br><br><br><br><br><br></body></html>
