<html><head>
<style>
.menu {
       height: 100%;
       width: 140px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 10px;
           margin-left: 140px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Массивы в языке Cи++</title>
<div class="menu">
<a href="./index.html">Главная</a>
<a href="./c++_example.html">Решения</a>
---------------------
<a href="#massiv_parametr">Массивы в параметрах функции</a>
<a href="#massiv_const">&nbsp;&nbsp; Константные массивы, как параметр функции</a>
<a href="#link_parametr">&nbsp;&nbsp; Массив по ссылке, как параметр функции</a>
<a href="#more_massiv">&nbsp;&nbsp; Многомерный массив как параметр функции</a>
<a href="#pointer">Указатели</a>
<a href="#operator_pointer">&nbsp;&nbsp; Операции с указателями</a>
<a href="#assign">&nbsp;&nbsp; Приведение типов</a>
<a href="#arifm_pointer">&nbsp;&nbsp;  Арифметика указателей</a>
<a href="#const_pointer">&nbsp;&nbsp;  Константы и указатели</a>
<a href="#array_pointer">&nbsp;&nbsp;  Указатели и массивы</a>
</div>

<div class="content">
<a name="massiv_parametr"><h3 align=center>Массивы в параметрах функции</h3>
Ссылка: <a href="https://metanit.com/cpp/tutorial/4.7.php">Массивы в параметрах функции</a>
<p>
Если функция принимает в качестве параметра массив, то фактически в эту функцию передается указатель на первый элемент массива. То есть как и в случае с указателями нам доступен адрес, по которому мы можем менять значения. Поэтому следующие объявления функции будут по сути равноценны:
<pre>
void print(int numbers[]);
void print(int *numbers);
</pre>
Передадим в функцию массив:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
 
void print(int[]);
 
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    print(nums);
}
 
void print(int numbers[])
{
    std::cout << "First number: " << numbers[0] << std::endl; // First number: 1
}
</pre></td></tr></table>
<p>
В данном случае функция print выводит на консоль первый элемент массива.
<p>
Теперь определим параметр как указатель:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
 
void print(int*);
 
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    print(nums);
}
 
void print(int *numbers)
{
    std::cout << "First number: " << *numbers << std::endl;
}
</pre></td></tr></table>
Здесь также в функцию передается массив, однако параметр представляет указатель на первый элемент массива.
<p>
<b>Ограничения</b><br>
Поскольку параметр, определенный как массив, рассматривается именно как указатель на первый элемент, то мы не сможем корректно получить длину массива, например, следующим образом:
<pre>
void print(int numbers[])
{
    int size = sizeof(numbers) / sizeof(numbers[0]);
    // или так 
    // size_t size = std::size(nums);
    std::cout << size << std::endl;
}
</pre>
И также мы не сможем использовать цикл for для перебора этого массива:
<pre>
void print(int numbers[])
{
    for (int n : numbers)
        std::cout << n << std::endl;
}
</pre>
<pre>

</pre>
<h4 align=center>Передача маркера конца массива</h4>
Чтобы должным образом определять конец массив, перебирать элементы массива, обращаться к этим элементам, необходимо использовать специальный маркер, который бы сигнализировал об окончании массива. Для этого могут использоваться разные подходы.
<p>
Первый подход заключается в том, чтобы один из элементов массива сам сигнализировал о его окончании. В частности, массив символов может представлять строку - набор символов, который завершается нулевым символом '\0'. Фактически нулевой символ служит признком окончания символьного массива:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
 
void print(char[]);
 
int main()
{
    char chars[] {"Hello"};
    print(chars);
}
 
void print(char chars[])
{
    for (unsigned i{}; chars[i] != '\0'; i++)
    {
        std::cout << chars[i];
    }
}
</pre></td></tr></table>
<p>
Однако при таком подходе мы должны быть уверены, что массив содержит такой подобный признак завершения. И если бы в данном случае нулевого байта не оказалось бы в строке, то это привело бы к неприятным последствиям. Поэтому обычно применяется другой подход, который заключается в передаче в функцию размера массива:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
  
void print(int[], size_t);
  
int main()
{
    int nums[]{1, 2, 3, 4, 5};
    size_t n {std::size(nums)};
    print(nums, n);
}
  
void print(int numbers[], size_t n)
{
    for(size_t i {}; i < n; i++)
    {
        std::cout << numbers[i] << "\t";
    }
}
</pre></td></tr></table>
Третий подход заключается в передаче указателя на конец массива. Можно вручную вычислять указатель на конец массива. А можно использовать встроенные библиотечные функции std::begin() и std::end():
<pre>
int nums[] { 1, 2, 3, 4, 5 };
int *begin {std::begin(nums)};      // указатель на начало массива
int *end {std::end(nums)};      // указатель на конец массива
</pre>
Причем end возвращает указатель не на последний элемент, а адрес за последним элементом в массиве.
<p>
Применим данные функции:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
 
void print(int*, int*);
 
int main()
{
    int nums[] { 1, 2, 3, 4, 5 };
    int *begin {std::begin(nums)};
    int *end {std::end(nums)};
 
    print(begin, end);
}
 
void print(int *begin, int *end)
{
    for (int *ptr {begin}; ptr != end; ptr++)
    {
        std::cout << *ptr << "\t";
    }
}
</pre></td></tr></table>
<pre>


</pre>
<a name="massiv_const"><h3 align=center>Константные массивы, как параметр функции</h3>
Поскольку при передаче массива передается фактически указатель на первый элемент, то используя этот указатель, мы можем изменить элемены массива. Если нет необходимости в изменении массива, то лучше параметр-массив определять как константный:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
  
void print(const int*, const size_t);
void twice(int*, const size_t);
  
int main()
{
    int numbers[]{1, 2, 3, 4, 5};
    size_t n = std::size(numbers);
    print(numbers, n);
    twice(numbers, n); // увеличиваем элементы массива в два раза
    print(numbers, n);
}
  
void print(const int numbers[], const size_t n)
{
    for(size_t i {}; i < n; i++)
    {
        std::cout << numbers[i] << "\t";
    }
    std::cout << std::endl;
}
void twice(int *numbers, const size_t n)
{
    for(size_t i {}; i < n; i++)
    {
        numbers[i] = numbers[i] * 2;
    }
}
</pre></td></tr></table>
<p>
В данном случае функция print просто выводит значения из массива, поэтому параметры этой функции помечаются как константные.
<p>
Функция twice изменяет элементы массива - увеличивает их в два раза, поэтому в этой функции параметр-массив является неконстантным. Причем поле выполнения функции twice массив numbers будет изменен.
<p>
Консольный вывод программы:
<pre>
1	2	3	4	5
2	4	6	8	10
</pre>
<pre>


</pre>
<a name="link_parametr"><h3 align=center>Передача массива по ссылке</h3>
Ссылка на источник: <a href="https://metanit.com/cpp/tutorial/4.7.php">Передача массив по ссылке</a>
Один из сценариев передачи массива в функцию представляет передача массива по ссылке. Прототип функции, которая принимает массив по ссылке, выглядит следующим образом:
<pre>
void print(int (&)[]);
</pre>
Обратите внимание на скобки в записи (&). Они указывают именно на то, что массив передается по ссылке. Пример использования:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
  
void print(int (&)[], size_t);
 
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    size_t count = std::size(nums);
    print(nums, count);
}
void print(int (&numbers)[], size_t count)
{
    for(size_t i{}; i < count; i++)
    {
        std::cout << numbers[i] << "\t";
    }
}
</pre></td></tr></table>
<p>
Подобным образом можпо передавать <b>константные ссылки на массивы</b>:
<pre>
void print(const int (&)[]);
</pre>
С одной стороны, может показаться, что в передаче массива по ссылке нет большого смысла, поскольку при передачи массива по значению итак просто передается адрес этого массива. Но с другой стороны, передача массива по ссылке имеет некоторые преимущества. Во-первых, не копируется значение - адрес массива, мы напрямую работаем с оригинальным массивом. Во-вторых, передача массива по ссылке позволяет ограничить размер такого массива, соотвественно при компиляции компилятор уже будет знать, сколько элементов будет иметь массив.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
#include &lt;iostream>
  
void print(const int (&)[5]); // массив строго с 5 элементами
 
int main()
{
    int nums1[] {1, 2, 3, 4, 5};
    print(nums1);
}
void print(const int (&numbers)[5])
{
    for(unsigned i{}; i < 5; i++)
    {
        std::cout << numbers[i] << "\t";
    }
}
</pre></td></tr></table>
<p>
Здесь функция print принимает ссылку строго на массив с 5 элементами. И поскольку мы знаем точный размер массива, то нам нет необходимости передавать в функцию дополнительно размер массива.
<p>
Если же мы попробуем передать в функцию массив с другим количеством элементов, то на этапе компиляции получим ошибку.
<pre>


</pre>
<a name="more_massiv"><h3 align=center>Передача многомерного массива</h3>
Многомерный массив также передается как указатель на его первый элемент. В то же время поскольку элементами многомерного массива являются другие массивы, то указатель на первый элемент многомерного массива фактически будет представлять указатель на массив.
<p>
Когда определяется параметр как указатель на массив, размер второй размерности (а также всех последующих размерностей) должен быть определен, так как данный размер является частью типа элемента. Пример объявления:
<pre>
void print(int (*numbers)[3]);
</pre>
Здесь предполагается, что передаваемый массив будет двухмерным, и все его подмассивы будут иметь по 3 элемента. Стоит обратить внимание на скобки вокруг имени параметра, которые и позволяют определить параметр как указатель на массив. И от этой ситуации стоит отличать следующую:
<pre>
void print(int *numbers[3])
</pre>
В данном случае параметр определен как массив указателей, а не как указатель на массив.
<p>
Рассмотрим применение указателя на массив в качестве параметра:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>  
void print(const int(*)[3], const size_t);
int main()
{
    int table[][3] { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
    // количество строк или подмассивов
    size_t rowsCount {std::size(table)};
    print(table, rowsCount);
}
  
void print(const int (*rows)[3], const size_t rowsCount)
{
    // количество столбцов или элементов в каждом подмассиве
    size_t columnsCount {std::size(*rows)};
    for(size_t i{}; i < rowsCount; i++)
    {
        for (size_t j{}; j < columnsCount; j++)
        {
            std::cout << rows[i][j] << "\t";
        }
        std::cout << std::endl;
    }
}
</pre></td></tr></table>
<p>
В функции main определяется двухмерный массив - он состоит из трех подмассивов. Каждый подмассив имеет по три элемента.
<p>
В функцию print вместе с массивом передается и число строк - по сути число подмассивов. В самой функции print получаем количество элементов в каждом подмассиве и с помощью двух циклов перебираем все элементы. С помощью выражения rows[0] можно обратиться к первому подмассиву в двухмерном массиве, а с помощью выражения rows[0][0] - к первому элементу первого подмассива. И таким образом, манипулируя индексами можно перебрать весь двухмерный массив.
<p>
В итоге мы получим следующий консольный вывод:
<pre>
1	2	3
4	5	6
7	8	9
</pre>
Также мы могли бы использовать нотацию массивов при объявлении и определении функции print, которая может показаться проще, нежели нотация указателей. Но в этом случае опять же надо было бы указать явным образом вторую размерность:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>  
void print(const int[][3], const size_t);
int main()
{
    int table[][3] { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} };
    // количество строк или подмассивов
    size_t rowsCount {std::size(table)};
    print(table, rowsCount);
}
  
void print(const int rows[][3], const size_t rowsCount)
{
    // количество столбцов или элементов в каждом подмассиве
    size_t columnsCount {std::size(rows[0])};
    for( size_t i{}; i < rowsCount; i++)
    {
        for (size_t j{}; j < columnsCount; j++)
        {
            std::cout << rows[i][j] << "\t";
        }
        std::cout << std::endl;
    }
}
</pre></td></tr></table>
<pre>


================================================================================================================

</pre>
<a name="pointer"><h3 align=center>Указатели</h3>
Ссылки: <a href="https://metanit.com/cpp/tutorial/4.1.php">Указатели</a>
<p>
Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций. Как и ссылки, указатели применяются для косвенного доступа к объекту. Однако в отличие от ссылок указатели обладают большими возможностями.
<h4>Определение указателя</h4>
Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки *:
<pre>
тип_данных* название_указателя;
</pre>
Сначала идет тип данных, на который указывает указатель, и символ звездочки *. Затем имя указателя.
<p>
Например, определим указатель на объект типа int:
<pre>
int* p;
</pre>
Такой указатель может хранить только адрес переменной типа int, но пока данный указатель не ссылается ни на какой объект и хранит случайное значение. Мы его даже можем попробовать вывести на консоль:
<pre>
#include &lt;iostream>
 
int main()
{
    int* p;
    std::cout << p << std::endl;
}
</pre>
Например, в моем случае консоль вывела "0x8" - некоторый адрес в шестнадцатеричном формате (обычно для представления адресов в памяти применяется шестнадцатеричная форма). Но также можно инициализировать указатель некоторым значением:
<pre>
int* p{};
</pre>
Поскольку конкрентное значение не указано, указатель в качестве значения получает число 0. Это значение представляет специальный адрес, который не указывает не на что. Также можно явным образом инициализировать нулем, например, используя <b>специальную константу nullptr</b>:
<pre>
int* p{nullptr};
</pre>
Хотя никто не запрещает не инициализировать указатели. Однако в общем случае рекомендуется все таки инициализировать, либо каким-то конкретным значением, либо нулем, как выше. Так, к примеру, нулевое значение в будущем позволит определить, что указатель не указывает ни на какой объект.
<p>
Cтоит отметить что положение звездочки не влияет на определение указателя: ее можно помещать ближе к типу данных, либо к имени переменной - оба определения будут равноценны:
<pre>
int* p1{};
int *p2{};
</pre>
Также стоит отметить, что размер значения указателя (хранимый адрес) не зависит от типа указателя. Он зависит от конкретной платформы. На 32-разрядных платформах размер адресов равен 4 байтам, а на 64-разрядных - 8 байтам. Например:
<pre>
#include &lt;iostream>
 
int main()
{
    int *pint{};
    double *pdouble{};
    std::cout << "*pint size: " << <b>sizeof(pint)</b> << std::endl;
    std::cout << "*pdouble size: " << <b>sizeof(pdouble)</b> << std::endl;
}
</pre>
В данном случае определены два указателя на разные типы - int и double. Переменные этих типов имеют разные размеры - 4 и 8 байт соответственно. Но размеры значений указателей будут одинаковы. В моем случае на 64-разрядной платформе размер обоих указателей равен 8 байтам.
<h4>Получение адреса и оператор &</h4>
С помощью <b>операция &</b> можно получить адрес некоторого объекта, например, адрес переменной. Затем этот адрес можно присвоить указателю:
<pre>
int number {25};
int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
</pre>
Выражение <b>&</b>number возвращает адрес переменной number. Поэтому переменная pnumber будет хранить адрес переменной number. Что важно, переменная number имеет тип int, и указатель, который указывает на ее адрес, тоже имеет тип int. То есть должно быть соответствие по типу. Однако также можно использовать ключевое слово auto:
<pre>
int number {25};
<b>auto</b> *pnumber {<b>&</b>number}; // указатель pnumber хранит адрес переменной number
</pre>
Если мы попробуем вывести адрес переменной на консоль, то увидим, что он представляет шестнадцатиричное значение:
<pre>
#include &lt;iostream>
 
int main()
{
    int number {25};
    int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
    std::cout << "number addr: " << pnumber << std::endl;
}
</pre>
Консольный вывод программы в моем случае:<br>
number addr: 0x1543bffc74
<p>
В каждом отдельном случае адрес может отличаться и при разных запусках программы может меняться. К примеру, в моем случае машинный адрес переменной number - 0x1543bffc74. То есть в памяти компьютера есть адрес 0x1543bffc74, по которому располагается переменная number. Так как переменная x представляет тип int, то на большинстве архитектур она будет занимать следующие 4 байта (на конкретных архитектурах размер памяти для типа int может отличаться). Таким образом, переменная типа int последовательно займет ячейки памяти с адресами 0x1543bffc74, 0x1543bffc75, 0x1543bffc76, 0x1543bffc77.
<p>
И указатель pnumber будет ссылаться на адрес, по которому располагается переменная number, то есть на адрес 0x1543bffc74.
<p>
Итак, указатель pnumber хранит адрес переменной number, а где хранится сам указатель pnumber? Чтобы узнать это, мы также можем применить к переменной pnumber операцию &:
<pre>
#include &lt;iostream>
 
int main()
{
    int number {25};
    int *pnumber {&number}; // указатель pnumber хранит адрес переменной number
    std::cout << "number addr: " << pnumber << std::endl;
    std::cout << "pnumber addr: " << &pnumber << std::endl;
}
</pre>
Консольный вывод программы в моем случае:
<pre>
number addr: 0xe1f99ff7cc
pnumber addr: 0xe1f99ff7c0
</pre>
Здесь мы видим, что переменная number располагается по адресу 0xe1f99ff7cc, а указатель, который хранит этот адрес, - по адресу 0xe1f99ff7c0. Из вывода видно, что обе переменные хранятся совсем рядом в памяти
<h4>Получение значения по адресу</h4>
Но так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной number. Для этого применяется <b>операция * или операция разыменования</b> ("indirection operator" / "dereference operator"). Результатом этой операции всегда является объект, на который указывает указатель. Применим данную операцию и получим значение переменной number:
<pre>
#include &lt;iostream>
 
int main()
{
    int number {25};
    int *pnumber {&number};
    std::cout << "Address = " << pnumber<< std::endl;
    std::cout << "Value = " << *pnumber << std::endl;
}
</pre>
Пример консольного вывода:
<pre>
Address = 0x44305ffd4c
Value = 25
</pre>
<pre>

</pre>
<a name="operator_pointer"><h3 align=center>Операции с указателями</h3>
Ссылки: <a href="https://metanit.com/cpp/tutorial/4.2.php">Операции с указателями</a>
<p>
Указатели поддерживают ряд операций: присваивание, получение адреса указателя, получение значения по указателю, некоторые арифметические операции и операции сравнения.
<p>
<b>Значение, которое получено в результате операции разыменования, можно присвоить другой переменной</b>:
<pre>
int n1 {25};
int *pn1 {&n1}; // указатель pn1 хранит адрес переменной n1
<b>int n2 { *pn1};</b> // n2 получает значение, которое хранится по адресу в pn1
std::cout << "n2 = " << n2 << std::endl;  // n2=25
</pre>
И также <b>используя указатель, мы можем менять значение по адресу, который хранится в указателе</b>:
<pre>
int x = 10;
int *px = &x;
<b>*px = 45;</b>
std::cout << "x = " << x << std::endl;     // 45
</pre>
Так как по адресу, на который указывает указатель, располагается переменная x, то соответственно ее значение изменится.
<h4>Присвоение указателю другого указателя</h4>
Присвоение указателю другого указателя:
<pre>
#include &lt;iostream>
 
int main()
{
    int a {10};
    int b {2};
       
    int *pa {&a};   // указатель на переменную a
    int *pb {&b};   // указатель на переменную b
       
    std::cout << "pa: address=" << pa << "\t value=" << *pa << std::endl;
    std::cout << "pb: address=" << pb << "\t value=" << *pb << std::endl;
       
    pa = pb;    // теперь указатель pa хранит адрес переменной b
    std::cout << "pa: address=" << pa << "\t value=" << *pa << std::endl;
    *pa = 125;  // меняем значение по адресу в указателе pa
    std::cout << "b value=" << b << std::endl;
}
</pre>
Когда указателю присваивается другой указатель, то фактически первый указатель начинает также указывать на тот же адрес, на который указывает второй указатель:
<pre>
pa: address=0x56347ffc5c         value=10
pb: address=0x56347ffc58         value=2
pa: address=0x56347ffc58         value=2
b value=125
</pre>
<h4>Нулевые указатели</h4>
<b>Нулевой указатель</b> (null pointer) - это указатель, который не указывает ни на какой объект. Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить ему условное нулевое значение. Для определения нулевого указателя можно инициализировать указатель нулем или константой nullptr:
<pre>
int *p1{nullptr};
int *p2{};
</pre>
<h4>Ссылки на указатели</h4>
Так как ссылка не является объектом, то нельзя определить указатель на ссылку, однако можно определить ссылку на указатель. Через подобную ссылку можно изменять значение, на которое указывает указатель или изменять адрес самого указателя:
<pre>
#include &lt;iostream>
 
int main()
{
    int a {10};
    int b {6};
     
    int *p{};           // указатель
    <b>int *&pRef {p};</b>     // ссылка на указатель
    pRef = &a;          // через ссылку указателю p присваивается адрес переменной a
    std::cout << "p value=" << *p << std::endl;   // 10
    *pRef = 70;         // изменяем значение по адресу, на который указывает указатель
    std::cout << "a value=" << a << std::endl;    // 70
     
    pRef = &b;          // изменяем адрес, на который указывает указатель
    std::cout << "p value=" << *p << std::endl;   // 6
}
</pre>
<h4>Адрес указателя</h4>
Указатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме того, указатель, как и любая переменная, сам имеет адрес, по которому он располагается в памяти. Этот адрес можно получить также через операцию &:
<pre>
int a {10};
int *pa {&a};
std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a
</pre>
<h4>Операции сравнения</h4>
К указателям могут применяться операции сравнения >, >=, <, <=,==, !=. Операции сравнения применяются только к указателям одного типа. Для сравнения используются номера адресов:
<pre>
#include &lt;iostream>
 
int main()
{
    int a {10};
    int b {20};
    int *pa {&a};
    int *pb {&b};
     
    if(pa > pb)
        std::cout << "pa (" << pa << ") is greater than pb ("<< pb << ")" << std::endl;
    else
        std::cout << "pa (" << pa << ") is less or equal pb ("<< pb << ")" << std::endl;
}
</pre>
Консольный вывод в моем случае:<br>
pa (0xa9da5ffdac) is greater than pb (0xa9da5ffda8)
<a name="assign"><h3 align=center>Приведение типов</h3>
Иногда требуется присвоить указателю одного типа значение указателя другого типа. В этом случае следует выполнить операцию приведения типов с помощью операции (тип_указателя *):
<pre>
#include &lt;iostream>
 
int main()
{
    char c {'N'};
    char *pc {&c};            // указатель на символ
    <b>int *pd {(int *)pc};</b>      // указатель на int
    <b>void *pv {(void*)pc};</b>     // указатель на void
    std::cout << "pv=" << pv << std::endl;
    std::cout << "pd=" << pd << std::endl;
}
</pre>
Для преобразования указателя к другому типу в скобках перед указателем ставится тип, к которому надо преобразовать. Причем если мы не можем просто создать объект, например, переменную типа void, то для указателя это вполне будет работать. То есть можно создать указатель типа void.
<p>
Кроме того, следует отметить, что указатель на тип char (char *pc {&c}) при выводе на консоль система интерпретирует как строку:<br>
std::cout << "pc=" << pc << std::endl;
<p>
Поэтому если мы все-таки хотим вывести на консоль адрес, который хранится в указателе типа char, то это указатель надо преобразовать к другому типу, например, к void* или к int*.
<pre>



</pre>
<a name="arifm_pointer"><h3 align=center>Арифметика указателей</h3>
Ссылки: <a href="https://metanit.com/cpp/tutorial/4.3.php">Арифметика указателей</a>
Указатели могут участвовать в арифметических операциях (сложение, вычитание, инкремент, декремент). Однако сами операции производятся немного иначе, чем с числами. И многое здесь зависит от типа указателя.
<p>
К указателю можно прибавлять целое число, и также можно вычитать из указателя целое число. Кроме того, можно вычитать из одного указателя другой указатель.
<p>
Рассмотрим вначале операции инкремента и декремента и для этого возьмем указатель на объект типа int:
<pre>
#include &lt;iostream>
  
int main()
{
    int n{10};
    int *pn {&n};
    std::cout << "address=" << pn << "\tvalue=" << *pn << std::endl;
       
    pn++;
    std::cout << "address=" << pn << "\tvalue=" << *pn << std::endl;
       
    pn--;
    std::cout << "address=" << pn << "\tvalue=" << *pn << std::endl;
}
</pre>
Операция инкремента ++ увеличивает значение на единицу. В случае с указателем увеличение на единицу будет означать увеличение адреса, который хранится в указателе, на размер типа указателя. То есть в данном случае указатель на тип int, а размер объектов int в большинстве архитектур равен 4 байтам. Поэтому увеличение указателя типа int на единицу означает увеличение адреса в указателе на 4. Так, в моем случае консольный вывод выглядит следующим образом:
<pre>
address=0x81315ffd84    value=10
address=0x81315ffd88    value=828374408
address=0x81315ffd84    value=10
</pre>
Здесь видно, что после инкремента значение указателя увеличилось на 4: с 0x81315ffd84 до 0x81315ffd88. А после декремента, то есть уменьшения на единицу, указатель получил предыдущий адрес в памяти. Фактически увеличение на единицу означает, что мы хотим перейти к следующему объекту в памяти, который находится за текущим и на который указывает указатель. А уменьшение на единицу означает переход назад к предыдущему объекту в памяти.
<p>
После изменения адреса мы можем получить значение, которое находится по новому адресу, однако это значение может быть неопределенным, как показано в случае выше.
<p>
В случае с указателем типа int увеличение/уменьшение на единицу означает изменение адреса на 4. Аналогично, для указателя типа short эти операции изменяли бы адрес на 2, а для указателя типа char на 1, а для double на 8.
<p>
Аналогично указатель будет изменяться при прибавлении/вычитании не единицы, а какого-то другого числа.
<pre>
#include &lt;iostream>
  
int main()
{
    double d {10.6};
    double *pd {&d};
    std::cout << "Pointer pd: address:" << pd << std::endl;
    pd = pd + 2;   // увеличение адреса на 16 байт - 2 объекта double
    std::cout << "Pointer pd: address:" << pd << std::endl;
           
    short n {5};
    short *pn {&n};
    std::cout << "Pointer pn: address:" << pn << std::endl;
    pn = pn - 3;   // уменьшение адреса на 6 байт - размер 3 объектов short
    std::cout << "Pointer pn: address:" << pn << std::endl;
}
</pre>
Добавление к указателю типа double числа 2<br>
pd = pd + 2;<br>
означает, что мы хотим перейти на два объекта double вперед, что подразумевает изменение адреса на 2 * 8 = 16 байт.
<p>
Вычитание из указателя типа short числа 3<br>
pn = pn - 3;<br>
означает, что мы хотим перейти на три объекта short назад, что подразумевает изменение адреса на 3 * 2 = 6 байт.
<p>
И в моем случае я получу следующий консольный вывод:
<pre>
Pointer pd: address:0xb88d5ffbe8
Pointer pd: address:0xb88d5ffbf8

Pointer pn: address:0xb88d5ffbe6
Pointer pn: address:0xb88d5ffbe0
</pre>
В отличие от сложения операция вычитания может применяться не только к указателю и целому числу, но и к двум указателям одного типа:
<pre>
#include &lt;iostream>
  
int main()
{
    int a{10};
    int b{23};
    int *pa {&a};
    int *pb {&b};
    auto ab {pa - pb};
       
    std::cout << "pa: " << pa << std::endl;
    std::cout << "pb: " << pb << std::endl;
    std::cout << "ab: " << ab << std::endl;
}
</pre>
Согласно стандарту разность указателей представляет тип std::ptrdiff_t, который в реальности является псевдонимом для типов int, long и long long. Какой конкретно из этих типов применяется для хранения разности, зависит от конкретной платформы. Например, на Windows 64x это тип long long. Поэтому переменная ab, которая хранит разность адресов, определена с помощью оператора auto. Консольный вывод в моем случае:
<pre>
pa: 0x6258fffab4
pb: 0x6258fffab0
ab: 1
</pre>
Результатом разности двух указателей является "расстояние" между ними. Например, в случае выше адрес из первого указателя на 4 больше, чем адрес из второго указателя (0x6258fffab0 + 4 = 0x6258fffab4). Так как размер одного объекта int равен 4 байтам, то расстояние между указателями будет равно (0x6258fffab4 - 0x6258fffab0)/4 = 1.
<h4>Некоторые особенности операций</h4>
При работе с указателями надо отличать операции с самим указателем и операции со значением по адресу, на который указывает указатель.
<pre>
int a {10};
int *pa {&a};
int b {*pa + 20};   // операция со значением, на который указывает указатель
pa++;               // операция с самим указателем
     
std::cout << "b: " << b << std::endl;  ;  // 30
</pre>
То есть в данном случае через операцию разыменования *pa получаем значение, на которое указывает указатель pa, то есть число 10, и выполняем операцию сложения. То есть в данном случае обычная операция сложения между двумя числами, так как выражение *pa представляет число.
<p>
Но в то же время есть особенности, в частности, с операциями инкремента и декремента. Дело в том, что <b>операции *, и префиксные операции ++ и -- имеют одинаковый приоритет и при размещении рядом выполняются справа налево</b>.
<p>
Например, выполним префиксный инкремент:
<pre>
int a {10};
<b>int *pa {&a};</b>
std::cout << "pa: address=" << pa << "\tvalue=" << *pa << std::endl;
int b {++*pa};      // инкремент значения по адресу указателя
           
std::cout << "b: value=" << b << std::endl;
std::cout << "pa: address=" << pa << "\tvalue=" << *pa << std::endl;
</pre>
<b>В выражении b {++*pa}; сначала происходит разыменовывание указателю - мы получаем значение по адресу указателю, то есть число 10. Затем к этому числу прибавляется единица</b>. И в моем случае результат работы будет следующий:
<pre>
pa: address=0x7ff7b31bd8b8	value=10
b: value=11
pa: address=0x7ff7b31bd8b8	value=11
</pre>
Изменим выражение:
<pre>
int b{*++pa};      // инкремент адреса указателя с последующим разыменовыванием
</pre>
Теперь сначала к указателю прибавляется единица (то есть к адресу добавляется 4, так как указатель типа int), затем мы получаем по этому адресу значение и присваиваем его переменной b. Полученное значение в этом случае может быть неопределенным:
<pre>
pa: address=0x7ff7b13d78b8	value=10
b: value=0
pa: address=0x7ff7b13d78bc	value=0
</pre>
В отличие от префиксных инкремента и декремента <b>постфиксные версии операций имеют больший приоритет, нежели операция разыменования *</b>. Например, возьмем следующую программу:
<pre>
int a {10};
int *pa {&a};
std::cout << "pa: address=" << pa << "\tvalue=" << *pa << std::endl;
int b{<b>*pa++</b>};      // инкремент адреса указателя с последующим разыменовыванием
           
std::cout << "b: value=" << b << std::endl;
std::cout << "pa: address=" << pa << "\tvalue=" << *pa << std::endl;
</pre>
Поскольку постфиксный инкремент имеет больший приоритет, то в выражении *pa++ сначала увеличиваем адрес указателя pa на единицу (опять фактически на 4, так как указатель типа int) и затем получаем значение по адресу. Однако поскольку постфиксный инкремент возвращает значение до увеличения, то в переменную b мы получим значение, которое было по адресу до инкремента. Например, консольный вывод в моем случае:
<pre>
pa: address=0x7ff7b55288b8	value=10
b: value=10
pa: address=0x7ff7b55288bc	value=0
</pre>
Изменим выражение:
<pre>
b {(*pa)++};
</pre>
Скобки изменяют порядок операций. Здесь сначала выполняется операция разыменования и получение значения, затем это значение увеличивается на 1. Теперь по адресу в указателе находится число 11. И затем, так как инкремент постфиксный, переменная b получает значение, которое было до инкремента, то есть опять число 10. Таким образом, в отличие от предыдущего случая все операции производятся над значением по адресу, который хранит указатель, но не над самим указателем. И, следовательно, изменится результат работы:
<pre>
pa: address=0x7ff7b7b268b8	value=10
b: value=10
pa: address=0x7ff7b7b268b8	value=11
</pre>
<pre>


</pre>
<a name="const_pointer"><h3 align=center>Константы и указатели</h3>
Ссылки: <a href="https://metanit.com/cpp/tutorial/4.4.php">Константы и указатели</a>
<p>
Указатели могут указывать как на переменные, так и на константы. <b>Чтобы определить указатель на константу, он тоже должен объявляться с ключевым словом const</b>:
<pre>
#include &lt;iostream>
 
int main()
{
    <b>const</b> int a {10};
    <b>const</b> int *pa {&a};
    std::cout << "address=" << pa << "\tvalue=" << *pa << std::endl;
}
</pre>
Здесь указатель pa указывает на константу a. Поэтому даже если мы захотим изменить значение по адресу, который хранится в указателе, мы не сможем это сделать, например так:<br>
*pa = 34;</br>
В этом случае мы просто получим ошибку во время компиляции.
<p>
Возможна также ситуация, когда указатель на константу на самом деле указывает на переменную:
<pre>
#include &lt;iostream>
 
int main()
{
    int a {10};
    const int *pa {&a};
    std::cout <<"value=" << *pa << std::endl;     // value=10
    a = 22;
    std::cout <<"value=" << *pa << std::endl;     // value=22
    //*pa = 34;     // так делать нельзя
}
</pre>
В этом случае переменную отдельно мы сможем изменять, однако по прежнему изменить ее значение через указатель мы не сможем.
<p>
Через указатель на константу мы не можем изменять значение переменной/константы. Но мы можем присвоить указателю адрес любой другой переменной или константы:
<pre>
const int a {10};
const int *pa {&a};     // указатель указывает на константу a
const int b {45};
pa = &b;                // указатель указывает на константу b
std::cout <<"*pa = " << *pa << std::endl;     // *pa = 45
std::cout <<"a = " << a << std::endl;     // a = 10 - константа a не изменяется
</pre>
<h4>Константный указатель</h4>
От указателей на константы надо отличать константные указатели. Они не могут изменять адрес, который в них хранится, но могут изменять значение по этому адресу.
<pre>
#include &lt;iostream>
 
int main()
{
    int a {10};
    int <b>*const</b> pa {&a};
    std::cout << "value=" << *pa << std::endl;      // value = 10
    *pa = 22;                                       // меняем значение
    std::cout << "value=" << *pa << std::endl;      // value = 22
   
    int b {45};
    // pa = &b;         так нельзя сделать
}
</pre>
<h4>Константный указатель на константу</h4>
И объединение обоих предыдущих случаев - константный указатель на константу, который не позволяет менять ни хранимый в нем адрес, ни значение по этому адресу:
<pre>
int main()
{
    int a {10};
    const int *const pa {&a};
 
    //*pa = 22;  так сделать нельзя
 
    int b {45};
    // pa = &b;  так сделать нельзя 
}
</pre>
<pre>



</pre>
<a name="array_pointer"><h3 align=center>Указатели и массивы</h3>
В C++ указатели и массивы тесно связаны. Обычно компилятор преобразует массив в указатели. С помощью указателей можно манипулировать элементами массива, как и с помощью индексов.
<p>
Имя массива по сути является адресом его первого элемента. Соответственно через операцию разыменования мы можем получить значение по этому адресу:
<pre>
#include &lt;iostream>
  
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    std::cout << "nums[0] address: " << nums << std::endl;
    std::cout << "nums[0] value: " << *nums << std::endl;
}
</pre>
Так, в моем случае я получу следующий консольный вывод:
<pre>
nums[0] address: 0x1f1ebffe60
nums[0] value: 1
</pre>
<b>Прибавляя к адресу первого элемента некоторое число, мы можем получить определенный элемент массива.</b>
<pre>
#include &lt;iostream>
  
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    int num2 = *(nums + 1);    // второй элемент
    int num3 = <b>*(nums + 2)</b>;    // третий элемент
    std::cout << "num2 = " << num2 << std::endl;    // num2 = 2
    std::cout << "num3 = " << num3 << std::endl;    // num3 = 3
}
</pre>
То есть, например, адрес второго элемента будет представлять выражение nums+1, а его значение - *(nums+1).
<p>
В отношении сложения и вычитания здесь действуют те же правила, что и в операциях с указателями. Добавление единицы означает прибавление к адресу значения, которое равно размеру типа массива. Так, в данном случае массив представляет тип int, размер которого, как правило, составляет 4 байта, поэтому прибавление единицы к адресу означает увеличение адреса на 4. Прибавляя к адресу 2, мы увеличиваем значение адреса на 4 * 2 = 8. И так далее.
<p>
Например, в цикле пробежимся по всем элементам:
<pre>
#include &lt;iostream>
  
int main()
{
    int nums[] {1, 2, 3, 4, 5};
    for(unsigned i{}; i < std::size(nums); i++)
    {
        std::cout << "nums[" << i << "]: address=" << nums+i << "\tvalue=" << *(nums+i) << std::endl;
    }
}
</pre>
И в итоге программа выведет на консоль следующий результат:
<pre>
nums[0]: address=0xd95adffc30   value=1
nums[1]: address=0xd95adffc34   value=2
nums[2]: address=0xd95adffc38   value=3
nums[3]: address=0xd95adffc3c   value=4
nums[4]: address=0xd95adffc40   value=5
</pre>
Но при этом имя массива это не стандартный указатель, и мы не можем изменить его адрес, например, так:
<pre>
int nums[] {1, 2, 3, 4, 5};
nums++;         // так сделать нельзя
int b {8};
nums = &b;          // так тоже сделать нельзя
</pre>
<h4>Указатели на массивы</h4>
Имя массива всегда хранит адрес самого первого элемента. И нередко для перемещения по элементам массива используются отдельные указатели:
<pre>
int nums[] {1, 2, 3, 4, 5};
int *ptr {nums};
int num3 = *(ptr+2);
std::cout <<  "num3: " << num3 << std::endl;  // num3: 3
</pre>
Здесь указатель ptr изначально указывает на первый элемент массива. Увеличив указатель на 2, мы пропустим 2 элемента в массиве и перейдем к элементу nums[2].
<p>
Можно сразу присвоить указателю адрес конкретного элемента массива:
<pre>
int nums[] {1, 2, 3, 4, 5};
int *ptr {&nums[2]};    // адрес третьего элемента
std::cout << "*ptr = " << *ptr  << std::endl; //*ptr = 3
</pre>
С помощью указателей легко перебрать массив:
<pre>
#include &lt;iostream>
  
int main()
{
    const int n = 5;
    int nums[n]{1, 2, 3, 4, 5};
 
    for(int *ptr{nums}; ptr<=&nums[n-1]; ptr++)
    {
        std::cout << "address=" << ptr << "\tvalue=" << *ptr << std::endl;
    }
}
</pre>
Так как указатель хранит адрес, то мы можем продолжать цикл, пока адрес в указателе не станет равным адресу последнего элемента.
<p>
Аналогичным образом можно перебрать и многомерный массив:
<pre>
#include &lt;iostream>
 
int main()
{
    int nums[3][4] { {1, 2, 3, 4} , {5, 6, 7, 8}, {9, 10, 11, 12}};
    unsigned int n { sizeof(nums)/sizeof(nums[0]) };         // число строк
    unsigned int m { sizeof(nums[0])/sizeof(nums[0][0]) };   // число столбцов
       
    int *end {nums[0] + n * m - 1};    // указатель на самый последний элемент 0 + 3 * 4 - 1 = 11
    int *ptr {nums[0]};                // указатель на первый элемент
    for( unsigned i{1}; ptr <= end; ptr++, i++)
    {
        std::cout << *ptr << "\t";
        // если остаток от целочисленного деления равен 0,
        // переходим на новую строку
        if(i%m == 0)
        {
            std::cout << std::endl;
        }
    }
}
</pre>
Поскольку в данном случае мы имеем дело с двухмерным массивом, то адресом первого элемента будет выражение a[0]. Соответственно указатель указывает на этот элемент. С каждой итерацией указатель увеличивается на единицу, пока его значение не станет равным адресу последнего элемента, который хранится в указателе end.
<p>
Мы также могли бы обойтись и без указателя на последний элемент, проверяя значение счетчика:
<pre>
#include &lt;iostream>
  
int main()
{
    const unsigned n {3};           // число строк
    const unsigned m {4};           // число столбцов
    int nums[n][m] { {1, 2, 3, 4} , {5, 6, 7, 8}, {9, 10, 11, 12}};
    const unsigned count {m * n};   // общее количество элементов
 
    int *ptr{nums[0]};  // указатель на первый элемент первого массива
    for(unsigned i{1}; i <= count; ptr++, i++)
    {
        std::cout << *ptr << "\t";
        // если остаток от целочисленного деления равен 0,
        // переходим на новую строку
        if(i%m == 0)
        {
            std::cout << std::endl;
        }
    }
}
</pre>
Но в обоих случаях программа вывела бы следующий результат:
<pre>
1	2	3	4
5	6	7	8
9	10	11	12
</pre>
<h4>Указатель на строки и массивы символов</h4>
Поскольку массив символов может интерпретироваться как строка, то указатель на значения типа char тоже может интерпретироваться как строка:
<pre>
#include &lt;iostream>
  
int main()
{
    char hello[] {"hello"};
    char *phello {hello};
    std::cout << phello << std::endl;       // hello
}
</pre>
При выводе на консоль значения указателя фактически будет выводиться строка.
<p>
Также можно применять операцию разыменовывания для получения отдельных символов, например, выведем первый символ:<br>
std::cout << *phello << std::endl;      // h
<p>
Если же необходимо вывести на консоль адрес указателя, то его надо преобразовать к типу void*:
<pre>
std::cout << (void*)phello << std::endl;    // 0x60fe8e
</pre>
В остальном работа с указателем на массив символов производится также, как и с указателями на массивы других типов.
<p>
Также поскольку указатель типа char тоже может интерпретироваться как строка, то теоретически мы можем написать следующим образом:
<pre>
<font color=red>char *phello {"hello"};</font> //не понял, вроде объявление указателя
</pre>
Однако следует учитывать, что строковые литералы в С++ рассматриваются как константы. Поэтому предыдущее определение указателя может при компиляции вызвать как минимум предупреждение, а попытка изменить элементы строки через указатель - к ошибке компиляции. Поэтому при определении указателя на строку, следует определять указатель как указатель на константу:
<pre>
#include &lt;iostream>
  
int main()
{
    const char *phello {"hello"}; // указатель на константу
    std::cout << phello << std::endl;   // hello
}
</pre>
<h4>Массивы указателей</h4>
Также можно определять массивы указателей. В некотором смысле массив указателей будет похож на массив, который содержит другие массивы. Однако массив указателей имеет преимущества.
<p>
Например, возьмем обычный двухмерный символьный массив - массив, который хранит строки:
<pre>
#include &lt;iostream>
    
int main()
{
    char langs[][20] { "C++", "Python", "JavaScript"};
    std::cout << langs[0] << ": " << std::size(langs[0]) << " bytes" << std::endl;  // C++: 20 bytes
}
</pre>
Для определения двухмерного массива мы должны указать как минимум размер вложенных массивов, который будет достаточным, чтобы вместить каждую строку. В данном случае размер каждого вложенного массива - 20 символов. Однако зачем для первой строки - "C++", которая содержит 4 символа (включая концевой нулевой байт) выделять аж 20 байтов? Это - ограничение подобных массивов. Массивы указателей же позволяют обойти подобное ограничение:
<pre>
#include &lt;iostream>
    
int main()
{
    const char *langs[] { "C++", "Python", "JavaScript"};
    // перебор массива
    for(unsigned i{}; i< std::size(langs); i++)
    {
        std::cout << langs[i] << std::endl;
    }
}
</pre>
В данном случае элементами массива langs являются указатели: 3 указателя, каждый из которых занимает 4 или 8 байт в зависимости от архитекутуры (размер адреса). Каждый из этих указателей указывает на адрес в памяти, где расположены соответствующие строки: "C++", "Python", "JavaScript". Однако каждая из этих строк будет занимать именно то пространство, которое ей непосредственно необходимо. То есть строка "С++" будет занимать 4 байта. С одной стороны, мы здесь сталкиваемся с дополнительными издержками: дополнительно выделяется память для хранения адресов в указателях. С другой стороны, когда строки в массиве сильно различаются по длине , то мы можем получить общий выигрыш в количестве потребляемой памяти.
<pre>





</pre>
</div></body></html>
