<html><head>
<style>
.menu {
       height: 100%;
       width: 155px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 5px;
           margin-left: 160px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Объектно-ориентированное программирование</title>
<div class="menu">
<a href="#obiekt">Объекты</a>
<a href="#klass">Классы</a>
<ul>
<li><a href="#konstrukt">Конструктор класса</a>
</ul>
</div>

<div class="content">
<h2 align=center>Объектно-ориентированное программирование</h2>
Ссылки: <a href="https://intuit.ru/studies/courses/49/49/lecture/27064">Лекция 4: Объектно-ориентированное программирование</a><br>
<a href="https://pyplanet.ru/article/classes.html">Объектно-ориентированное программирование. Классы, объекты</a><br>
<a href="https://itproger.com/course/python/17">Основы ООП. Создание класса и объекта</a><br>
<a href="https://www.youtube.com/watch?v=jtIq61A1LLw&list=PLQAt0m1f9OHvyjJNjZK_unnLwMOXPTja8&index=1&pp=iAQB">Видеоуроки Егорова Артема</a><br>
<a href="https://younglinux.info/oopython/objects">Создание классов и объектов</a><br>
<a href="https://docs.python.org/3/tutorial/classes.html">9. Classes</a>

<h4>Что такое объектно-ориентированное программирование (ООП)</h4>
Циклы, ветвления и функции – все это элементы структурного программирования. Его возможностей вполне хватает для написания 
небольших, простых программ и сценариев. Однако крупные проекты часто реализуют, используя парадигму объектно-ориентированного 
программирования (ООП). Что оно из себя представляет и какие преимущества дает?
<p>
В языке Python ООП играет ключевую роль. Даже программируя в рамках структурной парадигмы, вы все равно пользуетесь объектами 
и классами, пусть даже встроенными в язык, а не созданными лично вами.
<p>
Итак, что же такое объектно-ориентированное программирование?
<p>
Допустим, команда программистов занимается разработкой игры. Программу-игру можно представить как систему, состоящую из цифровых героев и среды их обитания, включающей множество предметов. Каждый воин, оружие, дерево, дом – это цифровой объект,
в котором "упакованы" его свойства и действия, с помощью которых он может изменять свои свойства и свойства других объектов.
<p>
Каждый программист может разрабатывать свою группу объектов. Разработчикам достаточно договориться только о том, как объекты будут взаимодействовать между собой, то есть об их интерфейсах. Пете не надо знать, как Вася реализует рост коровы в результате поедания травы. Ему, как разработчику лужайки, достаточно знать, что когда корова наклоняется к траве, последней на лужайке должно становиться меньше.
<p>
Ключевую разницу между программой, написанной с структурном стиле, и объектно-ориентированной можно выразить так. В первом случае, на первый план выходит логика, понимание последовательности выполнения действий для достижения поставленной цели. Во-втором – важнее представить программу как как систему объектов, взаимодействие которых способно решить ту или иную задачу.
<p>
Основными понятиями, используемыми в ООП, являются <b>класс, объект, наследование, инкапсуляция и полиморфизм</b>. В языке Python класс равносилен понятию тип данных.

<h4>Что такое класс или тип?</h4>
Проведем аналогию с реальным миром. Если мы возьмем конкретный стол, то это объект, но не класс. А вот общее представление о столах, их назначении – это класс. Ему принадлежат все реальные объекты столов, какими бы они ни были. Класс столов дает общую характеристику всем столам в мире, он их обобщает.
<p>
То же самое с целыми числами в Python. Тип int – это класс целых чисел. Числа 5, 100134, -10 и т. д. – это конкретные объекты этого класса.
<p>
В языке программирования Python объекты принято называть также экземплярами. Это связано с тем, что в нем все классы сами являются объектами класса type. Точно также как все модули являются объектами класса module.
<p>
Поэтому во избежании путаницы объекты, созданные на основе обычных классов, называют экземплярами. В этом курсе мы чаще будем такие объекты называть объектами, так как данная терминология более универсальная и используется в других языках.



<h4 align=center><a name="obiekt">Объект</h4>
В Python всё является объектами - строки, списки, словари, файлы, всё остальное.<br>
Объекты имеют  <b>атрибуты</b> и <b>методы</b>.<br>
Проверить является ли какое-то значение объектом, можно с помощью функции: <b>isinstance(var, object)</b>:
<pre>
isinstance(4, object)
True
>>> isinstance(Person, object)
True
>>> isinstance('stroka', object)
True
</pre>
<p>
Типы переменных (все что выводится через type(variable)) является встроенным классом в питоне. Например целые числа имеют тип или класс int. Строки принадлежат классу str.<br>
Чтобы создать экземпляр класса нужно выполнить var = name_class(). Пример:
<pre>
a = int()
a  # будет выведен 0 , так как по умолчанию создается объект класса  int равным 0
>>> s = str()
>>> s
''</pre>
Для строки по умолчанию создается пустая строка.
<ul>
<li> <b>Идентификатор объекта</b><br>
Каждый объект обладает своим уникальным идентификатором.<br>
Узнать идентификатор объекта можно с помощью функции id():
<pre>
>>> x = [1, 2, 3]
>>> id(x)
140705499364608
>>> id([1, 2, 3])
140705499676224</pre>
В данном примере создал два разных объекта x и [1, 2, 3]
<p>
<li> <b>Оператор is</b><br>
Также узнать ссылаются ли переменные на один и тот же объект (одинаковые идентификаторы) можно с помощью <b>оператора is</b>:
<pre>
>>> y = x
>>> y <b>is</b> x
True
>>> y is [1, 2, 3]
False</pre>
<p>

<li> <b>Изменяемые/неизменяемые  объекты</b><br>
В зависимости от того является ли объект изменяемым или нет, будет отличаться результат после выполнения операций с объектом:
<pre>
x = [1, 2, 3]
y = x
y.append(4)

s = "123"
t = s
t = t + "4"

print(str(x) + " " + s)</pre>
Будет выведено [1, 2, 3, 4] 123<br>
так как список является изменяемым объектом и изменив его через ссылку x, мы изменили его и для y. А строка является 
неизменяемым объектом, потому выполнив t = t + '4', мы создаем новый объект (место в памяти) для t, а s по-прежнему ссылается 
на свой объект '123'
<p>
Объекты бывают изменяемые и неизменяемые (англ. mutable и immutable). К неизменяемым относятся целые числа (int), числа с 
плавающей запятой (float), булевы значения (bool), строки (str), кортежи (tuple). К изменяемым — списки (list), множества 
(set), байтовые массивы (byte arrays) и словари (dict).
<p>
<li> <b>Тип объекта</b><br>
Каждый объект имеет свой тип.<br>
Тип объекта можно узнать с помощью функции type()<br>
Тип объекта определяет возможные значения объекта, его возможные методы.
<p>
<li> <b>Без ссылок новые объекты не создаются!</b>
<p>
Кешируются числа от -5 до 256 - т.е. при работе с этими числами Python обычно не будет создавать новый объект.
Так же кешируются строки, которые содержат только буквы, числа и нижнее подчеркивание.
Но это не гарантированное свойство, потому не нужно на это полагаться при проверке идентичности объектов.
<p>
Гарантированно в единствнном виде представлен (является синглтоном) из часто употребимых - None. С ним всегда используют для 
проверки оператор is, а не ==, т.к. он гарантированно будет в единственном экземпляре в памяти.


</ul>


<h3 align=center><a name="klass">Класс</h3>
<ul>
<li>
Объекты описываются не индивидуально, а с помощью классов. Класс - объект, являющийся шаблоном чертежём объекта.<br>
Объект, созданный на основе некоторого класса, называется <b>экземпляром класса</b>. Все объекты определенных пользователем 
классов являются экземплярами класса.
<p>
В языке программирования Python классы создаются с помощью инструкции class, за которой следует произвольное имя класса (первая 
буква всегда большая), после которого ставится двоеточие, далее с новой строки и с отступом реализуется тело класса:
<pre>
class ИмяКласса:
    код_тела_класса</pre>
Если класс является дочерним, то родительские классы перечисляются в круглых скобках после имени класса.
<p>
Класс определяет тип объекта, то есть его возможные состояния и набор операций.
<p>
Объект создается путем вызова класса по его имени. При этом после имени класса обязательно ставятся скобки:
<p>
<b>ИмяКласса()</b>
<p>
То есть класс вызывается подобно функции. Однако в случае вызова класса происходит не выполнение его тела, как это происходило 
бы при вызове функции, а создается объект. Поскольку в программном коде важно не потерять ссылку на только что созданный 
объект, то обычно его связывают с переменной. Поэтому создание объекта чаще всего выглядит так:
<p>
<b>имя_переменной = ИмяКласса()</b>
<p>
В последствии к объекту обращаются через связанную с ним переменную.
<p>
Пример "пустого" класса и двух созданных на его основе объектов:
<pre>
>>> class A:
...     pass
... 
>>> a = A()
>>> b = A()</pre>
<b>Класс как пространство имен</b><br>
С точки зрения пространства имен класс можно представить подобным модулю. Также как в модуле в классе могут быть свои 
переменные со значениями и функции. Также как в модуле у класса есть собственное пространство имен, доступ к которому возможен 
через имя класса:
<pre>
>>> class B:
...     n = 5
...     def adder(v):
...             return v + B.n
... 
>>> B.n
5
>>> B.adder(4)
9</pre>
Однако в случае классов используется особая терминология:<br>
Имена, определенные в классе, называются <b>атрибутами этого класса</b>.<br>
В примере имена n и adder – это атрибуты класса B.<br>
Атрибуты-переменные часто называют <b>полями или свойствами</b><br> 
(в других языках понятия "поле" и "свойство" не совсем одно и то же). Полем является n.<br>
Атрибуты-функции называются <b>методами</b>.<br>
Методом в классе B является adder. Количество свойств и методов в классе может быть любым.
<p>
<b>Класс как шаблон для создания объектов</b><br>
На самом деле классы – не модули. Они своего рода шаблоны, от которых создаются объекты-экземпляры. Такие объекты наследуют от 
класса его атрибуты. Вернемся к нашему классу B и создадим на его основе два объекта:
<pre>
>>> class B:
...     n = 5
...     def adder(v):
...             return v + B.n
... 
>>> a = B()
>>> b = B()</pre>
У объектов, связанных с переменными a и b, нет собственного поля n. Однако они наследуют его от своего класса:
<pre>
>>> a.n
5
>>> a.n is B.n
True</pre>
То есть поля a.n и B.n – это одно и то же поле, к которому можно обращаться и через имя a, и через имя b, и через имя класса. 
Поле одно, ссылок на него три.
<p>
<b>Однако что произойдет в момент присваивания этому полю значения через какой-нибудь объект-экземпляр?</b>
<pre>
>>> a.n = 10
>>> a.n
10
>>> b.n
5
>>> B.n
5</pre>
В этот момент у экземпляра появляется собственный атрибут n, который перекроет (переопределит) родительский, то есть тот, 
который достался от класса.
<pre>
>>> a.n is B.n
False
>>> b.n is B.n
True</pre>
При этом присвоение через B.n отразится только на b и B, но не на a:
<pre>
>>> B.n = 100
>>> B.n, b.n, a.n
(100, 100, 10)</pre>
<p>
<b>Как применить метод к экземпляру класса?</b><br>
Иная ситуация нас ожидает с атрибутом adder. При создании объекта от класса функция adder не наследуется как есть, а как бы превращается для объекта в одноименный метод:
<pre>
>>> B.adder is b.adder
False
>>> type(B.adder)
&lt;class 'function'&gt;
>>> type(b.adder) 
&lt;class 'method'&gt;</pre>
Через имя класса мы вызываем функцию adder:
<pre>
>>> B.adder(33)
133</pre>
Через имя объекта вызываем метод adder:
<pre>
>>> b.adder(33)
Traceback (most recent call last):
  File "<stdin>", line 1, in &lt;module&gt;
TypeError: adder() takes 1 positional 
argument but 2 were given</pre>
В сообщении об ошибке говорится, что adder принимает только один аргумент, а было передано два. Откуда появился второй, если в скобках было указано только одно число?
<br>Дело в том, что в отличии от функции <b>в метод первым аргументом всегда передается объект, к которому применяется этот метод</b>. То есть выражение b.adder(33) как бы преобразовывается в adder(b, 33). Сам же b.adder как объект типа method хранит сведения, с каким классом он связан и какому объекту-экземпляру принадлежит:
<pre>
>>> b.adder
&lt;bound method B.adder of 
&lt;__main__.B object at 0x7fcbf1ab9b80&gt;&gt;</pre>
В нашем случае, чтобы вызывать adder через объекты-экземпляры, класс можно переписать так:
<pre>
>>> class B:
...     n = 5
...     def adder(obj, v):
...             return v + obj.n
... 
>>> b = B()
>>> b.adder(33)
38</pre>
В коде выше при вызове метода adder переменной-параметру obj присваивается объект, связанный с переменной, к которой 
применяется данный метод. В данном случае это объект, связанный с b. Если adder будет вызван на другой объект, 
то уже он будет присвоен obj:
<pre>
>>> a = B()
>>> a.n = 9
>>> a.adder(3)
12</pre>
<b>В Python переменную-параметр метода, которая связывается с экземпляром своего класса, принято называть именем self.</b><br>
Таким образом, более корректный код будет таким:
<pre>
>>> class B:
...     n = 5
...     def adder(self, v):
...             return v + self.n</pre>

Можем ли мы все также вызывать adder как функцию, через имя класса? Вполне. Только теперь в функцию 
надо передавать два аргумента:
<pre>
>>> B.adder(B, 200)
205
>>> B.adder(a, 200)
209</pre>
Здесь первым аргументом в функцию передается объект, у которого есть поле n лишь только потому, что далее к этому полю 
обращаются через выражение self.n.
<p>
<b>При описании класса и внутри методов в теле метода  обращения к полям идут в виде self.поле = поле</b>


<h4>Атрибут __dict__</h4>
В Python у объектов есть встроенные специальные атрибуты. Мы их не определяем, но они есть. Одним из таких атрибутов объекта 
является свойство __dict__. Его значением является словарь, в котором ключи – это имена свойств экземпляра (переменные - 
атрибуты), а значения – текущие значения свойств.
<pre>
>>> class B:
...     n = 5
...     def adder(self, v):
...             return v + self.n
... 
>>> w = B()
>>> w.__dict__
{}
>>> w.n = 8
>>> w.__dict__
{'n': 8}</pre>
В примере у экземпляра класса B сначала нет собственных атрибутов. Свойство n и метод adder – это атрибуты объекта-класса, а не 
объекта-экземпляра, созданного от этого класса. Лишь когда мы выполняем присваивание новому полю n экземпляра, у него 
появляется собственное свойство, что мы наблюдаем через словарь __dict__.
<p>
В следующем уроке мы увидим, что свойства экземпляра обычно не назначаются за пределами класса. Это происходит в методах 
классах путем присваивание через self. Например, self.n = 10.
<p>
Атрибут __dict__ используется не только для просмотра свойств объекта. С его помощью можно удалять, добавлять свойства, а также 
изменять их значения.
<pre>
>>> w.__dict__['m'] = 100
>>> w.__dict__
{'n': 8, 'm': 100}
>>> w.m
100</pre>


<b>Пример:</b><br>
Пусть в ходе анализа данной предметной области необходимо определить класс Граф. Граф - это множество вершин и набор ребер, 
попарно соединяющий эти вершины. Над графом можно проделывать операции, такие как добавление вершины, ребра, проверка наличия 
ребра в графе и т.п. На языке Python определение класса может выглядеть так:
<pre>
from sets import Set as set  # тип для множества

class G:
  def __init__(self, V, E):
    self.vertices = set(V)
    self.edges = set(E)

  def add_vertex(self, v):
    self.vertices.add(v)

  def add_edge(self, (v1, v2)):
    self.vertices.add(v1)
    self.vertices.add(v2)
    self.edges.add((v1, v2))

  def has_edge(self, (v1, v2)):
    return (v1, v2) in self.edges

  def __str__(self):
    return "%s; %s" % (self.vertices, self.edges)</pre>
Использовать класс можно следующим образом:
<pre>
g = G([1, 2, 3, 4], [(1, 2), (2, 3), (2, 4)])

print g
g.add_vertex(5)
g.add_edge((5,6))
print g.has_edge((1,6))
print g</pre>
что даст в результате:
<pre>
Set([1, 2, 3, 4]); Set([(2, 4), (1, 2), (2, 3)])
False
Set([1, 2, 3, 4, 5, 6]); Set([(2, 4), (1, 2), (5, 6), (2, 3)])</pre>
Как видно из предыдущего примера, определить класс не так уж сложно. Конструктор класса имеет специальное имя __init__. 
(Деструктор здесь не нужен, но он бы имел имя __del__.)<br>
Методы класса определяются в пространстве имен класса.<br>
В качестве первого формального аргумента метода принято использовать self.<br>
Кроме методов в объекте класса имеются два атрибута: vertices (вершины) и edges (ребра).<br>
Для представления объекта G в виде строки используется специальный метод __str__().
<p>
Принадлежность классу можно выяснить с помощью встроенной функции isinstance():
<pre>print isinstance(g, G)</pre>


<a name="konstrukt"><h4>Конструктор класса</h4>
Исполнение конструктора класса начинается в момент создания нового объекта этого класса. Конструктор является специальным 
методом, который обязательно вызывается при создании объекта. <b>Он отвечает за инициализацию переменных и установку начальных 
значений для нового экземпляра класса.</b> Конструктор вызывается автоматически при создании объекта и возвращает готовый к 
использованию экземпляр класса.
<p>
Конструкторы позволяют задать некие характеристики для объекта сразу же при его создании. К примеру, у вас есть несколько 
переменных, которые точно должен иметь объект. Вы можете создать конструктор и указать несколько параметров, которые будут 
переданы при создании объекта. 
<p>
В одном классе может быть неограниченное количество конструкторов и сам интерпретатор будет понимать к какому конструктору вы 
обращаетесь. Чтобы создать конструктор необходимо использовать ключевое слово <b>__init__</b>.
<p>
Вот пример, который демонстрирует использование метода __init__():
<pre>
class Person:

    def __init__(self, name, age):

        self.name = name

        self.age = age

    def introduce(self):

        print("Привет, меня зовут", self.name, "и мне", self.age, "лет.")

person1 = Person("Алиса", 25)

person1.introduce()
</pre>
В этом примере у нас есть класс Person, у которого есть метод __init__() и метод introduce().<br>
Метод __init__() принимает два параметра: name и age.<br>
Внутри метода __init__() мы присваиваем значения этих параметров атрибутам self.name и self.age соответственно.<br>
При создании нового экземпляра класса Person и передаче имени и возраста в качестве аргументов, метод __init__() автоматически 
вызывается и инициализирует атрибуты объекта.<br>
Затем мы можем вызывать метод introduce(), который использует значения атрибутов name и age для вывода информации о человеке. 
Вывод программы будет следующим: Привет, меня зовут Алиса и мне 25 лет.<br>
Таким образом, метод __init__() позволяет задать начальные значения атрибутов объекта класса во время его создания. Он играет 
важную роль в инициализации объектов и предоставляет возможность установить начальное состояние объекта.
<p>
Если вы определите метод с другим названием, а не __init__(), и используете его для инициализации атрибутов объекта, то при 
создании экземпляра класса вам нужно будет вызвать этот метод явно. Вот пример кода, где используется метод blabla() для 
инициализации атрибутов объекта:
<pre>
class Person:

    def blabla(self, name, age):

        self.name = name

        self.age = age

    def introduce(self):

        print("Привет, меня зовут", self.name, "и мне", self.age, "лет.")

person1 = Person()

person1.blabla("Алиса", 25)

person1.introduce()</pre>
В этом примере мы создаем экземпляр класса Person без вызова метода __init__(). Вместо этого мы вызываем метод blabla() и 
передаем аргументы "Алиса" и 25, которые инициализируют атрибуты объекта name и age. Затем мы вызываем метод introduce(), 
который использует значения атрибутов name и age для вывода информации о человеке. Вывод программы будет следующим: Привет, 
меня зовут Алиса и мне 25 лет. Таким образом, вы можете использовать метод с любым другим названием, чтобы инициализировать 
атрибуты объекта. Однако, важно помнить, что вам нужно будет вызвать этот метод явно при создании экземпляра класса.
<p>
В Python, параметр self используется в методах класса для ссылки на сам объект (экземпляр класса), для которого вызывается 
метод. Он является обязательным параметром в определении методов класса.
<p>
Параметр self позволяет обращаться к атрибутам и методам объекта внутри самого класса. Он представляет собой ссылку на сам 
экземпляр класса, с помощью которого можно получить доступ к его атрибутам и вызвать его методы.
<p>
Если не использовать параметр self в методах класса, то не будет возможности получить доступ к атрибутам и методам объекта. 
Без использования self, метод не будет знать, какой объект класса обрабатывается, и будет вызвана ошибка.
<br><font color=red>TypeError: introduce() takes 0 positional arguments but 1 was given</font>
</ul>

<h4>Наследование, инкапсуляция и полиморфизм</h4>
Помимо классов и объектов, ООП содержит дополнительные три основные концепции: <b>наследование, инкапсуляция и полиморфизм</b>. 
<ol>
<li> <b>Наследование</b><br>
За счёт наследования можно создать один общий класс (класс родитель) и создать множество других классов (классы наследники), 
что будут наследовать все поля, методы и конструкторы из главного класса.
<p>
<b>Зачем использовать наследование?</b><br>
Предположим что у нас есть один большой класс «Транспорт». В классе описываются базовые характеристики для всех транспортных 
средств:
<p>
поля: скорость, вес, запас хода и тому подобное;<br>
методы: получение информации из полей, установка новых значений;<br>
конструктор: пустой и по установке всех полей.<br>
<p>
На основе класса мы спокойно можем создать объект легковой машины, объект грузовика, объект самолета и так далее. У всех 
объектов будут одинаковые характеристики и методы. 
<p>
Мы явно понимаем, что у объекта машина и самолёт будут разные поля и характеристики. Как можно поступить:
<p>
Можно создать два отдельных класса: «Car» и «Airplane». В каждом классе будут все методы, поля и конструкторы повторно 
переписанные из класса «Транспорт», а также будут новые методы, что важны только для конкретного класса;
Можно создать два класса наследника: «Car» и «Airplane». Оба класса будут наследовать всё от класса «Транспорт» и при этом 
будут содержать свои дополнительные функции. Таким образом повторения кода не будет и код станет меньше и чище.
<p>
<b>Создание классов наследников</b><br>
Для создания класса наследника требуется создать класс и указать наследование от главного класса.
<p>
Пример класса наследника:
<pre>
class Cars:
	wheels = 4 # Общее значение для всех объектов,
	# так как все машины имеют колеса
		
class BMW (Cars):
	is_m_serias = true # Является ли модель "М" серии?
	# Переменная нужна только в классе BMW</pre>
<p>
Основное (но не единственное) преимущество, которое дает концепция наследования в программировании, – это вынос одинакового 
кода из разных классов в один родительский класс. Другими словами, наследование позволяет сводить на нет повторение кода в 
разных частях программы.
<p>
<li> <b>Полиморфизм</b><br>
Полиморфизм позволяет изменять функции в классах наследниках. Пример:
<pre>
class Cars:
	def nothing(self): # Пустая функция
		pass
		
class BMW (Cars):
	def nothing(self, word):
		print (word + "!") # Функция теперь будет работать по новому
 
a = BMW()
a.nothing("Some")</pre>
<p>
Полиморфизм можно перевести как множество форм. В ООП под полиморфизмом понимается следующее. Объекты разных классов, с разной 
внутренней реализацией, то есть программным кодом, могут иметь "одинаковые" методы. На самом деле у методов совпадают только 
имена, а вложенный в них код (то, что они делают) различен. Вот и получается, что у одного имени как бы множество форм.
<p>
Полиморфизм полезен не только тем, что дает возможность объектам пользовательских классов участвовать в стандартных операциях. 
Если у объектов разных классов есть одноименный метод, то коллекция таких разнородных объектов может быть обработана в одном 
цикле.

<p>
<li> <b>Инкапсуляция</b><br>
Обычно считается, что без инкапсуляции невозможно представить себе ООП, что это ключевое понятие. История развития методологий 
программирования движима борьбой со сложностью разработки программного обеспечения. Сложность больших программных систем, в 
создании которых участвует сразу большое количество разработчиков, уменьшается, если на верхнем уровне не видно деталей 
реализации нижних уровней. Собственно, процедурный подход был первым шагом на этом пути. Под инкапсуляцией (encapsulation, что 
можно перевести по-разному, но на нужные ассоциации хорошо наводит слово "обволакивание") понимается сокрытие информации о 
внутреннем устройстве объекта, при котором работа с объектом может вестись только через его общедоступный (public) интерфейс. 
Таким образом, другие объекты не должны вмешиваться в "дела" объекта, кроме как используя вызовы методов.
<p>
В языке Python инкапсуляции не придается принципиального значения: ее соблюдение зависит от дисциплинированности программиста. 
В других языках программирования имеются определенные градации доступности методов объекта.
<p>
Инкапсуляция позволяет ограничить доступ к какой-либо функции в классе. Благодаря такому подходу злоумышленники или же мы сами 
не сможем случайно или намерено вызвать или изменить метод.
<p>
Пример:
<pre>
class Some:
	def _printWords(self):
		print ("Попробуй меня вызвать")

obj = Some()
obj._printWords() # Вызов функции ничего не даст</pre>
При помощи двойного подчеркивания эффект защиты усиливается, поэтому вызвать функцию будет невозможным.

</ol>



</div><br><br><br><br></body</html>
