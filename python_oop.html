<html><head>
<style>
.menu {
       height: 100%;
       width: 155px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 5px;
           margin-left: 160px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Объектно-ориентированное программирование</title>
<div class="menu">
<a href="#obiekt">Объекты</a>
<a href="#klass">Классы:</a>
<a href="#konstrukt">&nbsp;&nbsp; Конструктор класса</a>
<a href="#наследование">&nbsp;&nbsp; Наследование</a>
<a href="#iterator">&nbsp;&nbsp; Итерация классов</a>
<a href="#modul">Импорт и создание модулей</a>
<a href="#lib">Стандартная библиотека:</a>
<a href="#sys">&nbsp;&nbsp; Модуль sys</a>
<a href="#subprocess">&nbsp;&nbsp; Модуль subprocess</a>
<a href="#os">&nbsp;&nbsp; Модуль os</a>
<a href="#ospath">&nbsp;&nbsp; Модуль os.path</a>
<a href="#glob">&nbsp;&nbsp; Модуль glob</a>
<a href="#datetime">&nbsp;&nbsp; Модуль datetime</a>
<a href="#functools">&nbsp;&nbsp; Модуль functools/partial</a>
<a href="#dekorator">Декораторы, замыкания</a>

</div>

<div class="content">
<h2 align=center>Объектно-ориентированное программирование</h2>
Ссылки: <a href="https://intuit.ru/studies/courses/49/49/lecture/27064">Лекция 4: Объектно-ориентированное программирование</a><br>
<a href="https://pyplanet.ru/article/classes.html">Объектно-ориентированное программирование. Классы, объекты</a><br>
<a href="https://itproger.com/course/python/17">Основы ООП. Создание класса и объекта</a><br>
<a href="https://www.youtube.com/watch?v=jtIq61A1LLw&list=PLQAt0m1f9OHvyjJNjZK_unnLwMOXPTja8&index=1&pp=iAQB">Видеоуроки Егорова Артема</a><br>
<a href="https://younglinux.info/oopython/objects">Создание классов и объектов</a><br>
<a href="https://docs.python.org/3/tutorial/classes.html">9. Classes</a>

<h4>Что такое объектно-ориентированное программирование (ООП)</h4>
Циклы, ветвления и функции – все это элементы структурного программирования. Его возможностей вполне хватает для написания 
небольших, простых программ и сценариев. Однако крупные проекты часто реализуют, используя парадигму объектно-ориентированного 
программирования (ООП). Что оно из себя представляет и какие преимущества дает?
<p>
В языке Python ООП играет ключевую роль. Даже программируя в рамках структурной парадигмы, вы все равно пользуетесь объектами 
и классами, пусть даже встроенными в язык, а не созданными лично вами.
<p>
Итак, что же такое объектно-ориентированное программирование?
<p>
Допустим, команда программистов занимается разработкой игры. Программу-игру можно представить как систему, состоящую из цифровых героев и среды их обитания, включающей множество предметов. Каждый воин, оружие, дерево, дом – это цифровой объект,
в котором "упакованы" его свойства и действия, с помощью которых он может изменять свои свойства и свойства других объектов.
<p>
Каждый программист может разрабатывать свою группу объектов. Разработчикам достаточно договориться только о том, как объекты будут взаимодействовать между собой, то есть об их интерфейсах. Пете не надо знать, как Вася реализует рост коровы в результате поедания травы. Ему, как разработчику лужайки, достаточно знать, что когда корова наклоняется к траве, последней на лужайке должно становиться меньше.
<p>
Ключевую разницу между программой, написанной с структурном стиле, и объектно-ориентированной можно выразить так. В первом случае, на первый план выходит логика, понимание последовательности выполнения действий для достижения поставленной цели. Во-втором – важнее представить программу как как систему объектов, взаимодействие которых способно решить ту или иную задачу.
<p>
Основными понятиями, используемыми в ООП, являются <b>класс, объект, наследование, инкапсуляция и полиморфизм</b>. В языке Python класс равносилен понятию тип данных.

<h4>Что такое класс или тип?</h4>
Проведем аналогию с реальным миром. Если мы возьмем конкретный стол, то это объект, но не класс. А вот общее представление о столах, их назначении – это класс. Ему принадлежат все реальные объекты столов, какими бы они ни были. Класс столов дает общую характеристику всем столам в мире, он их обобщает.
<p>
То же самое с целыми числами в Python. Тип int – это класс целых чисел. Числа 5, 100134, -10 и т. д. – это конкретные объекты этого класса.
<p>
В языке программирования Python объекты принято называть также экземплярами. Это связано с тем, что в нем все классы сами являются объектами класса type. Точно также как все модули являются объектами класса module.
<p>
Поэтому во избежании путаницы объекты, созданные на основе обычных классов, называют экземплярами.



<h3 align=center><a name="obiekt">Объект</h3>
В Python всё является объектами - строки, списки, словари, файлы, всё остальное.<br>
Объекты имеют  <b>атрибуты</b> и <b>методы</b>.<br>
Проверить является ли какое-то значение объектом, можно с помощью функции: <b>isinstance(var, object)</b>:
<pre>
isinstance(4, object)
True
>>> isinstance(Person, object)
True
>>> isinstance('stroka', object)
True
</pre>
<p>
Здесь object - является самым верхним объектом (надклассом) и поэтому все значения входят в object, но можно делать проверку на 
вхождение значения в какой-нибудь конкретный класс, например: a = Person() и isinstance(a, Person) вернёт True
<p>
Типы переменных (все что выводится через type(variable)) является встроенным классом в питоне. Например целые числа имеют тип или класс int. Строки принадлежат классу str.<br>
Чтобы создать экземпляр класса нужно выполнить var = name_class(). Пример:
<pre>
a = int()
a  # будет выведен 0 , так как по умолчанию создается объект класса  int равным 0
>>> s = str()
>>> s
''</pre>
Для строки по умолчанию создается пустая строка.
<ul>
<li> <b>Идентификатор объекта</b><br>
Каждый объект обладает своим уникальным идентификатором.<br>
Узнать идентификатор объекта можно с помощью функции id():
<pre>
>>> x = [1, 2, 3]
>>> id(x)
140705499364608
>>> id([1, 2, 3])
140705499676224</pre>
В данном примере создал два разных объекта x и [1, 2, 3]
<p>
<li> <b>Оператор is</b><br>
Также узнать ссылаются ли переменные на один и тот же объект (одинаковые идентификаторы) можно с помощью <b>оператора is</b>:
<pre>
>>> y = x
>>> y <b>is</b> x
True
>>> y is [1, 2, 3]
False</pre>
<p>

<li> <b>Изменяемые/неизменяемые  объекты</b><br>
В зависимости от того является ли объект изменяемым или нет, будет отличаться результат после выполнения операций с объектом:
<pre>
x = [1, 2, 3]
y = x
y.append(4)

s = "123"
t = s
t = t + "4"

print(str(x) + " " + s)</pre>
Будет выведено [1, 2, 3, 4] 123<br>
так как список является изменяемым объектом и изменив его через ссылку x, мы изменили его и для y. А строка является 
неизменяемым объектом, потому выполнив t = t + '4', мы создаем новый объект (место в памяти) для t, а s по-прежнему ссылается 
на свой объект '123'
<p>
Объекты бывают изменяемые и неизменяемые (англ. mutable и immutable). К неизменяемым относятся целые числа (int), числа с 
плавающей запятой (float), булевы значения (bool), строки (str), кортежи (tuple). К изменяемым — списки (list), множества 
(set), байтовые массивы (byte arrays) и словари (dict).
<p>
<li> <b>Тип объекта</b><br>
Каждый объект имеет свой тип.<br>
Тип объекта можно узнать с помощью функции type()<br>
Тип объекта определяет возможные значения объекта, его возможные методы.
<p>
<li> <b>Без ссылок новые объекты не создаются!</b>
<p>
Кешируются числа от -5 до 256 - т.е. при работе с этими числами Python обычно не будет создавать новый объект.
Так же кешируются строки, которые содержат только буквы, числа и нижнее подчеркивание.
Но это не гарантированное свойство, потому не нужно на это полагаться при проверке идентичности объектов.
<p>
Гарантированно в единствнном виде представлен (является синглтоном) из часто употребимых - None. С ним всегда используют для 
проверки оператор is, а не ==, т.к. он гарантированно будет в единственном экземпляре в памяти.


</ul>


<h3 align=center><a name="klass">Класс</h3>
<ul>
<li>
Объекты описываются не индивидуально, а с помощью классов. Класс - объект, являющийся шаблоном чертежём объекта.<br>
Объект, созданный на основе некоторого класса, называется <b>экземпляром класса</b>. Все объекты определенных пользователем 
классов являются экземплярами класса.
<p>
В языке программирования Python классы создаются с помощью инструкции class, за которой следует произвольное имя класса (первая 
буква всегда большая), после которого ставится двоеточие, далее с новой строки и с отступом реализуется тело класса:
<pre>
class ИмяКласса:
    код_тела_класса</pre>
Если класс является дочерним, то родительские классы перечисляются в круглых скобках после имени класса.
<p>
Класс определяет тип объекта, то есть его возможные состояния и набор операций.
<p>
Объект создается путем вызова класса по его имени. При этом после имени класса обязательно ставятся скобки:
<p>
<b>ИмяКласса()</b>
<p>
То есть класс вызывается подобно функции. Однако в случае вызова класса происходит не выполнение его тела, как это происходило 
бы при вызове функции, а создается объект. Поскольку в программном коде важно не потерять ссылку на только что созданный 
объект, то обычно его связывают с переменной. Поэтому создание объекта чаще всего выглядит так:
<p>
<b>имя_переменной = ИмяКласса()</b>
<p>
В последствии к объекту обращаются через связанную с ним переменную.
<p>
Пример "пустого" класса и двух созданных на его основе объектов:
<pre>
>>> class A:
...     pass
... 
>>> a = A()
>>> b = A()</pre>
<b>Класс как пространство имен</b><br>
С точки зрения пространства имен класс можно представить подобным модулю. Также как в модуле в классе могут быть свои 
переменные со значениями и функции. Также как в модуле у класса есть собственное пространство имен, доступ к которому возможен 
через имя класса:
<pre>
>>> class B:
...     n = 5
...     def adder(v):
...             return v + B.n
... 
>>> B.n
5
>>> B.adder(4)
9</pre>
Однако в случае классов используется особая терминология:<br>
Имена, определенные в классе, называются <b>атрибутами этого класса</b>.<br>
В примере имена n и adder – это атрибуты класса B.<br>
Атрибуты-переменные часто называют <b>полями или свойствами</b><br> 
(в других языках понятия "поле" и "свойство" не совсем одно и то же). Полем является n.<br>
Атрибуты-функции называются <b>методами</b>.<br>
Методом в классе B является adder. Количество свойств и методов в классе может быть любым.
<p>
<b>Класс как шаблон для создания объектов</b><br>
На самом деле классы – не модули. Они своего рода шаблоны, от которых создаются объекты-экземпляры. Такие объекты наследуют от 
класса его атрибуты. Вернемся к нашему классу B и создадим на его основе два объекта:
<table border=1><tr><td>
<pre>
>>> class B:
...     n = 5
...     def adder(v):
...             return v + B.n
... 
>>> a = B()
>>> b = B()</pre></td></tr></table>
У объектов, связанных с переменными a и b, нет собственного поля n. Однако они наследуют его от своего класса:
<pre>
>>> a.n
5
>>> a.n is B.n
True</pre>
То есть поля a.n и B.n – это одно и то же поле, к которому можно обращаться и через имя a, и через имя b, и через имя класса. 
Поле одно, ссылок на него три.
<p>
<b>Однако что произойдет в момент присваивания полю n значения через какой-нибудь объект-экземпляр?</b>
<pre>
>>> a.n = 10
>>> a.n
10
>>> b.n
5
>>> B.n
5</pre>
В этот момент у экземпляра a появляется собственный атрибут n, который перекроет (переопределит) родительский, то есть тот, 
который достался от класса.
<pre>
>>> a.n is B.n
False
>>> b.n is B.n
True</pre>
При этом присвоение через B.n отразится только на b и B, но не на a:
<pre>
>>> B.n = 100
>>> B.n, b.n, a.n
(100, 100, 10)</pre>
<p>
<b>Как применить метод к экземпляру класса?</b><br>
Иная ситуация нас ожидает с атрибутом adder. При создании объекта от класса функция adder не наследуется как есть, а как бы 
превращается для объекта в одноименный метод:
<pre>
>>> B.adder is b.adder
False
>>> type(B.adder)
&lt;class 'function'&gt;
>>> type(b.adder) 
&lt;class 'method'&gt;</pre>
Через имя класса мы вызываем функцию adder:
<pre>
>>> B.adder(33)
133</pre>
Через имя объекта вызываем метод adder:
<pre>
>>> b.adder(33)
Traceback (most recent call last):
  File "<stdin>", line 1, in &lt;module&gt;
TypeError: adder() takes 1 positional 
argument but 2 were given</pre>
В сообщении об ошибке говорится, что adder принимает только один аргумент, а было передано два. Откуда появился второй, если в скобках было указано только одно число?
<br>Дело в том, что в отличии от функции <b>в метод первым аргументом всегда передается объект, к которому применяется этот 
метод</b>. То есть выражение b.adder(33) как бы преобразовывается в adder(b, 33). Сам же b.adder как объект типа method хранит 
сведения, с каким классом он связан и какому объекту-экземпляру принадлежит:
<pre>
>>> b.adder
&lt;bound method B.adder of 
&lt;__main__.B object at 0x7fcbf1ab9b80&gt;&gt;</pre>
В нашем случае, чтобы вызывать adder через объекты-экземпляры, класс можно переписать так:
<pre>
>>> class B:
...     n = 5
...     def adder(obj, v):
...             return v + obj.n
... 
>>> b = B()
>>> b.adder(33)
38</pre>
В коде выше при вызове метода adder переменной-параметру obj присваивается объект, связанный с переменной, к которой 
применяется данный метод. В данном случае это объект, связанный с b. Если adder будет вызван на другой объект, 
то уже он будет присвоен obj:
<pre>
>>> a = B()
>>> a.n = 9
>>> a.adder(3)
12</pre>
<b>В Python переменную-параметр метода, которая связывается с экземпляром своего класса, принято называть именем self.</b><br>
Таким образом, более корректный код будет таким:
<pre>
>>> class B:
...     n = 5
...     def adder(self, v):
...             return v + self.n</pre>

Можем ли мы все также вызывать adder как функцию, через имя класса? Вполне. Только теперь в функцию 
надо передавать два аргумента:
<pre>
>>> B.adder(B, 200)
205
>>> B.adder(a, 200)
209</pre>
Здесь первым аргументом в функцию передается объект, у которого есть поле n лишь только потому, что далее к этому полю 
обращаются через выражение self.n.
<p>
<b>При описании класса и внутри методов в теле метода  обращения к полям идут в виде self.поле = поле</b>


<h4>Атрибут __dict__</h4>
В Python у объектов есть встроенные специальные атрибуты. Мы их не определяем, но они есть. Одним из таких атрибутов объекта 
является свойство __dict__. Его значением является словарь, в котором ключи – это имена свойств экземпляра (переменные - 
атрибуты), а значения – текущие значения свойств.
<pre>
>>> class B:
...     n = 5
...     def adder(self, v):
...             return v + self.n
... 
>>> w = B()
>>> w.__dict__
{}
>>> w.n = 8
>>> w.__dict__
{'n': 8}</pre>
В примере у экземпляра класса B сначала нет собственных атрибутов. Свойство n и метод adder – это атрибуты объекта-класса, а не 
объекта-экземпляра, созданного от этого класса. Лишь когда мы выполняем присваивание новому полю n экземпляра, у него 
появляется собственное свойство, что мы наблюдаем через словарь __dict__.
<p>
В следующем уроке мы увидим, что свойства экземпляра обычно не назначаются за пределами класса. Это происходит в методах 
классах путем присваивание через self. Например, self.n = 10.
<p>
Атрибут __dict__ используется не только для просмотра свойств объекта. С его помощью можно удалять, добавлять свойства, а также 
изменять их значения.
<pre>
>>> w.__dict__['m'] = 100
>>> w.__dict__
{'n': 8, 'm': 100}
>>> w.m
100</pre>


<b>Пример:</b><br>
Пусть в ходе анализа данной предметной области необходимо определить класс Граф. Граф - это множество вершин и набор ребер, 
попарно соединяющий эти вершины. Над графом можно проделывать операции, такие как добавление вершины, ребра, проверка наличия 
ребра в графе и т.п. На языке Python определение класса может выглядеть так:
<pre>
from sets import Set as set  # тип для множества

class G:
  def __init__(self, V, E):
    self.vertices = set(V)
    self.edges = set(E)

  def add_vertex(self, v):
    self.vertices.add(v)

  def add_edge(self, (v1, v2)):
    self.vertices.add(v1)
    self.vertices.add(v2)
    self.edges.add((v1, v2))

  def has_edge(self, (v1, v2)):
    return (v1, v2) in self.edges

  def __str__(self):
    return "%s; %s" % (self.vertices, self.edges)</pre>
Использовать класс можно следующим образом:
<pre>
g = G([1, 2, 3, 4], [(1, 2), (2, 3), (2, 4)])

print g
g.add_vertex(5)
g.add_edge((5,6))
print g.has_edge((1,6))
print g</pre>
что даст в результате:
<pre>
Set([1, 2, 3, 4]); Set([(2, 4), (1, 2), (2, 3)])
False
Set([1, 2, 3, 4, 5, 6]); Set([(2, 4), (1, 2), (5, 6), (2, 3)])</pre>
Как видно из предыдущего примера, определить класс не так уж сложно. Конструктор класса имеет специальное имя __init__. 
(Деструктор здесь не нужен, но он бы имел имя __del__.)<br>
Методы класса определяются в пространстве имен класса.<br>
В качестве первого формального аргумента метода принято использовать self.<br>
Кроме методов в объекте класса имеются два атрибута: vertices (вершины) и edges (ребра).<br>
Для представления объекта G в виде строки используется специальный метод __str__().
<p>
Принадлежность классу можно выяснить с помощью встроенной функции isinstance():
<pre>print isinstance(g, G)</pre>


<a name="konstrukt"><h4>Конструктор класса</h4>
Исполнение конструктора класса начинается в момент создания нового объекта этого класса. Конструктор является специальным 
методом, который обязательно вызывается при создании объекта. <b>Он отвечает за инициализацию переменных и установку начальных 
значений для нового экземпляра класса.</b> Конструктор вызывается автоматически при создании объекта и возвращает готовый к 
использованию экземпляр класса.
<p>
Конструкторы позволяют задать некие характеристики для объекта сразу же при его создании. К примеру, у вас есть несколько 
переменных, которые точно должен иметь объект. Вы можете создать конструктор и указать несколько параметров, которые будут 
переданы при создании объекта. 
<p>
В одном классе может быть неограниченное количество конструкторов и сам интерпретатор будет понимать к какому конструктору вы 
обращаетесь. Чтобы создать конструктор необходимо использовать ключевое слово <b>__init__</b>.
<p>
Вот пример, который демонстрирует использование метода __init__():
<pre>
class Person:

    def __init__(self, name, age):

        self.name = name

        self.age = age

    def introduce(self):

        print("Привет, меня зовут", self.name, "и мне", self.age, "лет.")

person1 = Person("Алиса", 25)

person1.introduce()
</pre>
В этом примере у нас есть класс Person, у которого есть метод __init__() и метод introduce().<br>
Метод __init__() принимает два параметра: name и age.<br>
Внутри метода __init__() мы присваиваем значения этих параметров атрибутам self.name и self.age соответственно.<br>
При создании нового экземпляра класса Person и передаче имени и возраста в качестве аргументов, метод __init__() автоматически 
вызывается и инициализирует атрибуты объекта.<br>
Затем мы можем вызывать метод introduce(), который использует значения атрибутов name и age для вывода информации о человеке. 
Вывод программы будет следующим: Привет, меня зовут Алиса и мне 25 лет.<br>
Таким образом, метод __init__() позволяет задать начальные значения атрибутов объекта класса во время его создания. Он играет 
важную роль в инициализации объектов и предоставляет возможность установить начальное состояние объекта.
<p>
Если вы определите метод с другим названием, а не __init__(), и используете его для инициализации атрибутов объекта, то при 
создании экземпляра класса вам нужно будет вызвать этот метод явно. Вот пример кода, где используется метод blabla() для 
инициализации атрибутов объекта:
<pre>
class Person:

    def blabla(self, name, age):

        self.name = name

        self.age = age

    def introduce(self):

        print("Привет, меня зовут", self.name, "и мне", self.age, "лет.")

person1 = Person()

person1.blabla("Алиса", 25)

person1.introduce()</pre>
В этом примере мы создаем экземпляр класса Person без вызова метода __init__(). Вместо этого мы вызываем метод blabla() и 
передаем аргументы "Алиса" и 25, которые инициализируют атрибуты объекта name и age. Затем мы вызываем метод introduce(), 
который использует значения атрибутов name и age для вывода информации о человеке. Вывод программы будет следующим: Привет, 
меня зовут Алиса и мне 25 лет. Таким образом, вы можете использовать метод с любым другим названием, чтобы инициализировать 
атрибуты объекта. Однако, важно помнить, что вам нужно будет вызвать этот метод явно при создании экземпляра класса.
<p>
В Python, параметр self используется в методах класса для ссылки на сам объект (экземпляр класса), для которого вызывается 
метод. Он является обязательным параметром в определении методов класса.
<p>
Параметр self позволяет обращаться к атрибутам и методам объекта внутри самого класса. Он представляет собой ссылку на сам 
экземпляр класса, с помощью которого можно получить доступ к его атрибутам и вызвать его методы.
<p>
Если не использовать параметр self в методах класса, то не будет возможности получить доступ к атрибутам и методам объекта. 
Без использования self, метод не будет знать, какой объект класса обрабатывается, и будет вызвана ошибка.
<br><font color=red>TypeError: introduce() takes 0 positional arguments but 1 was given</font>
</ul>

<h3 align=center><a name="наследование">Наследование, инкапсуляция и полиморфизм</h3>
Помимо классов и объектов, ООП содержит дополнительные три основные концепции: <b>наследование, инкапсуляция и полиморфизм</b>. 
<ol>
<li> <b>Наследование</b><br>
За счёт наследования можно создать один общий класс (класс родитель) и создать множество других классов (классы наследники), 
что будут наследовать все поля, методы и конструкторы из главного класса.
<p>
<b>Зачем использовать наследование?</b><br>
Предположим что у нас есть один большой класс «Транспорт». В классе описываются базовые характеристики для всех транспортных 
средств:
<p>
поля: скорость, вес, запас хода и тому подобное;<br>
методы: получение информации из полей, установка новых значений;<br>
конструктор: пустой и по установке всех полей.<br>
<p>
На основе класса мы спокойно можем создать объект легковой машины, объект грузовика, объект самолета и так далее. У всех 
объектов будут одинаковые характеристики и методы. 
<p>
Мы явно понимаем, что у объекта машина и самолёт будут разные поля и характеристики. Как можно поступить:
<p>
Можно создать два отдельных класса: «Car» и «Airplane». В каждом классе будут все методы, поля и конструкторы повторно 
переписанные из класса «Транспорт», а также будут новые методы, что важны только для конкретного класса;
Можно создать два класса наследника: «Car» и «Airplane». Оба класса будут наследовать всё от класса «Транспорт» и при этом 
будут содержать свои дополнительные функции. Таким образом повторения кода не будет и код станет меньше и чище.
<p>
<b>Создание классов наследников</b><br>
Для создания класса наследника требуется создать класс и указать наследование от главного класса.
<p>
Пример класса наследника:
<pre>
class Cars:
	wheels = 4 # Общее значение для всех объектов,
	# так как все машины имеют колеса
		
class BMW (Cars):
	is_m_serias = true # Является ли модель "М" серии?
	# Переменная нужна только в классе BMW</pre>
<p>
Основное (но не единственное) преимущество, которое дает концепция наследования в программировании, – это вынос одинакового 
кода из разных классов в один родительский класс. Другими словами, наследование позволяет сводить на нет повторение кода в 
разных частях программы.
<p>
Для определения является ли класс B наследником класса A (или A - родитель для B) служит функция issubclass(child, parent):
<p> 
issubclass(B, A)<br>
вернёт True, если класс B является потомком класса A, иначе False.<br>
Самым верхним классом, который не имеет родителя (надкласса) является <b>objekt</b>.<br>
<font color=red>Странно, почему issubclass(int, objekt) выдает ошибку, как и type(objekt)?</font>
<p>
<b>Множественное наследование</b><br>
Для ответа на вопрос в каком порядке будет искаться метод в нескольких классах, служит функция mro():
<pre>Name_class.mro()</pre>
выдаст список из Name_class и родительских классов в порядке в каком будет искаться какой-нибудь метод. Этот порядок равен 
порядку в каком родительские классы указаны в качестве аргументов (в скобках) при объявлении Name_class.
<p>
Конкретный пример:
<pre>
>>> int.mro()
[&lt;class 'int'&gt;, &lt;class 'object'&gt;]</pre>

<h4>Функция super()</h4>
super() - это функция, которая позволяет вызывать методы родительского класса в дочернем классе. Она используется, когда нужно 
вызвать методы родительского класса в дочернем классе, чтобы избежать дублирования кода и улучшить его читаемость.
<p>
Функция super() можно использовать для вызова методов как в методах, так и в конструкторах дочернего класса.
<p>
<b>Как работает функция super() в Python?</b><br>
Когда мы создаем дочерний класс, он наследует все атрибуты и методы родительского класса. Для того, чтобы вызвать метод 
родительского класса, мы можем использовать функцию super().
<p>
При вызове super() Python ищет родительский класс в иерархии наследования, начиная с текущего класса и переходя к родительским 
классам в порядке, заданном в списке наследования. После нахождения родительского класса, super() вызывает его методы и 
передает все аргументы, которые были переданы методу дочернего класса.
<p>
Пример использования super() в Python
Рассмотрим пример, который показывает, как использовать super() для вызова метода родительского класса.
<pre>
class Animal:
    def __init__(self, name):
        self.name = name

    def make_sound(self):
        print("The animal makes a sound")

class Dog(Animal):
    def __init__(self, name):
        super().__init__(name)

    def make_sound(self):
        super().make_sound()
        print("The dog barks")

my_dog = Dog("Buddy")
my_dog.make_sound()</pre>
В этом примере у нас есть два класса: Animal и Dog. Класс Dog наследует от Animal.
<p>
Мы переопределяем метод make_sound() в классе Dog, но вместо того, чтобы полностью переписывать метод, мы вызываем метод 
make_sound родительского класса с помощью super(), а затем добавляем к нему свой код.
<p>
Результат выполнения этого кода будет:
<pre>
>>> The animal makes a sound
>>> The dog barks</pre>
В этом примере мы вызываем метод make_sound() родительского класса с помощью super(), а затем добавляем к нему свой код, чтобы 
сделать ту же самую вещь, но с дополнительным функционалом.
<p>
<b>Синтаксис:</b><br>
Если <b>super().metod()</b> то metod() будет браться с родительского класса в порядке аргументов текущего класса.
<p>
Если <b>super(Name_class, self).metod()</b> то metod() будет искаться в родительском классе для класса Name_class.

<h4>Правило наследования:</h4>
если среди родителей класса - два класса, которые являются прямыми "родственниками", причём "родитель" перечислен до "потомка" 
- то возникает ошибка.  Потому, как - вроде программист определяет такой  порядок, а MRO предусматривает обратный (т.е. сначала 
"потомки" - потом "родители").
<p>
<li> <b>Полиморфизм</b><br>
Полиморфизм позволяет изменять функции в классах наследниках. Пример:
<pre>
class Cars:
	def nothing(self): # Пустая функция
		pass
		
class BMW (Cars):
	def nothing(self, word):
		print (word + "!") # Функция теперь будет работать по новому
 
a = BMW()
a.nothing("Some")</pre>
<p>
Полиморфизм можно перевести как множество форм. В ООП под полиморфизмом понимается следующее. Объекты разных классов, с разной 
внутренней реализацией, то есть программным кодом, могут иметь "одинаковые" методы. На самом деле у методов совпадают только 
имена, а вложенный в них код (то, что они делают) различен. Вот и получается, что у одного имени как бы множество форм.
<p>
Полиморфизм полезен не только тем, что дает возможность объектам пользовательских классов участвовать в стандартных операциях. 
Если у объектов разных классов есть одноименный метод, то коллекция таких разнородных объектов может быть обработана в одном 
цикле.

<p>
<li> <b>Инкапсуляция</b><br>
Обычно считается, что без инкапсуляции невозможно представить себе ООП, что это ключевое понятие. История развития методологий 
программирования движима борьбой со сложностью разработки программного обеспечения. Сложность больших программных систем, в 
создании которых участвует сразу большое количество разработчиков, уменьшается, если на верхнем уровне не видно деталей 
реализации нижних уровней. Собственно, процедурный подход был первым шагом на этом пути. Под инкапсуляцией (encapsulation, что 
можно перевести по-разному, но на нужные ассоциации хорошо наводит слово "обволакивание") понимается сокрытие информации о 
внутреннем устройстве объекта, при котором работа с объектом может вестись только через его общедоступный (public) интерфейс. 
Таким образом, другие объекты не должны вмешиваться в "дела" объекта, кроме как используя вызовы методов.
<p>
В языке Python инкапсуляции не придается принципиального значения: ее соблюдение зависит от дисциплинированности программиста. 
В других языках программирования имеются определенные градации доступности методов объекта.
<p>
Инкапсуляция позволяет ограничить доступ к какой-либо функции в классе. Благодаря такому подходу злоумышленники или же мы сами 
не сможем случайно или намерено вызвать или изменить метод.
<p>
Пример:
<pre>
class Some:
	def _printWords(self):
		print ("Попробуй меня вызвать")

obj = Some()
obj._printWords() # Вызов функции ничего не даст</pre>
При помощи двойного подчеркивания эффект защиты усиливается, поэтому вызвать функцию будет невозможным.
</ol>




<h3 align=center><a name="iterator">Создание итерируемого класса</a></h3>
Итерирование чего-то - это значит это что-то можно перебирать по элементам, как в цикле for.
<p>
<b><a href="https://docs.python.org/3/library/stdtypes.html#iterator-types">Перевод документации</a>:</b>
<p>
<i><b>Итератор</b> - Объект, означающий поток данных. Повторные вызовы метода __next__() от итератора (или передача итератору 
встроенной функции next()) возвращают последовательные элементы в потоке. Когда больше нет доступных данных, возникает 
исключение StopIteration. На этом этапе объект iterator исчерпан, и любые дальнейшие вызовы его метода __next__() 
просто снова вызовут StopIteration.
<p>
Итераторы должны иметь метод __iter__(), который возвращает сам объект iterator. Объект-контейнер (например, список) создает 
новый итератор каждый раз, когда вы передаете его функции iter() или используете в цикле for.</i>
<p>
Python поддерживает концепцию итерации по контейнерам. Это реализовано с использованием двух методов; они 
используются для того, чтобы позволить определяемым пользователем классам поддерживать итерацию.
<p>
Для объектов-контейнеров должен быть определен один метод, обеспечивающий итеративную поддержку:
<p>
<b>container.__iter__()</b><br>
Возвращает объект iterator. Объект необходим для поддержки протокола iterator, описанного ниже.
<p>
Сами объекты iterator необходимы для поддержки следующих двух методов, которые вместе образуют протокол iterator:
<p>
<b>итератор.__iter__()</b><br>
Возвращает сам объект iterator. Это необходимо для того, чтобы разрешить использование как контейнеров, так и итераторов с 
операторами for и in.
<p>
<b>iterator.__next__()</b><br>
Возвращает следующий элемент из итератора. Если больше нет элементов, вызовите исключение StopIteration.
<p>
<table border=1>
<tr><td valign=top>
Обычный цикл:
<pre>
books = ["111", "222", "333"]
>>> for book in books:
...  print(book)
</pre>
</td>
<td>
Этот же цикл через встроенные функции iter() и next():
<pre>
books_iterator = iter(books)
  while True:
    try:
       book = next(books_iterator)
    except StopIteration:
       break
    print(book)</pre>
</td>
<td>
Тот же код с помощью методов:
<pre>
books_iterator = books.__iter__()
  while True:
    try:
       book = books_iterator.__next__()
    except StopIteration:
       break
    print(book)
</pre>
</td>
</tr></table>
<p>
Видим: у типа list есть метод __iter__, который возвращает объект. Этот объект, в свою очередь, имеет метод __next__, который 
возвращает, по одному, элементы списка books и поднимает StopIteration, когда этих элементов больше нет. Еще этот объект тоже 
имеет метод __iter__, который возвращает его самого:
<pre>
>>> books = ["111", "222", "333"]
>>> books
['111', '222', '333']
>>> type(books)
&lt;class 'list'&gt;
>>> books_iterator = books.__iter__()
>>> books_iterator
&lt;list_iterator object at 0x7fbf0e732820&gt;
>>> type(books_iterator)
&lt;class 'list_iterator'&gt;
>>> books_iterator.__iter__() is books_iterator
True</pre>
Вместе __iter__ и __next__ составляют протокол итератора. Так вот, объект класса, соблюдающего этот протокол, называется 
<b>итератором (iterator)</b>. Объект класса, который реализует метод __iter__, называется <b>итерируемым (iterable)</b>. В 
данном случае:<br>
books_iterator – итератор,<br>
books – итерируемое.
<p>
Роль метода __next__ заключается в том, чтобы задавать порядок обхода итерируемого (не обязательно делать этот порядок строго 
от первого к последнему). Метод __iter__ нужен для того, чтобы итератор и итерируемое могли использоваться с оператором in:
<pre>
>>> books_iterator = iter(books)
>>> for book in books_iterator:
...  print(book)</pre>


<h4>Как сделать итератор из класса</h4>
Вот так выглядит итератор, который обходит список, начиная с последнего элемента и заканчивая первым:
<table border=1><tr><td>
<pre>
class ReverseIt():
    def __init__(self, reverse_me):
        self.reverse_me = reverse_me
        self.current_index = len(reverse_me) - 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.current_index < 0:
            raise StopIteration()
        current_element = self.reverse_me[self.current_index]
        self.current_index -= 1
        return current_element</pre>
</td></tr></table>        
И вот так его можно использовать:
<pre>
>>> reverse_books_iterator = ReverseIt(books)
>>> for book in reverse_books_iterator:
...  print(book)
</pre>
Мы написали именно reverse_books_iterator = ReverseIt(books), а не reverse_books_iterator = iter(books). Последнее вернет нам обычный итератор. Но мы могли бы так написать, если бы у списка метод __iter__ был определен так:
<pre>
def __iter__(self):
    return ReverseIt(self)</pre>
<p>
Создадим класс, основанный на типе данных lsit, экземпляры которого будут итерироваться парами.
<pre>
# Сначала создадим итератор, в котором определим метод next и условие окончания итерации
class DoubleElementListIterator:
    # В init определим атрибуты итератора на основе значений которых будет работать метод next 
    def __init__(self, lst):
        # Прежде всего передадим итератору в качестве атрибута сам итерируемый список
        self.lst = lst
        # Затем опредилм атрибут - номер текущего элемента в листе
        self.i = 0
    # Прописываем правило итерирования и остановки
    def __next__(self):
        # Если счетчик итераций не дошел до последнего элемента листа, 
        # то в качестве следующего значения вернем пару из двух элементов стоящих после текущего:
        if self.i < len(self.lst):
            self.i += 2
            return self.lst[self.i - 2], self.lst[self.i - 1]
        # если достигнут последний элемент в листе останавливаем итерацию
        else:
            raise StopIteration

# Теперь создаем класс, экземпляры которого мы хотим итерировать итератором (способом) описанным выше            
class MyList(list):
    # Определяем метод итератор, который ссылается на уже описанный итератор        
    def __iter__(self):
        return DoubleElementListIterator(self)

for pair in MyList([1, 2, 3, 4, 5, 6]):
    print(pair)</pre>
<p>
Резюме:
<ul>
<li> Итерируемое – объект, у которого есть метод __iter__ и он возвращает итератор.
<li> Итератор – объект, у которого есть методы __iter__ и __next__.
<li> Эти методы называют “магическими”, они часто используются в синтаксических конструкциях вроде for ... in ....
</ul>


<h3 align=center>Генераторы - итераторы</h3>
Создание итератора в Python — достаточно громоздкая операция. Для этого нужно написать класс и реализовать методы __iter__() и 
__next__(). После этого требуется настроить внутренние состояния и вызывать исключение StopIteration, когда больше нечего 
возвращать.
<p>
Генераторы служат для той же цели, что и итераторы, но код для их описания меньше.<br>
Генераторы предоставляют удобный способ реализации протокола iterator. Если метод __iter__() объекта контейнера 
реализован как генератор, он автоматически вернет объект-итератор (технически, объект-генератор), предоставляющий методы 
__iter__() и __next__().
<p>
Генераторы создают с помощью функции или выражения.
<p>
Генератор — это объект, который сразу при создании не вычисляет значения всех своих элементов.
<br>Он хранит в памяти только последний вычисленный элемент, правило перехода к следующему и условие, при котором выполнение 
прерывается.
<br>Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется.
<p>
Этим генераторы отличаются от списков — те хранят в памяти все свои элементы, и удалить их можно только программно. Вычисления 
с помощью генераторов называются ленивыми, они экономят память.
<pre>
>>> alist = [4, 16, 64, 256]
>>> alist
[4, 16, 64, 256]
>>> out = (a**(1/2) for a in alist)
>>> out
&lt;generator object &lt;genexpr&gt; at 0x7fc6cc244ba0&gt;
>>> print(out)
&lt;generator object &lt;genexpr&gt; at 0x7fc6cc244ba0&gt;
>>> print(next(out))
2.0
>>> print(list(out))
[4.0, 8.0, 16.0]
>>> alist
[4, 16, 64, 256]
>>> out
&lt;generator object &lt;genexpr&gt; at 0x7fc6cc244ba0&gt;
>>> print(list(out))
<font color=red>[]</font> # не очень понятно почему пустой список
>>> out = (a**(1/2) for a in alist) # создаем новый генератор
>>> out
&lt;generator object &lt;genexpr&gt; at 0x7fc6cc244c10&gt; # новый генератор
>>> print(list(out)) # выводим список с текущего указателя генератора и указатель остановится за пределы списка
[2.0, 4.0, 8.0, 16.0]
>>> print(list(out))
[]</pre>
Здесь помоему генератор это типа указатель на текущий элемент итерируемого объекта с последнего вызова генератора.
<p>
Чтобы освоить yield, вы должны понимать, что когда вы вызываете функцию, код внутри тела функции не исполняется. Функция 
только возвращает объект-генератор — немного мудрёно :-)
<p>
Ваш код будет вызываться каждый раз, когда for обращается к генератору.
<p>
Теперь трудная часть:
<br>В первый запуск вашей функции, она будет исполняться от начала до того момента, когда она наткнётся на yield — тогда она 
вернёт первое значение из цикла. На каждый следующий вызов будет происходить ещё одна итерация написанного вами цикла, 
возвращаться будет следующее значение — и так пока значения не кончатся.



<h4>Создание генератора с помощью выражения</h4>
Как и выражения создающие списки, выражения создающие генераторы позволяют быстро получить объект генератора с помощью всего 
одной строчки кода. Использоваться они могут в тех же случаях, что и выражения создающие списки, но при этом у них есть одно 
дополнительное преимущество. Их можно создавать не удерживая весь объект в памяти перед итерацией. Если перефразировать, вы не 
будете расходовать память при использовании генератора.
<p>
Возьмем возведение в квадрат некоторых чисел:
<pre>
nums_squared_lc = [num**2 for num in range(5)]
nums_squared_gc = (num**2 for num in range(5))</pre>
И nums_squared_lc, и nums_squared_gc выглядят практически одинаково, но есть одно ключевое отличие. Вы сможете его заметить? 
Для первого объекта использовались квадратные скобки и это привело к созданию списка. Для второго использовались круглые 
скобки, и это привело к созданию генератора. Посмотрите, что произойдет, если мы выведем содержание каждого из этих объектов:
<pre>
nums_squared_lc
[0, 1, 4, 9, 16]
nums_squared_gc
&lt;generator object &lt;genexpr&gt; at 0x107fbbc78&gt;</pre>
Это подтверждает тот факт, что с помощью круглых скобок вы создали объект генератора, а также то, что он отличается от списка.

<h4>Генераторы с помощью функций</h4>
От обычных функций отличаются наличием вместо return слова yield.<br>
yield выполняет функцию next() возвращая следующий элемент из перебираемого класса.
<p>









<h3 align=center><a name="modul" href="https://pyplanet.ru/article/import.html">Импорт и создание модулей</a></h3>
<b>Модулем</b> в Python называется любой файл с программой.
<p>
Каждая программа может подключить модуль и получить доступ к его классам, функциям и объектам.
<p>
Модуль может быть написан не только на Python, но и, например, на C или C++.
<p>
К примеру, модуль math написан как раз на C и имеет интерфейс для вызова из Python.

<h4>Пакеты</h4>
В языке Python набор модулей, посвященных одной проблеме, можно поместить в <b>пакет</b>. Хорошим примером такого пакета 
является пакет xml, в котором собраны модули для различных аспектов обработки XML. Пакеты также как и модули можно 
импортировать и выполнять его функции. Если модуль - это файл, то пакет - это папка. В отличии от обычной папки в пакете 
должен находиться файл __init__

<p>
В программе на Python модуль представлен объектом-модулем, атрибутами которого являются имена, определенные в модуле:
<pre>
>>> import datetime
>>> d1 = datetime.date(2004, 11, 20)</pre>
В данном примере импортируется модуль datetime. В результате работы оператора import в текущем пространстве имен появляется 
объект с именем datetime.
<p>
Модули для использования в программах на языке Python по своему происхождению делятся на обычные (написанные на Python) и 
модули расширения, написанные на другом языке программирования (как правило, на C). С точки зрения пользователя они могут 
отличаться разве что быстродействием. Бывает, что в стандартной библиотеке есть два варианта модуля: на Python и на C. Таковы, 
например, модули pickle и cPickle. Обычно модули на Python в чем-то гибче, чем модули расширения.
<p>
Модуль оформляется в виде отдельного файла с исходным кодом. Стандартные модули находятся в каталоге, где их может найти 
соответствующий интерпретатор языка.<br>
При импорте модуля интерпретатор Python пытается найти модуль в следующих местах:
<ul>
<li> Директория, где находится файл, в котором вызывается команда импорта.

<li> Директория, определённая в консольной переменной PYTHONPATH (если модуль не найден с первого раза).

<li> Путь, заданный по умолчанию (если модуль не найден в предыдущих двух случаях).
</ul>
Путь поиска сохраняется в переменной path в системном модуле sys. Переменная sys.path включает в себя все три вышеописанных места поиска.<br>
<img src="./images/python_base2.png">
<p>
Чтобы получить полный список модулей, установленных на ПК, используют команду help("modules") или по конкретному модулю атрибуты: help("name_modul")


<p>
Чтобы получить доступ к функциям из модуля, его необходимо импортировать. Сделать это можно несколькими способами:
<h4>Инструкция import</h4>
После ключевого слова import указывается название модуля.<br>
Название модуля - это имя файла без расширения.
<p>
Одной инструкцией можно подключить несколько модулей (для этого они указываются через запятую), хотя это не рекомендуется 
делать, так как снижает читаемость кода. Импортируем модуль math:
<pre>import math</pre>
После импортирования модуля его название становится переменной, через которую можно получить доступ к атрибутам (функциям) 
модуля. Например чтобы вычислить синус числа импортируем сначало модуль (математическую библиотеку) math и после этого можем 
использовать его функцию sin:
<pre>
>>> import math
>>> math.sin(1)
0.8414709848078965</pre>
Стоит отметить, что если указанный атрибут модуля не будет найден, возникнет исключение AttributeError. А если не удастся найти модуль для импортирования, то ModuleNotFoundError.
<p>
<i>При импортировании модуля, он сразу выполняется. И его имя прописывается в ключе словаря sys.path (python теперь знает этот модуль). Если повторно этот модуль импортировать, то ничего не произойдет и выполняться не будет.</i>

<h4>Использование псевдонимов</h4>
Если название модуля слишком длинное, или оно вам не нравится по каким-то другим причинам, то для него можно создать 
псевдоним, с помощью ключевого слова as.
<pre>
>>> import math as m
>>> m.sin(1)
0.8414709848078965</pre>
Теперь доступ ко всем атрибутам модуля math осуществляется только с помощью переменной m, а переменной math в этой программе 
уже не будет (если, конечно, вы после этого не напишете import math, тогда модуль будет доступен как под именем m, так и под 
именем math).
<h4>Инструкция from ... import ...</h4>
Подключить только определенные атрибуты (функции) модуля, а не полностью весь модуль можно с помощью инструкции from:
<pre><b>from &lt;Название модуля&gt; import &lt;Атрибут 1&gt; [ as &lt;Псевдоним 1&gt; ], [&lt;Атрибут 2&gt; [ as 
&lt;Псевдоним 2&gt; ] ...]</b></pre>
Эта инструкция позволяет подключить из модуля только указанные вами атрибуты. При этом сам модуль не записывается в 
переменную, а в глобальную область видимости добавляются те функции и объекты, которые вы импортировали. Для длинных имён 
также можно назначить псевдоним, указав его после ключевого слова as.
<pre>
>>> from math import sin, ceil as c
>>> sin(1)
0.8414709848078965
>>> c(4.6)
5</pre>
Импортируемые атрибуты можно разместить на нескольких строках, если их много, для лучшей читаемости кода:
<pre>
from math import (
    sin, cos,
    tan, atan
)</pre></pre>
<h4>Инструкция from ... import *</h4>
Второй формат инструкции from позволяет подключить все (точнее, почти все) переменные из модуля.
<p>
Данным способом импортируются только атрибуты, определённые в переменной __all__ у модуля (если создатель модуля об этом 
побеспокоился). Или только те атрибуты, которые не начинаются с _ (это соглашение о "скрытых" переменных, его мы рассмотрим в 
дальнейших лекциях).
<pre>from math import *</pre>
С данным способом нужно быть крайне аккуратным. Имена в модуле, совпадающие с именами в главной программе, во время импорта инструкцией from будут перезаписаны (и наоборот, переменные в главной программе будут перезаписывать функции с такими же названиями из импортированного модуля). И в целом, забивать пространство имён - не самая удачная идея.
<h4>Создание своего модуля на Python</h4>
Теперь пришло время создать свой модуль. Это можно сделать, просто создав файл с программой, например, назовём его mymodule.py, в котором определим какую-нибудь функцию:
<pre>
def hello():
    print('Hello, world!')</pre>
Теперь в этой же папке создадим другой файл, например, main.py:
<pre>
import mymodule

mymodule.hello()</pre>
Выведет Hello, world!.
<p>
Иии... это всё! Вы сделали свой модуль! В конце отвечу на несколько вопросов, связанных с созданием модулей.
<p>
Можно ли использовать модуль как самостоятельную программу?<br>
Можно. Однако следует помнить, что при импортировании модуля его код выполняется полностью, то есть, если программа что-то печатает, то при её импортировании это будет напечатано.
<p>
Подобного эффекта можно избежать, если проверять, запущен ли скрипт как программа, или импортирован. Это можно сделать с помощью магической переменной __name__, которая определена в любой программе, и равна "__main__", если скрипт запущен в качестве главной программы, и имя модуля, если он импортирован. Например, mymodule.py может выглядеть вот так:
<pre>
def hello():
    print('Hello, world!')

if __name__ == "__main__":
    hello()</pre>
<b>Как назвать модуль?</b><br>
Помните, что вы (или другие люди) будут его импортировать и использовать в качестве переменной.
<p>
Модуль нельзя именовать так же, как и ключевое слово:
<pre>
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield</pre>
Имена модулей нельзя начинать с цифры
<p>
Не нужно называть модуль также, как какую-либо из встроенных функций. Технически так сделать, конечно, можно, но это создаст большие неудобства при его последующем использовании
<p>
<b>Куда поместить модуль?</b><br>
Туда, где его потом можно будет найти.
<p>
Пути поиска модулей указаны в переменной sys.path. В него включены текущая директория (то есть модуль можно оставить в папке с основной программой), а также директории, в которых установлен python.
<p>
Кроме того, переменную sys.path можно изменять вручную, что позволяет положить модуль в любое удобное для вас место (главное, не забыть в главной программе модифицировать sys.path).










<h3 align=center><a name="lib">Обзор стандартной библиотеки</h3>
Ссылки: <a href="https://intuit.ru/studies/courses/49/49/lecture/27060?page=4">Обзор стандартной библиотеки</a><br>
<a href="https://docs.python.org/3/library/">Список модулей стандартной библиотеки</a><br>
<a href="https://pythonworld.ru/moduli">Модули</a>
<p>
На сайте <a href="https://pypi.org/">Индекс пакетов Python (PyPI) - это хранилище программного обеспечения для языка 
программирования Python.</a> находятся тысячи готовых пакетов. Скачивают и устанавливают их обычно с помощью 
питоновского менеджера программ pip. Обычно pip уже установлен. Чтобы проверить это и заодно узнать версию, служит команда:
<pre>pip3 --version</pre>
У меня <i>pip 20.0.2 from /usr/lib/python3/dist-packages/pip (python 3.8)</i>
<p>
Для того, чтобы установить какую-нибудь библиотеку из Python Package Index (например пакет simple-crypt из следующей задачи), 
необходимо запустить команду:
<pre>$ pip install simple-crypt</pre>
Если операционная система linux скажет, что вам не хватает прав для данной операции, используйте команду:
<pre>$ sudo pip install simple-crypt</pre>
========================================================================================================

<p>
Помимо создания собственных модулей python содержит большое количество собственных модулей, называемых библиотекой 
стандартных  модулей.<br>
Модули стандартной библиотеки можно условно разбить на группы по тематике.
<ul>
<li> <b>Сервисы периода выполнения.</b> Модули: <b>sys</b>, atexit, copy, traceback, math, cmath, random, time, calendar, 
datetime, sets, array, struct, itertools, locale, gettext.

<a name="sys"><h4>Модуль sys</h4>
Ссылки: <a href="https://python-scripts.com/module-sys">Разбираем модуль sys</a>
<p>
Модуль sys предоставляет системе особые параметры и функции.
<ol>
<li> <b>sys.argv</b><br>
Значение sys.argv – это список аргументов командной строки, которые причастны к скрипту Python. Первый аргумент, argv[0], 
имеет аналогичное скрипту Python наименование. В зависимости от платформы, на которой вы работаете, первый аргумент может 
содержать полный путь к скрипту или к названию файла. Для дополнительных деталей обратитесь к документации. А тем временем, 
попробуем поработать с парочкой примеров, чтобы познакомиться с этим инструментом:<br>
В интерпретаторе выполним:
<pre>
>>> import sys
>>> print(sys.argv)
['']</pre>
Получили пустой список, потому что никакую программу не запускали.
<p>
Если создадим скрипт 1.py с кодом:
<pre>
import sys
print(sys.argv)</pre>
и запустим его с командной строки:
<br><img src="./images/python_base7.png">
<p>
<li> sys.executable
<li> sys.exit
<li> sys.modules
<li> sys.path
<li> sys.platform
<li> sys.stdin/stdout/stderr
</ol>

<a name="subprocess"><h4>Модуль subprocess</h4>
Ссылки: <a href="https://python-scripts.com/subprocess">Модуль subprocess — Работаем с процессам</a>
<p>
Модуль subprocess дает разработчику возможность запускать процессы программ из Python. Другим словами, вы можете запускать 
приложения и передавать им аргументы при помощи модуля subprocess. Модуль subprocess был внедрен в Python 2.4 для замены 
настроек вызовов модуля os, таких как os.popen, os.spawn и os.system, а также для замены popen2 и старых командных модулей.
<p>
<ul>
<li> <b>Функция вызова call</b><br>
Модуль subprocess содержит функцию под названием call. Эта функция позволяет вам вызывать другую программу, дожидаться 
завершения команды и вернуть код возврата. Она принимает один или несколько аргументов, а также следует ключевым аргументам (с 
их значениями): stdin=None, stdout=None, stderr=None, shell=False.<br>
Взглянем на простой пример:
<pre>
import subprocess
 
# Для Windows
subprocess.call("notepad.exe")
 
# Для linux
subprocess.call("gedit")</pre>
Если вы запустите этот код на машине, которая работает на Windows Python, вы увидите открывшийся блокнот. Обратите внимание на 
то, что IDLE (<font color=red>наверное это имя интерпретатора</font>) ожидает, пока вы закроете блокнот, после чего вернет 
нулевой код (0).
<br>Это значит, что код был выполнен успешно. Если вы получите что-либо, что не является ноль, то вы столкнулись с какой-то 
ошибкой.
<p>
Метод call также принимает аргументы, для передачи программе, которую вы выполняете. Давайте взглянем на то, как это работает:
<pre>
import subprocess
code = subprocess.call(["ping", "www.yahoo.com"])</pre>
В ответе получим результат пингования сайта.<br>
Обратите внимание на то, что в данном примере мы передали список аргументов. Первый объект в списке это программа, которую мы 
хотим вызвать. Все остальное в списке – это аргументы, которые мы хотим передать программе. Так что в данном примере мы 
выполняем пинг на сайте Yahoo. Также обратите внимание на то, что код возврата нулевой, так что все прошло успешно. 
</ul>
<p>
Модуль copy содержит функции для копирования объектов.
<p>
В модулях math cmath собраны математические функции для действительных и комплексных аргументов.
<p>
Модуль random генерирует псевдослучайные числа для нескольких различных распределений.
<p>
модуль time дает функции для получения текущего времени и преобразования форматов времени.
<p>
Модуль sets реализует тип данных для множеств.
<p>
Модули array и struct реализуют низкоуровневый массив и структуру данных. Основное их назначение - разбор двоичных форматов 
данных.
<p>
Модуль itertools содержит набор функций для работы с итераторами. Итераторы позволяют работать с данными последовательно, как 
если бы они получались в цикле. Альтернативный подход - использование списков для хранения промежуточных результатов - требует 
подчас большого количества памяти, тогда как использование итераторов позволяет получать значения на момент, когда они 
действительно требуются для дальнейших вычислений.
<p>
Модуль locale применяется для работы с культурной средой. В конкретной культурной среде могут использоваться свои правила для 
написания чисел, валют, времени и даты и т.п.
<p>
Модуль gettext При интернационализации программы важно не только предусмотреть возможность использования нескольких культурных 
сред, но и перевод сообщений и меню программы на соответствующий язык.
<p>

<li> <b>Поддержка цикла разработки.</b> Модули: pdb, hotshot, profile, unittest, pydoc. Пакеты docutils, distutils.<br>
Модули этого раздела помогают поддерживать документацию, производить регрессионное тестирование, отлаживать и профилировать 
программы на Python, а также обслуживают распространение готовых программ, создавая среду для конфигурирования и установки 
пакетов.<p>

<li> <b>Взаимодействие с ОС (файлы, процессы).</b> Модули: <b>os, os.path</b>, getopt, <b>glob</b>, popen2, <b>shutil</b>, 
select, signal, stat, tempfile.
<p>
<a name="os"><h4>Модуль os</h4>
Модуль os предоставляет множество функций для работы с операционной системой, причём их поведение, как правило, не зависит от 
ОС, поэтому программы остаются переносимыми. Здесь будут приведены наиболее часто используемые из них.
<p>
<i>Будьте внимательны: некоторые функции из этого модуля поддерживаются не всеми ОС.</i>
<p>
<b>os.name</b> - имя операционной системы. Доступные варианты: 'posix', 'nt', 'mac', 'os2', 'ce', 'java'.
<p>
<b>os.environ</b> - словарь переменных окружения. Изменяемый (можно добавлять и удалять переменные окружения).
<p>
<b>os.getlogin()</b> - имя пользователя, вошедшего в терминал (Unix).
<p>
<b>os.getpid()</b> - текущий id процесса.
<p>
<b>os.uname()</b> - информация об ОС. возвращает объект с атрибутами: sysname - имя операционной системы, nodename - имя 
машины в сети (определяется реализацией), release - релиз, version - версия, machine - идентификатор машины.
<p>
<b>os.access(path, mode, *, dir_fd=None, effective_ids=False, follow_symlinks=True)</b> - проверка доступа к объекту у 
текущего пользователя. Флаги: os.F_OK - объект существует, os.R_OK - доступен на чтение, os.W_OK - доступен на запись, os.X_OK 
- доступен на исполнение.
<p>
<b>os.chdir(path)</b><br>
Смена текущей директории.<br>
path - путь к каталогу в виде строки.<br>
Возвращает None. Чтобы узнать, что изменилась рабочая папка, лучше применить функцию os.getcwd(): print(os.getcwd())
<br>Примеры использования:
<pre>
>>> import os
>>> os.getcwd()
# '/home/docs-python'
>>> os.chdir(os.pardir)
>>> os.getcwd()
# '/home'</pre>
<p>
<b>os.chmod(path, mode, *, dir_fd=None, follow_symlinks=True)</b> - смена прав доступа к объекту (mode - восьмеричное число).
<p>
<b>os.chown(path, uid, gid, *, dir_fd=None, follow_symlinks=True)</b> - меняет id владельца и группы (Unix).
<p>
<b>os.getcwd()</b> - текущая рабочая директория.
<p>
<b>os.link(src, dst, *, src_dir_fd=None, dst_dir_fd=None, follow_symlinks=True)</b> - создаёт жёсткую ссылку.
<p>
<b>os.listdir(path=".")</b> - список файлов и директорий в папке.
<p>
<b>os.mkdir(path, mode=0o777, *, dir_fd=None)</b> - создаёт директорию. OSError, если директория существует.
<p>
<b>os.makedirs(path, mode=0o777, exist_ok=False)</b> - создаёт директорию, создавая при этом промежуточные директории.
<p>
<b>os.remove(path, *, dir_fd=None)</b> - удаляет путь к файлу.
<p>
<b>os.rename(src, dst, *, src_dir_fd=None, dst_dir_fd=None)</b> - переименовывает файл или директорию из src в dst.
<p>
<b>os.renames(old, new)</b> - переименовывает old в new, создавая промежуточные директории.
<p>
<b>os.replace(src, dst, *, src_dir_fd=None, dst_dir_fd=None)</b> - переименовывает из src в dst с принудительной заменой.
<p>
<b>os.rmdir(path, *, dir_fd=None)</b> - удаляет пустую директорию.
<p>
<b>os.removedirs(path)</b> - удаляет директорию, затем пытается удалить родительские директории, и удаляет их рекурсивно, пока 
они пусты.
<p>
<b>os.symlink(source, link_name, target_is_directory=False, *, dir_fd=None)</b> - создаёт символическую ссылку на объект.
<p>
<b>os.sync()</b> - записывает все данные на диск (Unix).
<p>
<b>os.truncate(path, length)</b> - обрезает файл до длины length.
<p>
<b>os.utime(path, times=None, *, ns=None, dir_fd=None, follow_symlinks=True)</b> - модификация времени последнего доступа и 
изменения файла. Либо times - кортеж (время доступа в секундах, время изменения в секундах), либо ns - кортеж (время доступа в 
наносекундах, время изменения в наносекундах).
<p>
<b>os.walk(top, topdown=True, onerror=None, followlinks=False)</b> - генерация имён файлов в дереве каталогов, сверху вниз 
(если topdown равен True), либо снизу вверх (если False). Для каждого каталога функция walk возвращает кортеж (путь к 
каталогу, список каталогов, список файлов).
<p>
<b>os.system(command)</b> - исполняет системную команду, возвращает код её завершения (в случае успеха 0).
<p>
<b>os.urandom(n)</b> - n случайных байт. Возможно использование этой функции в криптографических целях.
<p>
<a name="ospath"><h4>os.path</h4>
Модуль, реализующий некоторые полезные функции на работы с путями.<br>
os.path является вложенным модулем в модуль os, и реализует некоторые полезные функции для работы с путями.
<p>
<ul>
<li> <b>os.path.abspath(path)</b> - возвращает нормализованный абсолютный путь.
<p>
<li> <b>os.path.basename(path)</b> - базовое имя пути (эквивалентно os.path.split(path)[1]).
<p>
<li> <b>os.path.commonprefix(list)</b> - возвращает самый длинный префикс всех путей в списке.
<p>
<li> <b>os.path.dirname(path)</b> - возвращает имя директории пути path.
<p>
<li> <b>os.path.exists(path)</b> - возвращает True, если path указывает на существующий путь или дескриптор открытого файла.
<p>
<li> <b>os.path.expanduser(path)</b> - заменяет ~ или ~user на домашнюю директорию пользователя.
<p>
<li> <b>os.path.expandvars(path)</b> - возвращает аргумент с подставленными переменными окружения ($name или ${name} 
заменяются переменной окружения name). Несуществующие имена не заменяет. На Windows также заменяет %name%.
<p>
<li> <b>os.path.getatime(path)</b> - время последнего доступа к файлу, в секундах.
<p>
<li> <b>os.path.getmtime(path)</b> - время последнего изменения файла, в секундах.
<p>
<li> <b>os.path.getctime(path)</b> - время создания файла (Windows), время последнего изменения файла (Unix).
<p>
<li> <b>os.path.getsize(path)</b> - размер файла в байтах.
<p>
<li> <b>os.path.isabs(path)</b> - является ли путь абсолютным.
<p>
<li> <b>os.path.isfile(path)</b> - является ли путь файлом.
<p>
<li> <b>os.path.isdir(path)</b> - является ли путь директорией.
<p>
<li> <b>os.path.islink(path)</b> - является ли путь символической ссылкой.
<p>
<li> <b>os.path.ismount(path)</b> - является ли путь точкой монтирования.
<p>
<li> <b>os.path.join(path1[, path2[, ...]])</b> - соединяет пути с учётом особенностей операционной системы.
<p>
<li> <b>os.path.normcase(path)</b> - нормализует регистр пути (на файловых системах, не учитывающих регистр, приводит путь к 
нижнему регистру).
<p>
<li> <b>os.path.normpath(path)</b> - нормализует путь, убирая избыточные разделители и ссылки на предыдущие директории. На 
Windows преобразует прямые слеши в обратные.
<p>
<li> <b>os.path.realpath(path)</b> - возвращает канонический путь, убирая все символические ссылки (если они поддерживаются).
<p>
<li> <b>os.path.relpath(path, start=None)</b> - вычисляет путь относительно директории start (по умолчанию - относительно 
текущей директории).
<p>
<li> <b>os.path.samefile(path1, path2)</b> - указывают ли path1 и path2 на один и тот же файл или директорию.
<p>
<li> <b>os.path.sameopenfile(fp1, fp2)</b> - указывают ли дескрипторы fp1 и fp2 на один и тот же открытый файл.
<p>
<li> <b>os.path.split(path)</b> - разбивает путь на кортеж (голова, хвост), где хвост - последний компонент пути, а голова - 
всё остальное. Хвост никогда не начинается со слеша (если путь заканчивается слешем, то хвост пустой). Если слешей в пути нет, 
то пустой будет голова.
<p>
<li> <b>os.path.splitdrive(path)</b> - разбивает путь на пару (привод, хвост).
<p>
<li> <b>os.path.splitext(path)</b> - разбивает путь на пару (root, ext), где ext начинается с точки и содержит не более одной 
точки.
<p>
<li> <b>os.path.supports_unicode_filenames</b> - поддерживает ли файловая система Unicode.
</ul>
<p>
<b><a href="https://habr.com/ru/articles/453862/">Почему вам следует использовать pathlib</a></b>
<p>
<a name="glob"><h4>Модуль glob</h4>
Модуль glob в Python предоставляет удобный способ искать файлы с определенными шаблонами.
<p>
Функция glob.glob() используется для поиска всех файлов, соответствующих определенному шаблону. В качестве аргумента она 
принимает строку с шаблоном.
<br>Пример использования:
<pre>
import glob
 
files = glob.glob('*.txt')
print(files)</pre>
В данном случае мы ищем все файлы с расширением .txt в текущей директории. Результат будет представлен в виде списка.
<p>
Если вы хотите искать файлы не только в текущей директории, но и во всех вложенных папках, используйте аргумент recursive=True.
<br>Пример использования:
<pre>
import glob
 
files = glob.glob('**/*.txt', recursive=True)
print(files)</pre>
Теперь функция glob.glob() будет искать файлы с расширением .txt в текущей директории и всех поддиректориях.
<p>
В модуле glob поддерживаются следующие символы-шаблоны:
<pre>
* — соответствует любому количеству символов (включая пустую строку)
? — соответствует одному любому символу
[...] — соответствует одному из символов, заключенных в квадратные скобки (например, [abc] соответствует символам a, b или c)
</pre>
Пример использования:
<pre>
import glob
 
files = glob.glob('*[0-9].txt')
print(files)</pre>
В данном случае мы ищем все файлы, имя которых заканчивается на цифру и расширением .txt.
<p>
<i>Важно: символы-шаблоны работают только для имен файлов и папок, а не для их содержимого.</i>
<p>
<li> <b>Обработка текстов.</b><br>
Модули: string, re, StringIO, codecs, difflib, mmap, sgmllib, htmllib, htmlentitydefs. 
Пакет xml.
<p>
<li> <b>Многопоточные вычисления.</b><br>
Модули: threading, thread, Queue.
<p>
<li> <b>Хранение данных. Архивация.</b><br>
Модули: pickle, shelve, anydbm, gdbm, gzip, zlib, zipfile, bz2, csv, tarfile.<br>
К этой категории отнесены модули, которые работают с внешними хранилищами данных.
<p>
<li> <b>Платформо-зависимые модули.</b><br>
Для UNIX: commands, pwd, grp, fcntl, resource, termios, readline, rlcompleter. Для Windows: msvcrt, _winreg, winsound.
<p>
<li> <b>Поддержка сети.</b><br>
Протоколы Интернет. Модули: cgi, Cookie, urllib, urlparse, httplib, smtplib, poplib, telnetlib, socket, asyncore. Примеры 
серверов: SocketServer, BaseHTTPServer, xmlrpclib, asynchat.<br>
Почти все модули из этой категории, обслуживающие клиентскую часть протокола, построены по одному и тому же принципу: из 
модуля необходим только класс, объект которого содержит информацию о соединении с сервером, а методы реализуют взаимодействие 
с сервером по соответствующему протоколу. Таким образом, чем сложнее протокол, тем больше методов и других деталей требуется 
для реализации клиента.<br>
Примеры серверов используются по другому принципу. В модуле с реализацией сервера описан базовый класс, из которого 
пользователь модуля должен наследовать свой класс, реализующий требуемую функциональность. Правда, иногда замещать нужно всего 
один или два метода.
<p>
<li> <b>Поддержка Internet.</b><br>
Форматы данных. Модули: quopri, uu, base64, binhex, binascii, rfc822, mimetools, MimeWriter, multifile, mailbox. Пакет 
email.<br>
В стандартной библиотеке Python имеются разноуровневые модули для работы с различными форматами, применяющимися для 
кодирования данных в сети Интернет и тому подобных приложениях.<br>
Сегодня наиболее мощным инструментом для обработки сообщений в формате является пакет email. С его помощью можно как разбирать 
сообщения в удобном для программной обработки виде, так и формировать сообщение на основе данных о полях и основном содержимом 
(включая вложения).
<p>
<li> <b>Python о себе.</b><br>
Модули: parser, symbol, token, keyword, inspect, tokenize, pyclbr, py_compile, compileall, dis, compiler.
<p>
<li> <b>Графический интерфейс. Модуль Tkinter.</b><br>
Почти все современные приложения имеют графический интерфейс пользователя. Такие приложения можно создавать и на языке Python. 
В стандартной поставке имеется модуль Tkinter, который есть не что иное, как интерфейс к языку Tcl/Tk, на котором можно 
описывать графический интерфейс.
<p>
Следует отметить, что существуют и другие пакеты для программирования графического интерфейса: wxPython (основан на 
wxWidgets), PyGTK и т.д. Среди этих пакетов в основном такие, которые работают на одной платформе (реже - на двух).
</ul>
Примечание:<br>
Очень часто модули содержат один или несколько классов, с помощью которых создается объект нужного типа, а затем речь идет уже 
не об именах из модуля, а об атрибутах этого объекта. И наоборот, некоторые модули содержат лишь функции, достаточно общие для 
того, чтобы работать над произвольными объектами (либо достаточно большой категорией объектов).

<h4><a name="functools"</a>Модуль functools</h4>
Ссылка: <a href="https://habr.com/ru/companies/otus/articles/504102/">Введение в Python Functools</a>
<p>
Functools – это библиотека Python, которая предназначена для работы с функциями высшего порядка. Такие функции могут принимать 
в себя другие функции и возвращать функции. Они помогают разработчиком писать код, который можно переиспользовать. Функции 
можно использовать или расширять, не переписывая их полностью. Модуль functools в Python предоставляет различные инструменты, 
которые позволяют добиться описанного эффекта. Например Partial.
<p>
<b>Partial</b><br>
С помощью partial функции можно заменить существующую функцию, которой уже переданы аргументы. Более того, мы также можем 
создать новую версию функции, добавив качественную документацию.
<p>
Мы можем создавать новые функции, передавая частичные аргументы. Также мы можем заморозить некоторые аргументы функции, что 
приведет к появлению нового объекта. Еще один способ представить partial, заключается в том, что с ее помощью мы можем создать 
функцию со значениями по умолчанию. Partial поддерживает ключевые слова и позиционные аргументы в качестве фиксированных.
<p>
Чтобы создать partial-функцию, используйте partial() из библиотеки functools. Пишется она следующим образом:
<pre>partial(func, /, *args, ** kwargs)</pre>

Так вы создадите partial функцию, которая вызовет func, передав ей фиксированные ключевые слова и позиционные аргументы. Здесь 
обычно передаются несколько необходимых аргументов для вызова функции func. Остальные аргументы передаются в *args и **kwargs.
<p>
Допустим, функция ниже складывает два числа:
<pre>
def multiply(x, y):
 
    return x * y</pre>

Теперь рассмотрим случай, когда нам понадобилось удвоить или утроить заданное число. В таком случае новые функции мы 
определим, как показано ниже:
<pre>
def multiply(x, y):
        return x * y
 
def doubleNum(x):
       return multiply(x, 2)
 
def tripleNum(x):
       return multiply(x, 3)</pre>
Когда сценария работы функции всего 2-3, конечно, логичнее сделать, как показано выше. Но когда нужно написать еще 100 таких 
функций, то смысла переписывать один и тот же код столько раз нет. Здесь нам и пригодятся partial функции. Чтобы ими 
воспользоваться, во-первых, нам нужно импортировать partial из Functools.
<pre>
from functools import partial
 
def multiply(x, y):
       return x * y
 
doubleNum = partial(multiply, 2)
tripleNum = partial(multiply, 3)
 
Print(doubleNum(10))
 
Output: 20</pre>

Как видно из примера, значения по умолчанию будут заменены переменными слева. Вместо x будет 2, а вместо y будет 10 при вызове 
doubleNum(10). В этом примере порядок не будет иметь принципиального значения, но в других вариантах использования он может 
иметь значение.



<h3 align=center>Дополнительные библиотеки</h3>
Python  может работать с дополнительными библиотеками, которые в состав python не входят и их нужно устанавливать в систему.
<ol>
<li> <b>Библиотека requests</b><br>
Служит для отправки запросов на сервер и получения от него ответа.
<p>
Для установки служит команда: <b>pip3 install requests</b><br>
У меня установлен уже в python.
<p>
Пример простого запроса в программе:
<pre>
import requests
r = requests.get('htpp://example.com')  # простой get-запрос
print(r.text) # вывод ответа от сервера</pre>
<img src="./images/python_base8.png">


<li> <b>Библиотека pandas</b><br>
Ссылки: <a href="https://education.yandex.ru/handbook/python/article/modul-pandas">Модуль pandas</a>
<p>
Применяется для обработки и анализа табличных данных. В этой библиотеке используется numpy для удобного хранения данных и вычислений.
 <b>Установка:</b>
<pre>pip install pandas</pre>

<li> NumPy - работа с числовыми массивами<br>
<b>Установка:</b><br>
sudo apt-get install python3-numpy<br>
или<br>
sudo pip3 install numpy
<p>
<b>Функции:</b><br>
n.ndim - количество строк в двухмерном массиве<br>
n.shape - количество строк и столбцов в двухмерном массиве<br>
n.size - количество элементов в двухмерном массиве<br>
array() - создаёт массив<br>
linspace(start, end, количество чисел в интервале от start до end) - генерирует числа<br>
reshape(количество строк, коли-во столбцов) - превращает одномерный массив в двухмерный.
<p>
<i>Когда вы используете
from numpy import *
<p>
Это значит, что будут подключены все имеющиеся библиотеки питона. И это очень плохо. Во-первых, все это счастье грузится ну очень долго. А во-вторых, если среди ваших библиотек окажутся взаимоисключающие, т.е. разные библиотеки, но использующие одинаковые имена функций, то ваш питон начнет пестрить сообщениями об ошибках, поскольку он не будет знать из какой библиотеки ему использовать ту или иную функцию. Чтобы этого не происходило, забудьте про эту строку и подключайте только то, что вам действительно необходимо в работе.
<p>
Допустим, мы хотим pапустить код из примера:
<pre>
x = linspace(0, 5, 10)
y = x ** 2
print(x)
print(y)

figure()
plot(x, y, 'r')
xlabel('x')
ylabel('y')
title('title')
show()</pre>

в этом коде используется linspace из numpy и figure(), plot(), xlabel(), ylabel(), title(), show() из matplotlib. Понятно, что подключать ради них абсолютно все библиотеки крайне глупо. Как мы можем поступить в данном случае? Ну, вариантов у нас несколько:
<pre>
--- Вариант 1 ---
from numpy import *
from matplotlib.pyplot import *

x = linspace(0, 5, 10)
y = x ** 2
print(x)
print(y)

figure()
plot(x, y, 'r')
xlabel('x')
ylabel('y')
title('title')
show()

--- Вариант 2 ---
import numpy, matplotlib.pyplot

x = numpy.linspace(0, 5, 10)
y = x ** 2
print(x)
print(y)

matplotlib.pyplot.figure()
matplotlib.pyplot.plot(x, y, 'r')
matplotlib.pyplot.xlabel('x')
matplotlib.pyplot.ylabel('y')
matplotlib.pyplot.title('title')
matplotlib.pyplot.show()

--- Вариант 3 (второй вариант, но чуть короче) ---
import numpy as a
import matplotlib.pyplot as b

x = a.linspace(0, 5, 10)
y = x ** 2
print(x)
print(y)

b.figure()
b.plot(x, y, 'r')
b.xlabel('x')
b.ylabel('y')
b.title('title')
b.show()
</pre>
Можно отдельно каждую функцию импортировать и переименовать... ну и так далее. По большому счету все зависит от того как у вас 
настроено рабочее окружение питона, т.е. какие библиотеки у него прописаны, а какие установлены, но по каким-то причинам не 
попадают в поле зрения. Например, данный вариант будет работать на Ubuntu Linux 17.10, но заставить его работать в Slackware 
Linux окажется весьма не просто.</i>
<p>
<li> matplotlob - построение графиков<br>
Ссылки: <a href="https://stepik.org/lesson/7629/step/1?unit=1285">библиотека matplotlob</a><br>
<a href="https://stepik.org/lesson/196432/step/1?auth=registration&unit=172894">matplotlib</a>
<p>
<i>В чем разница между matplotlib и pylab? Что такое pylab?Почему вызываем его а не matplotlib?<br>
matplotlib - ﻿это пакет, pylab﻿ - ﻿библиотека из него.<br>
https://matplotlib.org/api/pyplot_api.html</i>
<p>
<i>Импорт рylab неявным образом импортирует все функции из numpy и matplotlib россыпью? Пояснять неплохо бы. Не лучшее решение, по-моему. Во-первых, не очевидно для новичков, во-вторых, пространство имен засоряется неимоверно. Там еще обе библиотеки как np и plt модули импортируются.
<p>
Лучше явно:<pre>
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(0, 5, 10)
y = x**2
plt.figure()
plt.plot(x, y, 'r')</pre>

...и так далее.</i>
<p>
<li> SciPy - функции для научных вычислений
<p>
<li> Scikit-learn - алгоритмы машинного обучения
<p>
<li> PythonSeaborn - визулизация статистических данных
</ol>




<h3 align=center><a name="datetime">Модуль datetime</h3>
Ссылка: <a href="https://pythonru.com/primery/kak-ispolzovat-modul-datetime-v-python">Как использовать модуль datetime в 
Python</a><br>
<a href="https://timeweb.cloud/tutorials/python/metod-strptime-i-strftime-v-python">Преобразование строки в дату и наоборот</a>
<p>
Этот модуль позволяет управлять датами и временем, представляя их в таком виде, в котором пользователи смогут их понимать.
<p>
datetime включает различные компоненты. Так, он состоит из объектов (классов) следующих типов:
<ul>
<li> date — хранит дату
<li> time — хранит время
<li> datetime — хранит дату и время
</ul>
<p>
<b>Как получить текущие дату и время?</b>
С помощью модуля Python это сделать очень просто. Сначала нужно импортировать класс datetime из модуля datetime, после чего 
создать объект datetime. Модуль предоставляет метод now(), который возвращает текущие дату и время с учетом локальных настроек.
<p>
Пример:
<pre>
import datetime

dt_now = datetime.datetime.now()
print(dt_now)</pre>
Результ:
<pre>2020-11-14 15:43:32.249588</pre>
<p>
Класс date можно использовать для получения или изменения объектов даты. Например, для получения текущей с учетом настроек 
подойдет следующее:
<pre>
from datetime import date

current_date = date.today()
print(current_date)
</pre>
Результат:<br>
2020-11-14
<p>
<b>Получить текущее время</b><br>
Для получения текущего локального времени сперва нужно получить текущие дату и время, а затем достать из этого объекта только 
время с помощью метода time():
<pre>
import datetime

current_date_time = datetime.datetime.now()
current_time = current_date_time.time()
print(current_time)</pre>
Результат:<br>
15:51:05.627643
<p>
<b>Компоненты datetime в Python</b><br>
Модуль datetime в Python может использоваться для получения разных версий времени. Для этого нужно ознакомиться с атрибутами 
модуля. Используем для этого функцию dir().
<pre>
import datetime

attr = dir(datetime)
print(attr)
# ['MAXYEAR', 'MINYEAR', '__doc__', '__name__', '__package__', 'date', 'datetime',
# 'datetime_CAPI', 'time', 'timedelta', 'tzinfo']</pre>
<p>
<b>Как создавать объекты даты и времени</b><br>
Для создания объекта времени используется класс time из модуля datetime в Python. Синтаксис следующий: datetime.time(hour, 
minutes, seconds).
<p>
В этом примере создается объект времени представленный следующим образом (8, 48, 45).
<pre>
import datetime

timeobj= datetime.time(8,48,45)
print(timeobj)</pre>
Результат такой:
<pre>08:48:45</pre>
Сначала импортируется модуль datetime. После этого создается экземпляр класса (объект time). Затем ему присваивается значение 
datetime.time(8, 48, 45), где параметры 8, 48 и 45 представляют собой часы, минуты и секунды соответственно.
<p>
Для создания объекта даты нужно передать дату с использованием следующего синтаксиса:
<p>
datetime.datetime(year,month,day))
Такой пример:
<pre>
import datetime

date_obj = datetime.datetime(2020,10,17)
print(date_obj)</pre>
Вернет вот такой результат:
<pre>2020-10-17 00:00:00</pre>
<p>
<b>Timedelta</b><br>
timedelta представляет длительность (даты или времени). Модуль datetime включает атрибут timedelta(), который используется для 
управления датой в Python. Объект timedelta выглядит следующим образом:
<pre>
td_object =timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)
td_object
datetime.timedelta(0)</pre>
Все аргументы опциональные и их значения по умолчанию равно 0. Они могут быть целыми или числами с плавающей точкой, как 
положительными, так и отрицательными. Благодаря этому можно выполнять математические операции, такие как сложение, вычитание и 
умножение.
<p>
<b>Как вычислить разницу для двух дат</b><br>
Посмотрим на несколько примеров вычисления разницы во времени. Предположим, есть два объекта datetime:
<pre>
first_date = date(2020, 10, 2)
second_date = date(2020, 10, 30)</pre>
Для получения разницы нужно лишь вычесть значение одного объекта из второго:
<pre>
from datetime import date

first_date = date(2020, 10, 2)
second_date = date(2020, 10, 30)
delta = second_date - first_date
print(delta)</pre>
Результат:
<pre>28 days,0:00:00</pre>
Таким образом между 2 и 30 октября 2020 года 28 дней.
<p>
<b>Как вычислить разницу двух объектов datetime.time</b><br>
С помощью timedelta нельзя выполнять манипуляции над объектами time
<pre>
from datetime import datetime, timedelta

current_datetime = datetime.now()
current_time = current_datetime.time()
print("Текущее время:", current_time)
tm_after_1_hr = current_time + timedelta(hours=1)
print(tm_after_1_hr)</pre>
Такой код вернет ошибку.
<p>
<b>Как получать прошлые и будущие даты с помощью timedelta</b><br>
Поскольку timedelta — это длительность, то для получения прошлой или будущей даты нужно добавить объект timedelta к 
существующему или вычесть из него же. Вот пример нескольких уравнений, где n — это целое число, представляющее количество дней:
<pre>
import datetime

current_date = datetime.datetime.today()
past_date = datetime.datetime.today() – datetime.timedelta(days=n)
future_date = datetime.datetime.today() – datetime.timedelta(days=n)</pre>
Если нужно, например, получить дату за прошлые две недели, то достаточно вычесть 14 дней из текущей даты:
<pre>
import datetime

past_date = datetime.datetime.today() - datetime.timedelta(days=14)
print(past_date)</pre>
Результат:
<pre>2020-10-31 16:12:09.142258</pre>
Предположим, вы задумали практиковать определенный навык в течение 21 дня. Для получения будущей даты нужно добавить 21 день к 
текущей дате:
<pre>
import datetime

future_date = datetime.datetime.today() + datetime.timedelta(days=21)
print(future_date)</pre>
Результат:
<pre>2020-12-05 16:14:09.718325</pre>





<h3 align=center><a name="dekorator">Декоратор</h3>
Синтаксис:
<pre>
def  table(func):

    def inner(*args, **kwargs):
        print('table')
        func((*args, **kwargs)
        print('table')
        
    return func</pre>
<p>
<b>Замыкания</b>
<pre>
def say_name(name):
    def say_goodbyu():
        print('goodbyu ', name)
        
    return say_goodbyu</pre>
Замыканием называется взятие внутренней функцией аргументов внешней функции и пользование ими как своими.

</div><br><br><br><br></body</html>
