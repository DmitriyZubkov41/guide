<html><head>
<style>
.menu {
       height: 100%;
       width: 155px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 5px;
           margin-left: 165px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Объектно-ориентированное программирование</title>
<div class="menu">
<a href="index.html">Начальная</a>
<a href="python_base.html">Основы языка python</a>
<a href="python_funk.html">Функции</a>
<a href="python_funk_progr.html">Функциональное программирование</a>
<a href="python_library.html">Библиотеки</a>
<a href="python_parsing">Парсинг страниц</a>
<a href="python_gui.html">Графика</a>
<a href="python_bot.html">Боты</a>
<a href="python_example.html">Примеры</a>
<p>
<b>ООП:</b>
<a href="#obiekt">Объекты</a>
<a href="#klass">Классы:</a>
<a href="#konstrukt">&nbsp;&nbsp; Конструктор класса</a>
<a href="#наследование">&nbsp;&nbsp; Наследование</a>
<a href="#property">&nbsp;&nbsp; Свойство класса</a>
<a href="#iterator">&nbsp;&nbsp; Итерация классов</a>
<a href="#import">Импортирование классов</a>
<a href="#mag_metod">Магические методы</a>

</div>

<div class="content">
<h2 align=center>Объектно-ориентированное программирование</h2>
Ссылки: <a href="https://intuit.ru/studies/courses/49/49/lecture/27064">Лекция 4: Объектно-ориентированное программирование</a><br>
<a href="https://pyplanet.ru/article/classes.html">Объектно-ориентированное программирование. Классы, объекты</a><br>
<a href="https://itproger.com/course/python/17">Основы ООП. Создание класса и объекта</a><br>
<a href="https://www.youtube.com/watch?v=jtIq61A1LLw&list=PLQAt0m1f9OHvyjJNjZK_unnLwMOXPTja8&index=1&pp=iAQB">Видеоуроки Егорова Артема</a><br>
<a href="https://younglinux.info/oopython/objects">Создание классов и объектов</a><br>
<a href="https://docs.python.org/3/tutorial/classes.html">9. Classes</a><br>
<a href="https://ru.wikibooks.org/wiki/Python/Объектно-ориентированное_программирование_на_Python">Python/Объектно-ориентированное программирование на Python</a>
<h4>Что такое объектно-ориентированное программирование (ООП)</h4>
Циклы, ветвления и функции – все это элементы структурного программирования. Его возможностей вполне хватает для написания 
небольших, простых программ и сценариев. Однако крупные проекты часто реализуют, используя парадигму объектно-ориентированного 
программирования (ООП). Что оно из себя представляет и какие преимущества дает?
<p>
В языке Python ООП играет ключевую роль. Даже программируя в рамках структурной парадигмы, вы все равно пользуетесь объектами 
и классами, пусть даже встроенными в язык, а не созданными лично вами.
<p>
Итак, что же такое объектно-ориентированное программирование?
<p>
Допустим, команда программистов занимается разработкой игры. Программу-игру можно представить как систему, состоящую из цифровых героев и среды их обитания, включающей множество предметов. Каждый воин, оружие, дерево, дом – это цифровой объект,
в котором "упакованы" его свойства и действия, с помощью которых он может изменять свои свойства и свойства других объектов.
<p>
Каждый программист может разрабатывать свою группу объектов. Разработчикам достаточно договориться только о том, как объекты будут взаимодействовать между собой, то есть об их интерфейсах. Пете не надо знать, как Вася реализует рост коровы в результате поедания травы. Ему, как разработчику лужайки, достаточно знать, что когда корова наклоняется к траве, последней на лужайке должно становиться меньше.
<p>
Ключевую разницу между программой, написанной в структурном стиле, и объектно-ориентированной можно выразить так. В первом случае, на первый план выходит логика, понимание последовательности выполнения действий для достижения поставленной цели. Во-втором – важнее представить программу как систему объектов, взаимодействие которых способно решить ту или иную задачу.
<p>
Основными понятиями, используемыми в ООП, являются <b>класс, объект, наследование, инкапсуляция и полиморфизм</b>. В языке Python класс равносилен понятию тип данных.

<h4>Что такое класс или тип?</h4>
Проведем аналогию с реальным миром. Если мы возьмем конкретный стол, то это объект, но не класс. А вот общее представление о столах, их назначении – это класс. Ему принадлежат все реальные объекты столов, какими бы они ни были. Класс столов дает общую характеристику всем столам в мире, он их обобщает.
<p>
То же самое с целыми числами в Python. Тип int – это класс целых чисел. Числа 5, 100134, -10 и т. д. – это конкретные объекты этого класса.
<p>
В языке программирования Python объекты принято называть также <b>экземплярами</b>. Это связано с тем, что в нем все классы сами являются объектами класса type. Точно также как все модули являются объектами класса module. Поэтому во избежании путаницы объекты, созданные на основе обычных классов, называют экземплярами.
<h3 align=center><a name="obiekt">Объект</h3>
В Python всё является объектами - строки, списки, словари, файлы, всё остальное.<br>
Объекты имеют  <b>атрибуты</b> и <b>методы</b>.<br>
Проверить является ли какое-то значение объектом, можно с помощью функции: <b>isinstance(var, object)</b>:
<pre>
isinstance(4, object)
True
>>> isinstance(Person, object)
True
>>> isinstance('stroka', object)
True
</pre>
<p>
Здесь object - является самым верхним объектом (надклассом) и поэтому все значения входят в object, но можно делать проверку на 
вхождение значения в какой-нибудь конкретный класс, например: a = Person() и isinstance(a, Person) вернёт True
<p>
Типы переменных (все что выводится через type(variable)) является встроенным классом в питоне. Например целые числа имеют тип или класс int. Строки принадлежат классу str.<br>
Чтобы создать экземпляр класса нужно выполнить var = name_class(). Пример:
<pre>
a = int()
a  # будет выведен 0 , так как по умолчанию создается объект класса  int равным 0
>>> s = str()
>>> s
''</pre>
Для строки по умолчанию создается пустая строка.
<ul>
<li> <b>Идентификатор объекта</b><br>
Каждый объект обладает своим уникальным идентификатором.<br>
Узнать идентификатор объекта можно с помощью функции id():
<pre>
>>> x = [1, 2, 3]
>>> id(x)
140705499364608
>>> id([1, 2, 3])
140705499676224</pre>
В данном примере создал два разных объекта x и [1, 2, 3]
<p>
<li> <b>Оператор is</b><br>
Также узнать ссылаются ли переменные на один и тот же объект (одинаковые идентификаторы) можно с помощью <b>оператора is</b>:
<pre>
>>> y = x
>>> y <b>is</b> x
True
>>> y is [1, 2, 3]
False</pre>
<p>

<li> <b>Изменяемые/неизменяемые  объекты</b><br>
В зависимости от того является ли объект изменяемым или нет, будет отличаться результат после выполнения операций с объектом:
<pre>
x = [1, 2, 3]
y = x
y.append(4)

s = "123"
t = s
t = t + "4"

print(str(x) + " " + s)</pre>
Будет выведено [1, 2, 3, 4] 123<br>
так как список является изменяемым объектом и изменив его через ссылку x, мы изменили его и для y. А строка является 
неизменяемым объектом, потому выполнив t = t + '4', мы создаем новый объект (место в памяти) для t, а s по-прежнему ссылается 
на свой объект '123'
<p>
Объекты бывают изменяемые и неизменяемые (англ. mutable и immutable). К неизменяемым относятся целые числа (int), числа с 
плавающей запятой (float), булевы значения (bool), строки (str), кортежи (tuple). К изменяемым — списки (list), множества 
(set), байтовые массивы (byte arrays) и словари (dict).
<p>
<li> <b>Тип объекта</b><br>
Каждый объект имеет свой тип.<br>
Тип объекта можно узнать с помощью функции type()<br>
Тип объекта определяет возможные значения объекта, его возможные методы.
<p>
<li> <b>Без ссылок новые объекты не создаются!</b>
<p>
Кешируются числа от -5 до 256 - т.е. при работе с этими числами Python обычно не будет создавать новый объект.
Так же кешируются строки, которые содержат только буквы, числа и нижнее подчеркивание.
Но это не гарантированное свойство, потому не нужно на это полагаться при проверке идентичности объектов.
<p>
Гарантированно в единствнном виде представлен (является синглтоном) из часто употребимых - None. С ним всегда используют для 
проверки оператор is, а не ==, т.к. он гарантированно будет в единственном экземпляре в памяти.


</ul>


<h3 align=center><a name="klass">Класс</h3>
<ul>
<li>
Объекты описываются не индивидуально, а с помощью классов. Класс - объект, являющийся шаблоном чертежём объекта.<br>
Объект, созданный на основе некоторого класса, называется <b>экземпляром класса</b>.
<p>
В Python термины «класс», «тип» и «тип данных» имеют одинаковый смысл, являются синонимами.
<p>
В языке программирования Python классы создаются с помощью ключевого слова <b>class</b>, за которой следует произвольное имя класса (имена классов должны записываться в верблюжьем регистре (CamelCase): первая буква каждого слова записывается в верхнем регистре, слова не разделяются пробелами) после которого ставится двоеточие, далее с новой строки и с отступом реализуется тело класса:
<pre>
class <b>ИмяКласса</b>:
    код_тела_класса</pre>
Если класс является дочерним, то родительские классы перечисляются в круглых скобках после имени класса.
<p>
<i>Каждый класс должен иметь строку документации, следующую сразу же за определением класса. В ней вы должны представить краткое описание того, что делает класс, соблюдая те же правила форматирования, которые вы использовали при написании строк документации в функциях (тройные парные кавычки). В классах можно разделять методы одной пустой строкой, а в модулях
для разделения классов можно использовать две пустые строки. Если вам потребуется импортировать модуль из стандартной библиотеки и модуль из библиотеки, написанной вами, то начните с оператора import для модуля стандартной библиотеки. Затем добавьте пустую строку и оператор import для модуля, написанного вами. В программах с несколькими операторами import выполнение
этого правила поможет понять, откуда берутся разные модули, использованные в программе.</i>
<h4>Создание экземпляра класса</h4>
Объект создается путем вызова класса по его имени. При этом после имени класса обязательно ставятся скобки:
<p>
<b>ИмяКласса()</b>
<p>
То есть класс вызывается подобно функции. Однако в случае вызова класса происходит не выполнение его тела, как это происходило 
бы при вызове функции, а создается объект. Поскольку в программном коде важно не потерять ссылку на только что созданный 
объект, то обычно его связывают с переменной. Поэтому создание объекта чаще всего выглядит так:
<p>
<b>имя_экземпляра = ИмяКласса()</b>
<p>
<h4>Класс как пространство имен</h4>
С точки зрения пространства имен класс можно представить подобным модулю. Также как в модуле в классе могут быть свои 
переменные со значениями и функции. Также как в модуле у класса есть собственное пространство имен, доступ к которому возможен 
через имя класса:
<pre>
>>> class B:
...     n = 5
...     def adder(v):
...             return v + B.n
... 
>>> B.n
5
>>> B.adder(4)
9</pre>
Однако в случае классов используется особая терминология:<br>
Имена, определенные в классе, называются <b>атрибутами этого класса</b>.<br>
В примере имена n и adder – это атрибуты класса B.<br>
Атрибуты-переменные часто называют <b>полями или свойствами</b><br> 
(в других языках понятия "поле" и "свойство" не совсем одно и то же). Полем является n.<br>
Атрибуты-функции называются <b>методами</b>.<br>
Методом в классе B является adder. Количество свойств и методов в классе может быть любым.
<p>
<b>Класс как шаблон для создания объектов</b><br>
На самом деле классы – не модули. Они своего рода шаблоны, от которых создаются объекты-экземпляры. Такие объекты наследуют от 
класса его атрибуты. Вернемся к нашему классу B и создадим на его основе два объекта:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
>>> class B:
...     n = 5
...     def adder(v):
...             return v + B.n
... 
>>> a = B()
>>> b = B()
</pre></td></tr></table>
<p>
У объектов, связанных с переменными a и b, нет собственного поля n. Однако они наследуют его от своего класса:
<pre>
>>> a.n
5
>>> a.n is B.n
True</pre>
То есть поля a.n и B.n – это одно и то же поле, к которому можно обращаться и через имя a, и через имя b, и через имя класса. 
Поле одно, ссылок на него три.
<p>
<b>Однако что произойдет в момент присваивания полю n значения через какой-нибудь объект-экземпляр?</b>
<pre>
>>> a.n = 10
>>> a.n
10
>>> b.n
5
>>> B.n
5</pre>
В этот момент у экземпляра a появляется собственный атрибут n, который перекроет (переопределит) родительский, то есть тот, 
который достался от класса.
<pre>
>>> a.n is B.n
False
>>> b.n is B.n
True</pre>
При этом присвоение через B.n отразится только на b и B, но не на a:
<pre>
>>> B.n = 100
>>> B.n, b.n, a.n
(100, 100, 10)</pre>
<p>
<b>Как применить метод к экземпляру класса?</b><br>
Иная ситуация нас ожидает с атрибутом adder. При создании объекта от класса функция adder не наследуется как есть, а как бы 
превращается для объекта в одноименный метод:
<pre>
>>> B.adder is b.adder
False
>>> type(B.adder)
&lt;class 'function'&gt;
>>> type(b.adder) 
&lt;class 'method'&gt;</pre>
Через имя класса мы вызываем функцию adder:
<pre>
>>> B.adder(33)
133</pre>
Через имя объекта вызываем метод adder:
<pre>
>>> b.adder(33)
Traceback (most recent call last):
  File "<stdin>", line 1, in &lt;module&gt;
TypeError: adder() takes 1 positional 
argument but 2 were given</pre>
В сообщении об ошибке говорится, что adder принимает только один аргумент, а было передано два. Откуда появился второй, если в скобках было указано только одно число?
<br>Дело в том, что в отличии от функции при вызове метода всегда передаётся первым невидимый аргумент - объект, к которому применяется этот метод. То есть выражение b.adder(33) как бы преобразовывается в adder(b, 33). Сам же b.adder как объект типа method хранит сведения, с каким классом он связан и какому объекту-экземпляру принадлежит:
<pre>
>>> b.adder
&lt;bound method B.adder of 
&lt;__main__.B object at 0x7fcbf1ab9b80&gt;&gt;</pre>
В нашем случае, чтобы вызывать adder через объекты-экземпляры, класс можно переписать так:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
>>> class B:
...     n = 5
...     def adder(obj, v):
...             return v + obj.n
... 
>>> b = B()
>>> b.adder(33)
38
</pre></td></tr></table>
<p>
В коде выше при вызове метода adder переменной-параметру obj присваивается объект, связанный с переменной, к которой 
применяется данный метод. В данном случае это объект, связанный с b. Если adder будет вызван на другой объект, 
то уже он будет присвоен obj:
<pre>
>>> a = B()
>>> a.n = 9
>>> a.adder(3)
12</pre>
<b>В Python переменную-параметр метода, которая связывается с экземпляром своего класса, принято называть именем self.</b><br>
Таким образом, более корректный код будет таким:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
>>> class B:
...     n = 5
...     def adder(self, v):
...             return v + self.n
</pre></td></tr></table>
<p>
Можем ли мы все также вызывать adder как функцию, через имя класса? Вполне. Только теперь в функцию 
надо передавать два аргумента:
<pre>
>>> B.adder(B, 200)
205
>>> B.adder(a, 200)
209</pre>
Здесь первым аргументом в функцию передается объект, у которого есть поле n лишь только потому, что далее к этому полю 
обращаются через выражение self.n.
<p>
<b>При описании класса и внутри методов в теле метода  обращения к полям идут в виде self.поле = поле</b>


<h4>Атрибут __dict__</h4>
В Python у объектов есть встроенные специальные атрибуты. Мы их не определяем, но они есть. Одним из таких атрибутов объекта 
является свойство __dict__. Его значением является словарь, в котором ключи – это имена свойств экземпляра (переменные - 
атрибуты), а значения – текущие значения свойств.
<pre>
>>> class B:
...     n = 5
...     def adder(self, v):
...             return v + self.n
... 
>>> w = B()
>>> w.__dict__
{}
>>> w.n = 8
>>> w.__dict__
{'n': 8}</pre>
В примере у экземпляра класса B сначала нет собственных атрибутов. Свойство n и метод adder – это атрибуты объекта-класса, а не 
объекта-экземпляра, созданного от этого класса. Лишь когда мы выполняем присваивание новому полю n экземпляра, у него 
появляется собственное свойство, что мы наблюдаем через словарь __dict__.
<p>
В следующем уроке мы увидим, что свойства экземпляра обычно не назначаются за пределами класса. Это происходит в методах 
классах путем присваивание через self. Например, self.n = 10.
<p>
Атрибут __dict__ используется не только для просмотра свойств объекта. С его помощью можно удалять, добавлять свойства, а также 
изменять их значения.
<pre>
>>> w.__dict__['m'] = 100
>>> w.__dict__
{'n': 8, 'm': 100}
>>> w.m
100</pre>


<b>Пример:</b><br>
Пусть в ходе анализа данной предметной области необходимо определить класс Граф. Граф - это множество вершин и набор ребер, 
попарно соединяющий эти вершины. Над графом можно проделывать операции, такие как добавление вершины, ребра, проверка наличия 
ребра в графе и т.п. На языке Python определение класса может выглядеть так:
<pre>
from sets import Set as set  # тип для множества

class G:
  def __init__(self, V, E):
    self.vertices = set(V)
    self.edges = set(E)

  def add_vertex(self, v):
    self.vertices.add(v)

  def add_edge(self, (v1, v2)):
    self.vertices.add(v1)
    self.vertices.add(v2)
    self.edges.add((v1, v2))

  def has_edge(self, (v1, v2)):
    return (v1, v2) in self.edges

  def __str__(self):
    return "%s; %s" % (self.vertices, self.edges)</pre>
Использовать класс можно следующим образом:
<pre>
g = G([1, 2, 3, 4], [(1, 2), (2, 3), (2, 4)])

print g
g.add_vertex(5)
g.add_edge((5,6))
print g.has_edge((1,6))
print g</pre>
что даст в результате:
<pre>
Set([1, 2, 3, 4]); Set([(2, 4), (1, 2), (2, 3)])
False
Set([1, 2, 3, 4, 5, 6]); Set([(2, 4), (1, 2), (5, 6), (2, 3)])</pre>
Как видно из предыдущего примера, определить класс не так уж сложно. Конструктор класса имеет специальное имя __init__. 
(Деструктор здесь не нужен, но он бы имел имя __del__.)<br>
Методы класса определяются в пространстве имен класса.<br>
В качестве первого формального аргумента метода принято использовать self.<br>
Кроме методов в объекте класса имеются два атрибута: vertices (вершины) и edges (ребра).<br>
Для представления объекта G в виде строки используется специальный метод __str__().
<p>
Принадлежность классу можно выяснить с помощью встроенной функции isinstance():
<pre>print isinstance(g, G)</pre>


<a name="konstrukt"><h4>Конструктор класса или метод __init__()</h4>
Конструктор вызывается автоматически при создании экземпляра и создаёт его через метод __init__() . Конструкторы позволяют задать некие характеристики для объекта сразу же при его создании. К примеру, у вас есть несколько переменных, которые точно должен иметь объект. Вы можете создать конструктор и указать несколько параметров, которые будут переданы при создании объекта.
<p>
Первый параметр self обязателен; он должен предшествовать всем остальным параметрам. Его следует добавить в определение. При каждом вызове какого-нибудь метода (не только __init__(), связанного с классом), автоматически передается self — ссылка на экземпляр; она предоставляет конкретному экземпляру доступ к атрибутам и методам класса.
<p>
Вот пример, который демонстрирует использование метода __init__() для создания конструктора:
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
class Person:

    def __init__(self, name, age):

        self.name = name

        self.age = age

    def introduce(self):

        print("Привет, меня зовут", self.name, "и мне", self.age, "лет.")

person1 = Person("Алиса", 25)

person1.introduce()
</pre></td></tr></table>
<p>
В этом примере у нас есть класс Person, у которого есть метод __init__() и метод introduce().<br>
Метод __init__() принимает два параметра: name и age.<br>
Атрибуты, определённые внутри метода __init__ , называются <b>собственными атрибутами</b> экземпляра. В примере собственными атрибутами являются name и age. Также есть атрибуты класса, это такие атрибуты, которые объявляются внутри класса, но вне методов.<br>
Внутри метода __init__() мы присваиваем значения этих параметров атрибутам self.name и self.age соответственно.<br>
При создании нового экземпляра класса Person и передаче имени и возраста в качестве аргументов, метод __init__() автоматически 
вызывается и инициализирует атрибуты объекта.<br>
Затем мы можем вызывать метод introduce(), который использует значения атрибутов name и age для вывода информации о человеке. 
Вывод программы будет следующим: Привет, меня зовут Алиса и мне 25 лет.<br>
Таким образом, метод __init__() позволяет автоматически задать начальные значения атрибутов объекта класса во время его создания. Он играет важную роль в инициализации объектов и предоставляет возможность установить начальное состояние объекта.
<p>
Если вы определите метод с другим названием, а не __init__(), и используете его для инициализации атрибутов объекта, то при 
создании экземпляра класса вам нужно будет вызвать этот метод явно. Вот пример кода, где используется метод blabla() для 
инициализации атрибутов объекта:
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
class Person:

    def blabla(self, name, age):

        self.name = name

        self.age = age

    def introduce(self):

        print("Привет, меня зовут", self.name, "и мне", self.age, "лет.")

<font color=red>person1 = Person()</font>  # вроде здесь создали экземпляра

person1.blabla("Алиса", 25)  # а здесь вроде присвоили значения атрибутам экземпляра

person1.introduce()
</pre></td></tr></table>
<p>
В этом примере мы создаем экземпляр класса Person без вызова метода __init__(). Вместо этого мы вызываем метод blabla() и 
передаем аргументы "Алиса" и 25, которые инициализируют атрибуты объекта name и age. Затем мы вызываем метод introduce(), 
который использует значения атрибутов name и age для вывода информации о человеке. Вывод программы будет следующим:<br>
Привет, меня зовут Алиса и мне 25 лет.<br>
Таким образом, вы можете использовать метод с любым другим названием, чтобы инициализировать атрибуты объекта. Однако, важно помнить, что вам нужно будет вызвать этот метод явно при создании экземпляра класса.
<p>
В Python, параметр self используется в методах класса для ссылки на сам объект (экземпляр класса), для которого вызывается 
метод. Он является обязательным параметром в определении методов класса.
<p>
<font color=red>Параметр self позволяет обращаться к атрибутам и методам объекта внутри самого класса.</font> Он представляет собой ссылку на сам экземпляр класса, с помощью которого можно получить доступ к его атрибутам и вызвать его методы.
<p>
Если не использовать параметр self в методах класса, то не будет возможности получить доступ к атрибутам и методам объекта. 
Без использования self, метод не будет знать, какой объект класса обрабатывается, и будет вызвана ошибка.
<br><font color=red>TypeError: introduce() takes 0 positional arguments but 1 was given</font>
</ul>
<h4>Приватные атрибуты класса</h4>
В отличии от языка С++ в Python нет способа создать приватный атрибут (поле) класса типа private, чтобы к нему можно было обращаться только через методы класса. Но принято считать, что если имя атрибута начинается с нижней черточки, то к этому атрибуту желательно обращаться через метод класса, а не напрямую. Тем не менее напрямую обращаться можно.
<p>
<table border=1 style="border-collapse:collapse;"  cellpadding=10><tr><td>
<pre>
class BankAccount:
    def __init__(self, accountHolder):
        # Методы BankAccount могут обращаться к self._balance, но код
        # за пределами класса этого делать не должен:
        self.<b>_</b>balance = 0
        <b>self._name</b> = accountHolder

        with open(self._name + 'Ledger.txt', 'w') as ledgerFile:
        ledgerFile.write('Balance is 0\n')

    def deposit(self, amount):
        if amount <= 0:
            return # Отрицательные "зачисления" недопустимы.
        self._balance += amount
        with open(self._name + 'Ledger.txt', 'a') as ledgerFile:
        ledgerFile.write('Deposit ' + str(amount) + '\n')
        ledgerFile.write('Balance is ' + str(self._balance) + '\n')

    def withdraw(self, amount):
        if self._balance < amount or amount < 0:
            return # Не хватает средств на счете или снимается
        # отрицательная сумма.
        self._balance -= amount
        with open(self._name + 'Ledger.txt', 'a') as ledgerFile: 
        ledgerFile.write('Withdraw ' + str(amount) + '\n')
        ledgerFile.write('Balance is ' + str(self._balance) + '\n')

acct = BankAccount('Alice') # Создание учетного счета.
acct.deposit(120) # _balance можно изменять через deposit()
acct.withdraw(40) # _balance можно изменять через withdraw()

# Изменение _name или _balance за пределами BankAccount нежелательно, но возможно:
<font color=red>acct._balance = 1000000000</font>
acct.withdraw(1000)
<font color=red>acct._name = 'Bob'</font> # Теперь изменяется счет Боба!
acct.withdraw(1000) # Операция регистрируется в BobLedger.txt!
</pre></td></tr></table>
<p>
Хорошо спроектированные классы в целом автономны, и они должны предоставлять методы для присваивания атрибутам допустимых значений. Атрибуты _balance и _name помечены как приватные, а значение класса BankAccount должно изменяться только при помощи методов deposit() и withdraw() . Эти два метода содержат проверки , которые проверяют, что атрибут _balance не переводится в недействительное состояние (например, ему не присваивается отрицательное целое значение). Методы также регистрируют каждую операцию для текущего баланса. Код за пределами класса, изменяющий эти атрибуты (например, команды acct._balance = 1000000000 или acct._name = 'Bob'), может перевести объект в некорректное состояние и создать ошибки.
<pre>


</pre>
<h3 align=center><a name="наследование">Наследование</h3>
Помимо классов и объектов, ООП содержит дополнительные три основные концепции: <b>наследование, инкапсуляция и полиморфизм</b>. 
<p>
Работа над новым классом не обязана начинаться с нуля. Если класс, который вы пишете, представляет собой специализированную версию ранее написанного класса, то вы можете воспользоваться наследованием (inheritance).Один класс, наследующий от другого, автоматически получает все атрибуты и методы первого класса. Исходный класс называется родителем (parent), а новый класс — потомком (child class). Класс-потомок наследует атрибуты и методы класса-родителя, но при
этом может определять и собственные атрибуты и методы.
<p>
<b>Зачем использовать наследование?</b><br>
Предположим что у нас есть один большой класс «Транспорт». В классе описываются базовые характеристики для всех транспортных 
средств:
<p>
поля: скорость, вес, запас хода и тому подобное;<br>
методы: получение информации из полей, установка новых значений;<br>
конструктор: пустой и по установке всех полей.<br>
<p>
На основе класса мы спокойно можем создать объект легковой машины, объект грузовика, объект самолета и так далее. У всех 
объектов будут одинаковые характеристики и методы. 
<p>
Мы явно понимаем, что у объекта машина и самолёт будут разные поля и характеристики. Как можно поступить:
<p>
Можно создать два отдельных класса: «Car» и «Airplane». В каждом классе будут все методы, поля и конструкторы повторно 
переписанные из класса «Транспорт», а также будут новые методы, что важны только для конкретного класса; А можно создать два класса наследника: «Car» и «Airplane». Оба класса будут наследовать всё от класса «Транспорт» и при этом 
будут содержать свои дополнительные функции. Таким образом повторения кода не будет и код станет меньше и чище.
<h4>Метод __init__() класса-потомка</h4>
При написании нового класса на базе существующего часто приходится вызывать метод __init__() класса-родителя. При этом происходит инициализация любых атрибутов, определенных в данном методе, и они становятся доступными для класса-потомка. Например, попробуем создать модель электромобиля. Электромобиль представляет собой специализированную разновидность автомобиля, поэтому новый класс ElectricCar можно создать на базе класса Car , написанного ранее. Тогда нам останется
добавить в него код атрибутов и поведения, относящегося только к электромобилям. Начнем с создания простой версии класса ElectricCar , который делает все, что делает класс Car :<br>
electric_car.py<br>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
class Car:
    """Простая модель автомобиля."""
    def __init__(self, make, model, year):
        """Инициализирует атрибуты описания автомобиля.""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0


def get_descriptive_name(self):
    """Возвращает отформатированное описание."""
    long_name = f"{self.year} {self.make} {self.model}"
    return long_name.title()


def read_odometer(self):
    """Выводит данные о пробеге машины в милях."""
    print(f"This car has {self.odometer_reading} miles on it.")


def update_odometer(self, mileage):
    """Устанавливает на одометре заданное значение."""
    if mileage >= self.odometer_reading:
        self.odometer_reading = mileage
    else:
        print("You can't roll back an odometer!")


def increment_odometer(self, miles):
    """Увеличивает показания одометра с заданным приращением."""
    self.odometer_reading += miles


class ElectricCar(<b>Car</b>):
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, make, model, year):
        """Инициализирует атрибуты класса-родителя."""
        <b>super().__init__(make, model, year)</b>

my_leaf = ElectricCar('nissan', 'leaf', 2024)
print(my_leaf.get_descriptive_name())
</pre></td></tr></table>
<p>
Сначала создается класс Car. При создании класса-потомка класс-родитель должен быть частью текущего файла, а его определение должно предшествовать определению класса-потомка в файле. Затем определяется класс-потомок ElectricCar. В определении потомка имя класса-родителя заключается в круглые скобки. Метод __init__() получает информацию, необходимую для создания экземпляра Car.<br>
<b>Функция super()</b> — специальная; она позволяет вызвать метод родительского класса. Благодаря этой строке Python получает указание вызвать метод __init__() класса Car , в результате чего экземпляр ElectricCar имеет доступ ко всем атрибутам
класса-родителя. Имя super происходит из общепринятой терминологии: класс-родитель называется суперклассом, а класс-потомок — подклассом.
<h4>Переопределение методов класса-родителя</h4>
Любой метод родительского класса, который в моделируемой ситуации делает не то, что нужно, можно переопределить. Для этого в классе-потомке определяется метод с тем же именем, что и у метода класса-родителя. Python игнорирует метод родителя и обращает внимание только на метод, определенный в потомке. Допустим, в классе Car имеется метод fill_gas_tank() . Для электромобилей за-
правка бензином бессмысленна, поэтому этот метод логично переопределить. Например, это можно сделать так:
<pre>
class ElectricCar(Car):
    --пропуск--
    def fill_gas_tank(self):
        """У электромобилей нет бензобака."""
        print("This car doesn't have a gas tank!")
</pre>
И если кто-то попытается вызвать метод fill_gas_tank() для электромобиля, то Python игнорирует метод fill_gas_tank() класса Car и выполнит вместо него этот код. Когда вы используете наследование, потомок сохраняет те аспекты родителя, которые вам нужны, и переопределяет все ненужное.
<h4>Экземпляры как атрибуты</h4>
При моделировании явлений реального мира в программах классы нередко дополняются все бо́ льшим количеством подробностей. Списки атрибутов и методов растут, и через какое-то время файлы становятся чрезмерно длинными. В такой ситуации часть одного класса нередко можно записать в виде отдельного класса. Большой код разбивается на меньшие классы, которые работают во взаимодействии
друг с другом. Такой подход называется <b>композицией</b> (composition). Например, при дальнейшей доработке класса ElectricCar может оказаться, что в нем появилось слишком много атрибутов и методов, относящихся к аккумулятору. В таком случае можно остановиться и переместить все эти атрибуты и методы в отдельный класс Battery . Затем экземпляр Battery становится атрибутом класса ElectricCar :
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
class Car:
    --пропуск--


class Battery:
    """Простая модель аккумулятора электромобиля."""
    def __init__(self, battery_size=40):
        """Инициализирует атрибуты аккумулятора."""
        self.battery_size = battery_size

    def describe_battery(self):
        """Выводит информацию о мощности аккумулятора."""
        print(f"This car has a {self.battery_size}-kWh battery.")


class ElectricCar(Car):
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, make, model, year):
        """
        Инициализирует атрибуты класса-родителя.
        Затем инициализирует атрибуты, специфические для электромобиля.
        """
        super().__init__(make, model, year)
        <b>self.battery = Battery()</b>


my_leaf = ElectricCar('nissan', 'leaf', 2024)
print(my_leaf.get_descriptive_name())
my_leaf.battery.describe_battery()
</pre></td></tr></table>
<p>
Сначала определяется новый класс Battery , который не наследует ни от одного из других классов. Метод __init__() получает один параметр battery_size , кроме self . Если значение не предоставлено, то этот необязательный параметр задает battery_size значение 40 . Метод describe_battery() также перемещен в этот класс. Затем в класс ElectricCar добавляется атрибут self.battery. Эта строка дает Python указание создать новый экземпляр Battery (со значением battery_size по умолчанию, равным 40 , поскольку значение не задано) и сохранить его в атрибуте self.battery . Это будет происходить при каждом вызове __init__() ; теперь любой экземпляр ElectricCar будет иметь автоматически создаваемый экземпляр Battery . Программа создает экземпляр электромобиля и сохраняет его в переменной my_leaf . Когда потребуется вывести описание аккумулятора, необходимо обратиться к атрибуту battery : my_leaf.battery.describe_battery()<br>
Благодаря этой строке Python получает указание обратиться к экземпляру my_leaf , найти его атрибут battery и вызвать метод describe_battery() , связанный с экземпляром Battery из атрибута. Результат выглядит так же, как и в предыдущей версии:
<pre>
2024 Nissan Leaf
This car has a 40-kWh battery.
</pre>
Казалось бы, новый вариант требует большой дополнительной работы, но теперь аккумулятор можно моделировать, задавая любую степень детализации, при этом не усложняя класс ElectricCar .
<pre>


</pre>
<b>Функция issubclass()</b><br>
Для определения является ли класс B наследником класса A (или A - родитель для B) служит функция issubclass(child, parent):
<p> 
issubclass(B, A)<br>
вернёт True, если класс B является потомком класса A, иначе False.<br>
Самым верхним классом, который не имеет родителя (надкласса) является <b>objekt</b>.<br>
<font color=red>Странно, почему issubclass(int, objekt) выдает ошибку, как и type(objekt)?</font>
<p>
<b>Множественное наследование</b><br>
Для ответа на вопрос в каком порядке будет искаться метод в нескольких классах, служит функция mro():
<pre>Name_class.mro()</pre>
выдаст список из Name_class и родительских классов в порядке в каком будет искаться какой-нибудь метод. Этот порядок равен 
порядку в каком родительские классы указаны в качестве аргументов (в скобках) при объявлении Name_class.
<p>
Конкретный пример:
<pre>
>>> int.mro()
[&lt;class 'int'&gt;, &lt;class 'object'&gt;]</pre>

<h4>Функция super()</h4>
super() - это функция, которая позволяет вызывать методы родительского класса в дочернем классе. Она используется, когда нужно 
вызвать методы родительского класса в дочернем классе, чтобы избежать дублирования кода и улучшить его читаемость.
<p>
Функция super() можно использовать для вызова методов как в методах, так и в конструкторах дочернего класса.
<p>
<b>Как работает функция super() в Python?</b><br>
Когда мы создаем дочерний класс, он наследует все атрибуты и методы родительского класса. Для того, чтобы вызвать метод 
родительского класса, мы можем использовать функцию super().
<p>
При вызове super() Python ищет родительский класс в иерархии наследования, начиная с текущего класса и переходя к родительским 
классам в порядке, заданном в списке наследования. После нахождения родительского класса, super() вызывает его методы и 
передает все аргументы, которые были переданы методу дочернего класса.
<p>
Пример использования super() в Python
Рассмотрим пример, который показывает, как использовать super() для вызова метода родительского класса.
<pre>
class Animal:
    def __init__(self, name):
        self.name = name

    def make_sound(self):
        print("The animal makes a sound")

class Dog(Animal):
    def __init__(self, name):
        super().__init__(name)

    def make_sound(self):
        super().make_sound()
        print("The dog barks")

my_dog = Dog("Buddy")
my_dog.make_sound()</pre>
В этом примере у нас есть два класса: Animal и Dog. Класс Dog наследует от Animal.
<p>
Мы переопределяем метод make_sound() в классе Dog, но вместо того, чтобы полностью переписывать метод, мы вызываем метод 
make_sound родительского класса с помощью super(), а затем добавляем к нему свой код.
<p>
Результат выполнения этого кода будет:
<pre>
>>> The animal makes a sound
>>> The dog barks</pre>
В этом примере мы вызываем метод make_sound() родительского класса с помощью super(), а затем добавляем к нему свой код, чтобы 
сделать ту же самую вещь, но с дополнительным функционалом.
<p>
<b>Синтаксис:</b><br>
Если <b>super().metod()</b> то metod() будет браться с родительского класса в порядке аргументов текущего класса.
<p>
Если <b>super(Name_class, self).metod()</b> то metod() будет искаться в родительском классе для класса Name_class.

<h4>Правило наследования:</h4>
если среди родителей класса - два класса, которые являются прямыми "родственниками", причём "родитель" перечислен до "потомка" 
- то возникает ошибка.  Потому, как - вроде программист определяет такой  порядок, а MRO предусматривает обратный (т.е. сначала 
"потомки" - потом "родители").
<p>
<li> <b>Полиморфизм</b><br>
Полиморфизм позволяет изменять функции в классах наследниках. Пример:
<pre>
class Cars:
	def nothing(self): # Пустая функция
		pass
		
class BMW (Cars):
	def nothing(self, word):
		print (word + "!") # Функция теперь будет работать по новому
 
a = BMW()
a.nothing("Some")</pre>
<p>
Полиморфизм можно перевести как множество форм. В ООП под полиморфизмом понимается следующее. Объекты разных классов, с разной 
внутренней реализацией, то есть программным кодом, могут иметь "одинаковые" методы. На самом деле у методов совпадают только 
имена, а вложенный в них код (то, что они делают) различен. Вот и получается, что у одного имени как бы множество форм.
<p>
Полиморфизм полезен не только тем, что дает возможность объектам пользовательских классов участвовать в стандартных операциях. 
Если у объектов разных классов есть одноименный метод, то коллекция таких разнородных объектов может быть обработана в одном 
цикле.
</ol>
<pre>


</pre>
<a name="property"><h3 align=center>Свойство - динамический атрибут класса</h3>
Ссылка: <a href="https://ru.hexlet.io/courses/python-oop-basics/lessons/properties/theory_unit">Свойства</a><br>
<a href="https://metanit.com/python/tutorial/7.2.php">Инкапсуляция, атрибуты и свойства</a>
<p>
Отдельные объектно-ориентированные языки поддерживают закрытые атрибуты объектов, к которым нельзя получить доступ непосредственно; программистам зачастую приходится писать геттеры и сеттеры, чтобы считать и записать значения таких атрибутов.
В Python вы также можете написать геттеры и сеттеры, но характерным для Python способом — используя <b>свойства</b>.
<p>
В Python есть средство, позволяющее получить атрибут класса (свойство), значение которого вычисляется динамически, то есть во время обращения к атрибуту.
<pre>
class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname
    <b>@property
    def full_name(self):</b>  # это свойство
        return self.name + ' ' + self.surname

tom = Person('Thomas', 'Smith')
tom.full_name  # 'Thomas Smith'
</pre>
full_name выглядит как атрибут, но вычисляется динамически. Если мы поменяем name, то full_name автоматически также изменится:
<pre>
tom.name = 'Alice'
tom.full_name  # 'Alice Smith'
</pre>
Как вы можете видеть, свойство объявляется как метод без параметров (кроме self, естественно), декорированный с помощью property. Такой метод, возвращающий динамически вычисляемое значение, называется геттером (getter).
<p>
Атрибутам пространства имен можно присваивать значения, но что делать, если атрибут — свойство? Если вы попытаетесь присвоить значение свойству, у которого один лишь getter, вы получите ошибку "AttributeError: can't set attribute".
<p>
Чтобы иметь возможность присвоить значение свойству, нужно использовать сеттер (setter). Сеттер — это тоже метод, который принимает новое значение для атрибута и как-то его обрабатывает. Чтобы метод стал сеттером, его тоже нужно соответствующим образом декорировать. Если у вас уже есть геттер, вы можете сделать так:
<pre>
class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname
    
    # геттер
    @property
    <b>def full_name(self):</b>  # свойство
        return self.name + ' ' + self.surname

    # сеттер для свойства full_name
    @full_name.setter
    def full_name(self, new):
        self.name, self.surname = new.split(' ')
</pre>
Теперь свойству full_name можно присваивать новое полное имя. В итоге оно будет разделено по пробелу на две части, первая из которых станет новым именем, а вторая — фамилией. Пример:
<pre>
tom = Person('Thomas', 'Smith')
tom.full_name  # 'Thomas Smith'
tom.full_name = 'Alice Cooper'
tom.name  # 'Alice'
tom.surname  # 'Cooper'
</pre>
Сеттеры часто используют для того, чтобы проверить корректность нового значения или произвести какие-то его преобразования перед фактическим сохранением в другие атрибуты.
<h4>Делитер</h4>
Кроме геттеров и сеттеров, в Python существует еще один важный метод для управления атрибутами классов — это делитеры (deleter). Этот метод предоставляет дополнительный уровень контроля над тем, как атрибуты класса удаляются.
<p>
Делитер — это особый метод в классе, который вызывается при удалении атрибута. Как правило, удаление атрибута - это нечастая операция, и в большинстве случаев мы можем обойтись без явного определения делитера. Тем не менее, зная о его существовании, мы можем контролировать процесс удаления атрибутов, например, очищать связанные ресурсы или выполнять некоторую логику очистки.
<p>
В нашем примере с классом Person, если мы решим реализовать делитер для свойства full_name, то его можно использовать для удаления имени и фамилии. Давайте посмотрим, как это работает:
<pre>
class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    @property
    def full_name(self):
        return self.name + ' ' + self.surname

    @full_name.setter
    def full_name(self, new):
        self.name, self.surname = new.split(' ')

    <b>@full_name.deleter
    def full_name(self):</b>
        print("Удаляем имя и фамилию!")
        self.name = None
        self.surname = None
</pre>
Теперь при удалении свойства full_name будет вызываться наш делитер, который устанавливает свойствам name и surname значение None, тем самым "удаляя" эти значения. Пример:
<pre>
tom = Person('Thomas', 'Smith')
tom.full_name  # 'Thomas Smith'
del tom.full_name  # Удаляем имя и фамилию
tom.name       # None
tom.surname    # None
</pre>
Использование делитера особенно полезно в случаях, когда необходимо управлять удалением важных или связанных данных, или выполнять освобождение ресурсов (как, например, закрытие файлов или сетевых соединений) в момент уничтожения объекта или его свойств.
<h4>Декоратор property</h4>
Если посмотреть в документацию к декоратору property, то можно увидеть такую сигнатуру:
<p>
property(fget=None, fset=None, fdel=None, doc=None)
</p>
Первые три аргумента позволяют задать getter, setter и deleter, а аргумент doc позволяет указать docstring. В такой форме property удобно использовать, когда вы уже имеете готовые функции, которые хотите просто "упаковать" в свойство:
<pre>
def get_full_name(self):
    ...

def set_full_name(self, new):
    ...

class Person:
    ...
    full_name = property(
        fget=get_full_name,
        fset=set_full_name,
        doc='A full name of person'
    )
</pre>
<pre>


</pre>
<h3 align=center><a name="iterator">Создание итерируемого класса</a></h3>
Итерирование чего-то - это значит это что-то можно перебирать по элементам, как в цикле for.
<p>
<b><a href="https://docs.python.org/3/library/stdtypes.html#iterator-types">Перевод документации</a>:</b>
<p>
<i><b>Итератор</b> - Объект, означающий поток данных. Повторные вызовы метода __next__() от итератора (или передача итератору 
встроенной функции next()) возвращают последовательные элементы в потоке. Когда больше нет доступных данных, возникает 
исключение StopIteration. На этом этапе объект iterator исчерпан, и любые дальнейшие вызовы его метода __next__() 
просто снова вызовут StopIteration.
<p>
Итераторы должны иметь метод __iter__(), который возвращает сам объект iterator. Объект-контейнер (например, список) создает 
новый итератор каждый раз, когда вы передаете его функции iter() или используете в цикле for.</i>
<p>
Python поддерживает концепцию итерации по контейнерам. Это реализовано с использованием двух методов; они 
используются для того, чтобы позволить определяемым пользователем классам поддерживать итерацию.
<p>
Для объектов-контейнеров должен быть определен один метод, обеспечивающий итеративную поддержку:
<p>
<b>container.__iter__()</b><br>
Возвращает объект iterator. Объект необходим для поддержки протокола iterator, описанного ниже.
<p>
Сами объекты iterator необходимы для поддержки следующих двух методов, которые вместе образуют протокол iterator:
<p>
<b>итератор.__iter__()</b><br>
Возвращает сам объект iterator. Это необходимо для того, чтобы разрешить использование как контейнеров, так и итераторов с 
операторами for и in.
<p>
<b>iterator.__next__()</b><br>
Возвращает следующий элемент из итератора. Если больше нет элементов, вызовите исключение StopIteration.
<p>
<table border=1>
<tr><td valign=top>
Обычный цикл:
<pre>
books = ["111", "222", "333"]
>>> for book in books:
...  print(book)
</pre>
</td>
<td>
Этот же цикл через встроенные функции iter() и next():
<pre>
books_iterator = iter(books)
  while True:
    try:
       book = next(books_iterator)
    except StopIteration:
       break
    print(book)</pre>
</td>
<td>
Тот же код с помощью методов:
<pre>
books_iterator = books.__iter__()
  while True:
    try:
       book = books_iterator.__next__()
    except StopIteration:
       break
    print(book)
</pre>
</td>
</tr></table>
<p>
Видим: у типа list есть метод __iter__, который возвращает объект. Этот объект, в свою очередь, имеет метод __next__, который 
возвращает, по одному, элементы списка books и поднимает StopIteration, когда этих элементов больше нет. Еще этот объект тоже 
имеет метод __iter__, который возвращает его самого:
<pre>
>>> books = ["111", "222", "333"]
>>> books
['111', '222', '333']
>>> type(books)
&lt;class 'list'&gt;
>>> books_iterator = books.__iter__()
>>> books_iterator
&lt;list_iterator object at 0x7fbf0e732820&gt;
>>> type(books_iterator)
&lt;class 'list_iterator'&gt;
>>> books_iterator.__iter__() is books_iterator
True</pre>
Вместе __iter__ и __next__ составляют протокол итератора. Так вот, объект класса, соблюдающего этот протокол, называется 
<b>итератором (iterator)</b>. Объект класса, который реализует метод __iter__, называется <b>итерируемым (iterable)</b>. В 
данном случае:<br>
books_iterator – итератор,<br>
books – итерируемое.
<p>
Роль метода __next__ заключается в том, чтобы задавать порядок обхода итерируемого (не обязательно делать этот порядок строго 
от первого к последнему). Метод __iter__ нужен для того, чтобы итератор и итерируемое могли использоваться с оператором in:
<pre>
>>> books_iterator = iter(books)
>>> for book in books_iterator:
...  print(book)</pre>


<h4>Как сделать итератор из класса</h4>
Вот так выглядит итератор, который обходит список, начиная с последнего элемента и заканчивая первым:
<table border=1><tr><td>
<pre>
class ReverseIt():
    def __init__(self, reverse_me):
        self.reverse_me = reverse_me
        self.current_index = len(reverse_me) - 1

    def __iter__(self):
        return self

    def __next__(self):
        if self.current_index < 0:
            raise StopIteration()
        current_element = self.reverse_me[self.current_index]
        self.current_index -= 1
        return current_element</pre>
</td></tr></table>        
И вот так его можно использовать:
<pre>
>>> reverse_books_iterator = ReverseIt(books)
>>> for book in reverse_books_iterator:
...  print(book)
</pre>
Мы написали именно reverse_books_iterator = ReverseIt(books), а не reverse_books_iterator = iter(books). Последнее вернет нам обычный итератор. Но мы могли бы так написать, если бы у списка метод __iter__ был определен так:
<pre>
def __iter__(self):
    return ReverseIt(self)</pre>
<p>
Создадим класс, основанный на типе данных lsit, экземпляры которого будут итерироваться парами.
<pre>
# Сначала создадим итератор, в котором определим метод next и условие окончания итерации
class DoubleElementListIterator:
    # В init определим атрибуты итератора на основе значений которых будет работать метод next 
    def __init__(self, lst):
        # Прежде всего передадим итератору в качестве атрибута сам итерируемый список
        self.lst = lst
        # Затем опредилм атрибут - номер текущего элемента в листе
        self.i = 0
    # Прописываем правило итерирования и остановки
    def __next__(self):
        # Если счетчик итераций не дошел до последнего элемента листа, 
        # то в качестве следующего значения вернем пару из двух элементов стоящих после текущего:
        if self.i < len(self.lst):
            self.i += 2
            return self.lst[self.i - 2], self.lst[self.i - 1]
        # если достигнут последний элемент в листе останавливаем итерацию
        else:
            raise StopIteration

# Теперь создаем класс, экземпляры которого мы хотим итерировать итератором (способом) описанным выше            
class MyList(list):
    # Определяем метод итератор, который ссылается на уже описанный итератор        
    def __iter__(self):
        return DoubleElementListIterator(self)

for pair in MyList([1, 2, 3, 4, 5, 6]):
    print(pair)</pre>
<p>
Резюме:
<ul>
<li> Итерируемое – объект, у которого есть метод __iter__ и он возвращает итератор.
<li> Итератор – объект, у которого есть методы __iter__ и __next__.
<li> Эти методы называют “магическими”, они часто используются в синтаксических конструкциях вроде for ... in ....
</ul>


<h3 align=center>Генераторы - итераторы</h3>
Создание итератора в Python — достаточно громоздкая операция. Для этого нужно написать класс и реализовать методы __iter__() и 
__next__(). После этого требуется настроить внутренние состояния и вызывать исключение StopIteration, когда больше нечего 
возвращать.
<p>
Генераторы служат для той же цели, что и итераторы, но код для их описания меньше.<br>
Генераторы предоставляют удобный способ реализации протокола iterator. Если метод __iter__() объекта контейнера 
реализован как генератор, он автоматически вернет объект-итератор (технически, объект-генератор), предоставляющий методы 
__iter__() и __next__().
<p>
Генераторы создают с помощью функции или выражения.
<p>
Генератор — это объект, который сразу при создании не вычисляет значения всех своих элементов.
<br>Он хранит в памяти только последний вычисленный элемент, правило перехода к следующему и условие, при котором выполнение 
прерывается.
<br>Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется.
<p>
Этим генераторы отличаются от списков — те хранят в памяти все свои элементы, и удалить их можно только программно. Вычисления 
с помощью генераторов называются ленивыми, они экономят память.
<pre>
>>> alist = [4, 16, 64, 256]
>>> alist
[4, 16, 64, 256]
>>> out = (a**(1/2) for a in alist)
>>> out
&lt;generator object &lt;genexpr&gt; at 0x7fc6cc244ba0&gt;
>>> print(out)
&lt;generator object &lt;genexpr&gt; at 0x7fc6cc244ba0&gt;
>>> print(next(out))
2.0
>>> print(list(out))
[4.0, 8.0, 16.0]
>>> alist
[4, 16, 64, 256]
>>> out
&lt;generator object &lt;genexpr&gt; at 0x7fc6cc244ba0&gt;
>>> print(list(out))
<font color=red>[]</font> # не очень понятно почему пустой список
>>> out = (a**(1/2) for a in alist) # создаем новый генератор
>>> out
&lt;generator object &lt;genexpr&gt; at 0x7fc6cc244c10&gt; # новый генератор
>>> print(list(out)) # выводим список с текущего указателя генератора и указатель остановится за пределы списка
[2.0, 4.0, 8.0, 16.0]
>>> print(list(out))
[]</pre>
Здесь помоему генератор это типа указатель на текущий элемент итерируемого объекта с последнего вызова генератора.
<p>
Чтобы освоить yield, вы должны понимать, что когда вы вызываете функцию, код внутри тела функции не исполняется. Функция 
только возвращает объект-генератор — немного мудрёно :-)
<p>
Ваш код будет вызываться каждый раз, когда for обращается к генератору.
<p>
Теперь трудная часть:
<br>В первый запуск вашей функции, она будет исполняться от начала до того момента, когда она наткнётся на yield — тогда она 
вернёт первое значение из цикла. На каждый следующий вызов будет происходить ещё одна итерация написанного вами цикла, 
возвращаться будет следующее значение — и так пока значения не кончатся.



<h4>Создание генератора с помощью выражения</h4>
Как и выражения создающие списки, выражения создающие генераторы позволяют быстро получить объект генератора с помощью всего 
одной строчки кода. Использоваться они могут в тех же случаях, что и выражения создающие списки, но при этом у них есть одно 
дополнительное преимущество. Их можно создавать не удерживая весь объект в памяти перед итерацией. Если перефразировать, вы не 
будете расходовать память при использовании генератора.
<p>
Возьмем возведение в квадрат некоторых чисел:
<pre>
nums_squared_lc = [num**2 for num in range(5)]
nums_squared_gc = (num**2 for num in range(5))</pre>
И nums_squared_lc, и nums_squared_gc выглядят практически одинаково, но есть одно ключевое отличие. Вы сможете его заметить? 
Для первого объекта использовались квадратные скобки и это привело к созданию списка. Для второго использовались круглые 
скобки, и это привело к созданию генератора. Посмотрите, что произойдет, если мы выведем содержание каждого из этих объектов:
<pre>
nums_squared_lc
[0, 1, 4, 9, 16]
nums_squared_gc
&lt;generator object &lt;genexpr&gt; at 0x107fbbc78&gt;</pre>
Это подтверждает тот факт, что с помощью круглых скобок вы создали объект генератора, а также то, что он отличается от списка.

<h4>Генераторы с помощью функций</h4>
От обычных функций отличаются наличием вместо return слова yield.<br>
yield выполняет функцию next() возвращая следующий элемент из перебираемого класса.
<a name="import"><h3 align=center>Импортирование классов</h3>
По мере добавления новой функциональности в классы файлы могут стать слишком длинными даже при правильном использовании наследования и композиции. В соответствии с общей философией Python файлы не должны содержать лишние подробности. Для этого Python позволяет хранить классы в модулях и импортировать нужные классы в основную программу.
<h4>Импортирование одного класса</h4>
Начнем с создания модуля, содержащего только класс Car . Ниже приведен файл car.py с кодом класса Car :<br>
<b>car.py</b>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
"""Класс для представления автомобиля."""
class Car:
    """Простая модель автомобиля."""
    def __init__(self, make, model, year):
        """Инициализирует атрибуты описания автомобиля."""
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        """Возвращает отформатированное описание."""
        long_name = f"{self.year} {self.manufacturer} {self.model}"
        return long_name.title()

    def read_odometer(self):
        """Выводит данные о пробеге машины в милях."""
        print(f"This car has {self.odometer_reading} miles on it.")

    def update_odometer(self, mileage):
        """
        Устанавливает на одометре заданное значение.
        При попытке обратной подкрутки изменение отклоняется.
        """
        if mileage >= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print("You can't roll back an odometer!")

       def increment_odometer(self, miles):
           """Увеличивает показания одометра с заданным приращением."""
           self.odometer_reading += miles
</pre></td></tr></table>
<p>
Мы добавляем строку документации уровня модуля с кратким описанием содер-
жимого модуля (самая верхняя строка). Пишите строки документации для каждого созданного вами модуля.
<p>
Теперь создадим отдельный файл my_car.py . Он импортирует класс Car и создает экземпляр данного класса:<br>
<b>my_car.py</b>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from car import Car

my_new_car = Car('audi', 'a4', 2024)
print(my_new_car.get_descriptive_name())
my_new_car.odometer_reading = 23
my_new_car.read_odometer()
</pre></td></tr></table>
<p>
Оператор import дает Python указание открыть модуль car и импортировать класс Car . Теперь мы можем использовать этот класс, как если бы он был определен в данном файле. Результат остается тем же, что и в предыдущей версии:<br>
2024 Audi A4<br>
This car has 23 miles on it.<br>
Импортирование классов повышает эффективность программирования. Представьте, каким длинным получился бы файл этой программы, если бы в него был включен весь класс Car . Перемещая класс в модуль и импортируя этот модуль, вы получаете ту же функциональность, но основной файл программы при этом остается чистым и удобочитаемым. Кроме того, бо́льшая часть логики может храниться в отдельных файлах; когда ваши классы работают как положено, вы можете забыть об этих файлах и сосредоточиться на высокоуровневой логике основной программы.
<h4>Хранение нескольких классов в модуле</h4>
В одном модуле можно хранить сколько угодно классов, хотя все они должны быть как-то связаны друг с другом. Оба класса, Battery и ElectricCar , используются для представления автомобилей, поэтому мы добавим их в модуль car.py:<br>
<b>car.py</b>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
"""Классы для представления машин с бензиновым и электродвигателем."""
class Car:
    --пропуск--

class Battery:
    """Простая модель аккумулятора электромобиля."""
    --пропуск--

class ElectricCar(Car):
    """Представляет аспекты машины, специфические для электромобилей."""
    --пропуск--
</pre></td></tr></table>
<p>
Теперь вы можете создать новый файл my_electric_car.py , импортировать класс ElectricCar и создать новый экземпляр электромобиля:<br>
<b>my_electric_car.py</b>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from car import ElectricCar

my_leaf = ElectricCar('nissan', 'leaf', 2024)
print(my_leaf.get_descriptive_name())
my_leaf.battery.describe_battery()
my_leaf.battery.get_range()
</pre></td></tr></table>
<h4>Импортирование нескольких классов из модуля</h4>
В файл программы можно импортировать столько классов, сколько понадобится. Если вы захотите создать обычный автомобиль и электромобиль в одном файле, то потребуется импортировать оба класса, Car и ElectricCar :
<p>
<b>my_cars.py</b>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
<b>from car import Car, ElectricCar</b>

my_mustang = Car('ford', 'mustang', 2024)
print(my_mustang.get_descriptive_name())

my_leaf = ElectricCar('nissan', 'leaf', 2024)
print(my_leaf.get_descriptive_name())
</pre></td></tr></table>
<p>
Чтобы импортировать несколько классов из модуля, разделите их имена запятыми. После того как необходимые классы будут импортированы, вы можете создать столько экземпляров каждого класса, сколько потребуется. В этом примере создается обычный автомобиль Ford Mustang и электромобиль Nissan Leaf:
<pre>
2024 Ford Mustang
2024 Nissan Leaf
</pre>
<h4>Импортирование модуля целиком</h4>
Можно импортировать весь модуль, а потом обращаться к нужным классам, используя точечную запись. Этот способ прост, а полученный код легко читается. Каждый вызов, создающий экземпляр класса, содержит имя модуля, поэтому в программе не будет конфликтов с именами, используемыми в текущем файле. Вот как выглядят импорт всего модуля car , а затем создание обычного автомобиля и электромобиля:
<p>
<b>my_cars.py</b>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
import car

my_mustang = <b>car.Car</b>('ford', 'mustang', 2024)  # имя модуля.имя класса
print(my_mustang.get_descriptive_name())

my_leaf = <b>car.ElectricCar</b>('nissan', 'leaf', 2024)
print(my_leaf.get_descriptive_name())
</pre></td></tr></table>
<p>
Сначала импортируется весь модуль car, после чего программа обращается к нужным классам, используя синтаксис:
<pre>
 имя_модуля.ИмяКласса
</pre>
Затем снова создаются экземпляры my_mustang и экземпляр my_leaf.
<h4>Импортирование всех классов из модуля</h4>
Для импортирования всех классов из модуля используется следующий синтаксис:
<p>
from имя_модуля import *
<p>
Применять этот способ не рекомендуется по двум причинам. Прежде всего бывает полезно прочитать операторы import в начале файла и получить четкое представление о том, какие классы используются в программе. А этот способ не позволяет понять, какие классы из модуля нужны программе. Кроме того, возможны конфликты с именами в файле. Если вы случайно импортируете класс с именем, уже
присутствующим в файле, то в программе могут возникнуть ошибки, которые трудно выявить. Почему я привожу описание этого способа? Хотя использовать его не рекомендуется, скорее всего, вы встретите его в коде других разработчиков. Итак, если вам нужно импортировать большое количество классов из модуля, то лучше импортировать весь модуль и воспользоваться синтаксисом имя_
модуля.ИмяКласса . Вы не видите перечень всех используемых классов в начале файла, но по крайней мере понятно, где модуль используется в программе. К тому же предотвращаются потенциальные конфликты имен, которые могут возникнуть при
импортировании каждого класса в модуле.
<h4>Импортирование модуля в модуль</h4>
Иногда классы приходится распределять по нескольким модулям, чтобы избежать чрезмерного разрастания одного файла и хранения несвязанных классов в одном модуле. При хранении классов в нескольких модулях может оказаться, что класс из одного модуля зависит от класса из другого модуля. В таких случаях необходимый класс можно импортировать в первый модуль. Допустим, класс Car хранится в одном модуле, а классы ElectricCar и Battery — в другом. Мы создадим новый модуль electric_car.py (он заменит файл electric_car.py , созданный ранее) и скопируем в него только классы Battery и ElectricCar :
<p>
<b>electric_car.py</b>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
"""Набор классов для представления электромобилей."""
from car import Car

class Battery:
    --пропуск--

class ElectricCar(Car):
    --пропуск--
</pre></td></tr></table>
<p>
Классу ElectricCar необходим доступ к классу-родителю Car , поэтому класс Car импортируется прямо в модуль. Если вы забудете вставить эту команду, то при попытке создания экземпляра ElectricCar произойдет ошибка. Кроме того, необходимо обновить модуль Car , чтобы он содержал только класс Car :
<p>
car.py
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
"""Простая модель автомобиля."""
class Car:
    --пропуск--
</pre></td></tr></table>
<p>
Теперь вы можете импортировать классы из каждого модуля по отдельности и создать ту разновидность машины, которая вам нужна:
<p>
<b>my_cars.py</b>
<p>
<table border=1 style="border-collapse:collapse;" cellpadding=10><tr><td>
<pre>
from car import Car
from electric_car import ElectricCar

my_mustang = Car('ford', 'mustang', 2024)
print(my_mustang.get_descriptive_name())

my_leaf = ElectricCar('nissan', 'leaf', 2024)
print(my_leaf.get_descriptive_name())
</pre></td></tr></table>
<p>
Сначала класс Car импортируется из своего модуля, а класс ElectricCar — из своего. После этого создаются экземпляры обоих разновидностей.
<h4>Использование псевдонимов</h4>
Как было показано в главе 8, псевдонимы весьма полезны при использовании модулей для организации кода проектов. Кроме того, они позволят импортировать классы. Для примера возьмем программу, которая должна создать группу экземпляров электрических машин. Многократно вводить (и читать) имя ElectricCar будет очень утомительно. Имени ElectricCar можно назначить псевдоним в операторе import :
<p>
from electric_car import ElectricCar as EC
<p>
С этого момента вы сможете использовать этот псевдоним каждый раз, когда вам потребуется создать экземпляр ElectricCar :
<p>
my_leaf = EC('nissan', 'leaf', 2024)
<p>
Вы также можете присвоить псевдоним модулю. Ниже показано, как импортировать модуль electric_car целиком, используя псевдоним:
<p>
import electric_car as ec
</p>
Теперь вы можете использовать псевдоним этого модуля с полным именем класса:
<p>
my_leaf = ec.ElectricCar('nissan', 'leaf', 2024)
<pre>



==========================================================================================================================



</pre>
<h3 align=center><a name="mag_metod">Магические методы</h3>
Ссылки: <a href="https://habr.com/ru/articles/186608/">Руководство по магическим методам в Питоне</a>
<p>
Что такое магические методы? Они всё в объектно-ориентированном Питоне. Это специальные методы, с помощью которых вы можете добавить в ваши классы «магию». Они всегда обрамлены двумя нижними подчеркиваниями (например, __init__ или __lt__).
</div><pre>











</pre></body</html>
