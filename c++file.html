<html><head>
<style>
.menu {
       height: 100%;
       width: 140px;
       position: fixed; /* Фиксированная боковая панель (оставайтесь на месте при прокрутке) */
       background-color: Gray;  
      }
 .menu a {
  padding: 15px 5px 5px 5px;
  text-decoration: none;
  font-size: 15px;
  /*color: #818181;*/
  display: block;
          }     
.content {
           padding: 0px 0px 0px 10px;
           margin-left: 140px; /* То же, что и ширина боковой панели */
         }
</style>
</head><body>
<title>Cи++</title>
<div class="menu">
<a href="./index.html">Главная</a>
--------------------------
<a href="./c++_massiv.html">Массивы</a>
<a href="./c++_example.html">Решения</a>
---------------------
Работа с файлами:
<a href="#file">Файловые потоки</a>
<a href="#mode">&nbsp;&nbsp; Режимы доступа к файлам</a>
<a href="#read">Чтение запись в файл в текстовом режиме</a>
<a href="#binar_mode">Чтение запись в файл в бинарном режиме</a>
</div>

<div class="content">
Ссылки на учебники: <a href="https://metanit.com/cpp/tutorial/">Руководство по языку программирования C++</a><br>
<a href="https://proproprogs.ru/c_base/cpp-pervaya-programma-na-s">Первая программа на С++</a>
<a name="file"><h3 align=center>Файловые потоки</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-faylovye-potoki-otkrytie-i-zakrytie-faylov-rezhimy-dostupa">Файловые потоки. Открытие и закрытие файлов. Режимы доступа</a><br>
<a href="https://metanit.com/cpp/tutorial/8.2.php">Файловые потоки. Открытие и закрытие</a>
<p>
В языке С++ существует набор классов, упрощающих работу с файловыми потоками (или, попросту, с файлами). Они следующие:
<ul>
<li> <b>ifstream</b> – для чтения данных из файла;
<p>
<li> <b>ofstream</b> – для записи данных в файл;
<p>
<li> <b>fstream</b> – для записи и чтения данных из файла.
</ul>
И аналогичные им классы с дополнительной буквой w, означающей работу с данными типа wchar_t:
<ul>
<li> wifstream – для чтения данных из файла;
<li> wofstream – для записи данных в файл;
<li> wfstream – для записи и чтения данных из файла.
</ul>
В рамках этого курса мы ограничимся первыми тремя классами. Три других используются аналогичным образом.
<p>
Для их использования в программе вначале необходимо подключить <b>заголовочный файл с именем fstream</b>:
<pre>
#include &lt;fstream>
</pre>
После этого можно создавать объекты этих классов. Например:
<pre>
#include &lt;iostream>
#include &lt;fstream>
 
using std::cout;
using std::cin;
using std::endl;
 
int main()
{
    std::ofstream ofs; //объект ofs класса ofstream в пространстве имён std
    std::ifstream ifs;
    return 0;
}
</pre>
Чтобы связать выходной и входной потоки с определенными файлами, используется <b>метод open</b> следующим образом:
<pre>
    ofs.open("ofs.dat");
    ifs.open("ifs.dat");
</pre>
Здесь файл ofs.dat открывается на запись в текстовом режиме доступа; файл ifs.dat – открывается на чтение также в текстовом режиме доступа.
<p>
После запуска программы в текущем (рабочем) каталоге появится пустой файл с именем ofs.dat.
<p>
Также открытие файла можно делать сразу в момент создания объектов классов потоков следующим образом:
<pre>
    std::ofstream ofs("ofs.dat");
    std::ifstream ifs("ifs.dat");
</pre>
Результат будет аналогичным.
<p>
Далее, мы знаем, что после завершения работы с файлами их обязательно нужно закрывать. Для этого используется <b>метод close()</b> объектов ofs и ifs:
<pre>
    ofs.close();
    ifs.close();
</pre>
И последний важный штрих в этой схеме открытия и закрытия файлов. Нам нужно проверить, что файл был открыт успешно, прежде чем начинать что-либо в него записывать или считывать. Для этого предусмотрен <b>метод is_open()</b>. Я для его демонстрации запишу следующие строчки:
<pre>
    cout << (ofs.is_open() ? "Файл ofs.dat открыт" : "Ошибка открытия файла ofs.dat") << endl;
    cout << (ifs.is_open() ? "Файл ifs.dat открыт" : "Ошибка открытия файла ifs.dat") << endl;
</pre>
После запуска программы увидим в консоли сообщения:
<pre>
Файл ofs.dat открыт
Ошибка открытия файла ifs.dat
</pre>
То есть, на запись файл был открыт успешно, а на чтение – с ошибкой. И это логично, так как файла ifs.dat в рабочем каталоге не существует.
<pre>


</pre>
<a name="mode"><h3 align=center>Режимы доступа к файлам</h3>
Давайте теперь посмотрим, какие режимы доступа к файлам мы можем прописывать при их открытии. Основные, следующие:
<ul>
<li> ios::in – для чтения (только для объектов классов ifstream или fstream);
<li> ios::out – для записи; прежние данные удаляются (только для объектов классов ofstream или fstream);
<li> ios::app – для дозаписи; прежние данные не удаляются;
<li> ios::ate – при открытии указатель файла смещается в конец;
<li> ios::binary – открытие файла в бинарном режиме доступа.
</ul>
Указанные флаги используются, как самостоятельно, так и в допустимых комбинациях с другими флагами. Например, мы можем указать открыть файл на дозапись:
<pre>
int main()
{
    using std::ios;
    std::ofstream ofs("ofs.dat");
    std::ifstream ifs("ifs.dat", <b>ios::app</b>);
    ...
    return 0;
}
</pre>
Обратите внимание, что после выполнения программы файл ifs.dat создается и успешно открывается благодаря изменению режима открытия. Сам файл, конечно же, будет пустым.
<p>
Или можно записать следующую комбинацию флагов для открытия файлов в бинарном режиме доступа:
<pre>
    std::ofstream ofs("ofs.dat", ios::out | ios::binary);
    std::ifstream ifs("ifs.dat", ios::app | ios::binary);
</pre>
И так далее. Мы можем прописывать, как самостоятельные флаги, так и их допустимые комбинации. Допустимость можно определить с позиции здравого смысла. Либо, почитать в документации.
<pre>

=========================================================================================================================


</pre>
<a name="read"><h3 align=center>Чтение и запись данных в файл в текстовом режим</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-chtenie-i-zapis-dannyh-v-fayl-v-tekstovom-rezhime">Чтение и запись данных в файл в текстовом режим</a><br>
<a href="https://metanit.com/cpp/tutorial/8.3.php">Чтение и запись текстовых файлов</a>
<p>
Продолжаем тему работы с файлами.<br>
Пусть в программе открывается файл на запись в текстовом режиме доступа:
<pre>
#include &lt;iostream>
#include &lt;fstream>
 
<font color=red>using std::ios;</font> //зачем?
 
int main()
{
    std::ofstream ofs("out_course.dat");    // открытие файла
 
    ofs.close();            // закрытие файла
    return 0;
}
</pre>
Чтобы поместить в него какие-либо данные базовых типов, достаточно воспользоваться операцией <<, например, следующим образом:
<pre>
if(ofs.is_open()) {
        <b>ofs << 10 << " " << -5.34 << " " << -34 << std::endl;</b>
    }
</pre>
Чтобы прочитать файл, воспользуемся файловым потоком, открытым с помощью класса ifstream, следующим образом:
<pre>
int main()
{
    ...
 
    // ------------- чтение данных из файла --------------------------------
    int data_i1 {}, data_i2 {};
    double data_d1 {};
 
    <b>std::ifstream ifs("out_course.dat");
    
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_d1 >> data_i2;</b>
    }
    std::cout << data_i1 << " " << data_d1 << " " << data_i2 << std::endl;
 
    ifs.close();            // закрытие файла
 
    return 0;
}
</pre>
Как видите, для чтения данных произвольного типа используется операция >>, которую также можно вызывать по цепочке. При этом пробел автоматически воспринимается, как разделитель между данными, подобно тому, как это было для функции scanf() языка Си. И, разумеется, формат читаемых данных должен совпадать с типом переменных, в которые происходит чтение. Например, если совпадений по типам не будет:
<pre>
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_i2 >> data_d1;
    }
</pre>
То данные будут прочитаны некорректно.
<pre>

</pre>
<h3 align=center>Запись и чтение строк</h3>
Но это были числа. Что если нам нужно записывать и считывать строки целиком? Нет ничего проще. Запись строк происходит совершенно так же, как и запись чисел. Например:
<pre>
    if(ofs.is_open()) {
        ofs << 10 << " " << -5.34 << " " << -34 << "\n";
        <b>ofs << "I'm Sergey Balakirev" << std::endl;</b>
    }
</pre>
В выходном файле видим эту строку. А вот чтение имеет свои нюансы. Опять же, операция >> работает по аналогии с функцией scanf(), а значит, читает строку до первого пробела. Например:
<pre>
    std::string str;
 
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_d1 >> data_i2;
        ifs >> str;
    }
 
    std::cout << str << std::endl;
</pre>
Увидим фрагмент:<br>
I'm<br>
Причем, обратите внимание, так как объект-строка str основывается на динамическом массиве, то выход за его пределы при чтении длинных строк происходить не будет. То есть, это безопасная операция. А вот если бы мы воспользовались обычным массивом символов:<br>
char msg[100];<br>
ifs >> msg;<br>
то вполне можно выйти за его пределы и записать информацию в недопустимые ячейки памяти. Работа такой программы становится непредсказуемой. Об этом всегда следует помнить, при работе со строками.
<p>
Итак, вернем прежний вариант строки str и спрашивается, как же все-таки прочитать всю строку до символа перевода строки, либо до конца файла? Для этого можно воспользоваться уже знакомой нам <b>функцией getline()</b> следующим образом (не забываем прописать: #include &lt;string>):
<pre>
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_d1 >> data_i2;
        std::getline(ifs, str);
        std::getline(ifs, str);
    }
</pre>
Обратите внимание, мне пришлось дважды вызвать функцию getline() для чтения следующей строки. Дело в том, что после чтения числовых данных указатель файла ведет на символ переноса строки, поэтому первая функция его читает и выдает пустую строку, а следующая уже читает с новой строки все символы до следующего перевода строки. Поэтому, для пропуска всех пустых строк, можно записать следующую конструкцию:
<pre>
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_d1 >> data_i2;
        str = "";
        while(str.length() == 0)
            std::getline(ifs, str);
    }
</pre>
<pre>

====================================================================================================================


</pre>
<a name="binar_mode"><h3 align=center>Чтение и запись данных в файл в бинарном режиме</h3>
Ссылки: <a href="https://proproprogs.ru/c_base/cpp-chtenie-i-zapis-dannyh-v-fayl-v-binarnom-rezhime">Чтение и запись данных в файл в бинарном режиме</a>
<p>
Бинарный режим позволяет сохранять данные в файл в том же виде, в котором они представлены в ячейках памяти устройства. То есть, мы можем просто прочитать данные из памяти и перенести их в файл. И, наоборот, прочитать данные из файла и занести их в нужные ячейки памяти. В результате, сложные структуры данных достаточно просто можно сохранять и загружать из файла.
<p>
Давайте предположим, что нам в программе нужно сохранять массив из вещественных чисел в файл. Такие «не простые» наборы данных удобнее всего сохранять и, затем, читать в бинарном режиме доступа:
<pre>
#include &lt;iostream>
#include &lt;fstream>
 
using std::ios;
 
int main()
{
    double pow[] {4.3, -54.33, 0.01};
 
    std::ofstream ofs("out_course.dat", ios::out | <b>ios::binary</b>);
 
    if(ofs.is_open()) {
    }
 
    ofs.close();
    return 0;
}
</pre>
Если сейчас попытаться сохранить массив pow, используя операцию <<:
<pre>
    if(ofs.is_open()) {
        ofs << pow;
    }
</pre>
то в файл запишется адрес массива в текстовом виде. Как же нам сохранить данные этого массива, перенеся данные из ячеек памяти, которые он занимает, в файл? Для этого следует воспользоваться методом write() следующим образом:
<pre>
    if(ofs.is_open()) {
        <b>ofs.write((char *)pow, sizeof(pow));</b> //запись в файл из массива
    }
</pre>
Этот метод работает по аналогии с функцией write() языка Си. Первым аргументом передается адрес области памяти, которая переносится в файл, а вторым аргументом – размер сохраняемого фрагмента. В нашем случае – это размер массива pow в байтах.
<p>
После выполнения программы в выходном файле появится набор нечитаемых символов, соответствующих байтовому представлению массива pow в памяти устройства. Прочитать обратно эти данные в массив очень просто. Для этого откроем файл на чтение также в бинарном режиме и прочитаем байты с помощью метода read():
<pre>
    // ------------- чтение данных из файла --------------------------------
    double read_pow[5] {0};
 
    std::ifstream ifs("out_course.dat", ios::in | <b>ios::binary);</b> //бинарный режим
 
    if(ifs.is_open()) {
        <b>ifs.read((char *)read_pow, sizeof(pow));</b>
    }
 
    for(double x : read_pow)
        std::cout << x << " ";
 
    ifs.close()
</pre>
Метод read() работает по аналогии с функцией read() языка Си и позволяет заносить в указанную область памяти, прочитанные из файла данные. В данном случае, мы в массив read_pow заносим байты, ранее сохраненного массива pow. Разумеется, массив read_pow должен иметь тот же тип данных и размер не меньше, чем pow.
<p>
После запуска программы, увидим значения:<br>
4.3 -54.33 0.01 0 0<br>
Как видим, данные были успешно прочитаны.
<pre>


</pre>
<h3 align=center>Чтение и запись структур в файл</h3>
Давайте, для лучшего понимания, приведу еще один практический пример использования бинарного режима доступа. Пусть у нас объявлена следующая структура:
<pre>
struct person {
    char fio[100];
    short old;
    unsigned int salary;
    double weight;
};
</pre>
И, затем, в программе выполняется сохранение <b>массива таких структур</b> и их последующее чтение следующим образом:
<pre>
int main()
{
    struct person ps[] {{"Sergey Balakirev", 102, 1000001, 82.6},
                        {"Bjarne Stroustrup", 56, 100001, 78.2},
                        {"Dennis Ritchie", 62, 10001, 88.9},
                        {"Kenneth Thompson", 58, 10002, 75.3},
                    };
 
    std::ofstream ofs("out_course.dat", ios::out | ios::binary);
 
    if(ofs.is_open()) {
        <b>for(auto& p : ps)
            <font color=red>ofs.write((char *)&p, sizeof(p));</font></b> //берём указатель от указателя
    }
 
    ofs.close();
 
    // ------------- чтение данных из файла --------------------------------
    struct person ps_r[10];
    int count = 0;
 
    std::ifstream ifs("out_course.dat", ios::in | ios::binary);
 
    if(ifs.is_open()) {
        <b>while(ifs.read((char *)&ps_r[count], sizeof(person)))</b> {
            count++;
        }
    }
 
    ifs.close();
 
    std::cout << count << std::endl;
    for(int i = 0; i < count; ++i) {
        std::cout << ps_r[i].fio << "\n";
        std::cout << ps_r[i].old << " " << ps_r[i].salary << " " << ps_r[i].weight << std::endl;
    }
 
    return 0;
}
</pre>
Вначале мы перебираем поэлементно все элементы массива ps и с помощью метода write() записываем друг за другом в файл. После этого объявляем еще один массив таких же структур и в цикле поэлементно читаем данные из файла в этот новый массив.
<p>
Обратите внимание, как выполняется чтение данных. Условием окончания цикла while является возвращаемое значение метода read(). Этот метод вернет 0 (false), когда данные в файле закончатся. Таким образом, мы прочитаем ровно столько же порций данных, сколько было записано. Вывод результата в консоль это подтверждает.
<pre>





</pre>
</div></body></html>
