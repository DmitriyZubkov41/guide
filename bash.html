<html><head></head><body>
<title>Bash</title>
<h2 align="center">Программирование на Bash</h2>
Ссылки: <a href="https://habr.com/ru/companies/ruvds/articles/325522/">Bash-скрипты: начало</a>
<p>
В командной строке можно выполнить несколько команд за один раз, введя их через точку с запятой: <i>pwd ; whoami</i>.<br>
Записав эту последовательность команд в файл, можно при вызове этого файла выполнить эти команды. Файлы имеют расширение .sh и называются bash-скриптами.
<p>
Первая строка, так называемый шебанг, таких скриптов всегда:<br>
<b>#!bin/bash</b>
<p>
В других строках этого файла символ решётки используется для обозначения комментариев, которые оболочка не обрабатывает. Однако, первая строка — это особый случай, здесь решётка, за которой следует восклицательный знак (эту последовательность называют шебанг) и путь к bash, указывают системе на то, что сценарий создан именно для bash.
<p>
После того как написали скрипт и сохранили его осталось лишь сделать этот файл исполняемым, иначе, попытавшись его запустить, вы столкнётесь с ошибкой Permission denied:<br>
<b>chmod +x path/file.sh</b>
<p>
Чтобы выполнить его:<br>
<b>bash file.sh</b><br>
или<br>
<b>.file.sh</b><br>
или<br>
<b>source file.sh</b>
<h3>Переменные:</h3>
Существуют два типа переменных, которые можно использовать в bash-скриптах:
<ul>
<li>Переменные среды
<li>Пользовательские переменные
</ul>
Переменные среды - это переменные типа $HOME.
<p>
Обратная косая черта перед знаком $ говорит что это не переменная.<br>
\$1 - это не переменная $1, а 1 доллар.
<p>
 В дополнение к переменным среды, bash-скрипты позволяют задавать и использовать в сценарии собственные переменные. Подобные переменные хранят значение до тех пор, пока не завершится выполнение сценария. Также начинаются с $.
<h3>Подстановка команд</h3>
Одна из самых полезных возможностей bash-скриптов — это возможность извлекать информацию из вывода команд и назначать её переменным, что позволяет использовать эту информацию где угодно в файле сценария.<br>
Сделать это можно двумя способами:
<ul>
<li> С помощью значка обратного апострофа: <b>`</b>
<li> С помощью конструкции $()
</ul>
Используя первый подход, проследите за тем, чтобы вместо обратного апострофа не ввести одиночную кавычку. Команду нужно заключить в два таких значка:<br>
mydir=`pwd`
<p>
При втором подходе то же самое записывают так:<br>
mydir=$(pwd)
<p>
А скрипт, в итоге, может выглядеть так:
<p><pre>
#!/bin/bash
mydir=$(pwd)
echo $mydir
</pre><br>
В ходе его работы вывод команды pwd будет сохранён в переменной mydir, содержимое которой, с помощью команды echo, попадёт в консоль.

<h3>Математические операции</h3>
Для выполнения математических операций в файле скрипта можно использовать конструкцию вида $((a+b)):
<p><pre>
#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
var2=$(( $var1 * 2 ))
echo $var2
</pre>
<h3>Управляющая конструкция if-then</h3>
управляющая конструкция if-then в наиболее простом виде выглядит так:
<pre>
if команда
then
команды
fi
</pre>
<h3>Управляющая конструкция if-then-else</h3>
<pre>
if команда
then
команды
else
команды
fi
</pre>
Если первая команда возвратит ноль, что означает её успешное выполнение, условие окажется истинным и выполнение не пойдёт по ветке else. В противном случае, если будет возвращено что-то, отличающееся от нуля, что будет означать неудачу, или ложный результат, будут выполнены команды, расположенные после else.
<p>
Более сложный случай с вложенными блоками условия:
<pre>
if команда1
then
команды
elif команда2
then
команды
fi
</pre>
Если первая команда вернёт ноль, что говорит о её успешном выполнении, выполнятся команды в первом блоке then, иначе, если первое условие окажется ложным, и если вторая команда вернёт ноль, выполнится второй блок кода.

<h3>Сравнение чисел</h3>
В скриптах можно сравнивать числовые значения. Ниже приведён список соответствующих команд:
<ul>
<li> if [ n1 -eq n2 ] Возвращает истинное значение, если n1 равно n2.
<li> if [ n1 -ge n2 ] Возвращает истинное значение, если n1больше или равно n2.
<li> if [ n1 -gt n2 ] Возвращает истинное значение, если n1 больше n2.
<li> if [ n1 -le n2 ] Возвращает истинное значение, если n1меньше или равно n2.
<li> if [ n1 -lt n2 ] Возвращает истинное значение, если n1 меньше n2.
<li> if [ n1 -ne n2 ] Возвращает истинное значение, если n1не равно n2.
</ul>
Выражения сравнения помещается в квадратные скобки и между скобкой и знаком стоит пробел.

<h3>Сравнение строк</h3>
Можно сравнивать и строковые значения.
<ul>
<li> if [ str1 = str2 ] Проверяет строки на равенство, возвращает истину, если строки идентичны.
<li> if [ str1 != str2 ] Возвращает истину, если строки не идентичны.
<li> if [ str1 \< str2 ] Возвращает истину, если str1меньше, чем str2.
<li> if [ str1 \> str2 ]  Возвращает истину, если str1больше, чем str2.
<li> if [ -n str1 ] Возвращает истину, если длина str1больше нуля.
<li> if [ -z str1 ] Возвращает истину, если длина str1равна нулю.
</ul>
особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.

<h3>Проверки файлов</h3>
<ul>
<li> if [ -d file ] Проверяет, существует ли файл, и является ли он директорией.
<li> if [ -e file ] Проверяет, существует ли файл.
<li> if [ -f file ]  Проверяет, существует ли файл, и является ли он файлом.
<li> if [ -r file ] Проверяет, существует ли файл, и доступен ли он для чтения.
<li> if [ -s file ]  Проверяет, существует ли файл, и не является ли он пустым.
<li> if [ -w file ] Проверяет, существует ли файл, и доступен ли он для записи.
<li> if [ -x file ] Проверяет, существует ли файл, и является ли он исполняемым.
<li> if [ file1 -nt file2 ]  Проверяет, новее ли file1, чем file2.
<li> if [ file1 -ot file2 ] Проверяет, старше ли file1, чем file2.
<li> if [ -O file ]  Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.
<li> if [ -G file ] Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.
</ul>
<h2><a href="https://habr.com/ru/companies/ruvds/articles/325928/">Циклы</a></h2>
<h3>Циклы for</h3>
<pre>
for var in list
do
команды
done
</pre>
В каждой итерации цикла в переменную var будет записываться следующее значение из списка list. В первом проходе цикла, таким образом, будет задействовано первое значение из списка. Во втором — второе, и так далее — до тех пор, пока цикл не дойдёт до последнего элемента.
<h4>Инициализация цикла списком, полученным из результатов работы команды</h4>
Ещё один способ инициализации цикла for заключается в передаче ему списка, который является результатом работы некоей команды. Тут используется подстановка команд для их исполнения и получения результатов их работы.
<pre>
#!/bin/bash
file="myfile"
for var in $(cat $file)
do
echo " $var"
done
</pre>
В этом примере задействована команда cat, которая читает содержимое файла. Полученный список значений передаётся в цикл и выводится на экран. Обратите внимание на то, что в файле, к которому мы обращаемся, содержится список слов, разделённых знаками перевода строки, пробелы при этом не используются.
<p>
надо учесть, что подобный подход, если ожидается построчная обработка данных, не сработает для файла более сложной структуры, в строках которого может содержаться по несколько слов, разделённых пробелами. Цикл будет обрабатывать отдельные слова, а не строки.
<h4>Разделители полей</h4>
Причина вышеописанной особенности заключается в специальной переменной окружения, которая называется IFS (Internal Field Separator) и позволяет указывать разделители полей. По умолчанию оболочка bash считает разделителями полей следующие символы:
<p>
Пробел<br>
Знак табуляции<br>
Знак перевода строки
<p>
Если bash встречает в данных любой из этих символов, он считает, что перед ним — следующее самостоятельное значение списка.<br>
Для того, чтобы решить проблему, можно временно изменить переменную среды IFS. Вот как это сделать в bash-скрипте, если исходить из предположения, что в качестве разделителя полей нужен только перевод строки:
<p>
IFS=$'\n'
<p>
После добавления этой команды в bash-скрипт, он будет работать как надо, игнорируя пробелы и знаки табуляции, считая разделителями полей лишь символы перевода строки.
<h3>Обход файлов, содержащихся в директории</h3>
Один из самых распространённых вариантов использования циклов for в bash-скриптах заключается в обходе файлов, находящихся в некоей директории, и в обработке этих файлов.<br>
Например, вот как можно вывести список файлов и папок:
<pre>
#!/bin/bash
for file in /home/likegeeks/*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done
</pre>
При проверке условия в операторе if, мы заключаем имя переменной в кавычки. Сделано это потому что имя файла или папки может содержать пробелы.
<h3>Циклы for в стиле C</h3>
Схема цикла при подобном подходе выглядит так:
<p>
for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))
<p>
На bash это можно написать так:
<p>
for (( a = 1; a < 10; a++ ))
<p>
А вот рабочий пример:
<pre>
#!/bin/bash
for (( i=1; i <= 10; i++ ))
do
echo "number is $i"
done
</pre>
<h3>Цикл while</h3>
Конструкция for — не единственный способ организации циклов в bash-скриптах. Здесь можно пользоваться и циклами while. В таком цикле можно задать команду проверки некоего условия и выполнять тело цикла до тех пор, пока проверяемое условие возвращает ноль, или сигнал успешного завершения некоей операции. Когда условие цикла вернёт ненулевое значение, что означает ошибку, цикл остановится.
<p>
Вот схема организации циклов while
<p>
while команда проверки условия
<p>
do
<p>
другие команды
<p>
done
<p>
Взглянем на пример скрипта с таким циклом:
<pre>
#!/bin/bash
var1=5
while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done
</pre>
На входе в цикл проверяется, больше ли нуля переменная $var1. Если это так, выполняется тело цикла, в котором из значения переменной вычитается единица. Так происходит в каждой итерации, при этом мы выводим в консоль значение переменной до его модификации. Как только $var1 примет значение 0, цикл прекращается.
<h3>Вложенные циклы</h3>
В теле цикла можно использовать любые команды, в том числе — запускать другие циклы. Такие конструкции называют вложенными циклами:
<pre>
#!/bin/bash
for (( a = 1; a <= 3; a++ ))
do
echo "Start $a:"
for (( b = 1; b <= 3; b++ ))
do
echo " Inner loop: $b"
done
done
</pre>
<h3>Обработка содержимого файла</h3>
Чаще всего вложенные циклы используют для обработки файлов. Так, внешний цикл занимается перебором строк файла, а внутренний уже работает с каждой строкой. Вот, например, как выглядит обработка файла /etc/passwd:
<pre>
#!/bin/bash
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
echo "Values in $entry –"
IFS=:
for value in $entry
do
echo " $value"
done
done
</pre>
В этом скрипте два цикла. Первый проходится по строкам, используя в качестве разделителя знак перевода строки. Внутренний занят разбором строк, поля которых разделены двоеточиями.
<h3>Управление циклами</h3>
Возможно, после входа в цикл, нужно будет остановить его при достижении переменной цикла определённого значения, которое не соответствует изначально заданному условию окончания цикла. Надо ли будет в такой ситуации дожидаться нормального завершения цикла? Нет конечно, и в подобных случаях пригодятся следующие две команды:
<p>
break<br>
continue
<h4>Команда break</h4>
Эта команда позволяет прервать выполнение цикла. Её можно использовать и для циклов for, и для циклов while:
<pre>
#!/bin/bash
for var1 in 1 2 3 4 5 6 7 8 9 10
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Number: $var1"
done
</pre>
<h4>Команда continue</h4>
Когда в теле цикла встречается эта команда, текущая итерация завершается досрочно и начинается следующая, при этом выхода из цикла не происходит. Посмотрим на команду continue в цикле for:
<pre>
#!/bin/bash
for (( var1 = 1; var1 < 15; var1++ ))
do
if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
then
continue
fi
echo "Iteration number: $var1"
done
</pre>
Когда условие внутри цикла выполняется, то есть, когда $var1 больше 5 и меньше 10, оболочка исполняет команду continue. Это приводит к пропуску оставшихся в теле цикла команд и переходу к следующей итерации.

<h3>Обработка вывода, выполняемого в цикле</h3>
Данные, выводимые в цикле, можно обработать, либо перенаправив вывод, либо передав их в конвейер. Делается это с помощью добавления команд обработки вывода после инструкции done.<br>
Например, вместо того, чтобы показывать на экране то, что выводится в цикле, можно записать всё это в файл или передать ещё куда-нибудь:
<pre>
#!/bin/bash
for (( a = 1; a < 10; a++ ))
do
echo "Number is $a"
done > myfile.txt
echo "finished."
</pre>
Оболочка создаст файл myfile.txt и перенаправит в этот файл вывод конструкции for.

<h3><a href="https://habr.com/ru/companies/ruvds/articles/326328/">Bash-скрипты, часть 3: параметры и ключи командной строки</a></h3>

<h3><a href="https://habr.com/ru/companies/ruvds/articles/326594/">Bash-скрипты, часть 4: ввод и вывод</a></h3>

<h3><a href="https://habr.com/ru/companies/ruvds/articles/326826/">Bash-скрипты, часть 5: сигналы, фоновые задачи, управление сценариями</a></h3>

<h3><a href="https://habr.com/ru/companies/ruvds/articles/327248/">Bash-скрипты, часть 6: функции и разработка библиотек</a></h3>

<h3><a href="https://habr.com/ru/companies/ruvds/articles/327530/">Bash-скрипты, часть 7: sed и обработка текстов</a></h3>

<h3><a href="https://habr.com/ru/companies/ruvds/articles/327754/">Bash-скрипты, часть 8: язык обработки данных awk</a></h3>

<h3><a href="https://habr.com/ru/companies/ruvds/articles/327896/">Bash-скрипты, часть 9: регулярные выражения</a></h3>













<br><br><br><br><br><br><br></body></html>
